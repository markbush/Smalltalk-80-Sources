{
  "Collections-Abstract": {
    "Collection": {
      "comment": "I am the abstract class of all collection classes.\n",
      "class_name": "Collection",
      "superclass": "Object",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "with:with:": "with: firstObject with: secondObject\n\t\"Answer a new instance of me containing the two arguments as elements.\"\n\n\t| newCollection |\n\tnewCollection _ self new.\n\tnewCollection add: firstObject.\n\tnewCollection add: secondObject.\n\t^newCollection\n",
          "with:with:with:with:": "with: firstObject with: secondObject with: thirdObject with: fourthObject\n\t\"Answer a new instance of me, containing the four arguments as the elements.\"\n\n\t| newCollection |\n\tnewCollection _ self new.\n\tnewCollection add: firstObject.\n\tnewCollection add: secondObject.\n\tnewCollection add: thirdObject.\n\tnewCollection add: fourthObject.\n\t^newCollection\n",
          "with:": "with: anObject\n\t\"Answer a new instance of me containing anObject.\"\n\n\t| newCollection |\n\tnewCollection _ self new.\n\tnewCollection add: anObject.\n\t^newCollection\n",
          "with:with:with:": "with: firstObject with: secondObject with: thirdObject\n\t\"Answer with a new instance of me containing the three arguments as elements.\"\n\n\t| newCollection |\n\tnewCollection _ self new.\n\tnewCollection add: firstObject.\n\tnewCollection add: secondObject.\n\tnewCollection add: thirdObject.\n\t^newCollection\n"
        }
      },
      "instance_methods": {
        "printing": {
          "printOn:": "printOn: aStream\n\t| tooMany |\n\ttooMany _ aStream position + self maxPrint.\n\taStream nextPutAll: self class name, ' ('.\n\tself do:\n\t\t[:element |\n\t\taStream position > tooMany ifTrue: [aStream nextPutAll: '...etc...)'. ^self].\n\t\telement printOn: aStream.\n\t\taStream space].\n\taStream nextPut: $)\n",
          "storeOn:": "storeOn: aStream\n\t| noneYet |\n\taStream nextPutAll: '(('.\n\taStream nextPutAll: self class name.\n\taStream nextPutAll: ' new)'.\n\tnoneYet _ true.\n\tself do:\n\t\t[:each |\n\t\tnoneYet\n\t\t\tifTrue: [noneYet _ false]\n\t\t\tifFalse: [aStream nextPut: $;].\n\t\taStream nextPutAll: ' add: '.\n\t\taStream store: each].\n\tnoneYet ifFalse: [aStream nextPutAll: '; yourself'].\n\taStream nextPut: $)\n"
        },
        "testing": {
          "isEmpty": "isEmpty\n\t\"Answer whether the receiver contains any elements.\"\n\n\t^self size = 0\n",
          "occurrencesOf:": "occurrencesOf: anObject\n\t\"Answer how many of the receiver's elements are equal to anObject.\"\n\n\t| tally |\n\ttally _ 0.\n\tself do: [:each | anObject = each ifTrue: [tally _ tally + 1]].\n\t^tally\n",
          "includes:": "includes: anObject\n\t\"Answer whether anObject is one of the receiver's elements.\"\n\n\tself do: [:each | anObject = each ifTrue: [^true]].\n\t^false\n"
        },
        "accessing": {
          "size": "size\n\t\"Answer how many elements the receiver contains.\"\n\n\t| tally |\n\ttally _ 0.\n\tself do: [:each | tally _ tally + 1].\n\t^tally\n"
        },
        "private": {
          "maxPrint": "maxPrint\n\t\"Answer the maximum number of characters to print with printOn:.\"\n\t^5000\n",
          "errorNotFound": "errorNotFound\n\tself error: 'Object is not in the collection.'\n",
          "growSize": "growSize\n\t\"Answer an amount by which the receiver should grow to make room for more elements (in response to the message 'grow').\"\n\n\tself basicSize >= self maxSize ifTrue: [self error: 'unable to grow this collection'].\n\t^(self basicSize max: 2) min: self maxSize - self basicSize\n",
          "emptyCheck": "emptyCheck\n\tself isEmpty ifTrue: [self errorEmptyCollection]\n",
          "maxSize": "maxSize\n\t\"Answer the largest basicSize which is valid for the receiver's class.\"\n\n\t^65486 \"for VM3 interpreter DoradoST80Aug19\"\n",
          "errorNoMatch": "errorNoMatch\n\tself error: 'collection sizes do not match'\n",
          "errorNotKeyed": "errorNotKeyed\n\tself error: self class name, 's do not respond to keyed accessing messages.'\n",
          "errorEmptyCollection": "errorEmptyCollection\n\tself error: 'this collection is empty'\n"
        },
        "converting": {
          "asOrderedCollection": "asOrderedCollection\n\t\"Answer a new instance of OrderedCollection whose elements are the elements of\n\tthe receiver.  The order in which elements are added depends on the order in\n\twhich the receiver enumerates its elements.  In the case of unordered collections,\n\tthe ordering is not necessarily the same for multiple requests for the conversion.\"\n\n\t| anOrderedCollection |\n\tanOrderedCollection _ OrderedCollection new: self size.\n\tself do: [:each | anOrderedCollection addLast: each].\n\t^anOrderedCollection\n",
          "asBag": "asBag\n\t\"Answer a new instance of Bag whose elements are the elements of\n\tthe receiver.\"\n\n\t| aBag |\n\taBag _ Bag new.\n\tself do: [:each | aBag add: each].\n\t^aBag\n",
          "asSortedCollection:": "asSortedCollection: aBlock\n\t\"Answer a new instance of SortedCollection whose elements are the elements of\n\tthe receiver.  The sort order is defined by the argument, aBlock.\"\n\n\t| aSortedCollection |\n\taSortedCollection _ SortedCollection new: self size.\n\taSortedCollection sortBlock: aBlock.\n\taSortedCollection addAll: self.\n\t^aSortedCollection\n",
          "asSet": "asSet\n\t\"Answer a new instance of Set whose elements are the unique elements of\n\tthe receiver.\"\n\n\t| aSet |\n\taSet _ Set new: self size.\n\tself do: [:each | aSet add: each].\n\t^aSet\n",
          "asSortedCollection": "asSortedCollection\n\t\"Answer a new instance of SortedCollection whose elements are the elements of\n\tthe receiver.  The sort order is the default less than or equal ordering.\"\n\n\t| aSortedCollection |\n\taSortedCollection _ SortedCollection new: self size.\n\taSortedCollection addAll: self.\n\t^aSortedCollection\n"
        },
        "enumerating": {
          "collect:": "collect: aBlock\n\t\"Evaluate aBlock with each of the receiver's elements as the argument.  Collect the\n\tresulting values into a collection that is like the receiver.  Answer the new\n\tcollection. \"\n\n\t| newCollection |\n\tnewCollection _ self species new.\n\tself do: [:each | newCollection add: (aBlock value: each)].\n\t^newCollection\n",
          "detect:": "detect: aBlock\n\t\"Evaluate aBlock with each of the receiver's elements as the argument.\n\tAnswer the first element for which aBlock evaluates to true.\"\n\n\t^self detect: aBlock ifNone: [self errorNotFound]\n",
          "do:": "do: aBlock\n\t\"Evaluate aBlock with each of the receiver's elements as the argument.\"\n\n\tself subclassResponsibility\n",
          "reject:": "reject: aBlock\n\t\"Evaluate aBlock with each of the receiver's elements as the argument.\n\tCollect into a new collection like the receiver, only those elements for which\n\taBlock evaluates to false.  Answer the new collection.\"\n\n\t^self select: [:element | (aBlock value: element) == false]\n",
          "detect:ifNone:": "detect: aBlock ifNone: exceptionBlock\n\t\"Evaluate aBlock with each of the receiver's elements as the argument.\n\tAnswer the first element for which aBlock evaluates to true.\"\n\n\tself do: [:each | (aBlock value: each) ifTrue: [^each]].\n\t^exceptionBlock value\n",
          "select:": "select: aBlock\n\t\"Evaluate aBlock with each of the receiver's elements as the argument.\n\tCollect into a new collection like the receiver, only those elements for which\n\taBlock evaluates to true.  Answer the new collection.\"\n\n\t| newCollection |\n\tnewCollection _ self species new.\n\tself do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].\n\t^newCollection\n",
          "inject:into:": "inject: thisValue into: binaryBlock\n\t\"Accumulate a running value associated with evaluating the argument,\n\tbinaryBlock, with the current value and the receiver as block arguments.\n\tThe initial value is the value of the argument, thisValue.\n\t\tFor instance, to sum a collection, use:\n\t\t\tcollection inject: 0 into: [:subTotal :next | subTotal + next].\"\n\n\t| nextValue |\n\tnextValue _ thisValue.\n\tself do: [:each | nextValue _ binaryBlock value: nextValue value: each].\n\t^nextValue\n"
        },
        "adding": {
          "add:": "add: newObject\n\t\"Include newObject as one of the receiver's elements.  Answer newObject.\n\tThis message should not be sent to instances of subclasses of ArrayedCollection.\"\n\n\tself subclassResponsibility\n",
          "addAll:": "addAll: aCollection\n\t\"Include all the elements of aCollection as the receiver's elements.  Answer\n\taCollection.\"\n\n\taCollection do: [:each | self add: each].\n\t^aCollection\n"
        },
        "removing": {
          "removeAll:": "removeAll: aCollection\n\t\"Remove each element of aCollection from the receiver.  If successful for each,\n\tanswer aCollection.\"\n\n\taCollection do: [:each | self remove: each].\n\t^aCollection\n",
          "remove:": "remove: oldObject\n\t\"Remove oldObject as one of the receiver's elements.  Answer oldObject unless\n\tno element is equal to oldObject, in which case, create an error message.\"\n\n\t^self remove: oldObject ifAbsent: [self errorNotFound]\n",
          "remove:ifAbsent:": "remove: oldObject ifAbsent: anExceptionBlock\n\t\"Remove oldObject as one of the receiver's elements.  If several of the\n\telements are equal to oldObject, only one is removed. If no element is equal to\n\toldObject, answer the result of evaluating anExceptionBlock.  Otherwise,\n\tanswer the argument, oldObject.\n\n\tSequenceableCollections can not respond to this message.\"\n\n\tself subclassResponsibility\n"
        }
      }
    },
    "ArrayedCollection": {
      "comment": "I am an abstract collection of elements with integers as external keys.  I re-implement several messages inherited from SequenceableCollection in order to obtain some performance gains.\n\t\tSubclasses are\n\tArray\t\t elements are pointers\n\tByteArray\telements are bytes\n\tRunArray\telements are typically runs of the same thing\n\tString\t\telements are characters\n\tText\t\telements are characters with style\n\tWordArray\t\telements are words\n",
      "class_name": "ArrayedCollection",
      "superclass": "SequenceableCollection",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t\"Answer a new instance of me, with size = 0.\"\n\t^self new: 0\n",
          "with:with:": "with: firstObject with: secondObject\n\t\"Answer a new instance of me, containing firstObject and secondObject.\"\n\n\t| newCollection |\n\tnewCollection _ self new: 2.\n\tnewCollection at: 1 put: firstObject.\n\tnewCollection at: 2 put: secondObject.\n\t^newCollection\n",
          "new:withAll:": "new: size withAll: value\n\t\"Answer a new instance of me, whose every element is equal to the argument,\n\tvalue.\"\n\n\t^(self new: size) atAllPut: value\n",
          "with:with:with:with:": "with: firstObject with: secondObject with: thirdObject with: fourthObject\n\t\"Answer a new instance of me, containing the four arguments as the elements.\"\n\n\t| newCollection |\n\tnewCollection _ self new: 4.\n\tnewCollection at: 1 put: firstObject.\n\tnewCollection at: 2 put: secondObject.\n\tnewCollection at: 3 put: thirdObject.\n\tnewCollection at: 4 put: fourthObject.\n\t^newCollection\n",
          "with:": "with: anObject\n\t\"Answer a new instance of me, containing only anObject.\"\n\n\t| newCollection |\n\tnewCollection _ self new: 1.\n\tnewCollection at: 1 put: anObject.\n\t^newCollection\n",
          "with:with:with:": "with: firstObject with: secondObject with: thirdObject\n\t\"Answer a new instance of me, containing only these three objects.\"\n\n\t| newCollection |\n\tnewCollection _ self new: 3.\n\tnewCollection at: 1 put: firstObject.\n\tnewCollection at: 2 put: secondObject.\n\tnewCollection at: 3 put: thirdObject.\n\t^newCollection\n"
        }
      },
      "instance_methods": {
        "printing": {
          "storeOn:": "storeOn: aStream\n\taStream nextPutAll: '(('.\n\taStream nextPutAll: self class name.\n\taStream nextPutAll: ' new: '.\n\taStream store: self size.\n\taStream nextPut: $).\n\t(self storeElementsFrom: 1 to: self size on: aStream)\n\t\tifFalse: [aStream nextPutAll: '; yourself'].\n\taStream nextPut: $)\n"
        },
        "accessing": {
          "size": "size\n\t\"Answer the number of indexable fields in the receiver. This value is the\n\tsame as the largest legal subscript. Primitive is specified here to override\n\tSequenceableCollection size. Essential. See Object documentation\n\twhatIsAPrimitive. \"\n\n\t<primitive: 62>\n\t^self basicSize\n"
        },
        "private": {
          "storeElementsFrom:to:on:": "storeElementsFrom: firstIndex to: lastIndex on: aStream\n\t| noneYet defaultElement arrayElement |\n\tnoneYet _ true.\n\tdefaultElement _ self defaultElement.\n\tfirstIndex to: lastIndex do:\n\t\t[:index |\n\t\tarrayElement _ self at: index.\n\t\tarrayElement = defaultElement\n\t\t\tifFalse:\n\t\t\t\t[noneYet\n\t\t\t\t\tifTrue: [noneYet _ false]\n\t\t\t\t\tifFalse: [aStream nextPut: $;].\n\t\t\t\taStream nextPutAll: ' at: '.\n\t\t\t\taStream store: index.\n\t\t\t\taStream nextPutAll: ' put: '.\n\t\t\t\taStream store: arrayElement]].\n\t^noneYet\n",
          "defaultElement": "defaultElement\n\t^nil\n"
        },
        "adding": {
          "add:": "add: newObject\n\tself shouldNotImplement\n"
        }
      }
    },
    "SequenceableCollection": {
      "comment": "Abstract superclass for collections that have a well-defined order associated with their elements\n",
      "class_name": "SequenceableCollection",
      "superclass": "Collection",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "comparing": {
          "=": "= otherCollection\n\t\"Answer whether the species of the receiver is the same as otherCollection's species,\n\tand the receiver's size is the same as otherCollection's size, and each of the receiver's\n\telements equal the corresponding element of otherCollection\"\n\n\t| size index |\n\t(size _ self size) = otherCollection size ifFalse: [^false].\n\tself species == otherCollection species ifFalse: [^false].\n\tindex _ 0.\n\t[(index _ index + 1) <= size]\n\t\twhileTrue: [(self at: index) = (otherCollection at: index) ifFalse: [^false]].\n\t^true\n"
        },
        "copying": {
          ",": ", aSequenceableCollection\n\t\"Answer with a copy of the receiver concatenated with the argument,\n\ta SequencableCollection.\"\n\n\t^self copyReplaceFrom: self size + 1\n\t\t  to: self size\n\t\t  with: aSequenceableCollection\n",
          "copyWith:": "copyWith: newElement\n\t\"Answer a copy of the receiver that is 1 bigger than the receiver and has\n\tnewElement at the last element.\"\n\n\t| newIC |\n\tnewIC _ self species new: self size + 1.\n\tnewIC\n\t\treplaceFrom: 1\n\t\tto: self size\n\t\twith: self\n\t\tstartingAt: 1.\n\tnewIC at: newIC size put: newElement.\n\t^newIC\n",
          "copyFrom:to:": "copyFrom: start to: stop\n\t\"Answer a copy of a subset of the receiver, starting from element at index start\n\tuntil element at index stop.\"\n\n\t| newSize |\n\tnewSize _ stop - start + 1.\n\t^(self species new: newSize)\n\t\treplaceFrom: 1\n\t\tto: newSize\n\t\twith: self\n\t\tstartingAt: start\n",
          "copyWithout:": "copyWithout: oldElement\n\t\"Answer a copy of the receiver in which all occurrences of oldElement\n\thave been left out.\"\n\n\t| aStream |\n\taStream _ WriteStream on: (self species new: self size).\n\tself do: [:each | oldElement = each ifFalse: [aStream nextPut: each]].\n\t^aStream contents\n",
          "copyReplaceAll:with:": "copyReplaceAll: oldSubstring with: newSubstring\n\t\"Answer a copy of the receiver in which all occurrances of oldSubstring have\n\tbeen replaced by newSubstring.\"\n\n\t| aString startSearch currentIndex |\n\taString _ self.\n\tstartSearch _ 1.\n\t[(currentIndex _ aString indexOfSubCollection: oldSubstring startingAt: startSearch)\n\t\t\t > 0]\n\t\twhileTrue:\n\t\t\t[aString _ aString\n\t\t\t\t\t\tcopyReplaceFrom: currentIndex\n\t\t\t\t\t\tto: currentIndex + oldSubstring size - 1\n\t\t\t\t\t\twith: newSubstring.\n\t\t\tstartSearch _ currentIndex + newSubstring size].\n\t^aString\n\t\"'How noww brown cowow?' copyReplaceAll: 'ow' with: 'ello'\"\n",
          "shallowCopy": "shallowCopy\n\t^self copyFrom: 1 to: self size\n",
          "copyReplaceFrom:to:with:": "copyReplaceFrom: start to: stop with: replacementCollection\n\t\"Answer a copy of the receiver satisfying the following conditions:\n\n\tIf stop is less than start, then this is an insertion;\n\t\tstop should be exactly start-1,\n\t\tstart = 1 means insert before the first character,\n\t\tstart = size+1 means append after last character.\n\tOtherwise, this is a replacement;\n\t\tstart and stop have to be within the receiver's bounds.\"\n\n\t| newSequenceableCollection newSize endReplacement |\n\tnewSize _ self size - (stop - start + 1) + replacementCollection size.\n\tendReplacement _ start - 1 + replacementCollection size.\n\tnewSequenceableCollection _ self species new: newSize.\n\tnewSequenceableCollection\n\t\treplaceFrom: 1\n\t\tto: start - 1\n\t\twith: self\n\t\tstartingAt: 1.\n\tnewSequenceableCollection\n\t\treplaceFrom: start\n\t\tto: endReplacement\n\t\twith: replacementCollection\n\t\tstartingAt: 1.\n\tnewSequenceableCollection\n\t\treplaceFrom: endReplacement + 1\n\t\tto: newSize\n\t\twith: self\n\t\tstartingAt: stop + 1.\n\t^newSequenceableCollection\n"
        },
        "accessing": {
          "first": "first\n\t\"Answer the first element of the receiver.  Create an error if the receiver\n\tcontains no elements.\"\n\n\tself emptyCheck.\n\t^self at: 1\n",
          "indexOf:ifAbsent:": "indexOf: anElement ifAbsent: exceptionBlock\n\t\"Answer the index of anElement within the receiver.  If the receiver does\n\tnot contain anElement, answer the result of evaluating the exceptionBlock.\"\n\n\t(1 to: self size)\n\t\tdo: [:i | (self at: i) = anElement ifTrue: [^i]].\n\t^exceptionBlock value\n",
          "atAllPut:": "atAllPut: anObject\n\t\"Put anObject at every one of the receiver's indices.\"\n\n\t| index size |\n\tindex _ 0.\n\tsize _ self size.\n\t[(index _ index + 1) <= size]\n\t\twhileTrue: [self at: index put: anObject]\n",
          "last": "last\n\t\"Answer the last element of the receiver.  Create an error if the receiver\n\tcontains no elements.\"\n\n\tself emptyCheck.\n\t^self at: self size\n",
          "indexOfSubCollection:startingAt:ifAbsent:": "indexOfSubCollection: aSubCollection startingAt: anIndex ifAbsent: exceptionBlock\n\t\"Answer the index of the receiver's first element, such that that element\n\tequals the first element of aSubCollection, and the next elements equal the rest of\n\tthe elements of aSubCollection.  Begin the search at element anIndex of the\n\treceiver.  If no such match is found, answer the result of evaluating exceptionBlock.\"\n\n\t| firstElement eq |\n\taSubCollection size = 0 ifTrue: [^exceptionBlock value].\n\tfirstElement _ aSubCollection at: 1.\n\tanIndex to: self size - aSubCollection size + 1 do:\n\t\t[:i |\n\t\teq _ true.\n\t\t(self at: i) = firstElement\n\t\t\tifTrue:\n\t\t\t\t[1 to: aSubCollection size do:\n\t\t\t\t\t[:index |\n\t\t\t\t\t(self at: i + index - 1) = (aSubCollection at: index)\n\t\t\t\t\t\tifFalse: [eq _ false]].\n\t\t\t\teq ifTrue: [^i]]].\n\t^exceptionBlock value\n",
          "indexOfSubCollection:startingAt:": "indexOfSubCollection: aSubCollection startingAt: anIndex\n\t\"Answer the index of the receiver's first element, such that that element\n\tequals the first element of aSubCollection, and the next elements equal the rest of\n\tthe elements of aSubCollection.  Begin the search at element anIndex of the\n\treceiver.  If no such match is found, answer 0.\"\n\n\t^self\n\t\tindexOfSubCollection: aSubCollection\n\t\tstartingAt: anIndex\n\t\tifAbsent: [0]\n",
          "indexOf:": "indexOf: anElement\n\t\"Answer the index of anElement within the receiver.  If the receiver does\n\tnot contain anElement, answer 0.\"\n\n\t^self indexOf: anElement ifAbsent: [0]\n",
          "atAll:put:": "atAll: anInterval put: anObject\n\t\"Put anObject at every index specified by the integer elements of anInterval.\"\n\n\tanInterval do: [:index | self at: index put: anObject]\n",
          "replaceFrom:to:with:": "replaceFrom: start to: stop with: replacement\n\t\"This destructively replaces elements from start to stop in the receiver.\n\tAnswer the receiver itself.\n\tUse copyReplaceFrom:to:with: for insertion/deletion which may alter the\n\tsize of the result.\"\n\n\treplacement size = (stop - start + 1)\n\t\tifFalse: [self error: 'Size of replacement doesnt match'].\n\t^self replaceFrom: start to: stop with: replacement startingAt: 1\n",
          "size": "size\n\tself subclassResponsibility\n",
          "replaceFrom:to:with:startingAt:": "replaceFrom: start to: stop with: replacement startingAt: repStart\n\t\"This destructively replaces elements from start to stop in the receiver\n\tstarting at index, repStart, in the collection, replacement.  Answer the\n\treceiver.  No range checks are performed - this may be primitively implemented.\"\n\n\t| index repOff |\n\trepOff _ repStart - start.\n\tindex _ start - 1.\n\t[(index _ index + 1) <= stop]\n\t\twhileTrue: [self at: index put: (replacement at: repOff + index)]\n"
        },
        "private": {
          "errorOutOfBounds": "errorOutOfBounds\n\tself error: 'indices are out of bounds'\n",
          "swap:with:": "swap: oneIndex with: anotherIndex\n\t\"Move the element at oneIndex to anotherIndex, and vice-versa.\"\n\n\t| element |\n\telement _ self at: oneIndex.\n\tself at: oneIndex put: (self at: anotherIndex).\n\tself at: anotherIndex put: element\n"
        },
        "converting": {
          "mappedBy:": "mappedBy: aSequenceableCollection\n\t\"Answer a new instance of MappedCollection whose contents is the\n\treceiver and whose map is the argument, aSequencableCollection.\"\n\n\t^(MappedCollection collection: self map: aSequenceableCollection) contents\n",
          "asArray": "asArray\n\t\"Answer a new instance of Array whose elements are the elements of\n\tthe receiver, in the same order.\"\n\n\t| newArray |\n\tnewArray _ Array new: self size.\n\t1 to: self size do: [:index | newArray at: index put: (self at: index)].\n\t^newArray\n"
        },
        "enumerating": {
          "with:do:": "with: aSequenceableCollection do: aBlock\n\t\"Evaluate aBlock with each of the receiver's elements along with the corresponding\n\telement from aSequencableCollection.\"\n\n\t| otherCollection |\n\tself size ~= aSequenceableCollection size ifTrue: [^self errorNoMatch].\n\totherCollection _ ReadStream on: aSequenceableCollection.\n\tself do: [:each | aBlock value: each value: otherCollection next]\n",
          "collect:": "collect: aBlock\n\t| aStream index length |\n\taStream _ WriteStream on: (self species new: self size).\n\tindex _ 0.\n\tlength _ self size.\n\t[(index _ index + 1) <= length]\n\t\twhileTrue: [aStream nextPut: (aBlock value: (self at: index))].\n\t^aStream contents\n",
          "findFirst:": "findFirst: aBlock\n\t\"Return the index of my first element for which aBlock evaluates as true.\"\n\n\t| index |\n\tindex _ 0.\n\t[(index _ index + 1) <= self size] whileTrue:\n\t\t[(aBlock value: (self at: index)) ifTrue: [^index]].\n\t^ 0\n",
          "do:": "do: aBlock\n\t| index length |\n\tindex _ 0.\n\tlength _ self size.\n\t[(index _ index + 1) <= length]\n\t\twhileTrue: [aBlock value: (self at: index)]\n",
          "reverseDo:": "reverseDo: aBlock\n\t\"Evaluate aBlock with each of the receiver's elements as the argument, starting\n\twith the last element and taking each in sequence up to the first.  For\n\tSequenceableCollections, this is the reverse of the enumeration in do:.\"\n\n\tself size to: 1 by: -1 do: [:index | aBlock value: (self at: index)]\n",
          "select:": "select: aBlock\n\t| aStream index length |\n\taStream _ WriteStream on: (self species new: self size).\n\tindex _ 0.\n\tlength _ self size.\n\t[(index _ index + 1) <= length]\n\t\twhileTrue:\n\t\t\t[(aBlock value: (self at: index)) ifTrue: [aStream nextPut: (self at: index)]].\n\t^aStream contents\n",
          "reverse": "reverse\n\t\"Answer with a new collection like me with its elements in the opposite order.\"\n\n\t| aStream index length |\n\taStream _ WriteStream on: (self species new: self size).\n\tindex _ self size + 1.\n\t[(index _ index - 1) > 0]\n\t\twhileTrue: [aStream nextPut: (self at: index)].\n\t^aStream contents\n",
          "findLast:": "findLast: aBlock\n\t\"Return the index of my last element for which aBlock evaluates as true.\"\n\n\t| index |\n\tindex _ self size + 1.\n\t[(index _ index - 1) >= 1] whileTrue:\n\t\t[(aBlock value: (self at: index)) ifTrue: [^index]].\n\t^ 0\n"
        },
        "adding": {
          "grow": "grow\n\t\"The receiver becomes bigger--this is not a copy of the receiver, so all shared references survive.\"\n\n\t| newArray |\n\tnewArray _ self species new: self size + self growSize.\n\tnewArray replaceFrom: 1 to: self size with: self.\n\t^self become: newArray\n"
        },
        "removing": {
          "remove:ifAbsent:": "remove: oldObject ifAbsent: anExceptionBlock\n\t\"SequencableCollections cannot implement removing.\"\n\n\tself shouldNotImplement\n"
        }
      }
    }
  },
  "Collections-Arrayed": {
    "RunArray": {
      "comment": "RunArrays provide space-efficient storage of data which tends to be constant over long runs of the possible indices.  runs is an array of Integers, and each indicates the number of indices over which the corresponding value (in values) is constant.\n",
      "class_name": "RunArray",
      "superclass": "ArrayedCollection",
      "instanceVariables": "runs values",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t^self runs: Array new values: Array new\n",
          "new:withAll:": "new: size withAll: value\n\t\"Answer a new instance of me, whose every element is equal to the argument,\n\tvalue.\"\n\n\tsize = 0 ifTrue: [^self new].\n\t^self runs: (Array with: size) values: (Array with: value)\n",
          "runs:values:": "runs: newRuns values: newValues\n\t\"Answer a new instance of RunArray with runs and values specified\n\tby the arguments.\"\n\n\t| instance |\n\tinstance _ self basicNew.\n\tinstance setRuns: newRuns setValues: newValues.\n\t^instance\n",
          "readFrom:": "readFrom: aStream\n\t\"Answer a new instance of RunArray as described on the stream, aStream\"\n\n\t| size runs values |\n\tsize _ aStream nextWord.\n\truns _ Array new: size.\n\tvalues _ Array new: size.\n\t1 to: size do:\n\t\t[:x |\n\t\truns at: x put: aStream nextWord.\n\t\tvalues at: x put: aStream nextWord].\n\t^ self runs: runs values: values\n"
        }
      },
      "instance_methods": {
        "fileIn/Out": {
          "writeOn:": "writeOn: aStream\n\taStream nextWordPut: runs size.\n\t1 to: runs size do:\n\t\t[:x |\n\t\taStream nextWordPut: (runs at: x).\n\t\taStream nextWordPut: (values at: x)]\n"
        },
        "printing": {
          "storeOn:": "storeOn: aStream\n\taStream nextPut: $(.\n\taStream nextPutAll: self class name.\n\taStream nextPutAll: ' runs: '.\n\truns storeOn: aStream.\n\taStream nextPutAll: ' values: '.\n\tvalues storeOn: aStream.\n\taStream nextPut: $)\n"
        },
        "copying": {
          ",": ", aRunArray\n\t\"Answer a new RunArray that is a concatenation of the receiver and aRunArray.\"\n\n\t| new newRuns |\n\t(aRunArray isMemberOf: RunArray)\n\t\tifFalse:\n\t\t\t[new _ self copy.\n\t\t\t\"attempt to be sociable\"\n\t\t\taRunArray do: [:each | new addLast: each].\n\t\t\t^new].\n\truns size = 0 ifTrue: [^aRunArray copy].\n\taRunArray runs size = 0 ifTrue: [^self copy].\n\tvalues last ~= aRunArray first\n\t\tifTrue: [^RunArray\n\t\t\t\t\truns: runs , aRunArray runs\n\t\t\t\t\tvalues: values , aRunArray values].\n\tnewRuns _ runs\n\t\t\t\t\tcopyReplaceFrom: runs size\n\t\t\t\t\tto: runs size\n\t\t\t\t\twith: aRunArray runs.\n\tnewRuns at: runs size put: runs last + aRunArray runs first.\n\t^RunArray\n\t\truns: newRuns\n\t\tvalues:\n\t\t\t(values\n\t\t\t\tcopyReplaceFrom: values size\n\t\t\t\tto: values size\n\t\t\t\twith: aRunArray values)\n",
          "copyFrom:to:": "copyFrom: start to: stop\n\t| run1 offset1 value1 run2 offset2 value2 newRuns |\n\tstop < start ifTrue: [^RunArray new].\n\tself at: start setRunOffsetAndValue: [:run1 :offset1 :value1 | value1].\n\tself at: stop setRunOffsetAndValue: [:run2 :offset2 :value2 | value2].\n\trun1 = run2\n\t\tifTrue:\n\t\t\t[newRuns _ Array with: offset2 - offset1 + 1]\n\t\tifFalse:\n\t\t\t[newRuns _ runs copyFrom: run1 to: run2.\n\t\t\tnewRuns at: 1 put: (newRuns at: 1) - offset1.\n\t\t\tnewRuns at: newRuns size put: offset2 + 1].\n\t^RunArray runs: newRuns values: (values copyFrom: run1 to: run2)\n",
          "copyReplaceFrom:to:with:": "copyReplaceFrom: start to: stop with: replacement\n\t^(self copyFrom: 1 to: start - 1)\n\t\t, replacement\n\t\t, (self copyFrom: stop + 1 to: self size)\n"
        },
        "accessing": {
          "at:": "at: index\n\t| run offset value |\n\tself at: index setRunOffsetAndValue: [:run :offset :value | ^value]\n",
          "runLengthAt:": "runLengthAt: index\n\t\"Answer the length remaining in run beginning at index.\"\n\n\t| run offset value |\n\tself at: index\n\t\tsetRunOffsetAndValue: [:run :offset :value | ^(runs at: run) - offset]\n",
          "values": "values\n\t\"Answer the values in the receiver.\"\n\t^values\n",
          "size": "size\n\t| size |\n\tsize _ 0.\n\truns do: [:run | size _ size + run].\n\t^size\n"
        },
        "private": {
          "at:setRunOffsetAndValue:": "at: index setRunOffsetAndValue: aBlock\n\t\"Supply all run information to aBlock.\"\n\n\t| run limit position |\n\t\" Tolerates index=0 and index=size+1 for copyReplace:\"\n\trun _ 1.\n\tlimit _ runs size.\n\tposition _ index.\n\t[run <= limit and: [position > (runs at: run)]]\n\t\twhileTrue:\n\t\t\t[position _ position - (runs at: run).\n\t\t\trun _ run + 1].\n\trun > limit\n\t\tifTrue:\n\t\t\t[\"adjustment for size+1\"\n\t\t\trun _ run - 1.\n\t\t\tposition _ position + (runs at: run)].\n\t^aBlock\n\t\tvalue: run\t\"an index into runs and values\"\n\t\tvalue: position - 1\t\"zero-based offset from beginning of this run\"\n\t\tvalue: (values at: run)\t\"value for this run\"\n",
          "runs": "runs\n\t^runs\n",
          "setRuns:setValues:": "setRuns: newRuns setValues: newValues\n\truns _ newRuns.\n\tvalues _ newValues\n"
        },
        "adding": {
          "addLast:": "addLast: value\n\t\"Add value as the last element of the receiver.\"\n\n\t(runs size=0 or: [values last ~= value])\n\t  ifTrue:\n\t\t[runs_ runs copyWith: 1.\n\t\tvalues_ values copyWith: value]\n\t  ifFalse:\n\t\t[runs at: runs size put: runs last+1]\n",
          "addFirst:": "addFirst: value\n\t\"Add value as the first element of the receiver.\"\n\n\t(runs size=0 or: [values first ~= value])\n\t  ifTrue:\n\t\t[runs_ (Array with: 1) , runs.\n\t\tvalues_ (Array with: value) , values]\n\t  ifFalse:\n\t\t[runs at: 1 put: runs first+1]\n"
        }
      }
    },
    "Array": {
      "comment": "I am an arrayed collection of pointers.\n",
      "class_name": "Array",
      "superclass": "ArrayedCollection",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "comparing": {
          "hash": "hash\n\t\"make sure = arrays hash =ly\"\n\n\tself size = 0 ifTrue: [^17171].\n\t^(self at: 1) hash + (self at: self size) hash\n",
          "hashMappedBy:": "hashMappedBy: map\n\t\"Answer what my hash would be if oops changed according to map\"\n\tself size = 0 ifTrue: [^ self hash].\n\t^ (self first hashMappedBy: map) + (self last hashMappedBy: map)\n"
        },
        "printing": {
          "isLiteral": "isLiteral\n\tself detect: [:element | element isLiteral not] ifNone: [^true].\n\t^false\n",
          "printOn:": "printOn: aStream\n\t| tooMany |\n\ttooMany _ aStream position + self maxPrint.\n\taStream nextPut: $(.\n\tself do:\n\t\t[:element |\n\t\taStream position > tooMany ifTrue: [aStream nextPutAll: '...etc...)'. ^self].\n\t\telement printOn: aStream.\n\t\taStream space].\n\taStream nextPut: $)\n",
          "storeOn:": "storeOn: aStream\n\t\"Use the literal form if possible.\"\n\n\tself isLiteral\n\t\tifTrue:\n\t\t\t[aStream nextPut: $#; nextPut: $(.\n\t\t\tself do:\n\t\t\t\t[:element |\n\t\t\t\telement printOn: aStream.\n\t\t\t\taStream space].\n\t\t\taStream nextPut: $)]\n\t\tifFalse: [super storeOn: aStream]\n"
        },
        "converting": {
          "asArray": "asArray\n\t\"Answer with the receiver itself.\"\n\t^self\n"
        }
      }
    },
    "ByteArray": {
      "comment": "My elements can only be integers between 0 and 255.  The access messages at: and at:put: are handled primitively in class Object\n",
      "class_name": "ByteArray",
      "superclass": "ArrayedCollection",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "accessing": {
          "doubleWordAt:": "doubleWordAt: i\n\t\"Answer the value of the double word (4 bytes) starting at byte index i.\"\n\n\t| b0 b1 b2 w |\n\t\"Primarily for reading socket #s in Pup headers\"\n\tb0 _ self at: i.\n\tb1 _ self at: i+1.\n\tb2 _ self at: i+2.\n\tw _ self at: i+3.\n\t\"Following sequence minimizes LargeInteger arithmetic for small results.\"\n\tb2=0 ifFalse: [w _ (b2 bitShift: 8) + w].\n\tb1=0 ifFalse: [w _ (b1 bitShift: 16) + w].\n\tb0=0 ifFalse: [w _ (b0 bitShift: 24) + w].\n\t^w\n",
          "replaceFrom:to:withString:startingAt:": "replaceFrom: start to: stop withString: aString startingAt: repStart\n\t\"This destructively replaces elements from start to stop in the receiver\n\tstarting at index, repStart, in the string, aString.  Answer the\n\treceiver.\"\n\t| index repOff |\n\t<primitive: 105>\n\trepOff _ repStart - start.\n\tindex _ start - 1.\n\t[(index _ index + 1) <= stop]\n\t\twhileTrue:\n\t\t\t[self at: index put: (aString at: repOff + index) asInteger]\n",
          "wordAt:": "wordAt: i\n\t\"Answer the value of the word (2 bytes) starting at index i.\"\n\n\t| j |\n\tj _ i + i.\n\t^((self at: j - 1) bitShift: 8) + (self at: j)\n",
          "doubleWordAt:put:": "doubleWordAt: i put: value\n\t\"Set the value of the double word (4 bytes) starting at byte index i.\"\n\n\t| w |\n\t\"Primarily for setting socket #s in Pup headers\"\n\tw _ value truncated.\n\tself at: i put: (w digitAt: 4).\n\tself at: i + 1 put: (w digitAt: 3).\n\tself at: i + 2 put: (w digitAt: 2).\n\tself at: i + 3 put: (w digitAt: 1)\n",
          "wordAt:put:": "wordAt: i put: v\n\t\"Set the value of the word (2 bytes) starting at index i.\"\n\n\t| j |\n\tj _ i + i.\n\tself at: j - 1 put: ((v bitShift: -8) bitAnd: 8r377).\n\tself at: j put: (v bitAnd: 8r377)\n",
          "replaceFrom:to:with:startingAt:": "replaceFrom: start to: stop with: replacement startingAt: repStart\n\t\"This destructively replaces elements from start to stop in the receiver\n\tstarting at index, repStart, in the collection, replacement.  Answer the\n\treceiver.\"\n\t(replacement isKindOf: ByteArray)\n\t\tifTrue:\n\t\t\t[self primReplaceFrom: start to: stop with: replacement startingAt: repStart]\n\t\tifFalse:\n\t\t\t[super replaceFrom: start to: stop with: replacement startingAt: repStart]\n"
        },
        "private": {
          "defaultElement": "defaultElement\n\t^0\n",
          "primReplaceFrom:to:with:startingAt:": "primReplaceFrom: start to: stop with: replacement startingAt: repStart\n\t\"This destructively replaces elements from start to stop in the receiver\n\tstarting at index, repStart, in the collection, replacement.  Answer the\n\treceiver.  No range checks are performed - this may be primitively implemented.\"\n\n\t<primitive: 105>\n\tsuper replaceFrom: start to: stop with: replacement startingAt: repStart\n"
        },
        "converting": {
          "asString": "asString\n\n\t^(String new: self size) replaceFrom: 1 to: self size withByteArray: self startingAt: 1\n",
          "packBits:into:": "packBits: fieldSize into: byteArray\n\t\"Pack the low order fieldSize bits of the receiver's bytes into the bytes of byteArray.\"\n\n\t^self packBits: fieldSize startBit: 8-fieldSize into: byteArray\n",
          "unpackBits:into:": "unpackBits: fieldSize into: byteArray\n\t\"Unpack the packed bit fields of the receiver's bytes into the low order fieldSize bits of byteArray twice as large.  fieldSize must be 1, 2, 4, or 8.  The receiver's size must be even.  byteArray's size must be a multiple of 16/fieldSize.  Answers the unpacked array.\"\n\n\t| unpackedForm packedForm sourceX destX bitBlt fieldsPerWord ht |\n\tfieldsPerWord _ 16//fieldSize.\n\tht _ self size//2.\n\tunpackedForm _ Form new extent: fieldsPerWord*8@ht offset: 0@0 bits: byteArray.\n\tpackedForm _ Form new extent: 16@ht offset: 0@0 bits: self.\n\tbitBlt _ BitBlt destForm: unpackedForm\n\t\tsourceForm: packedForm\n\t\thalftoneForm: nil\n\t\tcombinationRule: Form over\n\t\tdestOrigin: 0@0\n\t\tsourceOrigin: 0@0\n\t\textent: fieldSize@ht\n\t\tclipRect: unpackedForm boundingBox.\n\n\tsourceX _ 0.\n\tdestX _ 8-fieldSize.\n\tfieldsPerWord timesRepeat:\n\t\t[bitBlt sourceX: sourceX; destX: destX; copyBits.\n\t\tsourceX _ sourceX + fieldSize.\n\t\tdestX _ destX + 8].\n\n\t^byteArray\n",
          "packBits:startBit:into:": "packBits: fieldSize startBit: fieldStart into: byteArray\n\t\"Pack fieldSize bits of the receiver's bytes into the bytes of byteArray.  fieldSize must be 1, 2, 4, or 8.  fieldStart is the bit offset of the field within the byte (8-fieldSize for low order bits).  The receiver's size must be a multiple of 16/fieldSize.  byteArray's size must be even.  Answers the packed array.\"\n\n\t| unpackedForm packedForm sourceX destX bitBlt fieldsPerWord ht |\n\tfieldsPerWord _ 16//fieldSize.\n\tht _ self size//fieldsPerWord.\n\tunpackedForm _ Form new extent: fieldsPerWord*8@ht offset: 0@0 bits: self.\n\tpackedForm _ Form new extent: 16@ht offset: 0@0 bits: byteArray.\n\tbitBlt _ BitBlt destForm: packedForm\n\t\tsourceForm: unpackedForm\n\t\thalftoneForm: nil\n\t\tcombinationRule: Form over\n\t\tdestOrigin: 0@0\n\t\tsourceOrigin: 0@0\n\t\textent: fieldSize@ht\n\t\tclipRect: (0@0 corner: 16@ht).\n\n\tsourceX _ fieldStart.\n\tdestX _ 0.\n\tfieldsPerWord timesRepeat:\n\t\t[bitBlt sourceX: sourceX; destX: destX; copyBits.\n\t\tsourceX _ sourceX + 8.\n\t\tdestX _ destX + fieldSize].\n\n\t^byteArray\n"
        }
      }
    }
  },
  "Collections-Sequenceable": {
    "LinkedList": {
      "comment": "I implement ordered collections using a chain of elements.  I can be initialized using\n\tLinkedList with: Link new\n",
      "class_name": "LinkedList",
      "superclass": "SequenceableCollection",
      "instanceVariables": "firstLink lastLink",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "testing": {
          "isEmpty": "isEmpty\n\t^firstLink == nil\n"
        },
        "accessing": {
          "first": "first\n\t\"Answer the first link;  create an error if the receiver is empty.\"\n\n\tself emptyCheck.\n\t^firstLink\n",
          "last": "last\n\t\"Answer the last link;  create an error if the receiver is empty.\"\n\n\tself emptyCheck.\n\t^lastLink\n",
          "size": "size\n\t\"Answer how many elements the receiver contains.\"\n\t| tally |\n\ttally _ 0.\n\tself do: [:each | tally _ tally + 1].\n\t^tally\n"
        },
        "enumerating": {
          "do:": "do: aBlock\n\t| aLink |\n\taLink _ firstLink.\n\t[aLink == nil] whileFalse:\n\t\t[aBlock value: aLink.\n\t\t aLink _ aLink nextLink]\n"
        },
        "adding": {
          "add:": "add: aLink\n\t\"Add aLink to the end of the receiver's list.\"\n\n\t^self addLast: aLink\n",
          "addLast:": "addLast: aLink\n\t\"Add aLink to the end of the receiver's list.\"\n\n\tself isEmpty\n\t\tifTrue: [firstLink _ aLink]\n\t\tifFalse: [lastLink nextLink: aLink].\n\tlastLink _ aLink.\n\t^aLink\n",
          "addFirst:": "addFirst: aLink\n\t\"Add aLink to the beginning of the receiver's list.\"\n\n\tself isEmpty ifTrue: [lastLink _ aLink].\n\taLink nextLink: firstLink.\n\tfirstLink _ aLink.\n\t^aLink\n"
        },
        "removing": {
          "removeLast": "removeLast\n\t\"Remove the receiver's last element.  If the receiver is empty, cause an error;\n\totherwise answer the removed element.  Using addLast:/removeLast causes the\n\treceiver to behave as a stack; using addFirst:/removeLast causes the receiver to\n\tbehave as a queue.\"\n\n\t| oldLink aLink |\n\tself emptyCheck.\n\toldLink _ lastLink.\n\tfirstLink == lastLink\n\t\tifTrue: [firstLink _ nil. lastLink _ nil]\n\t\tifFalse: [aLink _ firstLink.\n\t\t\t\t[aLink nextLink == oldLink] whileFalse:\n\t\t\t\t\t[aLink _ aLink nextLink].\n\t\t\t\t aLink nextLink: nil.\n\t\t\t\t lastLink _ aLink].\n\toldLink nextLink: nil.\n\t^oldLink\n",
          "removeFirst": "removeFirst\n\t\"Remove the first element.  If the receiver is empty, cause an error;\n\totherwise answer the removed element.  Using the sequence addFirst:/removeFirst\n\tcauses the receiver to behave as a stack; using addLast:/removeFirst causes the\n\treceiver to behave as a queue.\"\n\n\t| oldLink |\n\tself emptyCheck.\n\toldLink _ firstLink.\n\tfirstLink == lastLink\n\t\tifTrue: [firstLink _ nil. lastLink _ nil]\n\t\tifFalse: [firstLink _ oldLink nextLink].\n\toldLink nextLink: nil.\n\t^oldLink\n",
          "remove:ifAbsent:": "remove: aLink ifAbsent: aBlock\n\t\"Remove aLink from the receiver.  If it is not there, answer the result of\n\tevaluating aBlock.\"\n\n\t| tempLink |\n\taLink == firstLink\n\t\tifTrue: [firstLink _ aLink nextLink.\n\t\t\t\taLink == lastLink\n\t\t\t\t\tifTrue: [lastLink _ nil]]\n\t\tifFalse: [tempLink _ firstLink.\n\t\t\t\t[tempLink == nil ifTrue: [^aBlock value].\n\t\t\t\t tempLink nextLink == aLink]\n\t\t\t\t\twhileFalse: [tempLink _ tempLink nextLink].\n\t\t\t\ttempLink nextLink: aLink nextLink.\n\t\t\t\taLink == lastLink\n\t\t\t\t\tifTrue: [lastLink _ tempLink]].\n\taLink nextLink: nil.\n\t^aLink\n"
        }
      }
    },
    "Interval": {
      "comment": "I represent a finite arithmetic progression\n",
      "class_name": "Interval",
      "superclass": "SequenceableCollection",
      "instanceVariables": "start stop step",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t\"Create and answer with a new instance of the receiver (a class) with no indexable\n\tfields.  Fail if the class is indexable.  Override SequenceableCollection new.\n\tEssential.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 70>\n\tself isVariable ifTrue: [^self new: 0].\n\tself primitiveFailed\n",
          "from:to:by:": "from: startInteger to: stopInteger by: stepInteger\n\t\"Answer a new instance of me, starting at startInteger, ending and\n\tstopInteger, and with an interval increment of stepInteger.\"\n\n\t^self new\n\t\tsetFrom: startInteger\n\t\tto: stopInteger\n\t\tby: stepInteger\n",
          "from:to:": "from: startInteger to: stopInteger\n\t\"Answer a new instance of me, starting at startInteger, ending and\n\tstopInteger, and with an interval increment of 1.\"\n\n\t^self new\n\t\tsetFrom: startInteger\n\t\tto: stopInteger\n\t\tby: 1\n"
        }
      },
      "instance_methods": {
        "comparing": {
          "hash": "hash\n\t^(((start hash bitShift: 2)\n\t\tbitOr: stop hash)\n\t\tbitShift: 1)\n\t\tbitOr: self size\n",
          "=": "= anInterval\n\t\"Answer true if my species and anInterval species are equal, and\n\tif our starts, steps and sizes are equal.\"\n\n\tself species == anInterval species\n\t\tifTrue: [^start = anInterval first\n\t\t\t\t\tand: [step = anInterval increment and: [self size = anInterval size]]]\n\t\tifFalse: [^false]\n",
          "hashMappedBy:": "hashMappedBy: map\n\t\"My hash is independent of my oop\"\n\t^ self hash\n"
        },
        "printing": {
          "printOn:": "printOn: aStream\n\taStream nextPut: $(.\n\tstart printOn: aStream.\n\taStream nextPutAll: ' to: '.\n\tstop printOn: aStream.\n\tstep ~= 1\n\t\tifTrue:\n\t\t\t[aStream nextPutAll: ' by: '.\n\t\t\tstep printOn: aStream].\n\taStream nextPut: $)\n",
          "storeOn:": "storeOn: aStream\n\t\"This is possible because we know numbers store and print the same\"\n\n\tself printOn: aStream\n"
        },
        "copying": {
          "copy": "copy\n\t\"Return a copy of me.\n\tI override this message because my species is Array and copy, as inherited\n\tfrom SequenceableCollection, uses copyFrom:to:, which creates a new object\n\tof my species\"\n\n\t^self shallowCopy\n"
        },
        "accessing": {
          "first": "first\n\t^start\n",
          "at:put:": "at: anInteger put: anObject\n\t\"Storing into an Interval is not allowed.\"\n\n\tself error: 'you can not store into an interval'\n",
          "at:": "at: anInteger\n\t\"Answer the anInteger'th element.\"\n\n\t(anInteger >= 1 and: [anInteger <= self size])\n\t\tifTrue: [^start + (step * (anInteger - 1))]\n\t\tifFalse: [self errorSubscriptBounds: anInteger]\n",
          "last": "last\n\t^stop - (stop - start \\\\ step)\n",
          "increment": "increment\n\t\"Answer the receiver's interval increment.\"\n\t^step\n",
          "size": "size\n\tstep < 0\n\t\tifTrue: [start < stop\n\t\t\t\tifTrue: [^0]\n\t\t\t\tifFalse: [^stop - start // step + 1]]\n\t\tifFalse: [stop < start\n\t\t\t\tifTrue: [^0]\n\t\t\t\tifFalse: [^stop - start // step + 1]]\n"
        },
        "private": {
          "setFrom:to:by:": "setFrom: startInteger to: stopInteger by: stepInteger\n\tstart _ startInteger.\n\tstop _ stopInteger.\n\tstep _ stepInteger\n",
          "species": "species\n\t^Array\n"
        },
        "enumerating": {
          "collect:": "collect: aBlock\n\t| nextValue i result |\n\tresult _ self species new: self size.\n\tnextValue _ start.\n\ti _ 1.\n\tstep < 0\n\t\tifTrue: [[stop <= nextValue]\n\t\t\t\twhileTrue:\n\t\t\t\t\t[result at: i put: (aBlock value: nextValue).\n\t\t\t\t\tnextValue _ nextValue + step.\n\t\t\t\t\ti _ i + 1]]\n\t\tifFalse: [[stop >= nextValue]\n\t\t\t\twhileTrue:\n\t\t\t\t\t[result at: i put: (aBlock value: nextValue).\n\t\t\t\t\tnextValue _ nextValue + step.\n\t\t\t\t\ti _ i + 1]].\n\t^result\n",
          "do:": "do: aBlock\n\t| aValue |\n\taValue _ start.\n\tstep < 0\n\t\tifTrue: [[stop <= aValue]\n\t\t\t\twhileTrue:\n\t\t\t\t\t[aBlock value: aValue.\n\t\t\t\t\taValue _ aValue + step]]\n\t\tifFalse: [[stop >= aValue]\n\t\t\t\twhileTrue:\n\t\t\t\t\t[aBlock value: aValue.\n\t\t\t\t\taValue _ aValue + step]]\n",
          "reverseDo:": "reverseDo: aBlock\n\t\"Evaluate aBlock for each element of my interval, in reverse order.\"\n\n\t| aValue |\n\taValue _ stop.\n\tstep < 0\n\t\tifTrue: [[start >= aValue]\n\t\t\t\twhileTrue:\n\t\t\t\t\t[aBlock value: aValue.\n\t\t\t\t\taValue _ aValue - step]]\n\t\tifFalse: [[start <= aValue]\n\t\t\t\twhileTrue:\n\t\t\t\t\t[aBlock value: aValue.\n\t\t\t\t\taValue _ aValue - step]]\n"
        },
        "adding": {
          "add:": "add: newObject\n\t\"Adding to an Interval is not allowed.\"\n\tself shouldNotImplement\n"
        },
        "removing": {
          "remove:": "remove: newObject\n\t\"Removing from an Interval is not allowed.\"\n\n\tself error: 'elements cannot be removed from an Interval'\n"
        }
      }
    },
    "MappedCollection": {
      "comment": "I am re-ordering or subcollecting of a writeable SequenceableCollection.\n",
      "class_name": "MappedCollection",
      "superclass": "Collection",
      "instanceVariables": "domain map",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "collection:map:": "collection: aCollection map: aSequenceableCollection\n\t\"Answer a new instance of me that maps aCollection by aSequenceableCollection.\"\n\t^self basicNew setCollection: aCollection map: aSequenceableCollection\n",
          "new": "new\n\tself error: 'MappedCollections must be created using the collection:map: message'\n"
        }
      },
      "instance_methods": {
        "printing": {
          "storeOn:": "storeOn: aStream\n\taStream nextPut: $(.\n\tdomain storeOn: aStream.\n\taStream nextPutAll: ' mappedBy: '.\n\tmap storeOn: aStream.\n\taStream nextPut: $)\n"
        },
        "copying": {
          "copy": "copy\n\t\"This returns another MappedCollection whereas copyFrom:to: will return an\n\tobject like my domain\"\n\n\t^MappedCollection collection: domain map: map\n"
        },
        "accessing": {
          "at:put:": "at: anIndex put: anObject\n\t^domain at: (map at: anIndex) put: anObject\n",
          "at:": "at: anIndex\n\t^domain at: (map at: anIndex)\n",
          "contents": "contents\n\t\"Answer the receiver's domain for mapping, a SequenceableCollection.\"\n\t^map collect: [:mappedIndex | domain at: mappedIndex]\n",
          "size": "size\n\t^map size\n"
        },
        "private": {
          "setCollection:map:": "setCollection: aCollection map: aDictionary\n\tdomain _ aCollection.\n\tmap _ aDictionary\n",
          "species": "species\n\t^domain species\n"
        },
        "enumerating": {
          "collect:": "collect: aBlock\n\t| aStream |\n\taStream _ WriteStream on: (self species new: self size).\n\tself do:\n\t\t[:domainValue |\n\t\taStream nextPut: (aBlock value: domainValue)].\n\t^aStream contents\n",
          "do:": "do: aBlock\n\tmap do:\n\t\t[:mapValue | aBlock value: (domain at: mapValue)]\n",
          "select:": "select: aBlock\n\t| aStream |\n\taStream _ WriteStream on: (self species new: self size).\n\tself do:\n\t\t[:domainValue |\n\t\t(aBlock value: domainValue)\n\t\t\tifTrue: [aStream nextPut: domainValue]].\n\t^aStream contents\n"
        },
        "adding": {
          "add:": "add: newObject\n\tself shouldNotImplement\n"
        }
      }
    },
    "SortedCollection": {
      "comment": "I am an ordered collection of elements, sorted via the function sortBlock.\n",
      "class_name": "SortedCollection",
      "superclass": "OrderedCollection",
      "instanceVariables": "sortBlock",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "sortBlock:": "sortBlock: aBlock\n\t\"Answer a new instance of me such that its elements are sorted according\n\tto the criterion specified in aBlock.\"\n\n\t^(super new: 10) sortBlock: aBlock\n",
          "new:": "new: anInteger\n\t\"The default sorting function is a <= comparison on elements.\"\n\n\t^(super new: anInteger) sortBlock: [:x :y | x <= y]\n"
        }
      },
      "instance_methods": {
        "comparing": {
          "=": "= aSortedCollection\n\t\"Answer true if my and aSortedCollection's species are the same,\n\tand if our blocks are the same, and if our elements are the same.\"\n\n\tself species = aSortedCollection species ifFalse: [^false].\n\tsortBlock = aSortedCollection sortBlock\n\t\tifTrue: [^super = aSortedCollection]\n\t\tifFalse: [^false]\n"
        },
        "copying": {
          "copyEmpty": "copyEmpty\n\t\"Answer a copy of the receiver without any of the receiver's elements.\"\n\n\t^SortedCollection sortBlock: sortBlock\n",
          "copy": "copy\n\t| newCollection |\n\tnewCollection _ self species sortBlock: sortBlock.\n\tnewCollection addAll: self.\n\t^newCollection\n"
        },
        "accessing": {
          "at:put:": "at: anInteger put: anObject\n\t\"Storing into a SortedCollection with at:put: is not allowed.\"\n\n\tself error: 'to add to a sorted collection, you must use add:'\n",
          "sortBlock": "sortBlock\n\t\"Answer the blockContext which is the criterion for sorting elements of\n\tthe receiver.\"\n\t^sortBlock\n",
          "sortBlock:": "sortBlock: aBlock\n\t\"Make the argument, aBlock, be the criterion for ordering elements of the\n\treceiver.\"\n\n\tsortBlock _ aBlock fixTemps.\n\t\"The sortBlock must copy its home context, so as to avoid circularities!\"\n\t\"Therefore sortBlocks with side effects may not work right\"\n\tself size > 0 ifTrue: [self reSort]\n"
        },
        "private": {
          "reSort": "reSort\n\tself sort: firstIndex to: lastIndex\n",
          "sort:to:": "sort: i to: j\n\t\"Sort elements i through j of self to be nondescending according to sortBlock.\"\n\n\t| di dij dj tt ij k l n |\n\t\"The prefix d means the data at that index.\"\n\t(n _ j + 1  - i) <= 1 ifTrue: [^self].\t\"Nothing to sort.\"\n\t \"Sort di,dj.\"\n\tdi _ self basicAt: i.\n\tdj _ self basicAt: j.\n\t(sortBlock value: di value: dj) \"i.e., should di precede dj?\"\n\t\tifFalse:\n\t\t\t[self swap: i with: j.\n\t\t\t tt _ di.\n\t\t\t di _ dj.\n\t\t\t dj _ tt].\n\tn > 2\n\t\tifTrue:  \"More than two elements.\"\n\t\t\t[ij _ (i + j) // 2.  \"ij is the midpoint of i and j.\"\n\t\t\t dij _ self basicAt: ij.  \"Sort di,dij,dj.  Make dij be their median.\"\n\t\t\t (sortBlock value: di value: dij) \"i.e. should di precede dij?\"\n\t\t\t   ifTrue:\n\t\t\t\t[(sortBlock value: dij value: dj) \"i.e., should dij precede dj?\"\n\t\t\t\t  ifFalse:\n\t\t\t\t\t[self swap: j with: ij.\n\t\t\t\t\t dij _ dj]]\n\t\t\t   ifFalse:  \"i.e. di should come after dij\"\n\t\t\t\t[self swap: i with: ij.\n\t\t\t\t dij _ di].\n\t\t\tn > 3\n\t\t\t  ifTrue:  \"More than three elements.\"\n\t\t\t\t[\"Find k>i and l<j such that dk,dij,dl are in reverse order.\n\t\t\t\tSwap k and l.  Repeat this procedure until k and l pass each other.\"\n\t\t\t\t k _ i.\n\t\t\t\t l _ j.\n\t\t\t\t [[l _ l - 1.  k <= l and: [sortBlock value: dij value: (self basicAt: l)]]\n\t\t\t\t   whileTrue.  \"i.e. while dl succeeds dij\"\n\t\t\t\t  [k _ k + 1.  k <= l and: [sortBlock value: (self basicAt: k) value: dij]]\n\t\t\t\t   whileTrue.  \"i.e. while dij succeeds dk\"\n\t\t\t\t  k <= l]\n\t\t\t\t   whileTrue:\n\t\t\t\t\t[self swap: k with: l].\n\t\"Now l<k (either 1 or 2 less), and di through dl are all less than or equal to dk\n\tthrough dj.  Sort those two segments.\"\n\t\t\t\tself sort: i to: l.\n\t\t\t\tself sort: k to: j]]\n",
          "indexForInserting:": "indexForInserting: newObject\n\t| index low high |\n\tlow _ firstIndex.\n\thigh _ lastIndex.\n\t[index _ high + low // 2.\n\tlow > high]\n\t\twhileFalse:\n\t\t\t[(sortBlock value: (self basicAt: index) value: newObject)\n\t\t\t\tifTrue: [low _ index + 1]\n\t\t\t\tifFalse: [high _ index - 1]].\n\t^low\n",
          "swap:with:": "swap: i with: j\n\t| t |\n\tt _ self basicAt: i.\n\tself basicAt: i put: (self basicAt: j).\n\tself basicAt: j put: t\n"
        },
        "enumerating": {
          "collect:": "collect: aBlock\n\t\"Evaluate aBlock with each of my elements as the argument.  Collect the\n\tresulting values into an OrderedCollection  Answer with the new collection.\n\tOverride superclass in order to produce OrderedCollection instead of\n\tSortedCollection. \"\n\n\t| newCollection |\n\tnewCollection _ OrderedCollection new.\n\tself do: [:each | newCollection add: (aBlock value: each)].\n\t^newCollection\n"
        },
        "adding": {
          "add:": "add: newObject\n\t| nextIndex |\n\tself isEmpty ifTrue: [^super addLast: newObject].\n\tnextIndex _ self indexForInserting: newObject.\n\tself insert: newObject before: nextIndex.\n\t^newObject\n",
          "grow": "grow\n\t\"We must duplicate this message from OrderedCollection so the addLast: won't cause an error.\"\n\n\t| newSelf |\n\tnewSelf _ self species new: self size + self growSize.\n\tnewSelf sortBlock: sortBlock.\n\tnewSelf addAll: self.\n\tself become: newSelf\n",
          "addAll:": "addAll: aCollection\n\taCollection size > (self size // 3)\n\t\tifTrue:\n\t\t\t[\"Faster to add the new elements and resort\"\n\t\t\taCollection do: [:each | super addLast: each].\n\t\t\tself reSort]\n\t\tifFalse: [\"Faster to add the elements individually in their proper places\"\n\t\t\taCollection do: [:each | self add: each]]\n"
        }
      }
    },
    "OrderedCollection": {
      "comment": "I am an ordered collection of elements.\n",
      "class_name": "OrderedCollection",
      "superclass": "SequenceableCollection",
      "instanceVariables": "firstIndex lastIndex",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t^self new: 10\n",
          "new:": "new: anInteger\n\t\"If a subclass adds fields, then it is necessary for that subclass to reimplement\n\tnew: \"\n\n\t^(super new: anInteger) setIndices\n"
        }
      },
      "instance_methods": {
        "copying": {
          "copyWith:": "copyWith: newElement\n\t\"Answer a copy of the receiver that is 1 bigger than the receiver and\n\tincludes the argument, newElement, at the end.\"\n\n\t| newCollection |\n\tnewCollection _ self copy.\n\tnewCollection add: newElement.\n\t^newCollection\n",
          "copyFrom:to:": "copyFrom: startIndex to: endIndex\n\t\"Answer a copy of the receiver that contains elements from position startIndex\n\tto endIndex.\"\n\n\t| targetCollection index |\n\tendIndex < startIndex ifTrue: [^self species new: 0].\n\ttargetCollection _ self species new: endIndex + 1 - startIndex.\n\tstartIndex to: endIndex do: [:index | targetCollection add: (self at: index)].\n\t^targetCollection\n",
          "copyWithout:": "copyWithout: oldElement\n\t\"Answer a copy of the receiver that does not contain any elements equal\n\tto oldElement.\"\n\n\t| newCollection each |\n\tnewCollection _ self species new: self size.\n\tself do: [:each | oldElement = each ifFalse: [newCollection add: each]].\n\t^newCollection\n",
          "copyEmpty": "copyEmpty\n\t\"Answer a copy of the receiver that contains no elements.\"\n\n\t^self species new\n",
          "copyReplaceFrom:to:with:": "copyReplaceFrom: start to: stop with: replacementCollection\n\t\"Answer a copy of the receiver with replacementCollection's elements\n\tin place of the receiver's start'th to stop'th elements.\n\tThis does not expect a 1-1 map from replacementCollection to the\n\tstart to stop elements, so it will do an insert or append.\"\n\n\t| newOrderedCollection delta newIndex index mySize startIndex stopIndex |\n\t\"if start is less than 1, ignore stop and assume this is inserting at the front.\n\tif start greater than self size, ignore stop and assume this is appending.\n\totherwise, it is replacing part of me and start and stop have to be within my\n\tbounds. \"\n\tdelta _ 0.\n\tstartIndex _ start.\n\tstopIndex _ stop.\n\tstart < 1\n\t\tifTrue: [startIndex _ stopIndex _ 0]\n\t\tifFalse: [startIndex > self size\n\t\t\t\tifTrue: [startIndex _ stopIndex _ self size + 1]\n\t\t\t\tifFalse:\n\t\t\t\t\t[(stopIndex < (startIndex - 1) or: [stopIndex > self size])\n\t\t\t\t\t\tifTrue: [self errorOutOfBounds].\n\t\t\t\t\tdelta _ stopIndex - startIndex + 1]].\n\tnewOrderedCollection _\n\t\tself species new: self size + replacementCollection size - delta.\n\t1 to: startIndex - 1 do: [:index | newOrderedCollection add: (self at: index)].\n\t1 to: replacementCollection size do:\n\t\t[:index | newOrderedCollection add: (replacementCollection at: index)].\n\tstopIndex + 1 to: self size do: [:index | newOrderedCollection add: (self at: index)].\n\t^newOrderedCollection\n"
        },
        "accessing": {
          "first": "first\n\t\"Answer the first element.  If the receiver is empty, create an errror message.\n\tThis is a little faster than the implementation in the superclass\"\n\n\tself emptyCheck.\n\t^self basicAt: firstIndex\n",
          "before:": "before: oldObject\n\t\"Answer the element before oldObject.  If the receiver does not contain oldObject\n\tor if the receiver contains no elements before oldObject, create an error message.\"\n\n\t| index |\n\tindex _ self find: oldObject.\n\tindex = firstIndex\n\t\tifTrue: [^self errorFirstObject]\n\t\tifFalse: [^self basicAt: index - 1]\n",
          "at:put:": "at: anInteger put: anObject\n\t\"Put anObject at element index anInteger.\n\tat:put: can not be used to append, front or back, to an ordered collection;\n\t it is used by a knowledgeable client to replace an element\"\n\n\t| index |\n\tindex _ anInteger truncated.\n\t(index < 1 or: [index + firstIndex - 1 > lastIndex])\n\t\tifTrue: [self errorNoSuchElement]\n\t\tifFalse: [^super at: index + firstIndex - 1 put: anObject]\n",
          "at:": "at: anInteger\n\t\"Answer with my element at index anInteger.\n\tat: is used by a knowledgeable client to access an existing element\"\n\n\t(anInteger < 1 or: [anInteger + firstIndex - 1 > lastIndex])\n\t\tifTrue: [self errorNoSuchElement]\n\t\tifFalse: [^super at: anInteger + firstIndex - 1]\n",
          "after:": "after: oldObject\n\t\"Answer the element after oldObject.  If the receiver does not contain oldObject\n\tor if the receiver contains no elements after oldObject, create an error message.\"\n\n\t| index |\n\tindex _ self find: oldObject.\n\tindex = lastIndex\n\t\tifTrue: [^self errorLastObject]\n\t\tifFalse: [^self basicAt: index + 1]\n",
          "last": "last\n\t\"Answer the last element.  If the receiver is empty, create an errror message.\n\tThis is a little faster than the implementation in the superclass\"\n\n\tself emptyCheck.\n\t^self basicAt: lastIndex\n",
          "size": "size\n\t^lastIndex - firstIndex + 1\n"
        },
        "private": {
          "errorNotFound": "errorNotFound\n\tself error: 'element not found'\n",
          "errorNoSuchElement": "errorNoSuchElement\n\tself error: 'attempt to index non-existent element in an ordered collection'\n",
          "makeRoomAtLast": "makeRoomAtLast\n\t| index newLast |\n\tnewLast _ self size.\n\tself basicSize - self size = 0 ifTrue: [self grow].\n\tfirstIndex = 1 ifTrue: [^self].\n\t\"we might be here under false premises or grow did the job for us\"\n\tindex _ 1.\n\t[index <= newLast]\n\t\twhileTrue:\n\t\t\t[self basicAt: index put: (self basicAt: index + firstIndex - 1).\n\t\t\tself basicAt: index + firstIndex - 1 put: nil.\n\t\t\tindex _ index + 1].\n\tfirstIndex _ 1.\n\tlastIndex _ newLast\n",
          "removeIndex:": "removeIndex: removedIndex\n\t| index |\n\tindex _ removedIndex.\n\t[index < lastIndex]\n\t\twhileTrue:\n\t\t\t[self basicAt: index put: (self basicAt: index + 1).\n\t\t\tindex _ index + 1].\n\tself basicAt: lastIndex put: nil.\n\tlastIndex _ lastIndex - 1\n",
          "makeRoomAtFirst": "makeRoomAtFirst\n\t| delta index |\n\tdelta _ self basicSize - self size.\n\tdelta = 0\n\t\tifTrue:\n\t\t\t[self grow.\n\t\t\tdelta _ self basicSize - self size].\n\tlastIndex = self basicSize ifTrue: [^self].\n\t\"just in case we got lucky\"\n\tindex _ self basicSize.\n\t[index > delta]\n\t\twhileTrue:\n\t\t\t[self basicAt: index put: (self basicAt: index - delta + firstIndex - 1).\n\t\t\tself basicAt: index - delta + firstIndex - 1 put: nil.\n\t\t\tindex _ index - 1].\n\tfirstIndex _ delta + 1.\n\tlastIndex _ self basicSize\n",
          "insert:before:": "insert: anObject before: spot\n\t| index delta spotIndex|\n\tspotIndex _ spot.\n\tdelta _ spotIndex - firstIndex.\n\tfirstIndex = 1\n\t\tifTrue:\n\t\t\t[self makeRoomAtFirst.\n\t\t\tspotIndex _ firstIndex + delta].\n\tindex _ firstIndex _ firstIndex - 1.\n\t[index < (spotIndex - 1)]\n\t\twhileTrue:\n\t\t\t[self basicAt: index put: (self basicAt: index + 1).\n\t\t\tindex _ index + 1].\n\tself basicAt: index put: anObject.\n\t^anObject\n",
          "find:": "find: oldObject\n\t| index |\n\tindex _ firstIndex.\n\t[index <= lastIndex and: [oldObject ~= (self basicAt: index)]]\n\t\twhileTrue: [index _ index + 1].\n\tindex <= lastIndex\n\t\tifTrue: [^index]\n\t\tifFalse: [self errorNotFound]\n",
          "errorLastObject": "errorLastObject\n\tself error: 'specified object is last object'\n",
          "errorFirstObject": "errorFirstObject\n\tself error: 'specified object is first object'\n",
          "setIndices": "setIndices\n\tfirstIndex _ self basicSize // 2 max: 1.\n\tlastIndex _ firstIndex - 1 max: 0\n"
        },
        "enumerating": {
          "collect:": "collect: aBlock\n\t\"Evaluate aBlock with each of my elements as the argument.  Collect the\n\tresulting values into a collection that is like me.  Answer with the new\n\tcollection. Override superclass in order to use add:, not at:put:.\"\n\n\t| newCollection |\n\tnewCollection _ self species new.\n\tself do: [:each | newCollection add: (aBlock value: each)].\n\t^newCollection\n",
          "do:": "do: aBlock\n\t\"override the superclass for performance\"\n\n\t| index |\n\tindex _ firstIndex.\n\t[index <= lastIndex]\n\t\twhileTrue:\n\t\t\t[aBlock value: (self basicAt: index).\n\t\t\tindex _ index + 1]\n",
          "reverseDo:": "reverseDo: aBlock\n\t\"override the superclass for performance\"\n\n\t| index |\n\tindex _ lastIndex.\n\t[index >= firstIndex]\n\t\twhileTrue:\n\t\t\t[aBlock value: (self basicAt: index).\n\t\t\tindex _ index - 1]\n",
          "select:": "select: aBlock\n\t\"Evaluate aBlock with each of my elements as the argument.  Collect into a new\n\tcollection like me, only those elements for which aBlock evaluates to true.\n\tOverride superclass in order to use add:, not at:put:.\"\n\n\t| newCollection |\n\tnewCollection _ self copyEmpty.\n\tself do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].\n\t^newCollection\n",
          "reverse": "reverse\n\t\"Answer with a new collection like me with its elements in the opposite order.\n\tOverride superclass in order to use add:, not at:put:.\"\n\n\t| newCollection |\n\tnewCollection _ self species new.\n\tself reverseDo: [:each | newCollection add: each].\n\t^newCollection\n"
        },
        "adding": {
          "add:": "add: newObject\n\t^self addLast: newObject\n",
          "addLast:": "addLast: newObject\n\t\"Add newObject to the end of the receiver.  Answer newObject.\"\n\n\tlastIndex = self basicSize ifTrue: [self makeRoomAtLast].\n\tlastIndex _ lastIndex + 1.\n\tself basicAt: lastIndex put: newObject.\n\t^newObject\n",
          "add:before:": "add: newObject before: oldObject\n\t\"Add the argument, newObject, as an element of the receiver.  Put it\n\tin the position just preceding oldObject.  Answer newObject.\"\n\n\t| index |\n\tindex _ self find: oldObject.\n\tself insert: newObject before: index.\n\t^newObject\n",
          "addAllLast:": "addAllLast: anOrderedCollection\n\t\"Add each element of anOrderedCollection at the end of the receiver.  Answer\n\tanOrderedCollection.\"\n\n\tanOrderedCollection do: [:each | self addLast: each].\n\t^anOrderedCollection\n",
          "add:after:": "add: newObject after: oldObject\n\t\"Add the argument, newObject, as an element of the receiver.  Put it\n\tin the position just succeeding oldObject.  Answer newObject.\"\n\n\t| index |\n\tindex _ self find: oldObject.\n\tself insert: newObject before: index + 1.\n\t^newObject\n",
          "addAllFirst:": "addAllFirst: anOrderedCollection\n\t\"Add each element of anOrderedCollection at the beginning of the receiver.\n\tAnswer anOrderedCollection.\"\n\n\tanOrderedCollection reverseDo: [:each | self addFirst: each].\n\t^anOrderedCollection\n",
          "grow": "grow\n\t\"Become larger.\n\tTypically, a subclass has to override this if the subclass adds instance variables\"\n\n\t| newSelf |\n\tnewSelf _ self species new: self size + self growSize.\n\tself do: [:each | newSelf addLast: each].\n\tself become: newSelf\n",
          "addFirst:": "addFirst: newObject\n\t\"Add newObject to the beginning of the receiver.  Add newObject.\"\n\n\tfirstIndex = 1 ifTrue: [self makeRoomAtFirst].\n\tfirstIndex _ firstIndex - 1.\n\tself basicAt: firstIndex put: newObject.\n\t^newObject\n",
          "addAll:": "addAll: anOrderedCollection\n\t\"Add each element of anOrderedCollection at my end.  Answer anOrderedCollection.\"\n\n\t^self addAllLast: anOrderedCollection\n"
        },
        "removing": {
          "removeLast": "removeLast\n\t\"Remove the last element of the receiver.  If the receiver is empty, create an error\n\tmessage.\"\n\n\t| lastObject |\n\tself emptyCheck.\n\tlastObject _ self basicAt: lastIndex.\n\tself basicAt: lastIndex put: nil.\n\tlastIndex _ lastIndex - 1.\n\t^lastObject\n",
          "removeFirst": "removeFirst\n\t\"Remove the first element of the receiver.  If the receiver is empty, create an error\n\tmessage.\"\n\n\t| firstObject |\n\tself emptyCheck.\n\tfirstObject _ self basicAt: firstIndex.\n\tself basicAt: firstIndex put: nil.\n\tfirstIndex _ firstIndex + 1.\n\t^firstObject\n",
          "removeAllSuchThat:": "removeAllSuchThat: aBlock\n\t\"Evaluate aBlock for each element of the receiver.  Remove each element for\n\twhich aBlock evaluates to true.\n\tA subclass might have to override this message to initialize additional instance\n\tvariables for newCollection\"\n\n\t| index element newCollection |\n\tnewCollection _ self species new.\n\tindex _ firstIndex.\n\t[index <= lastIndex]\n\t\twhileTrue:\n\t\t\t[element _ self basicAt: index.\n\t\t\t(aBlock value: element)\n\t\t\t\tifTrue:\n\t\t\t\t\t[newCollection add: element.\n\t\t\t\t\tself removeIndex: index]\n\t\t\t\tifFalse: [index _ index + 1]].\n\t^newCollection\n",
          "remove:ifAbsent:": "remove: oldObject ifAbsent: absentBlock\n\t| index |\n\tindex _ firstIndex.\n\t[index <= lastIndex]\n\t\twhileTrue:\n\t\t\t[oldObject = (self basicAt: index)\n\t\t\t\tifTrue:\n\t\t\t\t\t[self removeIndex: index.\n\t\t\t\t\t^oldObject]\n\t\t\t\tifFalse: [index _ index + 1]].\n\t^absentBlock value\n"
        }
      }
    }
  },
  "Collections-Streams": {
    "ReadWriteStream": {
      "comment": "I am a positionable stream into which we can both read and write.\n",
      "class_name": "ReadWriteStream",
      "superclass": "WriteStream",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "fileIn/Out": {
          "timeStamp": "timeStamp\n\t\"Append the current time to the receiver as a chunk.\"\n\n\t| aStream |\n\taStream _ WriteStream on: (String new: 16).\n\tSmalltalk timeStamp: aStream.\n\tself nextChunkPut: aStream contents printString.\t\"double quotes and !s\"\n\tself cr; cr\n",
          "fileIn": "fileIn\n\t\"This is special for reading expressions from text that has been formatted\n\twith exclamation delimitors.  The expressions are read and passed to the\n\tCompiler.  Answer the result of compilation.\"\n\n\t| val |\n\tCursor read showWhile:\n\t\t[[self atEnd]\n\t\t\twhileFalse:\n\t\t\t\t[self skipSeparators.\n\t\t\t\tval _ (self peekFor: $!)\n\t\t\t\t\t\t\tifTrue: [(Compiler evaluate: self nextChunk logged: false)\n\t\t\t\t\t\t\t\t\tscanFrom: self]\n\t\t\t\t\t\t\tifFalse: [Compiler evaluate: self nextChunk logged: true]].\n\t\tself close].\n\t^val\n",
          "fileOutChanges": "fileOutChanges\n\t\"Append to the receiver a description of all system changes.\"\n\n\tCursor write showWhile:\n\t\t[self timeStamp.\n\t\tSmalltalk changes fileOutOn: self.\n\t\tself close]\n",
          "fileOutChangesFor:": "fileOutChangesFor: class\n\t\"Append to the receiver a description of the changes to the argument, class.\"\n\n\tCursor write showWhile:\n\t\t[self timeStamp.\n\t\tSmalltalk changes fileOutChangesFor: class on: self.\n\t\tself close]\n"
        },
        "file status": {
          "close": "close\n\t\"Prsumably sets the status of the stream to be closed.\n\tThis message does nothing at this level, but is included for FileStream\n\tcompatibility.\"\n\t^self\n"
        },
        "accessing": {
          "next": "next\n\t\"Return the next object in the Stream represented by the receiver. Fail if\n\tthe collection of this stream is not an Array or a String. Fail if the\n\tstream is positioned at its end, or if the position is out of bounds in the\n\tcollection. Optional. See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 65>\n\t\"treat me as a FIFO\"\n\tposition >= readLimit\n\t\tifTrue: [^nil]\n\t\tifFalse: [^collection at: (position _ position + 1)]\n",
          "contents": "contents\n\t\"Answer with a copy of my collection from 1 to readLimit.\"\n\n\treadLimit _ readLimit max: position.\n\t^collection copyFrom: 1 to: readLimit\n"
        }
      }
    },
    "Stream": {
      "comment": "I am an abstract class representing objects that stream over a self typing data structure.\n",
      "class_name": "Stream",
      "superclass": "Object",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\tself error: 'Streams are created with on: and with:'\n"
        }
      },
      "instance_methods": {
        "testing": {
          "atEnd": "atEnd\n\t\"Answer whether the position is greater than or equal to the limit.\"\n\tself subclassResponsibility\n"
        },
        "accessing": {
          "nextPut:": "nextPut: anObject\n\t\"Insert the argument, anObject, at the next position in the receiver.\n\tAnswer anObject.\"\n\tself subclassResponsibility\n",
          "next:put:": "next: anInteger put: anObject\n\t\"Put anObject into the next anInteger elements of the receiver.\"\n\n\tanInteger timesRepeat: [self nextPut: anObject].\n\t^anObject\n",
          "next": "next\n\t\"Answer the next object in the receiver.\"\n\tself subclassResponsibility\n",
          "contents": "contents\n\t\"Answer the contents of the receiver.\"\n\tself subclassResponsibility\n",
          "nextMatchFor:": "nextMatchFor: anObject\n\t\"Gobble the next element and answer whether it is equal to anObject.\"\n\n\t^anObject = self next\n",
          "next:": "next: anInteger\n\t\"Answer an OrderedCollection of the next anInteger number of random numbers.\"\n\t| aCollection |\n\taCollection _ OrderedCollection new.\n\tanInteger timesRepeat: [aCollection addLast: self next].\n\t^aCollection\n",
          "nextPutAll:": "nextPutAll: aCollection\n\t\"Append the elements of aCollection onto the receiver.  Answer aCollection.\"\n\n\taCollection do: [:v | self nextPut: v].\n\t^aCollection\n"
        },
        "enumerating": {
          "do:": "do: aBlock\n\t\"Evaluate aBlock for each of the elements of the receiver.\"\n\n\t[self atEnd]\n\t\twhileFalse: [aBlock value: self next]\n"
        }
      }
    },
    "ReadStream": {
      "comment": "I am a reader of an indexable collection.  I only define the message next.\n",
      "class_name": "ReadStream",
      "superclass": "PositionableStream",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "on:from:to:": "on: aCollection from: firstIndex to: lastIndex\n\t\"Answer with a new instance streaming over a copy of aCollection from\n\tfirstIndex to lastIndex.\"\n\n\t^self basicNew\n\t\ton: aCollection\n\t\tfrom: firstIndex\n\t\tto: lastIndex\n"
        }
      },
      "instance_methods": {
        "accessing": {
          "nextPut:": "nextPut: anObject\n\tself shouldNotImplement\n",
          "next": "next\n\t\"Answer with the next object in the Stream represented by the receiver.\n\tFail if the collection of this stream is not an Array or a String. Fail if\n\tthe stream is positioned at its end, or if the position is out of bounds in\n\tthe collection. Optional. See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 65>\n\tposition >= readLimit\n\t\tifTrue: [^nil]\n\t\tifFalse: [^collection at: (position _ position + 1)]\n"
        },
        "private": {
          "on:from:to:": "on: aCollection from: firstIndex to: lastIndex\n\t| len |\n\tcollection _ aCollection.\n\treadLimit _  lastIndex > (len _ collection size)\n\t\t\t\t\t\tifTrue: [len]\n\t\t\t\t\t\tifFalse: [lastIndex].\n\tposition _ firstIndex <= 1\n\t\t\t\tifTrue: [0]\n\t\t\t\tifFalse: [firstIndex - 1]\n"
        }
      }
    },
    "WriteStream": {
      "comment": "I am a writer of an indexable collection. writeLimit marks the farthest that has been written into the collection, not the actual size of the collection.\n",
      "class_name": "WriteStream",
      "superclass": "PositionableStream",
      "instanceVariables": "writeLimit",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "with:from:to:": "with: aCollection from: firstIndex to: lastIndex\n\t\"Answer a new instance of me streaming on the subcollection of aCollection, starting\n\tat index firstIndex and ending at lastIndex.  Assume that the\n\tresulting collection is already full so the position and the limits are set to the end.\"\n\n\t^self basicNew with: (aCollection copyFrom: firstIndex to: lastIndex)\n",
          "with:": "with: aCollection\n\t\"Answer a new instance of me streaming on aCollection.  Assume that the\n\tcollection is already full so the position and the limits are set to the end.\"\n\n\t^self basicNew with: aCollection\n",
          "on:from:to:": "on: aCollection from: firstIndex to: lastIndex\n\t\"Answer with a new instance streaming over a copy of aCollection from\n\tfirstIndex to lastIndex.\"\n\n\t^self basicNew\n\t\ton: aCollection\n\t\tfrom: firstIndex\n\t\tto: lastIndex\n"
        }
      },
      "instance_methods": {
        "character writing": {
          "cr": "cr\n\t\"Append a return character to the receiver.\"\n\n\tself nextPut: Character cr\n",
          "emphasis": "emphasis\n\t^ 1\n\t\"Allows compatibility with streams which carry emphasis\"\n",
          "tab": "tab\n\t\"Append a tab character to the receiver.\"\n\n\tself nextPut: Character tab\n",
          "space": "space\n\t\"Append a space character to the receiver.\"\n\n\tself nextPut: Character space\n",
          "emphasis:": "emphasis: ignored\n\t\"Allows compatibility with streams which carry emphasis\"\n",
          "crtab": "crtab\n\t\"Append a return character, followed by a single tab character, to the receiver.\"\n\n\tself nextPut: Character cr.\n\tself nextPut: Character tab\n",
          "crtab:": "crtab: anInteger\n\t\"Append a return character, followed by anInteger tab characters, to the receiver.\"\n\n\tself nextPut: Character cr.\n\tanInteger timesRepeat: [self nextPut: Character tab]\n"
        },
        "fileIn/Out": {
          "nextChunkPut:": "nextChunkPut: aString\n\t\"Put aString onto self, doubling embedded terminators.\"\n\n\t| index stringSize char terminator |\n\tterminator _ $!.\n\tindex _ 0.\n\tstringSize _ aString size.\n\t[(index _ index + 1) <= stringSize]\n\t\twhileTrue:\n\t\t\t[char _ aString at: index.\n\t\t\tself nextPut: char.\n\t\t\tchar == terminator ifTrue: [\"double imbedded terminator\"\n\t\t\t\tself nextPut: char]].\n\tself nextPut: terminator\n"
        },
        "positioning": {
          "position:": "position: anInteger\n\treadLimit _ readLimit max: position.\n\tsuper position: anInteger\n",
          "reset": "reset\n\treadLimit _ readLimit max: position.\n\tposition _ 0\n"
        },
        "printing": {
          "store:": "store: anObject\n\t\"Have anObject print on me for rereading.\"\n\n\tanObject storeOn: self\n",
          "print:": "print: anObject\n\t\"Have anObject print on the receiver.\"\n\n\tanObject printOn: self\n"
        },
        "accessing": {
          "nextPut:": "nextPut: anObject\n\t\"Insert the argument at the next position in the Stream represented by the\n\treceiver. Fail if the collection of this stream is not an Array or a String.\n\tFail if the stream is positioned at its end, or if the position is out of\n\tbounds in the collection. Fail if the argument is not of the right type for\n\tthe collection. Optional. See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 66>\n\tposition = writeLimit\n\t\tifTrue: [^self pastEndPut: anObject]\n\t\tifFalse:\n\t\t\t[^collection at: (position _ position + 1) put: anObject]\n",
          "next": "next\n\tself shouldNotImplement\n",
          "contents": "contents\n\treadLimit _ readLimit max: position.\n\t^collection copyFrom: 1 to: position\n",
          "size": "size\n\t^readLimit _ readLimit max: position\n"
        },
        "private": {
          "on:": "on: aCollection\n\tsuper on: aCollection.\n\treadLimit _ 0.\n\twriteLimit _ aCollection size\n",
          "pastEndPut:": "pastEndPut: anObject\n\tcollection grow.\n\twriteLimit _ collection size.\n\tcollection at: (position _ position + 1) put: anObject\n",
          "with:": "with: aCollection\n\tsuper on: aCollection.\n\tposition _ readLimit _ writeLimit _ aCollection size\n",
          "on:from:to:": "on: aCollection from: firstIndex to: lastIndex\n\t| len |\n\tcollection _ aCollection.\n\treadLimit _\n\t\twriteLimit _ lastIndex > (len _ collection size)\n\t\t\t\t\t\tifTrue: [len]\n\t\t\t\t\t\tifFalse: [lastIndex].\n\tposition _ firstIndex <= 1\n\t\t\t\tifTrue: [0]\n\t\t\t\tifFalse: [firstIndex - 1]\n"
        }
      }
    },
    "PositionableStream": {
      "comment": "I assume that my contents is an indexable collection and that, in support of accessing the elements of my contents, I can reposition a pointer.  I am abstract in that I do not implement the messages next and nextPut: which are inherited from my superclass Stream.\n",
      "class_name": "PositionableStream",
      "superclass": "Stream",
      "instanceVariables": "collection position readLimit",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "on:": "on: aCollection\n\t\"Answer a new instance of me, streaming over aCollection.\"\n\n\t^self basicNew on: aCollection\n",
          "on:from:to:": "on: aCollection from: firstIndex to: lastIndex\n\t\"Answer a new instance of me, streaming over a copy of aCollection from\n\tfirstIndex to lastIndex.\"\n\n\t^self basicNew on: (aCollection copyFrom: firstIndex to: lastIndex)\n"
        }
      },
      "instance_methods": {
        "fileIn/Out": {
          "skipSeparators": "skipSeparators\n\t\"Move the receiver's position past any separators.\"\n\n\t[self atEnd == false and: [self peek isSeparator]]\n\t\twhileTrue: [self next]\n",
          "nextChunk": "nextChunk\n\t\"Answer the contents of the receiver, up to the next terminator character, with\n\tdouble terminators ignored.\"\n\n\t| aStream char terminator |\n\tterminator _ $!.\n\taStream _ WriteStream on: (String new: 200).\n\tself skipSeparators.\n\t[(char _ self next)==nil]\n\t\twhileFalse:\n\t\t\t[char == terminator\n\t\t\t\tifTrue: [(self peekFor: terminator)\n\t\t\t\t\t\tifTrue: [\"doubled terminator\"\n\t\t\t\t\t\t\taStream nextPut: char]\n\t\t\t\t\t\tifFalse: [^aStream contents]]\n\t\t\t\tifFalse: [aStream nextPut: char]].\n\t^aStream contents\n"
        },
        "positioning": {
          "position:": "position: anInteger\n\t\"Set position to anInteger as long as anInteger is within the bounds of the\n\treceiver's contents.  If it is not, cause an error.\"\n\n\tanInteger >= 0 & (anInteger <= readLimit)\n\t\tifTrue: [position _ anInteger]\n\t\tifFalse: [self positionError]\n",
          "position": "position\n\t\"Answer the current position of accessing the stream.\"\n\t^position\n",
          "skipTo:": "skipTo: anObject\n\t\"Position the receiver past the next occurrance of anObject.  Answer true if\n\tanObject is found, false otherwise.\"\n\n\t[self atEnd]\n\t\twhileFalse: [self next = anObject ifTrue: [^true]].\n\t^false\n",
          "skip:": "skip: anInteger\n\t\"Set position to position+anInteger. A subclass might choose to be more\n\thelpful and select the minimum of self size and position+anInteger or\n\tmaximum of 1 and position+anInteger for the repositioning.\"\n\n\tself position: position + anInteger\n",
          "reset": "reset\n\t\"Set the receiver's position to 0.\"\n\tposition _ 0\n",
          "setToEnd": "setToEnd\n\t\"Set the position of the receiver to the end of its stream of elements.\"\n\tposition _ readLimit\n"
        },
        "testing": {
          "atEnd": "atEnd\n\t\"Answer true if the position is greater than or equal to the limit,\n\totherwise answer false. Fail if position or readLimit is not a SmallInteger.\n\tOptional. See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 67>\n\t^position >= readLimit\n",
          "isEmpty": "isEmpty\n\t\"Answer whether the receiver has no elements.\"\n\t^position = 0\n"
        },
        "accessing": {
          "peek": "peek\n\t\"Answer what would be returned with a self next, without\n\tchanging position.  If the receiver is at the end, answer nil.\"\n\n\t| nextObject |\n\tself atEnd ifTrue: [^nil].\n\tnextObject _ self next.\n\tposition _ position - 1.\n\t^nextObject\n",
          "upTo:": "upTo: anObject\n\t\"Answer a subcollection from position to the occurrence (if any, not\n\tinclusive) of anObject. If not there, answer everything.\"\n\n\t| newStream element |\n\tnewStream _ WriteStream on: (collection species new: 64).\n\t[self atEnd or: [(element _ self next) = anObject]]\n\t\twhileFalse: [newStream nextPut: element].\n\t^newStream contents\n",
          "contents": "contents\n\t\"Answer with a copy of my collection from 1 to readLimit.\"\n\n\t^collection copyFrom: 1 to: readLimit\n",
          "peekFor:": "peekFor: anObject\n\t\"Answer false and do not move the position if self next ~= anObject or if the\n\treceiver is at the end. Answer true and increment position if self next = anObject.\"\n\n\t| nextObject |\n\tself atEnd ifTrue: [^false].\n\tnextObject _ self next.\n\t\"peek for matching element\"\n\tanObject = nextObject ifTrue: [^true].\n\t\"gobble it if found\"\n\tposition _ position - 1.\n\t^false\n",
          "next:": "next: anInteger\n\t\"Answer the next anInteger elements of the receiver.\"\n\t| newArray |\n\tnewArray _ self contents species new: anInteger.\n\t1 to: anInteger do: [:index | newArray at: index put: self next].\n\t^newArray\n",
          "through:": "through: anObject\n\t\"Answer a subcollection from position to the occurrence (if any, not\n\tinclusive) of anObject. If not there, answer everything.\"\n\n\t| newStream element |\n\tnewStream _ WriteStream on: (collection species new: 64).\n\t[(self atEnd or: [(element _ self next) = anObject]) or: [newStream size > 64000]]\n\t\twhileFalse: [newStream nextPut: element].\n\tself atEnd\n\t\tifFalse:\t[newStream nextPut: element].\n\t^newStream contents\n"
        },
        "private": {
          "on:": "on: aCollection\n\tcollection _ aCollection.\n\treadLimit _ aCollection size.\n\tposition _ 0.\n\tself reset\n",
          "positionError": "positionError\n\t\"Since I am not necessarily writable, it is up to my subclasses to override\n\tposition: if expanding the collection is preferrable to giving this error.\"\n\n\tself error: 'Attempt to set the position of a PositionableStream out of bounds'\n"
        }
      }
    }
  },
  "Collections-Support": {
    "Association": {
      "comment": "I am a pair of associated objects--a key and a value.  I can serve as an entry in a dictionary.  Think of my key as the left-hand side of the dictionary and my value as the right-hand side.\n",
      "class_name": "Association",
      "superclass": "LookupKey",
      "instanceVariables": "value",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "key:value:": "key: newKey value: newValue\n\t\"Answer a new instance of me with the arguments as the key and\n\tvalue of the association.\"\n\t^(super key: newKey) value: newValue\n"
        }
      },
      "instance_methods": {
        "printing": {
          "printOn:": "printOn: aStream\n\tsuper printOn: aStream.\n\taStream nextPutAll: '->'.\n\tvalue printOn: aStream\n"
        },
        "accessing": {
          "key:value:": "key: aKey value: anObject\n\t\"Store the arguments as the variables of the receiver.\"\n\n\tkey _ aKey.\n\tvalue _ anObject\n",
          "value": "value\n\t\"Answer the value of the receiver.\"\n\t^value\n",
          "value:": "value: anObject\n\t\"Store the argument, anObject, as the value of the receiver.\"\n\tvalue _ anObject\n"
        }
      }
    },
    "LookupKey": {
      "comment": "I serve as the key for looking up entries in a Dictionary.  Subclasses of me are dictionary entries.  An available example is Association.\n",
      "class_name": "LookupKey",
      "superclass": "Magnitude",
      "instanceVariables": "key",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "key:": "key: aKey\n\t\"Answer a new instance of me with the argument as the lookup up.\"\n\t^self new key: aKey\n"
        }
      },
      "instance_methods": {
        "comparing": {
          "hash": "hash\n\t^key hash\n",
          "<": "< aLookupKey\n\t^key < aLookupKey key\n",
          "=": "= aLookupKey\n\tself species = aLookupKey species\n\t\tifTrue: [^key = aLookupKey key]\n\t\tifFalse: [^false]\n",
          "hashMappedBy:": "hashMappedBy: map\n\t\"Answer what my hash would be if oops changed according to map\"\n\t^ key hashMappedBy: map\n"
        },
        "printing": {
          "printOn:": "printOn: aStream\n\tkey printOn: aStream\n"
        },
        "accessing": {
          "key:": "key: anObject\n\t\"Store the argument, anObject, as the lookup key of the receiver.\"\n\tkey _ anObject\n",
          "key": "key\n\t\"Answer the lookup key of the receiver.\"\n\t^key\n"
        }
      }
    },
    "Link": {
      "comment": "I am a simple record of a pointer to another Link\n",
      "class_name": "Link",
      "superclass": "Object",
      "instanceVariables": "nextLink",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "nextLink:": "nextLink: aLink\n\t\"Answer a new instance of me referring to the argument, aLink.\"\n\t^self new nextLink: aLink\n"
        }
      },
      "instance_methods": {
        "accessing": {
          "nextLink:": "nextLink: aLink\n\t\"Store the argument, as the Link to which the receiver refers.\"\n\t^nextLink _ aLink\n",
          "nextLink": "nextLink\n\t\"Answer the Link to which the receiver points.\"\n\t^nextLink\n"
        }
      }
    }
  },
  "Collections-Text": {
    "Character": {
      "comment": "This class represents characters by storing their associated ASCII (extended to 256 codes) code.  The instances of this class are created uniquely, so that all instances $R (for instance) are identical\n",
      "class_name": "Character",
      "superclass": "Magnitude",
      "instanceVariables": "value",
      "classInstanceVariables": "",
      "classVariables": "CharacterTable",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"Create the table of unique Characters.  This code is not shown so that the\n\tuser can not destroy the system by trying to recreate the table.\"\n"
        },
        "constants": {
          "characterTable": "characterTable\n\t\"Answer the class variable in which unique Characters are stored.\"\n\t^CharacterTable\n"
        },
        "accessing untypeable characters": {
          "cr": "cr\n\t\"Answer the Character representing a carriage return.\"\n\t^self value: 13\n",
          "tab": "tab\n\t\"Answer the Character representing a tab.\"\n\t^self value: 9\n",
          "space": "space\n\t\"Answer the Character representing a space.\"\n\t^self value: 32\n",
          "newPage": "newPage\n\t\"Answer the Character representing a form feed.\"\n\t^self value: 12\n",
          "backspace": "backspace\n\t\"Answer the Character representing a backspace.\"\n\t^self value: 8\n",
          "esc": "esc\n\t\"Answer the Character representing an escape.\"\n\t^self value: 160\n"
        },
        "instance creation": {
          "new": "new\n\t\"Creating new characters is not allowed.\"\n\n\tself error: 'cannot create new characters'\n",
          "value:": "value: anInteger\n\t\"Answer the Character whose value is anInteger.\n\tCharacters are unique; they are stored in the class variable CharacterTable.\"\n\n\t^CharacterTable at: anInteger + 1\n",
          "digitValue:": "digitValue: x\n\t\"Answer the Character whose digit value is x.  For example,\n\tanswer $9 for x=9, $0 for x=0, $A for x=10, $Z for x=35.\"\n\n\t| index |\n\tindex _ x truncated.\n\t^CharacterTable at:\n\t\t(index < 10\n\t\t\tifTrue: [48 + index]\n\t\t\tifFalse: [55 + index])\n\t\t+ 1\n"
        }
      },
      "instance_methods": {
        "comparing": {
          "hash": "hash\n\t^value\n",
          ">": "> aCharacter\n\t\"Answer true if the receiver's value > aCharacter's value.\"\n\n\t^self asciiValue > aCharacter asciiValue\n",
          "<": "< aCharacter\n\t\"Answer true if the receiver's value < aCharacter's value.\"\n\n\t^self asciiValue < aCharacter asciiValue\n",
          "=": "= aCharacter\n\t\"Answer true if the receiver and the argument are the same object (have the\n\tsame object pointer) and false otherwise.  Optional.  See Object documentation\n\twhatIsAPrimitive.\"\n\n\t<primitive: 110>\n\t^self == aCharacter\n"
        },
        "printing": {
          "isLiteral": "isLiteral\n\t^true\n",
          "printOn:": "printOn: aStream\n\taStream nextPut: $$.\n\taStream nextPut: self\n",
          "storeOn:": "storeOn: aStream\n\t\"Character literals are preceded by '$'.\"\n\taStream nextPut: $$; nextPut: self\n"
        },
        "testing": {
          "tokenish": "tokenish\n\t\"Answer whether the receiver is a valid token-character--letter, digit, or colon.\"\n\n\t^self isLetter or: [self isDigit or: [self = $:]]\n",
          "isSeparator": "isSeparator\n\t\"Answer whether the receiver is one of the separator characters--space,\n\tcr, tab, line feed, or form feed.\"\n\n\tvalue = 32 ifTrue: [^true].\t\"space\"\n\tvalue = 13 ifTrue: [^true].\t\"cr\"\n\tvalue = 9 ifTrue: [^true].\t\"tab\"\n\tvalue = 10 ifTrue: [^true].\t\"line feed\"\n\tvalue = 12 ifTrue: [^true].\t\"form feed\"\n\t^false\n",
          "isUppercase": "isUppercase\n\t\"Answer whether the receiver is an uppercase letter.\"\n\t^self >= $A and: [self <= $Z]\n",
          "isDigit": "isDigit\n\t\"Answer whether the receiver is a digit.\"\n\t^self >= $0 and: [self <= $9]\n",
          "isVowel": "isVowel\n\t\"Answer whether the receiver is one of the vowels, AEIOU, in upper or lower case.\"\n\n\t^'AEIOU' includes: self asUppercase\n",
          "isLetter": "isLetter\n\t\"Answer whether the receiver is a letter.\"\n\t^(8r141 <= value and: [value <= 8r172])\n\t\tor: [8r101 <= value and: [value <= 8r132]]\n",
          "isAlphaNumeric": "isAlphaNumeric\n\t\"Answer whether the receiver is a letter or a digit.\"\n\t^self isLetter or: [self isDigit]\n",
          "isLowercase": "isLowercase\n\t\"Answer whether the receiver is a lowercase letter.\"\n\t^self >= $a and: [self <= $z]\n"
        },
        "copying": {
          "deepCopy": "deepCopy\n\t\"Answer with me becuase Characters are unique.\"\n",
          "copy": "copy\n\t\"Answer with me because Characters are unique.\"\n"
        },
        "accessing": {
          "asciiValue": "asciiValue\n\t\"Answer the value of the receiver.\"\n\t^value\n",
          "digitValue": "digitValue\n\t\"Answer 0-9 if the receiver is $0-$9, 10-35 if it is $A-$Z, and < 0 otherwise.\n\tThis is used to parse literal numbers of radix 2-36.\"\n\n\tvalue <= $9 asciiValue\n\t\tifTrue: [^value - $0 asciiValue].\n\tvalue >= $A asciiValue\n\t\tifTrue: [value <= $Z asciiValue ifTrue: [^value - $A asciiValue + 10]].\n\t^-1\n"
        },
        "converting": {
          "asCharacter": "asCharacter\n\t\"Answer the receiver itself.\"\n\t^self\n",
          "asUppercase": "asUppercase\n\t\"Answer a Character that is the upper case letter corresponding to the receiver.  If\n\tthe receiver is not a lower case letter, answer the receiver itself.\"\n\n\t8r141 <= value\n\t\tifTrue: [value <= 8r172\n\t\t\t\t\tifTrue: [^Character value: value-8r40]]\n",
          "asLowercase": "asLowercase\n\t\"Answer a Character that is the lower case letter corresponding to the receiver.  If\n\tthe receiver is not an upper case letter, answer the receiver itself.\"\n\n\t8r101 <= value\n\t\tifTrue: [value <= 8r132\n\t\t\t\t\tifTrue: [^Character value: value+8r40]]\n",
          "asSymbol": "asSymbol\n\t^Symbol internCharacter: self\n",
          "asInteger": "asInteger\n\t\"Answer the value of the receiver.\"\n\t^value\n"
        }
      }
    },
    "Symbol": {
      "comment": "Symbols are Strings which are created uniquely.  Thus, someString asSymbol == someString asSymbol.\n",
      "class_name": "Symbol",
      "superclass": "String",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "SingleCharSymbols USTable",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t| a v |\n\t\"make up table of 1-char atoms\"\n\tv _ Array new: 128.\n\ta _ String new: 1.\n\t1 to: 128 do:\n\t\t[:i |\n\t\ta at: 1 put: i - 1.\n\t\tv at: i put: a asSymbol].\n\tSingleCharSymbols _ v\n\t\"Symbol initialize.\"\n"
        },
        "instance creation": {
          "intern:": "intern: aString\n\t\"Answer a unique Symbol whose characters are those of aString.\"\n\n\t| sym index |\n\tself hasInterned: aString ifTrue: [:sym | ^sym].\n\t \"check if already exists\"\n\tsym _ (aString isMemberOf: Symbol)\n\t\tifTrue: [aString] \"putting old symbol in new table\"\n\t\tifFalse: [(Symbol new: aString size) string: aString]. \"create a new one\"\n\tindex _ aString stringhash \\\\ USTable size + 1.\n\tUSTable at: index put: ((USTable at: index) copyWith: sym).\n\t^sym\n",
          "correctMessage:": "correctMessage: unknown\n\t\"Attempt to correct the spelling of an unknown message symbol.\"\n\t| lc candidates score bestScore guess hasColon nArgs smaller larger |\n\tlc _ unknown first asLowercase.\n\thasColon _ unknown last = $:.\n\tunknown first isLetter ifFalse: [^ nil].\n\tnArgs _ (unknown select: [:char | char = $:]) size.\n\tcandidates _ OrderedCollection new.\n\tsmaller _ unknown size-4.\n\tlarger _ unknown size+4.\n\tSymbol allInstancesDo:  \"fast tests first\"\n\t\t[:each | (((each at: 1) = lc\n\t\t\t\tand: [each size between: smaller and: larger])\n\t\t\t\tand: [(each last = $:) = hasColon and: [each numArgs = nArgs]])\n\t\t\tifTrue: [candidates add: each]].\n\n\tbestScore _ 0.\n\tcandidates do:\n\t\t[:each |\n\t\t(score _ each spellAgainst: unknown) > bestScore ifTrue:\n\t\t\t[bestScore _ score. guess _ each]].\n\n\tbestScore > 50 ifFalse: [^false].\n\t(self confirm: 'Confirm correction to ' , guess)\n\t\tifTrue: [^ guess asSymbol]\n\t\tifFalse: [^ nil]\n",
          "internCharacter:": "internCharacter: aCharacter\n\t\"Answer with, and create if necessary, a unique Symbol whose characters\n\t are just this character.\"\n\t| ascii |\n\t(ascii _ aCharacter asciiValue) < 128\n\t\tifTrue: [^SingleCharSymbols at: ascii + 1].\n\t^self intern: (String with: aCharacter)\n"
        },
        "private": {
          "hasInterned:ifTrue:": "hasInterned: aString ifTrue: symBlock\n\t\"Answer with false if aString hasnt been interned (into a Symbol),\n\totherwise supply the symbol to symBlock and return true\"\n\n\t| v i ascii |\n\taString size = 1 ifTrue: [(ascii _ (aString at: 1) asciiValue) < 128\n\t\t\tifTrue:\n\t\t\t\t[symBlock value: (SingleCharSymbols at: ascii + 1).\n\t\t\t\t^true]].\n\tv _ USTable at: aString stringhash \\\\ USTable size + 1.\n\t1 to: v size do:\n\t\t[:i |\n\t\t(v at: i) == nil\n\t\t\tifFalse: [aString size = (v at: i) size ifTrue: [aString = (v at: i)\n\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t[symBlock value: (v at: i).\n\t\t\t\t\t\t\t^true]]]].\n\t^false\n",
          "table": "table\n\t\"Access for SystemTracer\"\n\n\t^USTable\n",
          "table:": "table: newArray\n\t\"Access for SystemTracer\"\n\n\t^USTable _ newArray\n",
          "rehash": "rehash\n\t\"Rebuild the hash table that holds all the unique Symbols.\"\n\n\t| sym |\n\tUSTable _ USTable collect: [:sym | Array new: 0].\n\tSymbol allInstancesDo: [:sym | self intern: sym]\n\t\"Symbol rehash\"\n"
        }
      },
      "instance_methods": {
        "comparing": {
          "hash": "hash\n\t\"Answer with a SmallInteger whose value is half of the receiver's object pointer\n\t(interpreting object pointers as 16-bit signed quantities).  Essential.  See\n\tObject documentation whatIsAPrimitive.\"\n\n\t<primitive: 75>\n\t^self\n",
          "=": "= anObject\n\t^self == anObject\n",
          "hashMappedBy:": "hashMappedBy: map\n\t\"Answer what my hash would be if oops changed according to map\"\n\t^ map newHashFor: self hash\n"
        },
        "printing": {
          "isLiteral": "isLiteral\n\t^Scanner isLiteralSymbol: self\n",
          "printOn:": "printOn: aStream\n\taStream nextPutAll: self\n",
          "storeOn:": "storeOn: aStream\n\tself isLiteral\n\t\tifTrue:\n\t\t\t[aStream nextPut: $#.\n\t\t\taStream nextPutAll: self]\n\t\tifFalse:\n\t\t\t[super storeOn: aStream.\n\t\t\taStream nextPutAll: ' asSymbol']\n"
        },
        "copying": {
          "shallowCopy": "shallowCopy\n\t\"Answer with me, because Symbols are unique.\"\n",
          "copy": "copy\n\t\"Answer with me, because Symbols are unique.\"\n"
        },
        "accessing": {
          "at:put:": "at: anInteger put: anObject\n\t\"you can not modify the receiver.\"\n\n\tself errorNoModification\n",
          "replaceFrom:to:with:startingAt:": "replaceFrom: start to: stop with: replacement startingAt: repStart\n\tself errorNoModification\n"
        },
        "private": {
          "stringhash": "stringhash\n\t^super hash\n",
          "errorNoModification": "errorNoModification\n\tself error:  'symbols can not be modified.'\n",
          "string:": "string: aString\n\t1 to: aString size do: [:j | super at: j put: (aString at: j)].\n\t^self\n",
          "species": "species\n\t^String\n"
        },
        "converting": {
          "asString": "asString\n\t| newString |\n\tnewString _ String new: self size.\n\t1 to: self size do: [:index | newString at: index put: (self at: index)].\n\t^newString\n",
          "asSymbol": "asSymbol\n"
        },
        "system primitives": {
          "isCompound": "isCompound\n\t\"return true if the receiver is of the form Class.foo \"\n\t^self includes: $.\n",
          "numArgs": "numArgs\n\t\"Answer the number of arguments that the receiver requires if it is interpreted\n\tas a message selector.\"\n\n\t| len n i |\n\tlen _ self size.\n\tn _ (self at: 1) isLetter ifTrue: [0] ifFalse: [1].\n\ti _ 1.\n\t[(i _ i + 1) <= len]\n\t\twhileTrue: \"count colons\"\n\t\t\t[(self at: i) = $: ifTrue: [n _ n + 1]].\n\t^n\n",
          "selectorPart": "selectorPart\n\t\"return just my part after the class name if the receiver is a compound selector\n\t (otherwise the whole thing)\"\n\t^(self copyFrom: (self indexOf: $.) + 1 to: self size) asSymbol\n",
          "isInfix": "isInfix\n\t\"Answer whether the receiver is an infix message selector.\"\n\t^(self at: 1) isLetter not\n",
          "keywords": "keywords\n\t\"Answer an array of the keywords that compose the receiver.\"\n\n\t| result aStream i l char |\n\tresult _ WriteStream on: (Array new: 10).\n\taStream _ WriteStream on: (String new: 16).\n\ti _ 1.\n\tl _ self size.\n\t[i <= l]\n\t\twhileTrue:\n\t\t\t[char _ self at: i.\n\t\t\taStream nextPut: char.\n\t\t\t(char = $: or: [i = l])\n\t\t\t\tifTrue:\n\t\t\t\t\t[result nextPut: aStream contents.\n\t\t\t\t\taStream reset].\n\t\t\ti _ i + 1].\n\t^result contents\n",
          "isKeyword": "isKeyword\n\t\"Answer whether the receiver is a message keyword, i.e., ends with colon.\"\n\n\tself size <= 1 ifTrue: [^false].\n\t^(self at: self size) = $:\n",
          "classPart": "classPart\n\t\"I must be a compound selector.  Return my class name\"\n\t| i |\n\ti _ self indexOf: $. ifAbsent: [self error: 'class part not found'].\n\t^(self copyFrom: 1 to: i-1) asSymbol\n"
        }
      }
    },
    "String": {
      "comment": "I am an indexed collection of Characters.  I really store 8-bit bytes, but my access protocol translates between these and real Character instances.\n",
      "class_name": "String",
      "superclass": "ArrayedCollection",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "StringBlter",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "fromString:": "fromString: aString\n\t\"Answer a new String that is a copy of the argument, aString.\"\n\n\t| newString |\n\tnewString _ self new: aString size.\n\taString size do: [:i | newString at: i put: (aString at: i)].\n\t^newString\n",
          "readFrom:": "readFrom: inStream\n\t\"Answer a new String that is determined by reading the stream, inStream.  Embedded\n\tdouble quotes become the quote Character.\"\n\n\t| outStream char done |\n\toutStream _ WriteStream on: (String new: 16).\n\t\"go to first quote\"\n\tinStream skipTo: $'.\n\tdone _ false.\n\t[done or: [inStream atEnd]]\n\t\twhileFalse:\n\t\t\t[char _ inStream next.\n\t\t\tchar = $'\n\t\t\t\tifTrue:\n\t\t\t\t\t[char _ inStream next.\n\t\t\t\t\tchar = $'\n\t\t\t\t\t\tifTrue: [outStream nextPut: char]\n\t\t\t\t\t\tifFalse: [done _ true]]\n\t\t\t\tifFalse: [outStream nextPut: char]].\n\t^outStream contents\n"
        },
        "examples": {
          "example": "example\n\t\"To see the string displayed at the cursor point, execute this expression and\n\tselect a point by pressing a mouse button.\"\n\n\t'this is some text' displayOn: Display at: Sensor waitButton\n\n\t\"String example\"\n"
        }
      },
      "instance_methods": {
        "comparing": {
          "hash": "hash\n\t| l m |\n\t(l _ m _ self size) <= 2\n\t  ifTrue:\n\t\t[l = 2\n\t\t  ifTrue: [m _ 3]\n\t\t  ifFalse:\n\t\t\t[l = 1\n\t\t\t  ifTrue: [^((self at: 1) asciiValue bitAnd: 127) * 106].\n\t\t\t^21845]].\n\t^(self at: 1) asciiValue * 48 + ((self at: (m - 1)) asciiValue + l)\n",
          ">": "> aString\n\t\"Answer true if and only if the receiver collates after aString.  The collation\n\tsequence is ascii with case differences ignored.\"\n\n\t^(self compare: aString) = 3\n",
          "spellAgainst:": "spellAgainst: aString\n\t\"Answer an integer between 0 and 100 indicating how similar the argument is to the receiver.  No case conversion is done.\"\n\n\t| i1 i2 size1 size2 score maxLen |\n\tsize1 _ self size.\n\tsize2 _ aString size.\n\tmaxLen _ size1 max: size2.\n\tscore _ 0.\n\ti1 _ i2 _ 1.\n\t[i1 <= size1 and: [i2 <= size2]] whileTrue:\n\t\t[(self at: i1) = (aString at: i2)\n\t\t\tifTrue: [score _ score+1. \t\t\"match\"\n\t\t\t\t\ti1 _ i1+1. \t\t\t\t\"advance both\"\n\t\t\t\t\ti2 _ i2+1]\n\t\t\tifFalse: [(i2 < size2 and: [(self at: i1) = (aString at: i2+1)])\n\t\t\t\t\t\tifTrue: [i2 _ i2+1] \t\"skip in other\"\n\t\t\tifFalse: [(i1 < size1 and: [(self at: i1+1) = (aString at: i2)])\n\t\t\t\t\t\tifTrue: [i1 _ i1+1] \t\"skip in self\"\n\t\t\tifFalse: [i1 _ i1+1. \t\t\t\t\"miss - advance both\"\n\t\t\t\t\ti2 _ i2+1] ] ] ].\n\n\tscore = maxLen\n\t\tifTrue: [^100]\n\t\tifFalse: [^100*score//maxLen]\n\n\t\" 'Smalltalk' spellAgainst: 'Smalltlak' \"\n",
          "sameAs:": "sameAs: aString\n\t\"Answer whether the receiver collates precisely with aString. The collation\n\tsequence is ascii with case differences ignored.\"\n\n\t^(self compare: aString) = 2\n",
          "<": "< aString\n\t\"Answer true if and only if the receiver collates before aString.  The collation\n\tsequence is ascii with case differences ignored.\"\n\n\t^(self compare: aString) = 1\n",
          "match:": "match: text\n\t\"Answer whether text matches the pattern in the receiver.  Matching\n\tignores upper/lower case differences.  Where the receiver contains #, text may\n\tcontain any single character.  Where the receiver contains *, text may contain any\n\tsequence of characters.\"\n\n\t| pattern scanning p t back textStream startScan |\n\tpattern _ ReadStream on: self.\n\ttextStream _ ReadStream on: text.\n\tscanning _ false.\n\t[pattern atEnd]\n\t\twhileFalse:\n\t\t\t[p _ pattern next.\n\t\t\tp = $*\n\t\t\t\tifTrue:\n\t\t\t\t\t[pattern atEnd ifTrue: [^true].\n\t\t\t\t\tscanning _ true.\n\t\t\t\t\tstartScan _ pattern position]\n\t\t\t\tifFalse:\n\t\t\t\t\t[textStream atEnd ifTrue: [^false].\n\t\t\t\t\tt _ textStream next.\n\t\t\t\t\t(t asUppercase = p asUppercase or: [p = $#])\n\t\t\t\t\t\tifFalse:\n\t\t\t\t\t\t\t[scanning ifFalse: [^false].\n\t\t\t\t\t\t\tback _ startScan - pattern position.\n\t\t\t\t\t\t\tpattern skip: back.\n\t\t\t\t\t\t\ttextStream skip: back + 1]].\n\t\t\t(scanning and: [pattern atEnd and: [textStream atEnd not]])\n\t\t\t\tifTrue: [back _ startScan - pattern position.\n\t\t\t\t\t\tpattern skip: back.\n\t\t\t\t\t\ttextStream skip: back + 1]\n\t\t\t].\n\t^textStream atEnd\n\n\t\" Examples:\n\n\t'xyz' match: 'Xyz'  true\n\t'x#z' match: 'x@z' true\n\t'x*z' match: 'x whyNot? z' true\n\t'*x' match: 'xx' true\n\t\"\n",
          "hashMappedBy:": "hashMappedBy: map\n\t\"My hash is independent of my oop\"\n\t^ self hash\n",
          ">=": ">= aString\n\t\"Answer true if and only if the receiver collates after aString or is the\n\tsame as aString.  The collation sequence is ascii with case differences ignored.\"\n\n\t^(self compare: aString) >= 2\n",
          "<=": "<= aString\n\t\"Answer true if and only if the receiver collates before aString or is the\n\tsame as aString.  The collation sequence is ascii with case differences ignored.\"\n\n\t^(self compare: aString) <= 2\n"
        },
        "printing": {
          "isLiteral": "isLiteral\n\t^true\n",
          "printOn:": "printOn: aStream\n\t\"Print inside string quotes, doubling inbedded quotes.\"\n\n\t^self storeOn: aStream\n",
          "storeOn:": "storeOn: aStream\n\t\"Print inside string quotes, doubling inbedded quotes.\"\n\n\t| i length x |\n\taStream nextPut: $'.\n\ti _ 0.\n\tlength _ self size.\n\t[(i _ i + 1) <= length]\n\t\twhileTrue:\n\t\t\t[aStream nextPut: (x _ self at: i).\n\t\t\tx == $' ifTrue: [aStream nextPut: x]].\n\t\"embedded quotes get doubled\"\n\taStream nextPut: $'\n"
        },
        "displaying": {
          "displayOn:at:": "displayOn: aDisplayMedium at: aPoint\n\t\"Show a representation of the receiver as a DisplayText at location\n\taPoint on aDisplayMedium.\"\n\tself asDisplayText displayOn: aDisplayMedium at: aPoint\n",
          "displayAt:": "displayAt: aPoint\n\t\"Show a representation of the receiver as a DisplayText at location\n\taPoint on the display screen.\"\n\tself asDisplayText displayAt: aPoint\n"
        },
        "copying": {
          "copyUpTo:": "copyUpTo: aCharacter\n\t\"Answer a copy of the receiver from index 1 to the first occurrence of\n\taCharacter, non-inclusive.\"\n\n\t| index |\n\tindex _ self indexOf: aCharacter ifAbsent: [^self].\n\t^self copyFrom: 1 to: index-1\n",
          "deepCopy": "deepCopy\n\t\"DeepCopy would otherwise mean make a copy of the character;  since\n\tcharacters are unique, just return a shallowCopy.\"\n\n\t^self shallowCopy\n"
        },
        "accessing": {
          "at:put:": "at: index put: aCharacter\n\t\"Store the Character in the field of the receiver indicated by the index.  Fail if the\n\tindex is not an Integer or is out of bounds, or if the argument is not a Character.\n\tEssential.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 64>\n\t(aCharacter isKindOf: Character)\n\t\tifTrue: [self errorNonIntegerIndex]\n\t\tifFalse: [self error: 'Strings only store Characters']\n",
          "at:": "at: index\n\t\"Answer the Character stored in the field of the receiver indexed by the\n\targument.  Fail if the index argument is not an Integer or is out of bounds.\n\tEssential.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 63>\n\t^Character value: (super at: index)\n",
          "findString:startingAt:": "findString: subString startingAt: start\n\t\"Answer the index of subString within the receiver, starting at start. If the receiver does not contain subString, answer 0.\"\n\n\t| aCharacter index |\n\tsubString isEmpty ifTrue: [^0].\n\taCharacter _ subString first.\n\tstart to: self size - subString size + 1 do:\n\t\t[:startIndex |\n\t\t(self at: startIndex) = aCharacter ifTrue:\n\t\t\t[index _ 1.\n\t\t\t[(self at: startIndex+index-1) = (subString at: index)] whileTrue:\n\t\t\t\t[index = subString size ifTrue: [^startIndex].\n\t\t\t\tindex _ index+1]]].\n\t^0\n",
          "string": "string\n\t\"Answer the receiver itself.  This is for compatibility with other text classes.\"\n\t^self\n",
          "basicAt:put:": "basicAt: index put: aCharacter\n\t\"Store the Character in the field of the receiver indicated by the index.  Fail if the\n\tindex is not an Integer or is out of bounds, or if the argument is not a Character.\n\tEssential.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 64>\n\t(aCharacter isKindOf: Character)\n\t\tifTrue: [self errorNonIntegerIndex]\n\t\tifFalse: [self error: 'Strings only store Characters']\n",
          "replaceFrom:to:withByteArray:startingAt:": "replaceFrom: start to: stop withByteArray: aByteArray startingAt: repStart\n\t\"This destructively replaces elements from start to stop in the receiver\n\tstarting at index, repStart, in the byte array, aByteArray.  Answer the\n\treceiver.\"\n\t| index repOff characterTable |\n\t<primitive: 105>\n\trepOff _ repStart - start.\n\tcharacterTable _ Character characterTable.\t\"in-line asCharacter for speed\"\n\tindex _ start - 1.\n\t[(index _ index + 1) <= stop]\n\t\twhileTrue:\n\t\t\t[self at: index put: (characterTable at: (aByteArray at: repOff + index)+1)]\n",
          "size": "size\n\t\"Answer the number of indexable fields in the receiver.  This value is the\n\tsame as the largest legal subscript.  Essential.  See Object documentation\n\twhatIsAPrimitive.\"\n\n\t<primitive: 62>\n\t^self basicSize\n",
          "replaceFrom:to:with:startingAt:": "replaceFrom: start to: stop with: replacement startingAt: repStart\n\t\"This destructively replaces elements from start to stop in the receiver\n\tstarting at index, repStart, in the collection, replacement.  Answer the\n\treceiver.\"\n\t(replacement isKindOf: String)\n\t\tifTrue:\n\t\t\t[self primReplaceFrom: start to: stop with: replacement startingAt: repStart]\n\t\tifFalse:\n\t\t\t[super replaceFrom: start to: stop with: replacement startingAt: repStart]\n",
          "basicAt:": "basicAt: index\n\t\"Answer the Character stored in the field of the receiver indexed by the\n\targument.  Fail if the index argument is not an Integer or is out of bounds.\n\tEssential.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 63>\n\t^Character value: (super at: index)\n"
        },
        "private": {
          "stringhash": "stringhash\n\t^self hash\n",
          "primReplaceFrom:to:with:startingAt:": "primReplaceFrom: start to: stop with: replacement startingAt: repStart\n\t\"This destructively replaces elements from start to stop in the receiver\n\tstarting at index, repStart, in the collection, replacement.  Answer the\n\treceiver.  No range checks are performed - this may be primitively implemented.\"\n\t<primitive: 105>\n\tsuper replaceFrom: start to: stop with: replacement startingAt: repStart\n",
          "compare:": "compare: s\n\t| i len endResult u1 u2 mylen |\n\tmylen _ self size.\n\tlen _ s size.\n\tmylen < len\n\t\tifTrue:\n\t\t\t[len _ mylen.\n\t\t\tendResult _ 1]\n\t\tifFalse: [endResult _ mylen = len\n\t\t\t\t\t\tifTrue: [2]\n\t\t\t\t\t\tifFalse: [3]].\n\ti _ 0.\n\t[(i _ i + 1) <= len]\n\t\twhileTrue:\n\t\t\t[u1 _ self at: i.\n\t\t\tu2 _ s at: i.\n\t\t\tu1 = u2\n\t\t\t\tifFalse:\n\t\t\t\t\t[u1 _ u1 asUppercase.\n\t\t\t\t\tu2 _ u2 asUppercase.\n\t\t\t\t\tu1 = u2 ifFalse:\n\t\t\t\t\t\t[^u1 < u2\n\t\t\t\t\t\t\tifTrue: [1]\n\t\t\t\t\t\t\tifFalse: [3]]]].\n\t^endResult\n"
        },
        "converting": {
          "asParagraph": "asParagraph\n\t\"Answer a Paragraph whose text string is the receiver.\"\n\t^Paragraph withText: self asText\n",
          "asUppercase": "asUppercase\n\t\"Answer a string made up from the receiver whose characters are all uppercase.\"\n\n\t| aStream |\n\taStream _ WriteStream on: (String new: self size).\n\tself do: [:aCharacter | aStream nextPut: aCharacter asUppercase].\n\t^aStream contents\n",
          "contractTo:": "contractTo: charCount  \"Shorten by ellipsis if too long\"\n\t| half |\n\tself size > charCount ifTrue:\n\t\t[half _ charCount // 2.\n\t\t^ self copyReplaceFrom: half\n\t\t\t\tto: self size - (charCount-half) + 2\n\t\t\t\twith: '...']\n\t\"\n\t'antidisestablishmentarianism' contractTo: 10 'anti...ism'\n\t\"\n",
          "asText": "asText\n\t\"Answer a Text whose string is the receiver.\"\n\t^Text fromString: self\n",
          "asLowercase": "asLowercase\n\t\"Answer a string made up from the receiver whose characters are all lowercase.\"\n\n\t| aStream |\n\taStream _ WriteStream on: (String new: self size).\n\tself do: [:aCharacter | aStream nextPut: aCharacter asLowercase].\n\t^aStream contents\n",
          "asString": "asString\n\t\"Answer the receiver itself.\"\n\t^self\n",
          "asDisplayText": "asDisplayText\n\t\"Answer a DisplayText whose text string is the receiver.\"\n\t^DisplayText text: self asText\n",
          "withCRs": "withCRs\n\t\"substitute CRs for backslashes\"\n\t^ self collect: [:char | char = $\\ ifTrue: [Character cr] ifFalse: [char]]\n",
          "oldRunEncoded": "oldRunEncoded\n\t\"Returns a string with equal consecutive bytes encoded as\n\t\t<0> <count> <val>\n\tSingle zeroes are encoded as <0> <0> \"\n\n\t| stream count previousByte byte |\n\tstream _ WriteStream on: (String new: self size).\n\tcount _ 0.\n\tpreviousByte _ self at: 1.\n\t2 to: self size do:\n\t\t[:i | byte _ self at: i.\n\t\t(byte = previousByte and: [count < 255])\n\t\t\tifTrue: [count _ count + 1]\n\t\t\tifFalse:\n\t\t\t\t[count > 0\n\t\t\t\t\tifTrue:\n\t\t\t\t\t\t[stream nextPut: (Character value: 0);\n\t\t\t\t\t\t\tnextPut: (Character value: count+1);\n\t\t\t\t\t\t\tnextPut: previousByte.\n\t\t\t\t\t\tcount _ 0]\n\t\t\t\t\tifFalse:\n\t\t\t\t\t\t[stream nextPut: previousByte.\n\t\t\t\t\t\tpreviousByte asInteger = 0\n\t\t\t\t\t\t\tifTrue: [stream nextPut: previousByte]].\n\t\t\t\tpreviousByte _ byte]].\n\tcount > 0\n\t\tifTrue:\n\t\t\t[stream nextPut: (Character value: 0);\n\t\t\t\tnextPut: (Character value: count+1);\n\t\t\t\tnextPut: previousByte]\n\t\tifFalse:\n\t\t\t[stream nextPut: previousByte.\n\t\t\tpreviousByte asInteger = 0 ifTrue: [stream nextPut: previousByte]].\n\t^stream contents\n",
          "asSymbol": "asSymbol\n\t\"Answer the unique symbol whose characters are the characters of the string.\"\n\t^Symbol intern: self\n",
          "oldRunDecodeOn:": "oldRunDecodeOn: decodedStream\n\t\"Decodes strings encoded by the message oldRunEncoded.\n\tOutput is written onto decodedStream\"\n\t| index size byte count bitsValue |\n\tindex _ 0. size _ self size.\n\t[index>=size] whileFalse:\n\t\t[byte _ (self at: (index _ index+1)).\n\t\tbyte asInteger == 0\n\t\t\tifTrue:\n\t\t\t\t[count _ (self at: (index _ index+1)) asInteger.\n\t\t\t\tcount = 0\n\t\t\t\t\tifTrue:  \"<0> <0> means one zero byte\"\n\t\t\t\t\t\t[decodedStream nextPut: byte]\n\t\t\t\t\tifFalse:  \"<0> <count> <bitsValue> means count bytes = bitsValue\"\n\t\t\t\t\t\t[bitsValue _ (self at: (index _ index+1)).\n\t\t\t\t\t\t[(count _ count-1)>=0] whileTrue: [decodedStream nextPut: bitsValue]]]\n\t\t\tifFalse:  \"<nonZero> means one nonZero byte\"\n\t\t\t\t[decodedStream nextPut: byte]].\n\t^ decodedStream contents\n",
          "asNumber": "asNumber\n\t\"Answer the number created by interpreting the receiver as the string\n\trepresentation of a number.\"\n\n\t^Number readFromString: self\n",
          "asFileName": "asFileName\n\t\"Answer a string made up from the receiver that is an acceptable file name.\"\n\t^Disk checkName: self fixErrors: true\n"
        }
      }
    },
    "Text": {
      "comment": "Instance Variables:\n\tstring:\tA String of Characters\n\truns:\tA RunArray of emphasis codes\n\nThe emphasis codes indicate abstract changes in character appearance.  Actual display is performed in the presence of a TextStyle which indicates, for each abstract code, an actual font to be used\n",
      "class_name": "Text",
      "superclass": "ArrayedCollection",
      "instanceVariables": "string runs",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "TextConstants",
      "class_methods": {
        "class initialization": {
          "initTextConstants2": "initTextConstants2\t\t\"Text initTextConstants.\"\n\t\"Initialize constants shared by classes associated with text display, e.g.,\n\tspace, tab, cr, bs, esc.\"\n\n\tTextConstants\t\tat: #Ctrlh\t\t\t\tput:\t(179 asCharacter).\n\tTextConstants\t\tat: #CtrlH\t\t\t\tput:\t(243 asCharacter).\n\tTextConstants\t\tat: #Ctrls\t\t\t\tput:\t(19 asCharacter).\n\tTextConstants\t\tat: #CtrlS\t\t\t\tput:\t(211 asCharacter).\n\n\tTextConstants\t\tat: #Ctrln\t\t\t\tput:\t(14 asCharacter).\n\tTextConstants\t\tat: #CtrlN\t\t\t\tput:\t(245 asCharacter).\n\tTextConstants\t\tat: #Ctrlp\t\t\t\tput:\t(138 asCharacter).\n\tTextConstants\t\tat: #CtrlTopBlank\t\t\tput:\t(222 asCharacter).\n\tTextConstants\t\tat: #CtrlMiddleBlank\t\tput:\t(229 asCharacter).\n\tTextConstants\t\tat: #CtrlBottomBlank\t\tput:\t(225 asCharacter).\n\n\t\t\"location of non-character stop conditions\"\n\tTextConstants\t\tat: #EndOfRun\t\t\tput:\t257.\n\tTextConstants\t\tat: #CrossedX\t\t\t\tput:\t258.\n\n\t\t\"values for alignment\"\n\tTextConstants\t\tat: #LeftFlush\t\t\tput:\t0.\n\tTextConstants\t\tat: #RightFlush\t\t\tput:\t1.\n\tTextConstants\t\tat: #Centered\t\t\t\tput:\t2.\n\tTextConstants\t\tat: #Justified\t\t\t\tput:\t3.\n\n\t\t\"subscripts for a marginTabsArray tuple\"\n\tTextConstants\t\tat: #LeftMarginTab\t\tput:\t1.\n\tTextConstants\t\tat: #RightMarginTab\t\tput:\t2.\n\n\t\t\"font faces\"\n\tTextConstants\t\tat: #Basal\t\t\t\tput:\t0.\n\tTextConstants\t\tat: #Bold\t\t\t\tput:\t1.\n\tTextConstants\t\tat: #Italic\t\t\t\tput:\t2.\n\tTextConstants\t\tat: #BoldItalic\t\t\tput:\t3.\n\tTextConstants\t\tat: #Underlined\t\t\tput:\t4.\n\tTextConstants\t\tat: #OverStruck\t\t\tput:\t8.\n\tTextConstants\t\tat: #Subscripted\t\t\tput:\t16.\n\tTextConstants\t\tat: #Superscripted\t\t\tput:\t32.\n\tTextConstants\t\tat: #SubscriptedUnderlined\t\t\tput:\t20.\n\tTextConstants\t\tat: #SuperscriptedUnderlined\t\t\tput:\t36.\n\tTextConstants\t\tat: #UnderlinedBit\t\tput:\t3.\n\tTextConstants\t\tat: #OverStruckBit\t\t\tput:\t4.\n\tTextConstants\t\tat: #SubscriptedBit\t\tput:\t5.\n\tTextConstants\t\tat: #SuperscriptedBit\t\t\tput:\t6.\n\tTextConstants\t\tat: #SubSuperscriptMask\t\t\tput:\t48.\n\tTextConstants\t\tat: #NonFaceEmphasisMask\t\t\tput:\t52. \"overstrike not supported\"\n\tTextConstants\t\tat: #FamilyName\t\t\tput:\t1.\n\tTextConstants\t\tat: #PointSize\t\t\t\tput:\t2.\n\tTextConstants\t\tat: #Face\t\t\t\tput:\t3.\n",
          "initialize": "initialize\n\t\"Initialize constants shared by classes associated with text display.\n\n\tText initialize.\"\n\n\t(Smalltalk includes: TextConstants)\n\t\tifFalse: [Smalltalk at: #TextConstants put: (Dictionary new: 32)].\n\tTextConstants at: #CaretForm\n\t\t \t\t put: (Cursor\n\textent: 16@16\n\tfromArray: #(\n\t\t2r110000000\n\t\t2r110000000\n\t\t2r1111000000\n\t\t2r11111100000\n\t\t2r11001100000\n\t\t2r0\n\t\t2r0\n\t\t2r0\n\t\t2r0\n\t\t2r0\n\t\t2r0\n\t\t2r0\n\t\t2r0\n\t\t2r0\n\t\t2r0\n\t\t2r0)\n\toffset: 8@0).\n\n\tself initTextConstants\n",
          "initTextConstants": "initTextConstants\t\"Text initTextConstants.\"\n\t\"Initialize constants shared by classes associated with text display, e.g.,\n\tspace, tab, cr, bs, esc.\"\n\n\t| tempArray  |\n\tTextConstants\t\tat: #Space\t\t\t\tput:\t(32 asCharacter).\n\tTextConstants\t\tat: #Tab\t\t\t\t\tput:\t(9 asCharacter).\n\tTextConstants\t\tat: #CR\t\t\t\t\tput:\t(13 asCharacter).\n\tTextConstants\t\tat: #BS\t\t\t\t\tput:\t(8 asCharacter).\n\tTextConstants\t\tat: #BS2\t\t\t\t\tput:\t(158 asCharacter).\n\tTextConstants\t\tat: #Ctrlw\t\t\t\tput:\t(145 asCharacter).\n\tTextConstants\t\tat: #ESC\t\t\t\t\tput:\t(160 asCharacter).\n\tTextConstants\t\tat: #Cut\t\t\t\t\tput:\t(173 asCharacter).\n\tTextConstants\t\tat: #Paste\t\t\t\tput:\t(30 asCharacter).\n\tTextConstants\t\tat: #Ctrlt\t\t\t\tput:\t(11 asCharacter).\n\tTextConstants\t\tat: #Ctrlf\t\t\t\tput:\t(12 asCharacter).\n\tTextConstants\t\tat: #Ctrlz\t\t\t\tput:\t(26 asCharacter).\n\n\t\t\"in case font doesn't have a width for space character\"\n\t\t\"some plausible numbers-- are there right ones?\"\n\tTextConstants\t\tat: #DefaultSpace\t\t\tput:\t4.\n\tTextConstants\t\tat: #DefaultTab\t\t\tput:\t24.\n\tTextConstants\t\tat: #DefaultLineGrid\t\tput:\t16.\n\tTextConstants\t\tat: #DefaultBaseline\t\tput:\t12.\n\tTextConstants\t\tat: #DefaultRule\t\t\tput:\tForm over.\n\tTextConstants\t\tat: #DefaultMask\t\t\tput:\tForm black.\n\n\tTextConstants\t\tat: #CtrlMinus\t\t\tput:\t(137 asCharacter).\n\tTextConstants\t\tat: #CtrlShiftMinus\t\tput:\t(201 asCharacter).\n\tTextConstants\t\tat: #Ctrlb\t\t\t\tput:\t(166 asCharacter).\n\tTextConstants\t\tat: #CtrlB\t\t\t\tput:\t(230 asCharacter).\n\tTextConstants\t\tat: #Ctrli\t\t\t\t\tput:\t(150 asCharacter).\n\tTextConstants\t\tat: #CtrlI\t\t\t\tput:\t(214 asCharacter).\n\tTextConstants\t\tat: #Ctrlx\t\t\t\tput:\t(151 asCharacter).\n\n\n\n\n\ttempArray _ Array new: Display width // DefaultTab.\n\t1 to: tempArray size do:\n\t\t[:i | tempArray\n\t\t\t\tat: i\n\t\t\t\tput: DefaultTab * i].\n\tTextConstants at: #DefaultTabsArray put: tempArray.\n\ttempArray _ Array new:\n\t\t\t\t\t(Display width // DefaultTab) // 2.\n\t1 to: tempArray size do:\n\t\t[:i | tempArray\n\t\t\t\tat: i\n\t\t\t\tput: (Array with: (DefaultTab*i) with: (DefaultTab*i))].\n\tTextConstants at: #DefaultMarginTabsArray \tput: tempArray.\n\tself initTextConstants2.\n"
        },
        "instance creation": {
          "fromString:": "fromString: aString\n\t\"Answer an instance of me whose characters are those of the argument, aString.\"\n\t^self string: aString emphasis: 1\n",
          "string:emphasis:": "string: aString emphasis: code\n\t\"Answer an instance of me whose characters are those of the argument, aString.\n\tUse the font whose index into the default TextStyle font array is code.\"\n\n\t^self string: aString runs: (RunArray new: aString size withAll: code)\n",
          "fromUser": "fromUser\n\t\"Answer an instance of me obtained by requesting the user to type some\n\tcharacters into a View.\"\n\n\t| result |\n\tFillInTheBlank\n\t\trequest: 'Type text followed by carriage return'\n\t\tdisplayAt: (50@ Display boundingBox height//2)\n\t\tcentered: false\n\t\taction: [:result]\n\t\tinitialAnswer: ''.\n\t^self fromString: result\n",
          "new:": "new: stringSize\n\t^self fromString: (String new: stringSize)\n"
        },
        "private": {
          "string:runs:": "string: aString runs: anArray\n\t^self basicNew setString: aString setRuns: anArray\n"
        }
      },
      "instance_methods": {
        "comparing": {
          "=": "= anotherText\n\t^string = anotherText string\n"
        },
        "printing": {
          "printOn:": "printOn: aStream\n\taStream nextPutAll: 'Text for '.\n\tstring printOn: aStream\n",
          "storeOn:": "storeOn: aStream\n\taStream nextPutAll: '(Text string: ';\n\t\tstore: string;\n\t\tnextPutAll: ' runs: ';\n\t\tstore: runs;\n\t\tnextPut: $)\n"
        },
        "copying": {
          "copyFrom:to:": "copyFrom: start to: stop\n\t\"Answer with a copied subrange of this text\"\n\n\t| realStart realStop |\n\tstop > self size\n\t\tifTrue: [realStop _ self size]\t\t\"handle selection at end of string\"\n\t\tifFalse: [realStop _ stop].\n\tstart < 1\n\t\tifTrue: [realStart _ 1]\t\t\t\"handle selection before start of string\"\n\t\tifFalse: [realStart _ start].\n\t^Text\n\t\tstring: (string copyFrom: realStart to: realStop)\n\t\truns: (runs copyFrom: realStart to: realStop)\n",
          "copyReplaceFrom:to:with:": "copyReplaceFrom: start to: stop with: aText\n\t^self shallowCopy replaceFrom: start to: stop with: aText\n",
          "copy": "copy\n\t^self deepCopy\n"
        },
        "accessing": {
          "at:put:": "at: index put: character\n\t^string at: index put: character\n",
          "at:": "at: index\n\t^string at: index\n",
          "findString:startingAt:": "findString: aString startingAt: start\n\t\"Answer the index of subString within the receiver, starting at position start.\n\tIf the receiver does not contain subString, answer 0.\"\n\n\t^string findString: aString asString startingAt: start\n",
          "string": "string\n\t\"Answer the string representation of the receiver.\"\n\t^string\n",
          "replaceFrom:to:with:": "replaceFrom: start to: stop with: aText\n\tstring _ string copyReplaceFrom: start to: stop with: aText string.\n\truns _ runs copyReplaceFrom: start to: stop with: aText runs\n",
          "size": "size\n\t^string size\n"
        },
        "private": {
          "runs": "runs\n\t^runs\n",
          "setString:setRuns:": "setString: aString setRuns: anArray\n\tstring _ aString.\n\truns _ anArray\n"
        },
        "converting": {
          "asParagraph": "asParagraph\n\t\"Answer a Paragraph whose text is the receiver.\"\n\t^Paragraph withText: self\n",
          "asUppercase": "asUppercase\n\tstring _ string asUppercase\n",
          "asText": "asText\n\t\"Answer the receiver itself.\"\n\t^self\n",
          "asLowercase": "asLowercase\n\tstring _ string asLowercase\n",
          "asString": "asString\n\t\"Answer a String representation of the textual receiver.\"\n\t^string\n",
          "asDisplayText": "asDisplayText\n\t\"Answer a DisplayText whose text is the receiver.\"\n\t^DisplayText text: self\n",
          "asNumber": "asNumber\n\t\"Answer the number created by interpreting the receiver as the textual\n\trepresentation of a number.\"\n\n\t^string asNumber\n"
        },
        "emphasis": {
          "runLengthFor:": "runLengthFor: characterIndex\n\t\"Answer the count of characters remaining in run beginning with\n\tcharacterIndex.\"\n\n\t^runs runLengthAt: characterIndex\n",
          "makeSelectorBoldIn:": "makeSelectorBoldIn: aClass\n\t\"For formatting Smalltalk source code, set the emphasis of that portion of\n\tthe receiver's string that parses as a message selector to be bold.\"\n\n\t| parser |\n\tstring size = 0 ifTrue: [^self].\n\t(parser _ aClass parserClass new) parseSelector: string.\n\tself emphasizeFrom: 1\n\t\tto: (parser endOfLastToken min: string size)\n\t\twith: 2\n",
          "emphasisAt:": "emphasisAt: characterIndex\n\t\"Answer the code for characters in the run beginning at characterIndex.\"\n\n\tself size = 0 ifTrue: [^1].\t\"null text tolerates access\"\n\t^runs at: characterIndex\n",
          "allBold": "allBold\n\tself emphasizeFrom: 1 to: self size with: 2\n",
          "emphasizeFrom:to:with:": "emphasizeFrom: start to: stop with: emphasis\n\t\"Set the emphasis for characters in the interval start-stop.\"\n\n\truns _\n\t\truns\n\t\t\tcopyReplaceFrom: start\n\t\t\tto: stop\n\t\t\twith: (RunArray new: stop - start + 1 withAll: emphasis)\n"
        }
      }
    }
  },
  "Collections-Unordered": {
    "IdentitySet": {
      "comment": "Just like Set, but uses == instead of = for comparisons\n",
      "class_name": "IdentitySet",
      "superclass": "Set",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "private": {
          "findElementOrNil:": "findElementOrNil: anObject\n\t\"Copied from Set with equality check changed to identity\"\n\t| index length probe pass |\n\tlength _ self basicSize.\n\tpass _ 1.\n\tindex _ anObject hash \\\\ length + 1.\n\t[(probe _ self basicAt: index) == nil or: [probe == anObject]]\n\t\twhileFalse: [(index _ index + 1) > length\n\t\t\t\tifTrue:\n\t\t\t\t\t[index _ 1.\n\t\t\t\t\tpass _ pass + 1.\n\t\t\t\t\tpass > 2 ifTrue: [^self grow findElementOrNil: anObject]]].\n\t^index\n"
        }
      }
    },
    "Dictionary": {
      "comment": "I am a set of associations.\n",
      "class_name": "Dictionary",
      "superclass": "Set",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "dictionary enumerating": {
          "associationsDo:": "associationsDo: aBlock\n\t\"Evaluate aBlock for each of the receiver's key/value associations.\"\n\n\tsuper do: aBlock\n",
          "keysDo:": "keysDo: aBlock\n\t\"Evaluate aBlock for each of the receiver's keys.\"\n\n\tself associationsDo: [:association | aBlock value: association key]\n"
        },
        "printing": {
          "printOn:": "printOn: aStream\n\t| tooMany |\n\ttooMany _ aStream position + self maxPrint.\n\taStream nextPutAll: self class name, ' ('.\n\tself associationsDo:\n\t\t[:element |\n\t\taStream position > tooMany ifTrue: [aStream nextPutAll: '...etc...)'. ^self].\n\t\telement printOn: aStream.\n\t\taStream space].\n\taStream nextPut: $)\n",
          "storeOn:": "storeOn: aStream\n\t| noneYet |\n\taStream nextPutAll: '(('.\n\taStream nextPutAll: self class name.\n\taStream nextPutAll: ' new)'.\n\tnoneYet _ true.\n\tself associationsDo:\n\t\t\t[:each |\n\t\t\tnoneYet\n\t\t\t\tifTrue: [noneYet _ false]\n\t\t\t\tifFalse: [aStream nextPut: $;].\n\t\t\taStream nextPutAll: ' add: '.\n\t\t\taStream store: each].\n\tnoneYet ifFalse: [aStream nextPutAll: '; yourself'].\n\taStream nextPut: $)\n"
        },
        "testing": {
          "occurrencesOf:": "occurrencesOf: anObject\n\t\"Answer how many of the receiver's elements are equal to anObject.\"\n\n\t| count |\n\tcount _ 0.\n\tself do: [:each | anObject = each ifTrue: [count _ count + 1]].\n\t^count\n",
          "includes:": "includes: anObject\n\tself do: [:each | anObject = each ifTrue: [^true]].\n\t^false\n"
        },
        "accessing": {
          "associationAt:": "associationAt: key\n\t\"Answer the association at key.  If key is not found, create an error message.\"\n\n\t^self associationAt: key ifAbsent: [self errorKeyNotFound]\n",
          "at:put:": "at: key put: anObject\n\t\"Set the value at key to be anObject.  If key is not found, create a new\n\tentry for key and set is value to anObject. Answer anObject.\"\n\n\t| index element |\n\tindex _ self findKeyOrNil: key.\n\telement _ self basicAt: index.\n\telement == nil\n\t\tifTrue: [self atNewIndex: index put: (Association key: key value: anObject)]\n\t\tifFalse: [element value: anObject].\n\t^anObject\n",
          "at:": "at: key\n\t\"Answer the value at key.  If key is not found, create an error message.\"\n\n\t^self at: key ifAbsent: [self errorKeyNotFound]\n",
          "associationAt:ifAbsent:": "associationAt: key ifAbsent: aBlock\n\t\"Answer the association at key.  If key is not found, answer the\n\tresult of evaluating aBlock.\"\n\n\t| index |\n\tindex _ self findKey: key ifAbsent: [^aBlock value].\n\t^self basicAt: index\n",
          "values": "values\n\t\"Answer a Bag containing the receiver's values.\"\n\n\t| aBag |\n\taBag _ Bag new.\n\tself do: [:value | aBag add: value].\n\t^aBag\n",
          "keyAtValue:ifAbsent:": "keyAtValue: value ifAbsent: exceptionBlock\n\t\"Answer the key whose value equals the argument, value.  If there is none,\n\tanswer the result of evaluating exceptionBlock.\"\n\n\tself associationsDo:\n\t\t[:association | value == association value ifTrue: [^association key]].\n\t^exceptionBlock value\n",
          "keyAtValue:": "keyAtValue: value\n\t\"Answer the key whose value equals the argument, value.  If there is none,\n\tcause an error.\"\n\n\t^self keyAtValue: value ifAbsent: [self errorValueNotFound]\n",
          "at:ifAbsent:": "at: key ifAbsent: aBlock\n\t\"Answer the value at key.  If key is not found, answer the\n\tresult of evaluating aBlock.\"\n\n\t| index |\n\tindex _ self findKey: key ifAbsent: [^aBlock value].\n\t^(self basicAt: index) value\n",
          "keys": "keys\n\t\"Answer a set containing the receiver's keys.\"\n\n\t| aSet key |\n\taSet _ Set new: self size.\n\tself keysDo: [:key | aSet add: key].\n\t^aSet\n",
          "associations": "associations\n\t\"Answer an OrderedCollection containing the receiver's associations in an\n\tarbitrary order.\"\n\n\t| aCollection key |\n\taCollection _ OrderedCollection new: self size.\n\tself associationsDo: [:key | aCollection add: key].\n\t^aCollection\n"
        },
        "private": {
          "errorKeyNotFound": "errorKeyNotFound\n\tself error: 'key not found'\n",
          "findKeyOrNil:": "findKeyOrNil: key\n\t| location length probe pass |\n\tlength _ self basicSize.\n\tpass _ 1.\n\tlocation _ key hash \\\\ length + 1.\n\t[(probe _ self basicAt: location) == nil or: [probe key = key]]\n\t\twhileFalse:\n\t\t\t[(location _ location + 1) > length\n\t\t\t\tifTrue:\n\t\t\t\t\t[location _ 1.\n\t\t\t\t\tpass _ pass + 1.\n\t\t\t\t\tpass > 2 ifTrue: [^self grow findKeyOrNil: key]]].\n\t^location\n",
          "findKey:ifAbsent:": "findKey: key ifAbsent: aBlock\n\t| index |\n\tindex _ self findKeyOrNil: key.\n\t(self basicAt: index) == nil ifTrue: [^aBlock value].\n\t^index\n",
          "errorValueNotFound": "errorValueNotFound\n\tself error: 'value not found'\n",
          "rehash": "rehash\n\t\"Smalltalk rehash.\"\n\n\t| newSelf |\n\tnewSelf _ self species new: self basicSize.\n\tself associationsDo: [:each | newSelf noCheckAdd: each].\n\tself become: newSelf\n"
        },
        "converting": {
          "asSortedCollection": "asSortedCollection\n\t| aSortedCollection |\n\taSortedCollection _ SortedCollection new: self size.\n\tself associationsDo: [:association | aSortedCollection add: association].\n\t^aSortedCollection\n"
        },
        "enumerating": {
          "collect:": "collect: aBlock\n\t\"Evaluate aBlock with each of my values as the argument.  Collect the resulting\n\tvalues into a collection that is like me.  Answer with the new collection.\"\n\n\t| newCollection |\n\tnewCollection _ Bag new.\n\tself do: [:each | newCollection add: (aBlock value: each)].\n\t^newCollection\n",
          "do:": "do: aBlock\n\tsuper do: [:assoc | aBlock value: assoc value]\n",
          "select:": "select: aBlock\n\t\"Evaluate aBlock with each of my values as the argument.  Collect into a new\n\tdictionary, only those associations for which aBlock evaluates to true.\"\n\n\t| newCollection |\n\tnewCollection _ self species new.\n\tself associationsDo:\n\t\t[:each |\n\t\t(aBlock value: each value) ifTrue: [newCollection add: each]].\n\t^newCollection\n"
        },
        "adding": {
          "add:": "add: anAssociation\n\t| index element |\n\tindex _ self findKeyOrNil: anAssociation key.\n\telement _ self basicAt: index.\n\telement == nil\n\t\tifTrue: [self atNewIndex: index put: anAssociation]\n\t\tifFalse: [element value: anAssociation value].\n\t^anAssociation\n",
          "declare:from:": "declare: key from: aDictionary\n\t\"Add key to the receiver.  If key already exists, do nothing.  If aDictionary includes\n\tkey, then remove it from aDictionary and use its association as the entry to the\n\treceiver.\"\n\n\t(self includesKey: key) ifTrue: [^self].\n\t(aDictionary includesKey: key)\n\t\tifTrue:\n\t\t\t[self add: (aDictionary associationAt: key).\n\t\t\taDictionary removeKey: key]\n\t\tifFalse:\n\t\t\t[self at: key put: nil]\n",
          "grow": "grow\n\t| newSelf |\n\tnewSelf _ self species new: self basicSize + self growSize.\n\tself associationsDo: [:each | newSelf noCheckAdd: each].\n\tself become: newSelf\n"
        },
        "removing": {
          "remove:": "remove: anObject\n\tself shouldNotImplement\n",
          "remove:ifAbsent:": "remove: anObject ifAbsent: exceptionBlock\n\tself shouldNotImplement\n"
        },
        "user interface": {
          "inspect": "inspect\n\t\"Create and schedule a DictionaryInspector in which the user can examine the\n\treceiver's variables.\"\n\n\tInspectorView open: (DictionaryInspector inspect: self)\n"
        },
        "dictionary testing": {
          "includesKey:": "includesKey: key\n\t\"Answer whether the receiver has a key equal to the argument, key.\"\n\n\t| index |\n\tindex _ self findKeyOrNil: key.\n\t^(self basicAt: index) ~~ nil\n",
          "includesAssociation:": "includesAssociation: anAssociation\n\t\"Answer whether the receiver has an element (association between a key and\n\ta value) that is equal to the argument, anAssociation.\"\n\n\t^super includes: anAssociation\n"
        },
        "dictionary removing": {
          "removeAssociation:": "removeAssociation: anAssociation\n\t\"Remove the key and value association, anAssociation, from the receiver.  Answer anAssociation.\"\n\n\t^self removeAssociation: anAssociation ifAbsent: [self errorNotFound]\n",
          "removeKey:": "removeKey: key\n\t\"Remove key from the receiver.  If key is not in the receiver, create an error\n\tmessage.  Otherwise, answer the value associated with key.\"\n\n\t^self removeKey: key ifAbsent: [self errorKeyNotFound]\n",
          "removeAssociation:ifAbsent:": "removeAssociation: anAssociation ifAbsent: anExceptionBlock\n\t\"Remove the key and value association, anAssociation, from the receiver.  If not found, answer the result of evaluating anExceptionBlock, otherwise answer anAssociation.\"\n\n\t^super remove: anAssociation ifAbsent: anExceptionBlock\n",
          "removeKey:ifAbsent:": "removeKey: key ifAbsent: aBlock\n\t\"Remove key from the receiver.  If key is not in the receiver,\n\tanswer the result of evaluating aBlock.  Otherwise, answer the value associated\n\twith key.\"\n\n\t| index element |\n\tindex _ self findKey: key ifAbsent: [^aBlock value].\n\telement _ self basicAt: index.\n\tself basicAt: index put: nil.\n\ttally _ tally - 1.\n\tself fixCollisionsFrom: index.\n\t^element\n"
        }
      }
    },
    "IdentityDictionary": {
      "comment": "I am a subclass of Dictionary in which the lookup is done using == rather than =.  I am represented as two parallel ordered collections of keys and values, rather than as a single collection of associations.\n",
      "class_name": "IdentityDictionary",
      "superclass": "Dictionary",
      "instanceVariables": "valueArray",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new:": "new: size\n\t\"Answer with a new instance of me, whose initial capacity is size.\n\tSize must be a power of 2.\"\n\n\t(size bitAnd: size - 1) = 0 ifFalse: [self error: 'size must be a power of 2'].\n\tsize >= 1 ifFalse: [self error: 'size must be >= 1'].\n\t^super new: size\n"
        }
      },
      "instance_methods": {
        "dictionary enumerating": {
          "associationsDo:": "associationsDo: aBlock\n\t\"Evaluate aBlock for associations consisting of my keys and their values.\"\n\n\t1 to: self basicSize do:\n\t\t[:index |\n\t\t(self basicAt: index) == nil\n\t\t\tifFalse: [aBlock value: (Association\n\t\t\t\t\t\t\t\t\t\tkey: (self basicAt: index)\n\t\t\t\t\t\t\t\t\t\tvalue: (valueArray at: index))]]\n"
        },
        "copying": {
          "copy": "copy\n\t| v copy |\n\tv _ valueArray.\n\tvalueArray _ valueArray shallowCopy.\n\tcopy _ super shallowCopy.\n\tvalueArray _ v.\n\t^copy\n"
        },
        "accessing": {
          "at:put:": "at: key put: value\n\t\"Set the value at key to be value.\"\n\n\t| index |\n\tindex _ self findKeyOrNil: key.\n\t(self basicAt: index) == nil\n\t\tifTrue:\n\t\t\t[tally _ tally + 1.\n\t\t\tself basicAt: index put: key].\n\tvalueArray at: index put: value.\n\tself fullCheck.\n\t^value\n",
          "associationAt:ifAbsent:": "associationAt: key ifAbsent: aBlock\n\t\"Answer with an Association consisting of key and my value at that key.\n\tIf key is not found, evaluate aBlock.\"\n\n\t| index |\n\tindex _ self findKey: key ifAbsent: [^aBlock value].\n\t^Association\n\t\tkey: (self basicAt: index)\n\t\tvalue: (valueArray at: index)\n",
          "keyAtValue:ifAbsent:": "keyAtValue: value ifAbsent: exceptionBlock\n\t\"Answer the key whose value equals the argument, value.  If there is none,\n\tanswer the result of evaluating exceptionBlock.\"\n\n\t| theKey |\n\t1 to: self basicSize do:\n\t\t[:index |\n\t\tvalue == (valueArray at: index)\n\t\t\tifTrue:\n\t\t\t\t[(theKey _ self basicAt: index) == nil\n\t\t\t\t\tifFalse: [^theKey]]].\n\t^exceptionBlock value\n",
          "at:ifAbsent:": "at: key ifAbsent: aBlock\n\t\"Answer with the value at key.  If key is not found, evaluate aBlock.\"\n\n\t| index |\n\tindex _ self findKey: key ifAbsent: [^aBlock value].\n\t^valueArray at: index\n"
        },
        "private": {
          "findKeyOrNil:": "findKeyOrNil: key\n\t| index length probe pass |\n\tlength _ self basicSize.\n\tpass _ 1.\n\tindex _ key asOop \\\\ length + 1.\n\t[(probe _ self basicAt: index) == nil or: [probe == key]]\n\t\twhileFalse: [(index _ index + 1) > length\n\t\t\t\tifTrue:\n\t\t\t\t\t[index _ 1.\n\t\t\t\t\tpass _ pass + 1.\n\t\t\t\t\tpass > 2 ifTrue: [^self grow findKeyOrNil: key]]].\n\t^index\n",
          "noCheckAdd:with:": "noCheckAdd: key with: value\n\t| index |\n\tindex _ self findKeyOrNil: key.\n\tself basicAt: index put: key.\n\ttally _ tally + 1.\n\t^valueArray at: index put: value\n",
          "setTally": "setTally\n\tsuper setTally.\n\tvalueArray _ Array new: self basicSize\n",
          "removeDangerouslyKey:ifAbsent:": "removeDangerouslyKey: key ifAbsent: errorBlock\n\t| location oldKey length entry |\n\tlocation _ self findKeyOrNil: key.\n\t(self basicAt: location) == nil ifTrue: [^errorBlock value].\n\tself basicAt: location put: nil.\n\tvalueArray at: location put: nil.\n\ttally _ tally - 1.\n\tlength _ self basicSize.\n\t[location _\n\t\tlocation = length\n\t\t\tifTrue: [1]\n\t\t\tifFalse: [location + 1].\n\t(self basicAt: location) == nil]\n\t\twhileFalse:\n\t\t\t[oldKey _ self findKeyOrNil: (self basicAt: location).\n\t\t\tlocation = oldKey ifFalse: [self swap: location with: oldKey]]\n",
          "noCheckAdd:": "noCheckAdd: anAssociation\n\t^self noCheckAdd: anAssociation key with: anAssociation value\n",
          "swap:with:": "swap: oneElement with: otherElement\n\tsuper swap: oneElement with: otherElement.\n\tvalueArray swap: oneElement with: otherElement\n"
        },
        "enumerating": {
          "do:": "do: aBlock\n\t1 to: self basicSize do:\n\t\t[:index |\n\t\t(self basicAt: index) == nil ifFalse: [aBlock value: (valueArray at: index)]]\n"
        },
        "adding": {
          "add:": "add: anAssociation\n\tself at: anAssociation key put: anAssociation value\n"
        },
        "dictionary removing": {
          "removeKey:ifAbsent:": "removeKey: key ifAbsent: errorBlock\n\tself removeDangerouslyKey: key ifAbsent: [^errorBlock value]\n"
        }
      }
    },
    "Set": {
      "comment": "I am an unordered collection of elements that are not duplicated in me.\n",
      "class_name": "Set",
      "superclass": "Collection",
      "instanceVariables": "tally",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t^self new: 2\n",
          "new:": "new: anInteger\n\t^(super new: (anInteger max: 1)) setTally\n"
        }
      },
      "instance_methods": {
        "testing": {
          "occurrencesOf:": "occurrencesOf: anObject\n\t(self includes: anObject)\n\t\tifTrue: [^1]\n\t\tifFalse: [^0]\n",
          "includes:": "includes: anObject\n\t^(self basicAt: (self findElementOrNil: anObject)) ~~ nil\n"
        },
        "accessing": {
          "at:put:": "at: index put: anObject\n\tself errorNotKeyed\n",
          "at:": "at: index\n\tself errorNotKeyed\n",
          "size": "size\n\t^tally\n"
        },
        "private": {
          "atNewIndex:put:": "atNewIndex: index put: anObject\n\tself basicAt: index put: anObject.\n\ttally _ tally + 1.\n\tself fullCheck\n",
          "fixCollisionsFrom:": "fixCollisionsFrom: index\n\t| myLength oldIndex nextIndex nextObject |\n\toldIndex _ index.\n\tmyLength _ self basicSize.\n\t[oldIndex _ oldIndex \\\\ myLength + 1.\n\tnextObject _ self basicAt: oldIndex.\n\tnextObject == nil]\n\t\twhileFalse:\n\t\t\t[nextIndex _ self findElementOrNil: nextObject.\n\t\t\tnextIndex = oldIndex\n\t\t\t\tifFalse:\n\t\t\t\t\t[self basicAt: nextIndex put: nextObject.\n\t\t\t\t\tself basicAt: oldIndex put: nil]]\n",
          "find:ifAbsent:": "find: anObject ifAbsent: aBlock\n\t| index |\n\tindex _ self findElementOrNil: anObject.\n\t(self basicAt: index) == nil\n\t\tifTrue: [^aBlock value]\n\t\tifFalse: [^index]\n",
          "setTally": "setTally\n\ttally _ 0\n",
          "fullCheck": "fullCheck\n\tself basicSize - self size <= (self basicSize // 4) ifTrue: [self grow]\n",
          "noCheckAdd:": "noCheckAdd: anObject\n\tself basicAt: (self findElementOrNil: anObject)\n\t\tput: anObject.\n\ttally _ tally + 1\n",
          "swap:with:": "swap: oneElement with: otherElement\n\t| save |\n\tsave _ self basicAt: oneElement.\n\tself basicAt: oneElement put: (self basicAt: otherElement).\n\tself basicAt: otherElement put: save\n",
          "rehash": "rehash\n\t| newSelf |\n\tnewSelf _ self species new: self basicSize.\n\tself do: [:each | newSelf noCheckAdd: each].\n\tself become: newSelf\n",
          "findElementOrNil:": "findElementOrNil: anObject\n\t| index length probe pass |\n\tlength _ self basicSize.\n\tpass _ 1.\n\tindex _ anObject hash \\\\ length + 1.\n\t[(probe _ self basicAt: index) == nil or: [probe = anObject]]\n\t\twhileFalse: [(index _ index + 1) > length\n\t\t\t\tifTrue:\n\t\t\t\t\t[index _ 1.\n\t\t\t\t\tpass _ pass + 1.\n\t\t\t\t\tpass > 2 ifTrue: [^self grow findElementOrNil: anObject]]].\n\t^index\n"
        },
        "enumerating": {
          "collect:": "collect: aBlock\n\t\"Evaluate aBlock with each of the receiver's elements as the argument.  Collect the\n\tresulting values into another Set.  Answer the new Set.  We override the general\n\tmethod, so that we make a big enough set and avoid growing. \"\n\n\t| newSet size index element |\n\ttally = 0 ifTrue: [^Set new: 2].\n\tnewSet _ Set new: (size _ self basicSize).\n\tindex _ 0.\n\t[(index _ index + 1) <= size] whileTrue:\n\t\t[(element _ self basicAt: index) == nil ifFalse:\n\t\t\t[newSet add: (aBlock value: element)]].\n\t^newSet\n",
          "do:": "do: aBlock\n\ttally = 0 ifTrue: [^self].\n\t1 to: self basicSize do:\n\t\t[:index |\n\t\t(self basicAt: index) == nil ifFalse: [aBlock value: (self basicAt: index)]]\n"
        },
        "adding": {
          "add:": "add: newObject\n\t| index |\n\tnewObject == nil ifTrue: [^newObject].\n\tindex _ self findElementOrNil: newObject.\n\t(self basicAt: index) == nil ifTrue: [self atNewIndex: index put: newObject].\n\t^newObject\n",
          "grow": "grow\n\t\"The receiver becomes twice as big--this is not a copy of the receiver, so all shared references survive.\"\n\n\t| newSelf |\n\tnewSelf _ self species new: self basicSize + self growSize.\n\tself do: [:each | newSelf noCheckAdd: each].\n\tself become: newSelf\n"
        },
        "removing": {
          "remove:ifAbsent:": "remove: oldObject ifAbsent: aBlock\n\t| index |\n\tindex _ self find: oldObject ifAbsent: [^aBlock value].\n\tself basicAt: index put: nil.\n\ttally _ tally - 1.\n\tself fixCollisionsFrom: index.\n\t^oldObject\n"
        }
      }
    },
    "Bag": {
      "comment": "I am an unordered collection of elements.  I store these elements in a dictionary, tallying up occurrences of equal objects.  Because I store an occurrence only once, my clients should beware that objects they store will not necessarily be retrieved such that == is true.  If the client cares, a subclass of me should be created.\n",
      "class_name": "Bag",
      "superclass": "Collection",
      "instanceVariables": "contents",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t^super new setDictionary\n"
        }
      },
      "instance_methods": {
        "testing": {
          "occurrencesOf:": "occurrencesOf: anObject\n\t(self includes: anObject)\n\t\tifTrue: [^contents at: anObject]\n\t\tifFalse: [^0]\n",
          "includes:": "includes: anObject\n\t^contents includesKey: anObject\n"
        },
        "accessing": {
          "sortedElements": "sortedElements\n\t\"Answer with a collection of elements with counts, sorted by element.\"\n\t| elements |\n\telements _ SortedCollection new.\n\tcontents associationsDo: [:assn | elements add: assn].\n\t^ elements\n",
          "at:put:": "at: index put: anObject\n\tself errorNotKeyed\n",
          "at:": "at: index\n\tself errorNotKeyed\n",
          "sortedCounts": "sortedCounts\n\t\"Answer with a collection of counts with elements, sorted by decreasing count.\"\n\t| counts |\n\tcounts _ SortedCollection sortBlock: [:x :y | x >= y].\n\tcontents associationsDo:\n\t\t[:assn |\n\t\tcounts add: (Association key: assn value value: assn key)].\n\t^ counts\n",
          "size": "size\n\t| tally |\n\ttally _ 0.\n\tcontents do: [:each | tally _ tally + each].\n\t^tally\n"
        },
        "private": {
          "setDictionary": "setDictionary\n\tcontents _ Dictionary new\n"
        },
        "enumerating": {
          "do:": "do: aBlock\n\tcontents associationsDo: [:assoc | assoc value timesRepeat: [aBlock value: assoc key]]\n"
        },
        "adding": {
          "add:": "add: newObject\n\t^self add: newObject withOccurrences: 1\n",
          "add:withOccurrences:": "add: newObject withOccurrences: anInteger\n\t\"Add the element newObject to the elements of the receiver.  Do so as\n\tthough the element were added anInteger number of times.  Answer newObject.\"\n\n\t(self includes: newObject)\n\t\tifTrue: [contents at: newObject put: anInteger + (contents at: newObject)]\n\t\tifFalse: [contents at: newObject put: anInteger].\n\t^newObject\n"
        },
        "removing": {
          "remove:ifAbsent:": "remove: oldObject ifAbsent: exceptionBlock\n\t| count |\n\t(self includes: oldObject)\n\t\tifTrue: [(count _ contents at: oldObject) = 1\n\t\t\t\tifTrue: [contents removeKey: oldObject]\n\t\t\t\tifFalse: [contents at: oldObject put: count - 1]]\n\t\tifFalse: [^exceptionBlock value].\n\t^oldObject\n"
        }
      }
    }
  },
  "Files-Abstract": {
    "FilePage": {
      "comment": "I represent a fixed size page or record of data from a File.  My instance is uniquely identified within its File by its pageNumber.\n\nThe normal layout of a FilePage is as a ByteArray, which begins with some header information (e.g. serial number, page number, size), some data with possible leftover allocation, and some trailer information: pageSize = headerSize + size + (dataSize - size) + trailerSize.  In the current implementations, all FilePages (except possibly the last page) of a File are full (i.e. no unused data allocation).  This assumption is also reflected in File characterSize, and in FileStream positioning methods.  Given the current implementation of ByteArrays and Strings, each page has a type (binary or text).  The messages asStream: and fromStream: do the necessary conversion.\n\nInstance Variables:\n\tfile\t\t<File> that contains the instance\n\tpage\t<Integer> the number of the instance\n\tbinary \t<Boolean> true if content of page is binary, else it is text\n",
      "class_name": "FilePage",
      "superclass": "Object",
      "instanceVariables": "file page binary",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "FilePool",
      "class_methods": {
        "documentation": {
          "documentation": "documentation\n\t\"My subclasses are expected to implement the following messages.  These are\n\tprovided as self subclassResponsibility.  Some are optional for implementation,\n\tdepending on the representation of the actual file page;  for some, defaults are\n\tprovided.\n\n\ttesting\n\t\tsize\n\tpage initialization\n\t\tpageNumber:\n\tpage accessing\n\t\t[optional] address\n\t\t[optional] address:\n\t\t[optional] pageNumber\n\t\t[optional] pageNumber:\n\t\t[optional] serialNumber:\n\tpage testing\n\t\t[default] dataSize\n\t\t[default] headerSize\n\t\t[default] trailerSize\n\tfile/page/directory implementation\n\t\tsize:\n\"\n"
        }
      },
      "instance_methods": {
        "file accessing": {
          "file": "file\n\t\"Answer with the receiver's file.\"\n\n\t^file\n",
          "endFile": "endFile\n\t\"Answer the result of making the receiver be the last page of its file.\"\n\n\t^file endFile: self\n"
        },
        "page initialization": {
          "file:page:": "file: aFile page: aByteArray\n\t\"Set the receiver's file to be aFile, and its page to contain aByteArray.\"\n\tfile _ aFile.\n\tpage _ aByteArray.\n\tself reinitialize\n",
          "file:": "file: aFile\n\t\"Set the receiver's file to be aFile.\"\n\tfile _ aFile\n",
          "page:": "page: aByteArray\n\t\"Set the receiver's page to contain aByteArray.\"\n\tpage _ aByteArray\n"
        },
        "file testing": {
          "isBinary": "isBinary\n\t\"Answer whether the information in the receiver is stored in binary format.\"\n\t^binary\n",
          "isText": "isText\n\t\"Answer whether the information in the receiver is stored as ascii characters.\"\n\t^binary == false\n"
        },
        "file status": {
          "reinitialize": "reinitialize\n\t\"Reset the receiver to its initial status.\"\n\tpage == nil ifTrue: [page _ self allocatePage].\n\tself size: 0\n",
          "reopen": "reopen\n\t\"Reopen the receiver's file and reinitialize the receiver onto it.\"\n\n\tfile reopen.\n\tfile initPage: self\n"
        },
        "testing": {
          "isEmpty": "isEmpty\n\t\"Answer whether this page has no data.\"\n\n\t^self size = 0\n"
        },
        "page testing": {
          "isFull": "isFull\n\t\"Answer whether the receiver has no more room at the end for more data.\"\n\t^self size = self dataSize\n",
          "dataSize": "dataSize\n\t\"Answer the maximum size of data (in characters) in the receiver's page.\"\n\t^512\n",
          "trailerSize": "trailerSize\n\t\"Answer the size of trailer in bytes.\"\n\n\t^0\n",
          "lastPage": "lastPage\n\t\"Answer whether the receiver is at the last page in its file.\"\n\n\t^self pageNumber >= file lastPageNumber\n",
          "headerSize": "headerSize\n\t\"Answer the size of the receiver's header in characters.\"\n\n\t^0\n",
          "pageSize": "pageSize\n\t\"Answer the total size of the receiver's page, in bytes.\"\n\n\t^self headerSize + self dataSize + self trailerSize\n"
        },
        "accessing": {
          "at:put:": "at: aByteIndex put: aByte\n\t\"Put the date byte, aByte, at location aByteIndex.  Answer aByte.\"\n\t^page at: (self dataIndex: aByteIndex size: 1) put: aByte\n",
          "at:": "at: aByteIndex\n\t\"Answer the data byte associated with aByteIndex.\"\n\n\t^page at: (self dataIndex: aByteIndex size: 1)\n",
          "wordAt:": "wordAt: aWordIndex\n\t\"Answer the data word associated with aWordIndex.\"\n\n\t^page wordAt: (self dataIndex: aWordIndex size: 2)\n",
          "wordAt:put:": "wordAt: aWordIndex put: aWord\n\t\"Put aWord at location aWordIndex.  Answer aWord.\"\n\t^page wordAt: (self dataIndex: aWordIndex size: 2) put: aWord\n",
          "size": "size\n\t\"Answer the number of data characters the receiver contains\n\t(0 <= self size <= self dataSize)\"\n\n\t^self subclassResponsibility\n"
        },
        "private": {
          "readOrAddPageNumber:": "readOrAddPageNumber: aPageNumber\n\t\"answer with the result of file reading a page or creating a page into me\"\n\n\tself pageNumber: aPageNumber.\n\tself size: 0.\n\t^file readOrAdd: self\n",
          "dataIndex:size:": "dataIndex: index size: nBytes\n\t\"Answer with an index offset properly into page, unless index would be\n\tout of bounds.   nBytes = 1 for characters; nBytes = 2 for words\"\n\n\t(index > 0 and: [index <= (self size // nBytes)])\n\t\tifTrue: [^(self headerSize // nBytes) + index]\n\t\tifFalse: [self error: 'index out of bounds']\n",
          "allocatePage": "allocatePage\n\t\"allocate a page buffer\"\n\n\t^ByteArray new: self pageSize\"this is a default\"\n"
        },
        "nonhomogeneous accessing": {
          "headerWordAt:": "headerWordAt: n\n\t\"Answer the n-th header word;  default is that it is at the beginning of\n\tpage.\"\n\n\t^page wordAt: n\n",
          "pageWordAt:put:": "pageWordAt: aWordIndex put: aWord\n\t\"Set and answer the word associated with aWordIndex in the page as a whole,\n\tignoring header, data and trailer boundaries.\"\n\n\t^page wordAt: aWordIndex put: aWord\n",
          "headerWordAt:put:": "headerWordAt: n put: v\n\t\"Set and answer n-th header word.\"\n\n\t^page wordAt: n put: v\n",
          "pageWordAt:": "pageWordAt: aWordIndex\n\t\"Answer the word associated with aWordIndex in the page as a whole,\n\tignoring header, data and trailer boundaries\"\n\n\t^page wordAt: aWordIndex\n",
          "write": "write\n\t\"Answer the result of writing the receiver onto its file.\"\n\t^file write: self\n",
          "readPageNumber:": "readPageNumber: aPageNumber\n\t\"Answer the result of file reading a page into the receiver.\"\n\n\tself pageNumber: aPageNumber.\n\tself size: 0.\n\t^file read: self\n"
        },
        "converting": {
          "asFileStream:": "asFileStream: aStream\n\t\"Initialize aStream (typically a FileStream) to access the data portion of the receiver\n\t-- this is the normal way to access characters and words.\n\tPages which segment data and header can do this differently.\"\n\n\t| offset len sourceData destData |\n\tlen _ self size.\n\toffset _ self headerSize.\n\tsourceData _ self dataString.\n\tbinary\n\t\tifTrue: [^aStream\n\t\t\t\t\ton: sourceData\n\t\t\t\t\tfrom: offset + 1\n\t\t\t\t\tto: offset + len\"self dataBeginning\"\n\t\t\t\t\t\"self dataEnd\"].\n\tdestData _ String new: self dataSize.\n\tdestData replaceFrom: 1 to: len withByteArray: sourceData startingAt: offset+1.\n\t^aStream on: destData from: 1 to: len\n",
          "fromFileStream:": "fromFileStream: aStream\n\t\"Copy data into page; pages which separate data and header can do this differently\"\n\t| sourceData destData offset |\n\tbinary\n\t\tifFalse:\n\t\t\t[offset _ self headerSize.\n\t\t\tsourceData _ aStream contents.\n\t\t\tdestData _ self dataString.\n\t\t\tdestData\n\t\t\t\treplaceFrom: offset + 1\n\t\t\t\tto: offset+ self size\n\t\t\t\twithString: sourceData\n\t\t\t\tstartingAt: 1]\n"
        },
        "file modes": {
          "text": "text\n\t\"Set the receiver's information type to be ascii characters.\"\n\tbinary _ false\n",
          "binary": "binary\n\t\"Set the receiver's information type to be binary.\"\n\tbinary _ true\n"
        },
        "page accessing": {
          "dataBeginning": "dataBeginning\n\t\"Answer the index in the receiver for the first element of data-1.\"\n\n\tbinary\n\t\tifTrue: [^self headerSize]\n\t\tifFalse: [^0]\n",
          "serialNumber:": "serialNumber: aSN\n\t\"Set the serial number of the receiver's page.\"\n\n\t^self subclassResponsibility\n",
          "dataString": "dataString\n\t\"Answer a string containing the data.\"\n\n\t^page\n",
          "address:": "address: addressNumber\n\t\"Set the receiver's disk address.\"\n\n\tself subclassResponsibility\n",
          "pageNumber": "pageNumber\n\t\"Answer the receiver's page number, an Integer.\"\n\n\t^self subclassResponsibility\n",
          "address": "address\n\t\"Answer the disk address for the receiver.  This need only be defined for\n\tthose subclasses which have access to an address, probably for local\n\tdisks and not for remote file servers\"\n\n\tself subclassResponsibility\n",
          "serialNumber": "serialNumber\n\t\"Answer the serial number of the receiver's page.\"\n\n\t^file serialNumber\n",
          "dataEnd": "dataEnd\n\t\"Answer the character index for the last character of actual data.\"\n\n\t^self dataBeginning + self size\n",
          "dataEnd:": "dataEnd: aPageIndex\n\t\"Set the end of the data in the receiver.\"\n\n\t^self size: aPageIndex - self dataBeginning\n",
          "pageNumber:": "pageNumber: anInteger\n\t\"Set the receiver's page number.\"\n\n\t^self subclassResponsibility\n",
          "page": "page\n\t\"Answer the receiver's page\"\n\n\t^page\n",
          "dataMaxEnd": "dataMaxEnd\n\t\"Answer the maximum possible data byte index.\"\n\n\t^self dataBeginning + self dataSize\n"
        },
        "file/page/directory implementation": {
          "size:": "size: aByteIndex\n\t\"Set the number of data characters the receiver contains to be aByteIndex.\n\taByteIndex <= dataSize on last page; aByteIndex = dataSize on earlier\n\tpages).\"\n\n\t^self subclassResponsibility\n",
          "doCommand:error:": "doCommand: command error: s\n\t\"Answer the result of executing a command on the receiver.\"\n\n\t^file doCommand: command page: self error: s\n"
        }
      }
    },
    "FileDirectory": {
      "comment": "A FileDirectory is uniquely identified by the device or server that it refers to. A FileDirectory is a collection of Files.  It may also be found in some other dictionary or FileDirectory, though often this is implicit\n",
      "class_name": "FileDirectory",
      "superclass": "Object",
      "instanceVariables": "directoryName closed",
      "classInstanceVariables": "",
      "classVariables": "ExternalReferences",
      "poolDictionaries": "FilePool",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\tself initializeExternalReferences\n\t\"FileDirectory initialize\"\n"
        },
        "documentation": {
          "documentation": "documentation\n\t\"subclasses are expected to implement the following messages which are\n\timplemented as self subclassResponsibility unless otherwise noted.\n\n\tfile accessing\n\t\tfileClass\n\t\t[optional] rename:newName:\n\t\t[default] checkNameOfFile:\n\t\t\t(default makes no sense to me; for the abstract anything is okay)\n\n\tfile status\n\t\t[optional] flush\n\n\tpage accessing\n\t\t[optional] allocate:after:\n\t\t[optional] allocateSN\n\t\t[optional] deallocate:\n\t\t[optional] freePages\n\n\tdictionary adding\n\t\taddNew:\n\n\tdictionary removing\n\t\tremoveOld:\n\n\tdictionary enumerating\n\t\t[optional] next\n\t\t[default] do:\n\t\t[optional] reset\n\n\tdirectory accessing\n\t\t[default] versionNumbers\n\n\"\n"
        },
        "instance creation": {
          "directoryFromName:setFileName:": "directoryFromName: fileDesignator setFileName: localNameBlock\n\t| directory stream |\n\t\"Answer the file directory implied from the designator, presumably at the start of the\n\tdesignator, and evaluate the block with the rest of the designator (presumably the\n\tfile name itself.\"\n\n\tdirectory _ Disk.\n\tstream _ ReadStream on: fileDesignator.\n\tlocalNameBlock value: (stream upTo: nil).\n\t^directory\n",
          "directory:directoryName:": "directory: aFileDirectory directoryName: aString\n\t\"Answer an instance of me in directory aFileDirectory whose name is aString.\"\n\n\t^self new setDirectory: aFileDirectory directoryName: aString\n"
        },
        "external reference access": {
          "addExternalReference:": "addExternalReference: anElement\n\t\"Add anElement as a file that is currently referenced in the system.\"\n\t(ExternalReferences includes: anElement)\n\t\tifFalse: [ExternalReferences addLast: anElement]\n",
          "removeExternalReference:": "removeExternalReference: anElement\n\t\"Remove anElement as a file that is currently referenced in the system.\"\n\tExternalReferences remove: anElement ifAbsent: []\n",
          "releaseExternalReferences": "releaseExternalReferences\n\t\"Remove and release all of the files referenced by the collection ExternalReferences.\"\n\t[ExternalReferences isEmpty]\n\t\twhileFalse: [ExternalReferences removeLast release]\n",
          "initializeExternalReferences": "initializeExternalReferences\n\t\"ExternalReferences is an OrderedCollection of the files that are referenced\n\tin the system.  Initialize this class variable.\"\n\tExternalReferences _ OrderedCollection new\n"
        }
      },
      "instance_methods": {
        "file accessing": {
          "isLegalOldFileName:": "isLegalOldFileName: aString\n\t\"Answer whether aString is a legal file name.\"\n\n\t^(self checkName: aString fixErrors: true) = aString\n\t\tand: [self includesKey: aString]\n",
          "checkNameOfFile:fixErrors:": "checkNameOfFile: aFile fixErrors: aBoolean\n\t\"See FileDirectory|checkNameOfFile: aFileName fixErrors: aBoolean.  The first argument\n\tis the name of the file, aFile.\"\n\t^self checkName: aFile fileName fixErrors: aBoolean\n",
          "filesMatching:": "filesMatching: pattern\n\t\"Answer an Array of the names of files that match the string, pattern.\"\n\t| names name |\n\tnames _ WriteStream on: (Array new: 10).\n\tself do:\n\t\t[:each |\n\t\tname _ each fileName.\n\t\t(pattern match: name)\n\t\t\tifTrue:\n\t\t\t\t[name last = $. ifTrue: [name _ name copyFrom: 1 to: name size - 1].\n\t\t\t\tnames nextPut: name]].\n\t^names contents\n",
          "file:": "file: aFileName\n\t\"Answer a FileStream on an old or new File whose name is aFileName.\"\n\n\t^(self findOrAddKey: aFileName) asFileStream\n",
          "isLegalFileName:": "isLegalFileName: aString\n\t\"Answer whether aString is a legal file name.\"\n\t^(self checkName: aString fixErrors: true) = aString\n",
          "checkName:fixErrors:": "checkName: aFileName fixErrors: aBoolean\n\t\"Check a string aFileName for validity as a file name.  If there are problems\n\t(e.g., illegal length or characters) and aBoolean is false, create an error;  if\n\tthere are problems and aBoolean is true, make the name legal (usually by\n\ttruncating and/or tranforming characters) and answer the new name.  Otherwise,\n\tanswer the name.  Default behavior is to get rid of ending period.\n\tSubclasses can do any kind of checking they want and answer either the\n\tname, or false if no good.\"\n\n\taFileName isEmpty ifTrue: [aBoolean ifFalse: [self error: 'file name empty']].\n\taFileName last = $.\n\t\tifTrue:\n\t\t\t[aBoolean ifFalse: [self error: 'file name ends in .'].\n\t\t\t^aFileName copyFrom: 1 to: aFileName size - 1]\n\t\tifFalse: [^aFileName]\n",
          "oldFile:": "oldFile: aFileName\n\t\"Answer a FileStream on an old File whose name is aFileName;  error if the\n\targument is not an old name.\"\n\n\t^(self findKey: aFileName) asFileStream\n",
          "rename:newName:": "rename: aFile newName: newName\n\t\"Rename the file, aFile, to have the name newName.  Create an\n\terror if a file by the name, newName, already exists.\"\n\tself subclassResponsibility\n",
          "checkNameOfFile:": "checkNameOfFile: aFileName\n\t\"See FileDirector|checkNameOfFile: aFileName fixErrors: false.\"\n\t^self checkNameOfFile: aFileName fixErrors: false\n",
          "newFile:": "newFile: aFileName\n\t\"Answer a FileStream on a new File whose name is aFileName;  error if the\n\targument is not a new file name.\"\n\n\t^(self addKey: aFileName) asFileStream\n",
          "fileClass": "fileClass\n\t\"Answer the proper subclass of File of which the files in the receiver are instances.\"\n\n\tself subclassResponsibility\n"
        },
        "file copying": {
          "store:": "store: aFileName\n\t\"Store the file whose name is aFileName to itself.  Subclasses may want to overwrite this to\n\tredirect the directory on which a file of the same name is copied.  See\n\tFileDirectory|storeFrom:copyTo:.\"\n\t^self storeFrom: aFileName copyTo: aFileName\n",
          "retrieve:": "retrieve: aFileName\n\t\"Copy the file whose name is aFileName to itself.  Subclasses may want to overwrite this to\n\tredirect the directory on which a file of the same name is copied.  See\n\tFileDirectory|retrieveFrom:copyTo:.\"\n\t^self retrieveFrom: aFileName copyTo: aFileName\n",
          "storeFrom:copyTo:": "storeFrom: aFileName1 copyTo: aFileName2\n\t\"Copy file whose name is aFileName1 (usually from a local directory) to a file\n\twhose name is aFileName2 (usually on the receiver).\"\n\n\t| f1 f2 |\n\tf1 _ self oldFile: aFileName1.\n\tf1 readOnly.\n\tf2 _ self file: aFileName2.\n\tf2 nextPutAll: f1.\n\tf2 close.\n\tf1 close\n",
          "retrieveFrom:copyTo:": "retrieveFrom: aFileName1 copyTo: aFileName2\n\t\"Copy file whose name is aFileName1 (usually from this receiver) to a file\n\twhose name is aFileName2 (usually a local directory).\"\n\n\t| f1 f2 |\n\tf1 _ self oldFile: aFileName1.\n\tf1 readOnly.\n\tf2 _ self file: aFileName2.\n\tf2 nextPutAll: f1.\n\tf2 close.\n\tf1 close\n"
        },
        "file testing": {
          "closed": "closed\n\t\"Answer whether the receiver is closed.\"\n\t^closed\n"
        },
        "printing": {
          "listFilesOn:": "listFilesOn: aStream\n\t\"Write a list of each file name in the receiver onto the stream, aStream.\"\n\tself do:\n\t\t[:aFile |\n\t\taStream cr.\n\t\taFile fileName printOn: aStream]\n",
          "printOn:": "printOn: aStream\n\taStream nextPutAll:\n\t\t(self closed\n\t\t\tifTrue: ['a closed ']\n\t\t\tifFalse: ['an open ']).\n\taStream nextPutAll: self class name.\n\taStream nextPutAll: ' on '.\n\tdirectoryName printOn: aStream\n"
        },
        "file status": {
          "flush": "flush\n\t\"Write any state on local storage.\"\n\n\tself subclassResponsibility\n",
          "open": "open\n\t\"Open the directory.\"\n\n\tclosed _ false.\n\t(ExternalReferences includes: self)\n\t\tifFalse: [ExternalReferences addLast: self]\n",
          "close": "close\n\t\"Close the receiver if it is not already closed.\"\n\tclosed\n\t\tifFalse:\n\t\t\t[ExternalReferences remove: self ifAbsent: [].\n\t\t\tself release]\n",
          "release": "release\n\t\"Release the receiver. a more forgiving version of close\n\twhich should always be possible even if close isn't desired or doesn't work.\"\n\n\tclosed _ true\n"
        },
        "testing": {
          "includesKey:": "includesKey: aFileName\n\t\"Answer whether a file whose name is aFileName is included in the receiver.\"\n\t| file |\n\tfile _ self find: (self initFileName: aFileName).\n\tfile notNil ifTrue:\n\t\t[file release. \"close the IFS connection, if an IFS leaf file\"\n\t\t^true].\n\t^false\n",
          "includes:": "includes: aFile\n\t\"Answer whether aFile is in the receiver's list of files.\"\n\t^(self find: aFile) notNil\n"
        },
        "accessing": {
          "fullName": "fullName\n\t\"Answer the name of the receiver in a form recognized when parsing file names (i.e., using [...]).  May be empty for a default directory.\"\n\t^''\n",
          "versionNumbers": "versionNumbers\n\t\"Answer true if versions numbers are supported.\"\n\n\t^false\t\t\"this is the default\"\n",
          "next": "next\n\t\"Answer the next file instance in the receiver (part of the streaming protocol).\"\n\tself subclassResponsibility\n",
          "directoryName": "directoryName\n\t\"Answer the name of the receiver.\"\n\t^directoryName\n"
        },
        "private": {
          "setDirectory:directoryName:": "setDirectory: aFileDirectory directoryName: aString\n\t\"assume that the directory is implicit\"\n\n\tdirectoryName _ aString.\n\tclosed _ true\n",
          "findOrAddKey:": "findOrAddKey: t1\n\t^self findOrAdd: (self initFileName: t1)\n",
          "find:": "find: aFile\n\t^self find: aFile ifAbsentDo: [:f | nil]\n",
          "initFile:": "initFile: aFile\n\taFile reinitialize.\n\t^aFile\n",
          "findOrAdd:": "findOrAdd: aFile\n\t\"find an old file if it exists, or create one\"\n\n\t| f |\n\t(f _ self find: aFile) notNil\n\t\tifTrue: [^f]\n\t\tifFalse: [^self addNew: aFile]\n",
          "find:ifAbsentDo:": "find: aFile ifAbsentDo: aBlock\n\t\"return aFile (partially initialized) if found, otherwise false.\n\tthis is a default implementation\"\n\n\t| fname |\n\t\"check file name\"\n\tfname _ self checkNameOfFile: aFile.\n\taFile fileName: fname.\n\t\"iterate through non-deleted entries of directory,\n\tand return partially initialized file if found\"\n\tself do: [:each | (fname sameAs: each fileName) ifTrue: [^each]].\n\t\"failure\"\n\t^aBlock value: aFile\n",
          "initFileName:": "initFileName: aFileName\n\t| aFile |\n\taFile _ self fileClass new.\n\taFile directory: self.\n\taFile fileName: aFileName.\n\taFile reinitialize.\n\t^aFile\n",
          "findKey:": "findKey: aFileName\n\t^self\n\t\tfind: (self initFileName: aFileName)\n\t\tifAbsentDo: [:file | file error: 'file not found']\n"
        },
        "enumerating": {
          "do:": "do: aBlock\n\t\"Sequence over all possible files in the receiver, evaluating aBlock for each one.\"\n\n\t| aFile |\n\tself reset.\n\t[aFile _ self next.\n\taFile notNil]\n\t\twhileTrue: [aBlock value: aFile]\n",
          "reset": "reset\n\t\"Set to the beginning of the directory.\"\n\tself subclassResponsibility\n"
        },
        "page accessing": {
          "newPage": "newPage\n\t\"Create a dummy file and a page from it.\"\n\n\t^(self initFileName: '') initPageNumber: 0\n",
          "deallocate:": "deallocate: aFilePage\n\t\"Deallocate aFilePage at some real disk address.\"\n\n\tself subclassResponsibility\n",
          "freePages": "freePages\n\t\"Answer the number of free pages remaining.\"\n\n\tself subclassResponsibility\n",
          "allocate:after:": "allocate: aFilePage after: virtualDiskAddress\n\t\"Answer aFilePage with its real disk address field filled in.\"\n\n\tself subclassResponsibility\n",
          "allocateSN:": "allocateSN: aFile\n\t\"Allocate a new serial number for the file, aFile.\"\n\n\tself subclassResponsibility\n"
        },
        "adding": {
          "add:": "add: aFile\n\t\"Add the file, aFile, to the receiver.   This creates a new version of the file rather than generating an error if a file with the same name exists.\"\n\n\t| old file |\n\tfile _ aFile.\n\tself versionNumbers\n\t\tifTrue:\n\t\t\t[\"ignore explicit version and directory will create a next version\"\n\t\t\tfile _ self initFileName: (file fileName copyUpTo: $!)]\n\t\tifFalse:\n\t\t\t[(self find: file) notNil\n\t\t\t\tifTrue:\n\t\t\t\t\t[\"otherwise, if file already exists,\n\t\t\t\t\t  rename it to name$, deleting that file first if it exists\"\n\t\t\t\t\told _ self initFileName: (file fileName copyWith: $$).\n\t\t\t\t\tself remove: old ifAbsentDo: [:f | false].\n\t\t\t\t\tself rename: file newName: old fileName.\n\t\t\t\t\tfile fileName: (file fileName copyUpTo: $$).\n\t\t\t\t\t(self find: file) notNil ifTrue: [file error: 'insert/rename ??']]].\n\tself addNew: file.\n\t^file\n",
          "addNew:": "addNew: aFile\n\t\"Add the argument, aFile, as a new file in the receiver.\"\n\tself subclassResponsibility\n",
          "addKey:": "addKey: aFileName\n\t\"If a file whose name is aFileName exists and the receiver does not know how\n\tto create a new version, the create an error.  Otherwise create a new empty file.\"\n\n\t^self add: (self initFileName: aFileName)\n"
        },
        "removing": {
          "removeOld:": "removeOld: aFile\n\t\"If aFile exists, remove it.\"\n\n\tself subclassResponsibility\n",
          "remove:ifAbsentDo:": "remove: aFileName ifAbsentDo: aBlock\n\t\"Remove aFile if found in the receiver.  Answer the result of evaluating aBlock if the file is not found.\"\n\n\t| f |\n\tf _ self find: aFileName ifAbsentDo: aBlock.\n\tf notNil\n\t\tifTrue: [^self removeOld: f]\n\t\tifFalse: [^aBlock value: f]\n",
          "remove:": "remove: aFile\n\t\"Remove aFile if found in the receiver.  Create an error if it is not.\"\n\n\t^self remove: aFile ifAbsentDo: [:f | f error: 'file not found']\n"
        },
        "dictionary removing": {
          "removeKey:": "removeKey: aFileName\n\t\"Remove and answer the file whose name is aFileName;  create an error if not\n\tfound.\"\n\t^self\n\t\tremove: (self initFileName: aFileName)\n\t\tifAbsentDo: [:f | f error: 'file not found']\n"
        }
      }
    },
    "File": {
      "comment": "I am an abstract representation of a collection of FilePages and a reference to a FileDirectory which contains me.  My instance is usually uniquely identified both by an alphanumeric name (a String) and a serial number (a ByteArray).\n\nAccording to this Smalltalk model, a File System consists of coordinated subclass definitions for FilePage, File, and FileDirectory.  User programs typically do not directly access a File or its FilePages but access it as a sequence of characters or bytes through a FileStream.\n\nInstance Variables:\n\tfileName\t\t<String>\n\tserialNumber\t<ByteArray>\n\tfileDirectory\t<FileDirectory>\n\tlastPageNumber\t<Integer>\n\tbinary\t\t\t<Boolean> indicates binary or textual contents\n\treadWrite\t\t<Integer> tells if writing is allowed\n\terror\t\t\t<Symbol> an error condition\n\tpageCache\t\tnot currently used.\n",
      "class_name": "File",
      "superclass": "Object",
      "instanceVariables": "fileDirectory fileName pageCache serialNumber lastPageNumber binary readWrite error",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "FilePool",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"Subclasses of File may want to share variables in pools.\n\tExecute before filin:  Smalltalk at: #XFilePool as: (Dictionary: 16).\n\tin XFile initialize.\"\n\n\tFilePool at: #Read put: 1.\n\tFilePool at: #Write put: 2.\n\tFilePool at: #Shorten put: 3\n"
        },
        "documentation": {
          "documentation": "documentation\n\t\"Subclasses of File are expected to implement the following messages.  Unless \totherwise indicated, they are provided as self subclassResponsibilty\n\n\ttesting\n\t\t[optional] characterSize\n\n\tfileStream accessing\n\t\tread:\n\t\twrite:\n\n\tfile accessing\n\t\tendFile:\n\n\tfile status\n\t(these are implemented as returning self)\n\t\tclose\n\t\trelease\n\n\terror handling\n\t\terrorString:\n\n\tfile/page/directory implementation\n\t\tdoCommand:page:error:\n\n\tprivate\n\t\t[optional] findLastPageNumber\n\t\t\t(this has an implementation but is circular with characterSize\n\t\t\t\tso one or both must be reimplemented)\n\t\tpageClass\n\n\"\n"
        }
      },
      "instance_methods": {
        "file accessing": {
          "fullName": "fullName\n\t\"Answer the name of the receiver, including directory names if necessary.\"\n\t^self directory fullName, self fileName\n",
          "fileName:": "fileName: aFileName\n\t\"Set the name of the receiver to be aFileName.\"\n\tfileName _ aFileName\n",
          "rename:": "rename: newFileName\n\t\"Change the name of the receiver to be newFileName.\"\n\n\tfileDirectory rename: self newName: newFileName\n",
          "endFile:": "endFile: aFilePage\n\t\"Make the file end with aFilePage, i.e., remove all file pages after\n\taFilePage, and answer the result of writing aFilePage (File|write:). If the argument is\n\tnil, delete all of the receiver's pages.\"\n\n\tself subclassResponsibility\n",
          "beSnapshotFile": "beSnapshotFile\n\tself subclassResponsibility\n",
          "directory": "directory\n\t\"Answer the directory in which the receiver is referenced.\"\n\t^fileDirectory\n",
          "fileName": "fileName\n\t\"Answer the name of the receiver.\"\n\t^fileName\n",
          "directory:": "directory: aFileDirectory\n\t\"Set the directory in which the receiver is referenced to be aFileDirectory.\"\n\tfileDirectory _ aFileDirectory\n"
        },
        "comparing": {
          "match:": "match: aFile\n\t\"Answer whether the two strings, the receiver's file name and that\n\tof the argument, aFile, match.  (See String|match:).\"\n\t^self fileName match: aFile fileName\n"
        },
        "file testing": {
          "isBinary": "isBinary\n\t\"Answer whether the information in the receiver is stored in binary format.\"\n\t^binary\n",
          "isText": "isText\n\t\"Answer whether the information in the receiver is stored as ascii characters.\"\n\t^binary == false\n"
        },
        "printing": {
          "printOn:": "printOn: aStream\n\tfileName printOn: aStream\n"
        },
        "file status": {
          "open": "open\n\t\"Open the receiver.\"\n\tself findLastPageNumber\n",
          "reinitialize": "reinitialize\n\t\"Reset the receiver to its initial status.\"\n\tlastPageNumber _ nil.\n\terror _ ''.\n\tserialNumber _ ByteArray new: 4.\n\t\"text mode is default\"\n\tbinary isNil ifTrue: [binary _ false]\n",
          "close": "close\n\t\"Close the receiver.  Subclasses may wish to update the leader page.\"\n\tself subclassResponsibility\n",
          "release": "release\n\t\"Release the receiver.  This is a more forgiving version of close\n\tand should always be possible even if close isn't desired or doesn't work.\"\n\n\tself subclassResponsibility\n",
          "reopen": "reopen\n\t\"Reopen the receiver by possibly looking it up in a file directory and then opening.\"\n\n\tself sameAsStoredFile\n\t\tifFalse:\n\t\t\t[self reinitialize.\n\t\t\tfileDirectory findOrAdd: self].\n\tself open\n"
        },
        "testing": {
          "characterSize": "characterSize\n\t\"Answer the size of the receiver in characters.  The definitions\n\tcharacterSize and findLastPageNumber are circular;  a subclass must\n\tdefine either or both.\"\n\n\t| page |\n\tpage _ self readPageNumber: self size.\n\t^lastPageNumber - 1 * page dataSize + page size\n"
        },
        "accessing": {
          "size": "size\n\t\"Answer the receiver's size in pages;  a file is a collection of pages.\"\n\n\tlastPageNumber isNil\n\t\tifTrue: [^self findLastPageNumber]\n\t\tifFalse: [^lastPageNumber]\n"
        },
        "private": {
          "readOrAddPageNumber:": "readOrAddPageNumber: aPageNumber\n\t\"create aFilePage and read or extend into it\"\n\n\t^self readOrAdd: (self initPageNumber: aPageNumber)\n",
          "pageClass": "pageClass\n\t\"answer with the appropriate subclass of FilePage which I contain\"\n\n\tself subclassResponsibility\n",
          "sameAsStoredFile": "sameAsStoredFile\n\t\"Answer true if File instance is correct enough so that it doesn't have to be\n\treinitialized.  This allows reopen to go more quickly for certain\n\timplementations.  For example, in a local file system, a write date and time\n\tmay guarantee that it hasn't changed since we closed this file.  This is the\n\tdefault. \"\n\n\t^false\n",
          "pageNumberFrom:": "pageNumberFrom: characterIndex\n\t\"compute a page number from a character index\"\n\n\t^characterIndex - 1 // self pageClass new dataSize + 1\n",
          "findLastPageNumber": "findLastPageNumber\n\t\"set and answer with the page number of my last page.\n\tsee circularity comment for characterSize\"\n\n\t^lastPageNumber _ self pageNumberFrom: self size\n"
        },
        "nonhomogeneous accessing": {
          "readOrAdd:": "readOrAdd: aFilePage\n\t\"Read aFilePage if it exists or extend File to create it as an empty page.\"\n\n\t| pageNumber filePage |\n\tfilePage _ aFilePage.\n\tpageNumber _ filePage pageNumber.\n\tpageNumber <= lastPageNumber ifTrue: [^self read: filePage].\n\t(lastPageNumber + 1 to: pageNumber - 1)\n\t\tdo: [\"write full intermediate pages\"\n\t\t\tfilePage pageNumber: pageNumber.\n\t\t\tfilePage _ self write: filePage].\n\t\"return an empty last page\"\n\tfilePage pageNumber: pageNumber.\n\tfilePage size: 0.\n\t^filePage\n",
          "read:": "read: aFilePage\n\t\"Read aFilePage if it exists, else answer false.  aFilePage contains a pageNumber and other\n\tinformation, e.g., a serialNumber necessary to obtain the page.  It is possible that\n\taFilePage pageNumber = 0 may or may not exist in some file systems. The pageNumber may\n\tbe used to compute a byte range to be read, or to lookup a disk address in a table.\n\tIn a file system where pages are linked, aFilePage may contain the address\n\tof the next page and may help reveal lastPageNumber.\"\n\n\tself subclassResponsibility\n",
          "write:": "write: aFilePage\n\t\"Write aFilePage, one that has been read or created (see File|readOrAdd:).\n\tIf aFilePage pageNumber < lastPageNumber, make sure page is full.\n\tIf aFilePage pageNumber = (lastPageNumber+1), then update file length.\n\tPage numbers greater than lastPageNumber+1 are illegal (use File|readOrAdd:).\n\n\tAnswer the result of writing the page.  In some implementations, at end of file,\n\tthe next empty page is also written and answered.\"\n\n\tself subclassResponsibility\n",
          "readPageNumber:": "readPageNumber: aPageNumber\n\t\"Create a FilePage for page number, aPageNumber, and read into it.\"\n\n\t^self read: (self initPageNumber: aPageNumber)\n"
        },
        "converting": {
          "asFileStream": "asFileStream\n\t\"Answer a FileStream on the first page of the receiver.\"\n\n\tself open.\n\t^FileStream on: (self readOrAddPageNumber: 1)\n"
        },
        "file modes": {
          "readWrite": "readWrite\n\t\"Answer the read/write status of the receiver.\"\n\t^readWrite\n",
          "text": "text\n\t\"Set the receiver's contents to be in ascii character format.\"\n\tbinary _ false\n",
          "binary": "binary\n\t\"Set the receiver's contents to be in binary format.\"\n\tbinary _ true\n",
          "readWrite:": "readWrite: statusInteger\n\t\"Set the read/write status of the receiver to be statusInteger.\"\n\treadWrite _ statusInteger\n"
        },
        "page accessing": {
          "serialNumber:": "serialNumber: aSerialNumber\n\t\"Set the receiver's serial number to be aSerialNumber.\"\n\tserialNumber _ aSerialNumber\n",
          "serialNumber": "serialNumber\n\t\"Answer the receiver's serial number.\"\n\t^serialNumber\n"
        },
        "error handling": {
          "errorString:": "errorString: anInteger\n\t\"Construct an error string corresponding to the error code, anInteger.\"\n\tself subclassResponsibility\n",
          "error:": "error: e\n\t\"Construct an error message using the argument, e.\"\n\n\t| s errorString |\n\ts _ WriteStream on: (String new: 50).\n\ts nextPutAll: fileName.\n\ts nextPutAll: ' '.\n\ts nextPutAll: e.\n\ts nextPutAll: ', '.\n\ts nextPutAll: error.\n\terrorString _ s contents.\n\terror _ ''.\n\t^super error: errorString\n",
          "error": "error\n\t\"Answer a Symbol indicating the last error condition.\"\n\t^error\n"
        },
        "file/page/directory implementation": {
          "size:": "size: aPageNumber\n\t\"Set the last page number of the receiver to be aPageNumber.\"\n\tlastPageNumber _ aPageNumber\n",
          "initPage:": "initPage: aFilePage\n\t\"Initialize the argument, aFilePage.\"\n\n\taFilePage reinitialize.\n\taFilePage serialNumber: serialNumber.\n\t^aFilePage\n",
          "doCommand:page:error:": "doCommand: command page: aFilePage error: errorString\n\t\"The argument, command, is typically read or write;\n\tpage is a FilePage containing data and possibly other information;\n\terrorString is a String to include in an error message\n\t(or if it is nil, no error is to be reported).\n\n\tExecute some disk primitive (which is usually another message).\n\n\tAnswer aFilePage if successful. If an error occurs, answer false if errorString is nil.\n\tOtherwise, create an error message with errorString.\"\n\n\tself subclassResponsibility\n",
          "initPageNumber:": "initPageNumber: aPageNumber\n\t\"Create and initialize the file page with page number, aPageNumber;\n\tserial number that of the receiver.  Answer the new FilePage.\"\n\n\t| aFilePage |\n\taFilePage _ self pageClass new file: self page: nil.\n\tbinary\n\t\tifTrue: [aFilePage binary]\n\t\tifFalse: [aFilePage text].\n\taFilePage pageNumber: aPageNumber.\n\taFilePage serialNumber: serialNumber.\n\t^aFilePage\n",
          "lastPageNumber": "lastPageNumber\n\t\"Answer the number of the last page of the receiver.\"\n\t^self size\n"
        }
      }
    }
  },
  "Files-Posix": {
    "PosixFileDirectory": {
      "class_name": "PosixFileDirectory",
      "superclass": "FileDirectory",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t^super new setDirectory: nil directoryName: ''\n"
        }
      },
      "instance_methods": {
        "file accessing": {
          "rename:newName:": "rename: aFile newName: newFileName\n\tself doPrimitive: 2 arg1: newFileName arg2: aFile\n",
          "fileNames": "fileNames\n\t^self\n\t\tdoPrimitive: 3\n\t\targ1: nil\n\t\targ2: nil\n",
          "fileClass": "fileClass\n\t^PosixFile\n"
        },
        "file status": {
          "flush": "flush\n\t^self\n"
        },
        "private": {
          "doPrimitive:arg1:arg2:": "doPrimitive: code arg1: arg1 arg2: arg2\n\t<primitive: 131>\n"
        },
        "enumerating": {
          "do:": "do: aBlock \n\t| files |\n\tfiles _ (self fileNames collect: [ : aFileName | self initFileName: aFileName  ]).\n\t(ReadStream on:files) do: aBlock\n"
        },
        "adding": {
          "add:": "add: aFile \n\t^self addNew: aFile\n",
          "addNew:": "addNew: aFile \n\t| fd |\n\tfd _ self doPrimitive: 0 arg1: aFile fileName arg2: nil.\n\taFile fd: fd.\n\taFile readWrite: Write.\n\t^aFile\n"
        },
        "removing": {
          "removeOld:": "removeOld: aFile\n\tself doPrimitive: 1 arg1: aFile fileName arg2: nil\n"
        }
      }
    },
    "PosixFilePage": {
      "class_name": "PosixFilePage",
      "superclass": "FilePage",
      "instanceVariables": "pageNumber bytesInPage",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "accessing": {
          "size:": "size: size\n\tbytesInPage _ size\n",
          "serialNumber:": "serialNumber: n \n\t^self\n",
          "size": "size\n\t^bytesInPage\n"
        },
        "page accessing": {
          "pageNumber": "pageNumber\n\t^pageNumber\n"
        },
        "file/page/directory implementation": {
          "pageNumber:": "pageNumber: pn\n\tpageNumber _ pn\n"
        }
      }
    },
    "PosixFile": {
      "class_name": "PosixFile",
      "superclass": "File",
      "instanceVariables": "fd cachedPageSize",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "file accessing": {
          "endFile:": "endFile: aPage\n\t| nextPage |\n\t\"Make the file end with aFilePage, i.e., remove all file pages after \n\taFilePage, and answer the result of writing aFilePage (File|write:). If the argument is\n\tnil, delete all of the receiver's pages.\"\n\t\n\taPage isNil ifFalse: [ nextPage _ self write: aPage ]\n\t\t    ifTrue: [ nextPage _ nil ].\n\t\"truncate\"\n\tself doCommand: 2 name: nil page: aPage error:'endFile:'.\n\tself findLastPageNumber.\n\t^nextPage\n",
          "beSnapshotFile": "beSnapshotFile\n\t<primitive: 128>\n"
        },
        "nonhomogenous accessing": {
          "read:": "read: page\n\t\"Read aFilePage if it exists, else answer false.  aFilePage contains a pageNumber and other\n\tinformation, e.g., a serialNumber necessary to obtain the page.  It is possible that \n\taFilePage pageNumber = 0 may or may not exist in some file systems. The pageNumber may\n\tbe used to compute a byte range to be read, or to lookup a disk address in a table.\n\tIn a file system where pages are linked, aFilePage may contain the address\n\tof the next page and may help reveal lastPageNumber.\"\n\n\t(self doCommand: 0 name: nil page: page error:'read:') ifFalse: [^nil].\n\t^page\n",
          "write:": "write: page\n\t| returnPage |\n\tself doCommand: 1 name: nil page: page error:'write:'.\n\n\treturnPage _ page.\n\t((page lastPage) and: [page isFull])\n\t  ifTrue: [\"last page can't be full, so glue on another page\"\n\t\treturnPage _ self initPageNumber: 0.\n\t\treturnPage reinitialize.\n\t\treturnPage pageNumber: (lastPageNumber _ page pageNumber + 1)].\n\treadWrite _ Read + Write.\n\t^returnPage\n"
        },
        "file status": {
          "open": "open\n\tself doCommand: 4 name: fileName page: nil error: 'open:'.\n\treadWrite _ Read.\n\tself findLastPageNumber\n",
          "reinitialize": "reinitialize\n\tsuper reinitialize.\n\tfd _ nil\n",
          "close": "close\n\tfd isNil ifFalse: [ ^self doCommand: 5 name: nil page: nil error:nil ]\n",
          "release": "release\n\tself close\n",
          "reopen": "reopen\n\tself close.\n\tself reinitialize.\n\tself open\n"
        },
        "testing": {
          "sizeOnDisk": "sizeOnDisk\n\t^self\n\t\tdoCommand: 3\n\t\tname: nil\n\t\tpage: nil\n\t\terror: nil\n"
        },
        "private": {
          "pageClass": "pageClass\n\t^PosixFilePage\n",
          "doPrimCommand:name:page:": "doPrimCommand: command name: name page: page\n\t<primitive: 130>\n",
          "doCommand:name:page:error:": "doCommand: command name: name page: page  error: e\n\t| result |\n\tresult _ self doPrimCommand: command name: name page: page.\n\t(result == false or: [ result isNil] ) ifTrue: [ \n\t\te isNil ifFalse: [ error _ self errorString: self lastError.\n\t\t\t\tself error: e]].\n\t^result\n",
          "findLastPageNumber": "findLastPageNumber\n\t|bytes|\n\t\"pages are numbered 1..N\"\n\tbytes _ self sizeOnDisk.\n\t^ lastPageNumber _ ((bytes + self pageSize - 1) // self pageSize) max: 1\n",
          "pageSize": "pageSize\n\tcachedPageSize isNil ifTrue: [cachedPageSize _ self pageClass new pageSize].\n\t^cachedPageSize\n"
        },
        "error handling": {
          "lastError": "lastError\n\t<primitive: 132>\n",
          "errorString:": "errorString: anInteger\n\t<primitive: 133>\n"
        },
        "file/page/directory implementation": {
          "fd:": "fd: descriptor\n\tfd _ descriptor\n"
        }
      }
    }
  },
  "Files-Streams": {
    "FileStream": {
      "comment": "I represent a Stream that accesses a FilePage from a File.  One use for my instance is to access larger \"virtual Strings\" than can be stored contiguously in main memory.  I restrict the objects stored and retrieved to be Integers or Characters.  An end of file pointer terminates reading;  it can be extended by writing past it, or the file can be explicitly truncated.\n\nTo use the file system for most applications, you typically create a FileStream.  This is done by sending a message to a FileDirectory (file:, oldFile:, newFile:, rename:newName:) which creates an instance of me.  Accesses to the file are then done via my instance.\n\nInstance variables\n\tpage\t\t\t<FilePage> the current FilePage being accessed\n\trwmode\t\t\t<Integer> denoting readOnly, readWrite, or readWriteShorten.\n\t\t\t\t\treadWriteShorten with textual contents is the default.\n\tclosed\t\t\t<Boolean> false if the file is open\n",
      "class_name": "FileStream",
      "superclass": "ExternalStream",
      "instanceVariables": "page rwmode closed",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "FilePool",
      "class_methods": {
        "instance creation": {
          "on:": "on: aFilePage\n\t^self new on: aFilePage\n",
          "fileNamed:": "fileNamed: fileDesignator\n\t\"Answer a FileStream on an old or new File designated by the string fileDesignator.\"\n\n\t| dir fName |\n\tdir _ FileDirectory directoryFromName: fileDesignator setFileName: [:fName].\n\t^(dir findOrAddKey: fName) asFileStream\n",
          "newFileNamed:": "newFileNamed: fileDesignator\n\t\"Answer a FileStream on a new File designated by the string fileDesignator.  Error if the argument is not a new file name.\"\n\n\t| dir fName |\n\tdir _ FileDirectory directoryFromName: fileDesignator setFileName: [:fName].\n\t^(dir addKey: fName) asFileStream\n",
          "oldFileNamed:": "oldFileNamed: fileDesignator\n\t\"Answer a FileStream on an old File designated by the string fileDesignator.  Error if the argument is not an old file name.\"\n\n\t| dir fName |\n\tdir _ FileDirectory directoryFromName: fileDesignator setFileName: [:fName].\n\t^(dir findKey: fName) asFileStream\n"
        }
      },
      "instance_methods": {
        "file accessing": {
          "file": "file\n\t\"Answer the file for the page the receiver is streaming over.\"\n\t^page file\n",
          "beSnapshotFile": "beSnapshotFile\n\t^self file beSnapshotFile\n",
          "name": "name\n\t\"Answer the name of the file for the page the receiver is streaming over.\"\n\t^page file fileName\n",
          "directory": "directory\n\t\"Answer the directory of the file for the page the receiver is currently streaming over.\"\n\t^page file directory\n",
          "page": "page\n\t\"Answer the page the receiver is streaming over.\"\n\t^page\n"
        },
        "fileIn/Out": {
          "printOutChanges": "printOutChanges\n\t\"Print out a description of all system changes.\"\n\n\tself fileOutChanges\n",
          "fileIn": "fileIn\n\t\"Guarantee fileStream is readOnly before fileIn for efficiency and to eliminate remote sharing conflicts\"\n\n\tTranscript refresh; cr; cr; show: 'Filing in from:'; crtab; show: self name; cr.\n\tself readOnly.\n\t^super fileIn\n",
          "fileOutChanges": "fileOutChanges\n\t\"Append to the receiver a description of all system changes.\"\n\n\tTranscript refresh; cr; cr; show: ('Filing out changes on:'); crtab; show: self name.\n\tsuper fileOutChanges\n"
        },
        "file testing": {
          "closed": "closed\n\t\"Answer the status of the file--false if open, true otherwise.\"\n\t^closed\n",
          "writing": "writing\n\t\"Answer whether it is possible to write on the receiver.\"\n\n\trwmode == nil\n\t\tifTrue:\n\t\t\t[self readWriteShorten.\t\"default mode\"\n\t\t\t^true].\n\t^(rwmode bitAnd: Write) = Write\n"
        },
        "positioning": {
          "position:": "position: pos\n\tself position: pos size: 1\n",
          "position": "position\n\t\"return current character position in File\"\n\n\t^self positionSize: 1\n",
          "skip:": "skip: n\n\t| pos plen pageOffset |\n\tn = 0 ifTrue: [^self].\n\tself reopen.\n\tpos _ position + n.\n\t(n > 0\n\t\tifTrue: [pos >= readLimit]\n\t\tifFalse:\n\t\t\t[self fixEnd.\n\t\t\t\"important on last page\"\n\t\t\tpos < page dataBeginning])\n\t\tifTrue:\n\t\t\t[plen _ page dataSize.\n\t\t\t\"assume p is not Large, otherwise use divMod:\"\n\t\t\tpos _ pos - page dataBeginning.\n\t\t\tpageOffset _ pos // plen.\n\t\t\t(self positionPage: page pageNumber + pageOffset character: pos \\\\ plen)\n\t\t\t\tifFalse: [self error: 'cannot skip ' , n printString]]\n\t\tifFalse: [\"same page\"\n\t\t\tposition _ pos]\n",
          "reset": "reset\n\t\"set position to beginning of File\"\n\n\t(self read: 1) isNil ifTrue: [self error: 'reset']\n",
          "setToEnd": "setToEnd\n\t\"set position to end of File.  logically: self position: self size\"\n\n\tself reopen.\n\t(self read: (self file size max: page pageNumber)) isNil\n\t\tifTrue: [self error: 'setToEnd'].\n\tposition _ readLimit\n"
        },
        "printing": {
          "printOn:": "printOn: aStream\n\tsuper printOn: aStream.\n\taStream nextPutAll: ' on '.\n\tself file printOn: aStream\n"
        },
        "nonhomogeneous positioning": {
          "wordPosition": "wordPosition\n\t\"return current position in words (2 characters)\"\n\n\t^self positionSize: 2\n",
          "wordPosition:": "wordPosition: wpos\n\t\"set current position in words\"\n\n\t^self position: wpos size: 2\n",
          "padTo:put:": "padTo: bsize put: aCharacter\n\t| rem |\n\trem _ bsize - ((page dataSize \\\\ bsize = 0\n\t\t\t\t\tifTrue: [position - page dataBeginning]\n\t\t\t\t\tifFalse: [self position])\n\t\t\t\t\t\\\\ bsize).\n\trem = bsize ifTrue: [^0].\n\tself next: rem put: aCharacter.\n\t^rem\n",
          "padTo:": "padTo: bsize\n\t| rem |\n\trem _ bsize - ((page dataSize \\\\ bsize = 0\n\t\t\t\t\tifTrue: [position - page dataBeginning]\n\t\t\t\t\tifFalse: [self position])\n\t\t\t\t\t\\\\ bsize).\n\trem = bsize ifTrue: [^0].\n\tself skip: rem.\n\t^rem\n"
        },
        "file status": {
          "flush": "flush\n\t\"Write the current page back onto the file.\"\n\tself closed\n\t\tifTrue: [^page]\n\t\tifFalse:\n\t\t\t[self fixEnd.\n\t\t\tpage fromFileStream: self.\n\t\t\t^page write]\n",
          "close": "close\n\t\"Set the receiver's file status to closed.\"\n\n\tclosed\n\t\tifFalse:\n\t\t\t[self writing\n\t\t\t\tifTrue: [(rwmode bitAnd: Shorten) = Shorten\n\t\t\t\t\t\t\tifTrue: [self shorten]\n\t\t\t\t\t\t\tifFalse: [self flush]].\n\t\t\tclosed _ true.\n\t\t\treadLimit _ writeLimit _ 0.\n\t\t\tself file close.\n\t\t\tFileDirectory removeExternalReference: self]\n",
          "release": "release\n\t\"Set the receiver's status to closed, if it is not already, and do not allow\n\tany further reading or writing.\"\n\tclosed\n\t\tifFalse:\n\t\t\t[closed _ true.\n\t\t\treadLimit _ writeLimit _ 0.\n\t\t\tself file release]\n",
          "reopen": "reopen\n\t\"Set the receiver's file to be open again, setting the position to its previous position.\n\tCreate an error if the file can not be reopened.\"\n\n\t| pos |\n\tclosed ifFalse: [^nil].\n\t\"reopen to previous position\"\n\tpos _ position.\n\t(self read: page pageNumber) isNil\n\t\tifTrue:\n\t\t\t[\"that page doesn't exist, so go to last one that does.\n\t\t\tnote that setToEnd would be recursive\"\n\t\t\t(self read: self file size) isNil\n\t\t\t\tifTrue: [^self error: 'cannot reopen or setToEnd'].\n\t\t\tposition _ readLimit]\n\t\tifFalse: [position _ pos min: readLimit]\n"
        },
        "testing": {
          "atEnd": "atEnd\n\t\"Answer true if current position is >= end of file position.\"\n\n\tclosed ifTrue: [self reopen].\n\tposition < readLimit ifTrue: [^false].\n\t(page lastPage or: [self nextPage isNil])\n\t\tifTrue: [^true].\n\t^position = readLimit\n"
        },
        "editing": {
          "edit": "edit\n\t\"Create and schedule a FileView of the contents of the receiver.  The label of the view is the name of the receiver.\"\n\n\tFileModel\n\t\topen: (FileModel fileStream: self)\n\t\tnamed: self file fullName\n"
        },
        "accessing": {
          "nextPut:": "nextPut: aByte\n\t| dmax |\n\trwmode == nil\n\t\tifTrue: [self readWriteShorten \"default mode\"].\n\t(rwmode bitAnd: Write) = 0\n\t\tifTrue: [^self error: 'no writing allowed!'].\n\tclosed ifTrue: [self reopen].\n\tposition < writeLimit\n\t\tifTrue: [^collection at: (position _ position + 1) put: aByte].\n\tdmax _ page dataMaxEnd.\n\twriteLimit < dmax\n\t\tifTrue: [writeLimit _ dmax]\n\t\tifFalse:\n\t\t\t[self nextPage isNil ifTrue: [^self error: 'cannot write!!!'].\n\t\t\tposition = readLimit ifTrue: [writeLimit _ dmax]].\n\t^collection at: (position _ position + 1) put: aByte\n",
          "next:into:": "next: anInteger into: aCollection\n\t\"Copy the next anInteger bytes from the receiver into aCollection.\"\n\n\t| howManyRead increment |\n\n\thowManyRead _ 0.\n\t[howManyRead < anInteger] whileTrue:\n\t\t[\n\t\tself atEnd ifTrue:\n\t\t\t[\n\t\t\t(howManyRead + 1) to: anInteger do: [:i | aCollection at: i put: (self next)].\n\t\t\t^aCollection\n\t\t\t].\n\t\tincrement _ (readLimit - position) min: (anInteger - howManyRead).\n\t\taCollection replaceFrom: (howManyRead + 1) to: (howManyRead _ howManyRead + increment) with: collection startingAt: (position + 1).\n\t\tposition _ position + increment.\n\t\t].\n\t^aCollection\n",
          "next": "next\n\t(position >= readLimit and: [self atEnd])\n\t\tifTrue: [^nil]\n\t\tifFalse: [^collection at: (position _ position + 1)]\n",
          "contentsOfEntireFile": "contentsOfEntireFile\n\t\"Read all of the contents of the receiver.\"\n\n\t| s |\n\tself readOnly.\n\tself reset.\n\ts _ self next: self size.\n\tself close.\n\t^s\n",
          "next:": "next: anInteger\n\n\t| newCollection howManyRead increment |\n\n\tnewCollection _ collection species new: anInteger.\n\n\thowManyRead _ 0.\n\t[howManyRead < anInteger] whileTrue:\n\t\t[\n\t\tself atEnd ifTrue:\n\t\t\t[\n\t\t\t(howManyRead + 1) to: anInteger do: [:i | newCollection at: i put: (self next)].\n\t\t\t^newCollection\n\t\t\t].\n\t\tincrement _ (readLimit - position) min: (anInteger - howManyRead).\n\t\tnewCollection replaceFrom: (howManyRead + 1) to: (howManyRead _ howManyRead + increment) with: collection startingAt: (position + 1).\n\t\tposition _ position + increment.\n\t\t].\n\t^newCollection\n",
          "size": "size\n\t\"return size of File in characters\"\n\n\tself reopen.\n\tself fixEnd.\n\t\"if on last page, return answer directly\"\n\tpage lastPage\n\t\tifTrue: [^page pageNumber - 1 * page dataSize + page size]\n\t\tifFalse: [^self file characterSize]\n",
          "nextPutAll:": "nextPutAll: aCollection\n\t| dmax howManyWritten increment collectionSize |\n\n\t((aCollection isKindOf: ByteArray) or: [aCollection isKindOf: String])\n\t\tifFalse: [^super nextPutAll: aCollection].\n\n\trwmode == nil\n\t\tifTrue: [self readWriteShorten \"default mode\"].\n\t(rwmode bitAnd: Write) = 0\n\t\tifTrue: [^self error: 'no writing allowed!'].\n\tclosed ifTrue: [self reopen].\n\n\thowManyWritten _ 0.\n\tcollectionSize _ aCollection size.\n\tdmax _ (page dataMaxEnd).\n\t[\n\tincrement _ (dmax - position) min: (collectionSize - howManyWritten).\n\tcollection replaceFrom: (position + 1) to: (position _ position + increment)\n\t\twith: aCollection startingAt: (howManyWritten + 1).\n\thowManyWritten _ howManyWritten + increment.\n\thowManyWritten < collectionSize.\n\t] whileTrue:\n\t\t[\n\t\tself nextPage isNil ifTrue: [^self error: 'cannot write!!!'].\n\t\tposition = readLimit ifTrue: [writeLimit _ dmax].\n\t\t].\n\tposition > writeLimit ifTrue: [writeLimit _ dmax].\n\t^aCollection\n"
        },
        "private": {
          "setMode:": "setMode: m\n\trwmode = m\n\t\t\"don't flush if first time or not write mode or continuing write mode\"\n\t\tifFalse: [(rwmode == nil or: [(rwmode bitAnd: Write) = 0\n\t\t\t\t\tor: [(m bitAnd: Write) = Write]])\n\t\t\t\t\tifTrue: [rwmode _ m]\n\t\t\t\t\tifFalse:\n\t\t\t\t\t\t[self flush.\n\t\t\t\t\t\trwmode _ m]]\n",
          "positionSize:": "positionSize: size\n\t\"compute the position for an object of a given size,\n\te.g. characters (1), words (2), fixed length (n),\n\tfrom the current character position and the current page\"\n\n\t| len pos |\n\tlen _ page dataSize.\n\t(size = 1 or: [len \\\\ size ~= 0])\n\t\tifTrue:\n\t\t\t[pos _ page pageNumber - 1 * len + (position - page dataBeginning).\n\t\t\tsize = 1\n\t\t\t\tifTrue: [^pos]\n\t\t\t\tifFalse: [^pos // size]]\n\t\tifFalse: [\"page length is a multiple of size\"\n\t\t\t\t^page pageNumber - 1 * (len // size)\n\t\t\t\t\t\t\t+ (position - page dataBeginning // size)]\n",
          "on:": "on: aFilePage\n\t\"initialize stream on aFilePage\"\n\n\tpage _ aFilePage.\n\t\t\"some page from a File, usually page 1, or another FileStream\"\n\t(page isKindOf: FileStream)\n\t\tifTrue: [page _ page page].\n\tpage asFileStream: self.\n\tclosed _ false.\n\tFileDirectory addExternalReference: self\n",
          "position:size:": "position: objpos size: size\n\t\"set the current character position and the current page\n\tfrom the position of an object of a given size (see positionSize:)\"\n\n\t| len pn c pos newSize |\n\tlen _ page dataSize.\n\tnewSize _ size. \"this may change at end of page\"\n\tsize = len\n\t\tifTrue:\n\t\t\t[\"page size\"\n\t\t\tpn _ objpos + 1.\n\t\t\tc _ 0]\n\t\tifFalse:\n\t\t\t[pos _ objpos.\n\t\t\tsize = 1 ifFalse: [len \\\\ size = 0\n\t\t\t\t\tifTrue: [\"page length is a multiple of size\"\n\t\t\t\t\t\tlen _ len // size]\n\t\t\t\t\tifFalse:\n\t\t\t\t\t\t[pos _ objpos * size.\n\t\t\t\t\t\tnewSize _ 1]].\n\t\t\t\"obtain quotient (page) and remainder (position)\"\n\t\t\tpn _ 1 + (pos // len).\n\t\t\tc _ newSize * (pos \\\\ len)].\n\t(self positionPage: pn character: c) ifTrue: [^objpos].\n\tself error: 'cannot read page ' , pn printString\n",
          "shorten": "shorten\n\t\"normally called by close and not directly by user\"\n\n\tpage dataEnd: (readLimit _ position).\n\tpage fromFileStream: self.\n\tself on: page endFile.\n\tposition _ readLimit\n",
          "fixEnd": "fixEnd\n\t(self writing and: [position > page dataEnd])\n\t\tifTrue: [\"fix the end of page\" page dataEnd: (readLimit _ position)]\n",
          "positionPage:character:": "positionPage: pn character: c\n\t\"normally accessed by position:size:, skip:\"\n\n\t(self read: pn) notNil\n\t\tifTrue:\n\t\t\t[\"c assumed between 0 and page dataSize.\n\t\t\tposition, readLimit were set in on:\"\n\t\t\tposition _ position + c.\n\t\t\t(position <= readLimit or: [self writing])\n\t\t\t\tifTrue: [^true]\n\t\t\t\tifFalse:\n\t\t\t\t\t[position _ readLimit.\n\t\t\t\t\t^false]]\n\t\tifFalse: [c = 0\n\t\t\t\tifTrue: [\"try end of previous page\"\n\t\t\t\t\t^self positionPage: pn - 1 character: page dataSize]\n\t\t\t\tifFalse: [^false]]\n"
        },
        "nonhomogeneous accessing": {
          "nextPage": "nextPage\n\t\"Answer the receiver as a FileStream on the next page or nil if there is no next page.\"\n\t^self read: page pageNumber + 1\n",
          "read:": "read: pageNumber\n\t\"The receiver is formatted into pages.  Access the information on page\n\tpageNumber.  Normally called by pastEnd, position:size:, reopen, reset, setToEnd.\n\tAnswer nil if the pageNumber does not exist in the receiver.  Else answer\n\tthe receiver as a FileStream on this new page.\"\n\n\t| p |\n\tpageNumber < 1 ifTrue: [^nil].\n\tclosed\n\t\tifTrue:\n\t\t\t[\"reopen the file, (re)read the page\"\n\t\t\tpage reopen.\n\t\t\t(p _ page readPageNumber: pageNumber) isNil\n\t\t\t\tifTrue: [^nil]\n\t\t\t\tifFalse: [^self on: p]].\n\t(pageNumber = page pageNumber and: [page size > 0 or: [position > page dataBeginning]])\n\t\tifTrue:\n\t\t\t[self fixEnd.\n\t\t\tposition _ page dataBeginning.\n\t\t\t^self].\n\t\"current page has wrong page number or is empty (possibly from error)\"\n\tself writing\n\t\tifTrue:\n\t\t\t[((pageNumber > page pageNumber and: [page isFull == false])\n\t\t\t\tifTrue:\n\t\t\t\t\t[\"fill up last page when positioning past it\"\n\t\t\t\t\tposition _ page dataMaxEnd.\n\t\t\t\t\ttrue]\n\t\t\t\tifFalse: [\"otherwise, fixEnd\"\n\t\t\t\t\tposition > page dataEnd])\n\t\t\t\tifTrue: [page dataEnd: (readLimit _ position)].\n\t\t\t\"write current page\"\n\t\t\tpage fromFileStream: self.\n\t\t\tp _ page write.\n\t\t\tp pageNumber = pageNumber ifFalse: [\"read it or create it\"\n\t\t\t\tp _ page readOrAddPageNumber: pageNumber\"already have next page, e.g. at end of AltoFile\"]]\n\t\tifFalse: [p _ page readPageNumber: pageNumber].\n\tp isNil ifTrue: [^nil].\n\t(page _ p) asFileStream: self\n"
        },
        "file modes": {
          "readWrite": "readWrite\n\t\"Set the receiver's mode so that pages are flushed, end of file can be extended by\n\twriting, and closing does not truncate file.\"\n\tself setMode: Read + Write\n",
          "readWriteShorten": "readWriteShorten\n\t\"Same as readWrite except close truncates file at current position.\"\n\tself setMode: Read + Write + Shorten\n",
          "text": "text\n\t\"Set the receiver's file to be in text mode.\"\n\n\tself file text.\n\t\"fix up current page\"\n\tpage text.\n\tself on: page\n",
          "binary": "binary\n\t\"Set the receiver's file to be binary mode.\"\n\n\tself file binary.\n\t\"fix up current page\"\n\tpage binary.\n\tself on: page\n",
          "writeShorten": "writeShorten\n\t\"Allow write and shorten the receiver's file upon closing.\"\n\tself setMode: Write + Shorten\n",
          "readOnly": "readOnly\n\t\"Set the receiver's mode so that pages are not flushed and reading stops at\n\tend of file.\"\n\tself setMode: Read\n"
        }
      }
    },
    "ExternalStream": {
      "comment": "I represent an accessor for a sequence of objects that communicate to the outside world.  My instances can contain non-homogenous elements.  Assumes streaming on a collection of binary, byte-sized elements.  My methods assume that a \"word\" consists of two-bytes.\n",
      "class_name": "ExternalStream",
      "superclass": "ReadWriteStream",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t^self basicNew\n"
        }
      },
      "instance_methods": {
        "positioning": {
          "resetContents": "resetContents\n\t\"Reset pointers so that can restart reading the collection over which the receiver streams.\"\n\tposition _ 0.\n\treadLimit _ 0\n"
        },
        "nonhomogeneous positioning": {
          "wordPosition": "wordPosition\n\t\"Answer the current position in words.\"\n\t^self position / 2\n",
          "wordPosition:": "wordPosition: wp\n\t\"Set current position in words to be wp.\"\n\tself position: 2 * wp\n",
          "padToNextWord": "padToNextWord\n\t\"Make position even (on word boundary), answering the padding character if any.\"\n\n\tposition even\n\t\tifTrue: [^false]\n\t\tifFalse: [^self next]\n",
          "skipWords:": "skipWords: nWords\n\t\"Position after nWords number of words.\"\n\tself skip: 2 * nWords\n",
          "padTo:put:": "padTo: bsize put: aCharacter\n\t\"Pad using the argument, aCharacter, to the next boundary of bsize characters,\n\tand answer how many characters were written.\"\n\tself subclassResponsibility\n",
          "padToNextWordPut:": "padToNextWordPut: char\n\t\"Make position even on word boundary, writing the padding character, char, if necessary.  Answer nil if already on a word boundary\"\n\n\tposition even\n\t\tifTrue: [^nil]\n\t\tifFalse: [^self nextPut: char]\n",
          "padTo:": "padTo: bsize\n\t\"Pad (skip) to next boundary of bsize characters, and answer how many characters\n\twere skipped.\"\n\tself subclassResponsibility\n"
        },
        "accessing": {
          "next:": "next: anInteger\n\t\"Answer the next anInteger elements of my collection.  Must override\n\tbecause default uses self contents species, which might involve a Large\n\tcollection. \"\n\n\t| newArray |\n\tnewArray _ collection species new: anInteger.\n\t1 to: anInteger do: [:index | newArray at: index put: self next].\n\t^newArray\n"
        },
        "nonhomogeneous accessing": {
          "nextWordPut:": "nextWordPut: aWord\n\t\"Append to the receiver an Integer as the next two bytes.\"\n\n\tself nextPut: ((aWord bitShift: -8) bitAnd: 255).\n\tself nextPut: (aWord bitAnd: 255).\n\t^aWord\n",
          "nextWord": "nextWord\n\t\"Answer the next two bytes from the receiver as an Integer.\"\n\n\t| high low |\n\thigh _ self next.\n\t\thigh==nil ifTrue: [^false].\n\tlow _ self next.\n\t\tlow==nil ifTrue: [^false].\n\t^(high asInteger bitShift: 8) + low asInteger\n",
          "nextSignedInteger": "nextSignedInteger\n\t\"Answer the next two bytes from the receiver as a signed Integer.\"\n\n\t| returnValue |\n\tself atEnd ifTrue: [^false].\n\treturnValue _ self next asInteger.\n\tself atEnd ifTrue: [^false].\n\t(returnValue _ returnValue * 256 + self next asInteger) highBit = 16\n\t\tifTrue:\t[^returnValue - 65536\t\"16-bit negative 0\"]\n\t\tifFalse:\t[^returnValue].\n",
          "nextStringPut:": "nextStringPut: s\n\t\"Append the string, s, to the receiver.\"\n\n\t| length |\n\t(length _ s size) < 192\n\t\tifTrue: [self nextPut: length]\n\t\tifFalse:\n\t\t\t[self nextPut: (length // 256 + 192).\n\t\t\tself nextPut: (length \\\\ 256)].\n\ts do: [:char | self nextPut: char asciiValue].\n\t^s\n",
          "nextNumber:": "nextNumber: n\n\t\"Answer the next n bytes as a positive Integer or LargePositiveInteger.\"\n\n\t| s |\n\tn <= 2\n\t\tifTrue:\n\t\t\t[s _ 0.\n\t\t\tn timesRepeat: [s _ s * 256 + self next].\n\t\t\t^s].\n\ts _ LargePositiveInteger new: n.\n\t1 to: n do: [:i | s at: n + 1 - i put: self next].\n\t\"reverse order of significance\"\n\t^s truncated\n",
          "nextString": "nextString\n\t\"Read a string from the receiver. The first byte is the length of the string, unless it\n\tis greater than 192, in which case the first two bytes encode the length.\"\n\n\t| aString char length|\n\tlength _ self next.\t\t\"first byte.\"\n\tlength >= 192 ifTrue: [length _ (length - 192) * 256 + self next].\n\taString _ String new: length.\n\t1 to: length do: [:i | aString at: i put: self next asCharacter].\n\t^aString\n",
          "nextNumber:put:": "nextNumber: n put: v\n\t\"Append to the receiver the argument, v, which is a positive SmallInteger or\n\ta LargePositiveInteger, as the next n bytes.  Possibly pad with leading zeros.\"\n\n\t| vlen i |\n\tvlen _ v digitLength.\n\tn < vlen\n\t\tifTrue: [self error: 'number too big']\n\t\tifFalse: [n > vlen ifTrue: [self next: n - vlen put: 0]].\n\t\"pad beginning with 0's\"\n\tvlen = 1\n\t\tifTrue: [self nextPut: v]\n\t\tifFalse: [(vlen = 2 and: [v isMemberOf: SmallInteger])\n\t\t\t\tifTrue: [self nextWordPut: v]\n\t\t\t\tifFalse: [\"LargeInteger (assume pos, no negative convention)\"\n\t\t\t\t\t1 to: vlen do: [:i | self nextPut: (v at: vlen + 1 - i)]]]\n"
        }
      }
    }
  },
  "Files-Xerox Alto": {
    "AltoFileDirectory": {
      "comment": "A concrete example of a FileDirectory class.  Implements the Xerox Alto File System.  See the Alto Operating System Reference Manual section about Disks.\n\nNote that the Alto file address format is\n\tbits\n\t0-3\t\tsector number\t(0 - 8r15, i.e., 12 or 14 sectors)\n\t4-12\tcylinder number (0 - 8r312, Model 31; 0-8r625, Model 44)\n\t13\t\thead number (0-1)\n\t14\t\tdisk number (0-1)\n\t15\t\trestore bit.\n\nInstance Variables:\n\tdirFile\t\t<File> or nil\n\tbitsFile\t\t<File> or nil\n\tdiskPages\t<Integer>\n\ttotalPages\t<Integer>\n\tnSectors\t\t<Integer>\n",
      "class_name": "AltoFileDirectory",
      "superclass": "FileDirectory",
      "instanceVariables": "dirFile bitsFile diskPages totalPages nSectors",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "AltoFilePool",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t^self directory: 0 directoryName: 0\n",
          "directory:directoryName:": "directory: aFileDirectory directoryName: aString\n\t\"Answer an instance of me in directory aFileDirectory whose name is aString.\"\n\n\t^super new setDirectory: aFileDirectory directoryName: aString\n"
        }
      },
      "instance_methods": {
        "file accessing": {
          "filesMatching:": "filesMatching: pattern\n\t^super filesMatching:\n\t\t(pattern last = $.\n\t\t\tifTrue: [pattern]\n\t\t\tifFalse: [pattern , '.'])\n",
          "checkName:": "checkName: aString\n\t\"Answer whether aString is a valid file name.\"\n\t^self checkName: aString fixErrors: false\n",
          "checkName:fixErrors:": "checkName: fname fixErrors: fixing\n\t\"Check file name for correct length and characters.\"\n\n\t| char len i newName special period |\n\tfname isEmpty\n\t\tifTrue: [fixing ifTrue: [^'$'].\n\t\t\t\t self error: 'empty file name'].\n\n\tspecial _ '.-+$!?'.\n\tperiod _ $..\n\tlen _ fname size.\n\n\t(len > 39 or: [len = 39 and: [(fname at: len) ~= period]])\n\t\tifTrue: [fixing ifTrue: [\"truncate name\" len _ 38]\n\t\tifFalse: [self error: 'name too long']].\n\n\tnewName _ WriteStream on: (String new: len + 1).\n\t1 to: len do: [:i |\n\t\tchar _ fname at: i.\n\t\t\"check characters: alphanumeric or 6 special\"\n\t\t(char isLetter or: [(special includes: char) or: [char isDigit]])\n\t\t \tifTrue: [newName nextPut: char]\n\t\t \tifFalse: [\n\t\t\t\tfixing ifTrue: [newName nextPut: $-]\n\t\t\t\t\tifFalse: [self error: ('illegal character ' copyWith: char)]]].\n\n\t\"make sure last character is period (isn't period when fixing)\"\n\t(fname at: len) = period\n\t\tifTrue: [fixing ifTrue: [newName skip: -1]]\n\t\tifFalse: [fixing ifFalse: [newName nextPut: period]].\n\n\t^newName contents\n",
          "rename:newName:": "rename: aFile newName: newFileName\n\t| holesize pos newFile newName file |\n\t(self findFileOrHole: (newFile _ self initFileName: newFileName))\n\t\t  ifTrue: [^newFile error: 'rename: new name already exists'].\n\n\tnewName _ newFile fileName.\n\t\"a possible insertion place\"\n\tpos _ dirFile position.\n\n\t(self findFileOrHole: (file _ self initFile: aFile))\n\t\tifFalse: [^file error: 'rename: old name does not exist'].\n\n\tholesize _ dirFile nextWord bitAnd: Dfmask - 1.\n\tdirFile skip: -2.\n\tfile fileName: newName.\n\t(self fileSize: file) \"new size of entry\" <= holesize\n\t  ifTrue:\n\t\t[\"new entry will fit in current entry\" \"read and save entry\"\n\t\tpos _ dirFile position.\n\t\tfile _ self next]\n\t  ifFalse: [\"delete and save entry\"\n\t\tfile _ self deleteEntry: file].\n\n\t\"position to same entry or hole discovered earlier\"\n\tdirFile position: pos.\n\tfile fileName: newName.\n\tself addEntry: file.\n\tfile readWrite: Write.\n\tfile writeTime isNil\n\t\tifTrue:\n\t\t\t[\"close file: updating name in leader page\"\n\t\t\tfile close]\n\t\"otherwise, file is open. defer leader page change until someone closes it\"\n",
          "checkNameOfFile:": "checkNameOfFile: aString\n\t\"Answer whether aString is a valid file name.\"\n\t^self checkNameOfFile: aString fixErrors: false\n",
          "fileClass": "fileClass\n\t^AltoFile\n"
        },
        "file status": {
          "flush": "flush\n\tbitsFile == nil ifFalse: [bitsFile flush]\n",
          "open": "open\n\t| f s a page len elen type |\n\tclosed\n\t  ifTrue:\n\t\t[\"assume some defaults in case DSHAPE is not in SysDir leader page.\n\tthese should only be needed if the disk is old (and not scavenged).\n\tthey will not work if a 14 sector system is missing DSHAPE (unlikely) since\n\taddresses of first page of SysDir and DiskDescriptor might be computed incorrectly\"\n\t\tnSectors _ 12.\n\t\tdiskPages _ 812 * nSectors.\n\t\ttotalPages _ 2 * diskPages.\n\n\t\t\"read SysDir leader page to find out file system configuration.  see AltoFileSys.D\".\n\t\tf _ self findKey: Dirname.\n\t\tf binary.\n\t\t\"to prevent address of page 1 from being stored\".\n\t\tf pageAddresses: nil.\n\t\tpage _ f readPageNumber: 0.\n\t\t\"length of property list, in words\"\n\t\tlen _ page at: 494.\n\t\tlen = 210\n\t\t  ifTrue:\n\t\t\t[\"scan file properties for DSHAPE\"\n\t\t\ts _ page asFileStream: ExternalStream new.\n\t\t\ts skipWords: (page at: 493).\n\t\t\t[len > 0] whileTrue:\n\t\t\t\t[type _ s next.\n\t\t\t\ttype = 0\n\t\t\t\t  ifTrue: [\n\t\t\t\t\t\"0 terminates list. property not found.\n\t\t\t\t\ttry to read it later from DiskDescriptor\"\n\t\t\t\t\tlen _ 0]\n\t\t\t\t  ifFalse:\n\t\t\t\t\t[elen _ s next.\n\t\t\t\t\t(type = 1 and: [elen = 5])\n\t\t\t\t\t  ifTrue:\n\t\t\t\t\t\t[\"DSHAPE. read property\"\n\t\t\t\t\t\tself configure: s.\n\t\t\t\t\t\t\"set flags so configure and loop are not done again\"\n\t\t\t\t\t\ts _ false.\n\t\t\t\t\t\tlen _ 0]\n\t\t\t\t\t  ifFalse:\n\t\t\t\t\t\t[\"skip over other property\"\n\t\t\t\t\t\tlen _ len - elen.\n\t\t\t\t\t\ts skipWords: elen - 1]]]].\n\n\t\t\"now, with the correct (or default) file system configuration,\n\t\tstore the virtual address of next page (1), and create a FileStream on SysDir\"\n\t\ta _ AltoFileAddressArray new directory: self.\n\t\ta addLast: (page headerWordAt: Nextp).\n\t\tf pageAddresses: a.\n\t\tdirFile _ f asFileStream.\n\t\tdirFile readOnly.\n\n\t\tbitsFile _ self oldFile: 'DiskDescriptor'.\n\t\tbitsFile binary.\n\t\tbitsFile readWrite.\n\t\tclosed _ false.\n\t\ts\n\t\t  ifTrue:\n\t\t\t[\"configuration not read from SysDir. this will work for 12 sector systems.\n\t\t\t14 sector systems should have had the DSHAPE property\"\n\t\t\tself configure: bitsFile].\n\t\tsuper open]\n",
          "close": "close\n\tclosed\n\t\tifFalse:\n\t\t\t[dirFile close.\n\t\t\tbitsFile == nil ifFalse: [\"an interrupted open?\" bitsFile close].\n\t\t\tsuper close]\n",
          "release": "release\n\tdirFile _ bitsFile _ nil.\n\tclosed _ true\n"
        },
        "accessing": {
          "next": "next\n\t^self nextFile: self fileClass new\n",
          "realToVirtual:": "realToVirtual: address\n\t\"Convert the argument, address, from a real address to a virtual address.\"\n\n\t^(( address bitShift: -12) bitAnd: 8r17) \"sector: field\"\n\t  + (nSectors * ((address bitAnd: 8r7774) bitShift: -2)) \"cylinder and head: field*\"\n\t  +  \"disk: field*pages per disk\"\n\t\t((address bitAnd: 2) = 2 \"diskPages*(address bitAnd: 2)//2\"\n\t\t  ifTrue: [diskPages]\n\t\t  ifFalse: [0])\n"
        },
        "private": {
          "virtualToReal:": "virtualToReal: vadr\n\t \"inverse of realToVirtual:\"\n\n\t| sec d |\n\tvadr < diskPages\n\t  ifTrue: [d _ 0. sec _ vadr] \"d _ (vadr // diskPages) bitShift: 1\"\n\t  ifFalse: [d _ 2. sec _ vadr \\\\ diskPages].\n\t^\"disk\" d +\n\t\"cylinder & head\" (sec // nSectors bitShift: 2) + \"(sec \\\\ nSectors) bitShift: 12\"\n\t\"sector\" (#(0 8r10000 8r20000 8r30000 8r40000 8r50000 8r60000 8r70000\n\t\t8r100000 8r110000 8r120000 8r130000 8r140000 8r150000 8r160000 8r170000)\n\t\tat: (sec \\\\ nSectors + 1))  \"Indexing is faster than LargeInteger arithmetic!\"\n",
          "nextFile:": "nextFile: aFile\n\t| w elen |\n\t[dirFile atEnd]\n\t\twhileFalse:\n\t\t\t[\"header word of directory\"\n\t\t\tw _ dirFile nextWord.\n\t\t\telen _ w bitAnd: Dfmask - 1.\n\t\t\t(w bitAnd: Dfmask) = Dfmask\n\t\t\t\tifTrue:\n\t\t\t\t\t[\"normal entry. create file instance\"\n\t\t\t\t\taFile directory: self.\n\t\t\t\t\taFile reinitialize.\n\t\t\t\t\t\"initialize from directory\"\n\t\t\t\t\taFile readFromDirectory: dirFile.\n\t\t\t\t\t\"skip to end of partially read entry\"\n\t\t\t\t\tdirFile skip: elen * 2 - (self fileSize: aFile).\n\t\t\t\t\t^aFile].\n\t\t\t\"deleted entry\"\n\t\t\tdirFile skipWords: elen - 1].\n\t^nil\n",
          "configure:": "configure: s\n\t\"read disk configuration from a Stream:\n\t\teither leader page of SysDir or beginning of DiskDescriptor\"\n\n\t| nDisks nHeads nTracks |\n\tnDisks _ s nextWord .\n\tnTracks _ s nextWord.\n\tnHeads _ s nextWord.\n\tnSectors _ s nextWord.\n\tdiskPages _ nTracks * nHeads * nSectors.\n\ttotalPages _ nDisks * diskPages\n",
          "diskID": "diskID\n\t\"return user name and disk name installed in O.S.\n\tlogin name is stored somewhere else???\"\n\n\t| f userName diskName len |\n\tf _ self oldFile: 'Sys.Boot'.\n\tf text.\n\tf readOnly.\n\tf position: 512.\n\tlen _ f next asciiValue.\n\tuserName _ f next: len.\n\tf padToNextWord.\n\tlen _ f next asciiValue.\n\tdiskName _ f next: len.\n\tf close.\n\t^Array with: userName with: diskName\n",
          "addEntry:": "addEntry: file\n\t \"called only by Insert: and rename:newName:\"\n\n\t| entrysize holesize |\n\tdirFile atEnd\n\t\tifTrue: [holesize _ nil]\n\t\tifFalse: [\n\t\t\t\"either a deleted entry or rename entry\"\n\t\t\tholesize _ dirFile nextWord bitAnd: Dfmask - 1.\n\t\t\tdirFile skip: -2].\n\n\tdirFile readWrite.\n\tentrysize _ (self fileSize: file) // 2.\n\tdirFile nextWordPut: Dfmask + entrysize.\n\tfile storeOnDirectory: dirFile.\n\n\t(holesize notNil and: [entrysize < holesize])\n\t  ifTrue: [\"mark remaining hole\" dirFile nextWordPut: holesize - entrysize].\n\tdirFile readOnly.\n\tbitsFile flush\n",
          "find:ifAbsentDo:": "find: aFile ifAbsentDo: aBlock\n\t| sn |\n\t(aFile fileName sameAs: Dirname)\n\t\tifTrue:\n\t\t\t[\"return system directory file. known serialNumber and leader\"\n\t\t\tsn _ ByteArray new: 4.\n\t\t\tsn wordAt: 1 put: 8r100000.\n\t\t\tsn wordAt: 2 put: 8r144.\n\t\t\taFile serialNumber: sn.\n\t\t\taFile leader: 8r10000 \"(self virtualToReal: 1)\".\n\t\t\t^aFile].\n\n\t\"^super find: aFile ifAbsent: aBlock\"\n\t(self findFileOrHole: aFile) ifFalse: [^aBlock value: aFile].\n\t^self nextFile: aFile\n",
          "deleteEntry:": "deleteEntry: file\n\t\"called only by Delete: and rename:newName:\n\tread and save\"\n\n\t| p nextFile |\n\tp _ dirFile position.\n\tnextFile _ self next.\n\tdirFile position: p.\n\n\t\"delete it from directory (turn off bit in entry length word)\"\n\tp _ dirFile nextWord bitAnd: Dfmask - 1.\n\tdirFile skip: -2.\n\tdirFile readWrite.\n\tdirFile nextWordPut: p.\n\tdirFile readOnly.\n\tdirFile skip: -2.\n\t^nextFile\n",
          "fileSize:": "fileSize: file\n\t\"return size in characters of a directory entry\n\n\tentry format\n\t\t1\tn (length in words, including this one) + undeleted bit (dfmask)\n\t\t2-3\tserialNumber\n\t\t4\tversion\n\t\t5\tfile number (0?)\n\t\t6\tvirtual address of page 0\n\t\t7-n name as Bcpl string (extra 0 if length even)\"\n\n\t^13 \"header word, sn, version, fn, leader, name\" + (file fileName size bitOr: 1)\n",
          "diskNumber": "diskNumber\n\t^directoryName\n",
          "findFileOrHole:": "findFileOrHole: t1\n\t| t2 t3 t4 t5 t6 t7 t8 t9 t10 |\n\tt2 _ self checkNameOfFile: t1.\n\tt1 fileName: t2.\n\tt8 _ t2 size.\n\tself reset.\n\tt5 _ nil.\n\tt6 _ Dfmask.\n\tt7 _ (self fileSize: t1) // 2.\n\t[dirFile atEnd]\n\t whileFalse: [t4 _ dirFile nextWord.\n\t\tt3 _ t4 bitAnd: Dfmask - 1.\n\t\tt7 > t3 ifTrue: [t9 _ -2]\n\t\t ifFalse: [t4 = t3\n\t\t\t ifTrue: [t9 _ -2.\n\t\t\t\tt3 < t6\n\t\t\t\t ifTrue: [t6 _ t3.\n\t\t\t\t\tt5 _ dirFile position]]\n\t\t\t ifFalse: [dirFile skip: 10.\n\t\t\t\tt9 _ -13.\n\t\t\t\tt8 = dirFile next\n\t\t\t\t ifTrue: [t10 _ 1.\n\t\t\t\t\t[t10 <= t8 and: [(t2 at: t10) asLowercase\n\t\t\t\t\t\t= dirFile next asCharacter asLowercase]]\n\t\t\t\t\t\t whileTrue: [t10 _ t10 + 1].\n\t\t\t\t\tt10 > t8\n\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t[dirFile skip: t9 - t8.\n\t\t\t\t\t\t\t^true].\n\t\t\t\t\tt9 _ t9 - t10]]].\n\t\tdirFile skip: t3 * 2 + t9].\n\tt5 notNil ifTrue: [dirFile position: t5 - 2].\n\t^false\n"
        },
        "enumerating": {
          "reset": "reset\n\tdirFile == nil\n\t\tifTrue: [self open]\n\t\tifFalse: [self flush].\n\tdirFile readOnly.\n\tdirFile reset\n"
        },
        "page accessing": {
          "deallocate:": "deallocate: page\n\t| index byte m |\n\tclosed ifTrue: [self open].\n\tindex _ self realToVirtual: page address.\n\t\"byte position\"\n\tbitsFile position: index // 8 + Boffset.\n\tbyte _ bitsFile next.\n\t\"bit position\"\n\tm _ 8r200 bitShift: 0 - (index bitAnd: 7).\n\n\t\"make page free by turning off bit in DiskDescriptor\"\n\t(byte bitAnd: m) = m\n\t  ifTrue:\n\t\t[bitsFile skip: -1.\n\t\tbitsFile nextPut: byte - m]\n\t  ifFalse:\n\t\t[Transcript cr. Transcript show: 'page already free (deallocate:)']\n",
          "freePages": "freePages\n\t| npages byte |\n\tself open.\n\tbitsFile position: Boffset.\n\tnpages _ 0.\n\t1 to: totalPages by: 8 do:\n\t\t[:i | (byte _ bitsFile next) = 255\n\t\t  ifFalse:\n\t\t\t[\"possibly up to 8 unused\"\n\t\t\tnpages _ npages + 8.\n\t\t\t[byte = 0] whileFalse:\n\t\t\t\t[npages _ npages - (byte bitAnd: 1).\n\t\t\t\tbyte _ byte bitShift: -1]\n\t\t\t\"all used\"]].\n\t^npages\n",
          "allocate:after:": "allocate: nextPage after: address\n\t| index stop ch m vadr oldCursor |\n\tindex _ nil.\n\t[true] whileTrue:\n\t\t[\"go around bittable from address to end, and beginning to address.\n\t\twe start over again if the table appears full or bitsFile is out of sync\"\n\t\t(index notNil and: [stop >= totalPages])\n\t\t  ifTrue:\n\t\t\t[\"wrap around to where we started\"\n\t\t\tstop _ address.\n\t\t\tindex _ 0]\n\t\t  ifFalse:\n\t\t\t[index isNil\n\t\t\t  ifFalse: [\"disk probably full\"\n\t\t\t\tSmalltalk releaseExternalViews.\n\t\t\t\tself error: 'YOUR DISK IS FULL (abort or make space and proceed)'].\n\n\t\t\tself open.\n\t\t\t\"index by bits rather than bytes? close enough for now\"\n\t\t\tindex _ address bitAnd: 8r177770.\n\t\t\tstop _ totalPages].\n\n\t\tbitsFile position: index // 8 + Boffset.\n\t\t[index notNil and: [(index _ index + 8) <= stop]] whileTrue:\n\t\t\t[(ch _ bitsFile next) = 8r377\n\t\t\t  ifFalse:\n\t\t\t\t[\"check that bitsFile position is correct --\n\t\t\t\tpossibly out of sync with index if  growSmalltalkBy: occurred?\"\n\t\t\t\tbitsFile position ~= (index // 8 + Boffset)\n\t\t\t\t  ifTrue: [index _ nil]\n\t\t\t\t  ifFalse:\n\t\t\t\t\t[m _ 8r200.\n\t\t\t\t\tindex - 8 to: index - 1 do:\n\t\t\t\t\t\t[:vadr | (ch bitAnd: m) = 0\n\t\t\t\t\t\t  ifTrue:\n\t\t\t\t\t\t\t[\"page appears free. first update DiskDescriptor\"\n\t\t\t\t\t\t\tbitsFile skip: -1.\n\t\t\t\t\t\t\tbitsFile nextPut: (ch _ ch bitOr: m).\n\n\t\t\t\t\t\t\t\"then check if page is really free\"\n\t\t\t\t\t\t\tvadr = 0\n\t\t\t\t\t\t\t  ifFalse: \"O.S. boot\"\n\t\t\t\t\t\t\t\t[nextPage reinitialize.\n\t\t\t\t\t\t\t\tnextPage freePage.\n\t\t\t\t\t\t\t\tnextPage address: (self virtualToReal: vadr).\n\t\t\t\t\t\t\t\t(nextPage doCommand: CCR error: nil) notNil\n\t\t\t\t\t\t\t\t  ifTrue: [oldCursor notNil ifTrue: [oldCursor show].\n\t\t\t\t\t\t\t\t\t\t^vadr]\n\t\t\t\t\t\t\t\t  ifFalse: \"otherwise, page not really free\"\n\t\t\t\t\t\t\t\t\t[oldCursor isNil ifTrue:\n\t\t\t\t\t\t\t\t\t\t[oldCursor _ Cursor currentCursor.\n\t\t\t\t\t\t\t\t\t\tCursor wait show. \"this may take a while\"]]]].\n\n\t\t\t\t\t\t\"page not free according to bit\"\n\t\t\t\t\t\tm _ m bitShift: -1]]]]]\n",
          "allocateSN:": "allocateSN: file\n\t| sn i |\n\t\"get last serial number used, a ByteArray\"\n\tbitsFile position: 8.\n\tsn _ bitsFile next: 4.\n\n\t\"Add 1 to 4-byte SN, handling overflow\"\n\ti _ 4.\n\t[(sn at: i) = 255] whileTrue:\n\t\t[sn at: i put: 0.  i _ i-1].\n\tsn at: i put: ((sn at: i) + 1).\n\n\t\"store new serial number, and return it\"\n\tbitsFile skip: -4.\n\tbitsFile nextPutAll: sn.\n\t^sn\n"
        },
        "adding": {
          "addNew:": "addNew: aFile\n\t| sn page |\n\tsn _ self allocateSN: aFile.\n\taFile serialNumber: sn.\n\n\t\"allocate a new page (more success after O.S. stuff, bittable etc.)\"\n\tself allocate: (page _ aFile initPageNumber: 0) after: 800.\n\n\t\"write 0th -- leader, in the process filling it in and then creating first page\".\n\tpage reinitialize.\n\tpage serialNumber: sn.\n\tpage size: page dataSize.\n\taFile leader: page address.\n\taFile readWrite: Write.\n\taFile updateLeader: page.\n\tself addEntry: aFile.\n\t^aFile\n"
        },
        "removing": {
          "removeOld:": "removeOld: file\n\t| aFile |\n\taFile _ self deleteEntry: file.\n\taFile open.\n\taFile endFile: nil.\n\tbitsFile flush\n",
          "remove:ifAbsentDo:": "remove: aFile ifAbsentDo: aBlock\n\t(self findFileOrHole: aFile) ifFalse: [^aBlock value: aFile].\n\tself removeOld: aFile\n"
        }
      }
    },
    "AltoFilePage": {
      "comment": "A FilePage from an AltoFile consists of an address (2 words), a label (8 words) and data (512 bytes).  The instance variable \"page\" is a ByteArray which contains first the label and then the data.\n",
      "class_name": "AltoFilePage",
      "superclass": "FilePage",
      "instanceVariables": "address",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "AltoFilePool",
      "instance_methods": {
        "file status": {
          "reinitialize": "reinitialize\n\tpage == nil\n\t\tifTrue: [super reinitialize]\n\t\tifFalse: [\"nextp, backp, lnused, numch, pn\"\n\t\t\t\tpage atAll: (1 to: 10) put: 0]\n"
        },
        "page testing": {
          "lastPage": "lastPage\n\t^(self headerWordAt: Nextp) = 0\n",
          "headerSize": "headerSize\n\t^16\n"
        },
        "accessing": {
          "size": "size\n\t^self headerWordAt: Numch\n"
        },
        "private": {
          "freePage": "freePage\n\tself headerWordAt: Sn1 put: -1.\n\tself headerWordAt: Sn2 put: -1.\n\tself headerWordAt: Vn put: -1\n",
          "label": "label\n\t^page\n"
        },
        "page accessing": {
          "serialNumber:": "serialNumber: sn\n\tself headerWordAt: Sn1 put: (sn wordAt: 1).\n\tself headerWordAt: Sn2 put: (sn wordAt: 2).\n\tself headerWordAt: Vn put: 1  \"fixed version\"\n",
          "address:": "address: addressNumber\n\taddress _ addressNumber\n",
          "pageNumber": "pageNumber\n\t^self headerWordAt: Pagen\n",
          "address": "address\n\t^address\n",
          "serialNumber": "serialNumber\n\t^self label copyFrom: Sn1 * 2 - 1 to: Sn2 * 2\n",
          "pageNumber:": "pageNumber: pn\n\tself headerWordAt: Pagen put: pn\n"
        },
        "file/page/directory implementation": {
          "size:": "size: size\n\tself headerWordAt: Numch put: size\n"
        }
      }
    },
    "AltoFileAddressArray": {
      "comment": "I am a RunArray where each run represents the virtual addresses of a block of contiguous pages.  Indexed by page numbers, my instance holds the virtual disk addresses of the pages.  Attributes inherited from RunArray are:  runs, an array of starting indicies;  and values, an array of the first virtual address in each block.\n\nInstance Variables:\n\tdirectory\t<FileDirectory>\n",
      "class_name": "AltoFileAddressArray",
      "superclass": "RunArray",
      "instanceVariables": "directory",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "accessing": {
          "at:": "at: index\n\t| run offset value |\n\tsuper at: index setRunOffsetAndValue:\n\t\t[:run :offset :value | ^directory virtualToReal: value + offset]\n"
        },
        "initialize-release": {
          "shortenTo:": "shortenTo: newSize\n\t\"Shortens the receiver to be size, newSize (for file shorten).  Create an\n\terror if newSize is greater than the old size.\"\n\n\t| oldSize short |\n\toldSize _ self size.\n\tnewSize > oldSize ifTrue: [^self error: 'invalid extension'].\n\tnewSize < oldSize\n\t\tifTrue:\n\t\t\t[short _ self copyFrom: 1 to: newSize.\n\t\t\truns _ short runs.\n\t\t\tvalues _ short values]\n",
          "directory:": "directory: aDirectory\n\t\"Set the receiver's directory to be the argument, aDirectory.\"\n\tdirectory _ aDirectory\n"
        },
        "adding": {
          "addLast:": "addLast: val\n\t| virt |\n\tvirt _ directory realToVirtual: val.\n\t(runs size = 0 or: [virt ~= ((values at: values size) + (runs at: runs size))])\n\t\tifTrue: [super addLast: virt] \"create new run\"\n\t\tifFalse: [runs at: runs size put: (runs at: runs size) + 1]. \"stretch last run\"\n\t^val\n"
        }
      }
    },
    "AltoFile": {
      "comment": "A concrete example of class File.\n\nInstance Variables:\n\twriteTime\t<Time>\n\tpageAddresses\t<RunArray> of page addresses\n\tleader\t\t<Integer> address of the page where the leader information is stored\n",
      "class_name": "AltoFile",
      "superclass": "File",
      "instanceVariables": "writeTime pageAddresses leader",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "AltoFilePool",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t| readStream |\n\tAltoFilePool at: #(CRR CCR CCW CWW ) put: #(18496 18512 18520 18536 ).\n\treadStream _ ReadStream on: #(1024 32 'SysDir.' ).\n\t#(Dfmask Boffset Dirname ) do:\n\t\t [:each | AltoFilePool at: each put: readStream next].\n\treadStream _ ReadStream on: #(1 2 3 4 5 6 7 8 ).\n\t#(Nextp Backp Unused Numch Pagen Vn Sn1 Sn2 ) do:\n\t\t[:each | AltoFilePool at: each put: readStream next]\n"
        }
      },
      "instance_methods": {
        "file accessing": {
          "endFile:": "endFile: aPage\n\t| page nextPage pn |\n\tpage _ aPage.\n\tpage isNil\n\t  ifTrue: [pn _ -1 \"free all of file\"]\n\t  ifFalse:\n\t\t[page isFull\n\t\t  ifTrue:\n\t\t\t[nextPage _ self write: page.\n\t\t\t\"if page was a full last page, next is an empty (and now last) page\"\n\t\t\tnextPage lastPage ifTrue: [^nextPage].\n\t\t\tpage _ self readPageNumber: page pageNumber + 1.\n\t\t\tpage isEmpty ifTrue: [^page].\n\t\t\tpage size: 0].\n\t\tpage headerWordAt: Nextp put: 0.\n\t\tself write: page.\n\t\t\"free rest of file\"\n\t\tpn _ page pageNumber].\n\n\tlastPageNumber _ nil \"reset by read:\".\n\t[lastPageNumber isNil and: [\n\t\t(nextPage _ self readPageNumber: (pn _ pn + 1)) notNil]] whileTrue:\n\t\t[nextPage reinitialize.\n\t\tnextPage freePage.\n\t\tnextPage doCommand: CWW error: 'endFile:'.\n\t\tfileDirectory deallocate: nextPage].\n\n\tpage notNil\n\t  ifTrue: [pageAddresses shortenTo: (lastPageNumber _ page pageNumber)].\n\t^page\n",
          "beSnapshotFile": "beSnapshotFile\n\t^self\n\t\tbeSnapshotSerialNumber: (self serialNumber)\n\t\tleaderVirtualDiskAddr: (fileDirectory realToVirtual: self leader)\n"
        },
        "file status": {
          "open": "open\n\t\"don't find last page immediately.  for later close\"\n\n\treadWrite _ Read\n",
          "reinitialize": "reinitialize\n\tsuper reinitialize.\n\tpageAddresses _ AltoFileAddressArray new directory: fileDirectory\n",
          "close": "close\n\t\"fix up leader page, and remember create time\"\n\n\tself updateLeader: (self readPageNumber: 0)\n",
          "release": "release\n"
        },
        "private": {
          "storeOnDirectory:": "storeOnDirectory: aFileStream\n\taFileStream nextPutAll: serialNumber.\n\taFileStream nextWordPut: 1.\n\taFileStream nextWordPut: 0.\n\taFileStream nextWordPut: (fileDirectory realToVirtual: leader).\n\taFileStream nextPut: fileName size.\n\tfileName do: [:char | aFileStream nextPut: char asciiValue].\n\taFileStream padToNextWordPut: 0\n",
          "updateLeader:": "updateLeader: page\n\t\"see <Alto>AltoFileSys.D, (p.3 leader page) for further info\"\n\n\t| aFileStream time lastwrite |\n\tpage binary.\n\taFileStream _ page asFileStream: ExternalStream new.\n\ttime _ Time timeWords.\n\t(readWrite bitAnd: Write) = Write\n\t\tifTrue:\n\t\t\t[fileDirectory flush.\n\t\t\t\"set creation/write/read date and file name\"\n\t\t\twriteTime _ time.\n\t\t\taFileStream nextPutAll: time.\n\t\t\taFileStream nextPutAll: time.\n\t\t\taFileStream nextPutAll: time.\n\t\t\tfileName isEmpty\n\t\t\t\tifFalse:\n\t\t\t\t\t[aFileStream nextPut: fileName size.\n\t\t\t\t\tfileName do: [:char | aFileStream nextPut: char asciiValue]]]\n\t\tifFalse:\n\t\t\t[\"skip creation, remember write, update read date\"\n\t\t\taFileStream skip: 4.\n\t\t\twriteTime _ aFileStream next: 4.\n\t\t\taFileStream nextPutAll: time].\n\tpage fromFileStream: aFileStream.\n\tself write: page\n",
          "dskprim:address:command:page:semaphore:": "dskprim: diskNumber address: diskAddress command: diskCommand page: buffer semaphore: aSemaphore\n\t\"Transfer a single record (page) to or from the Alto File System.  Fail if\n\tinteger arguments are not 16-bit positive Integers.  Fail if a disk transfer\n\t is already in progress.  Fail if the buffer is not large enough or is\n\tpointer containing.  Fail if the last argument is not a Semaphore.  Xerox\n\tspecific primitive.  See Object documentation what IsAPrimitive.\n\n\tdiskNumber is 0 or 1,\n\tdiskAddress is the starting Alto disk address (Integer),\n\tdiskCommand is the disk command (usually CCR, CCW, CWW)\n\t(Integer), buffer is the string containing label and data,\n\taSemaphore is signalled when the transfer completes.\n\tIf disk primitive encounters an error, the receiver's instance variable\n\tnamed error is set to the DCB status.  This Integer is greater than 0 and\n\tis\n\tinterpreted by errorString:.  Normally error is set to 0.\"\n\n\t<primitive: 128>\n\terror _ -1\n\t\"set error when the primitive fails\"\n",
          "pageClass": "pageClass\n\t^AltoFilePage\n",
          "beSnapshotSerialNumber:leaderVirtualDiskAddr:": "beSnapshotSerialNumber: aByteArray leaderVirtualDiskAddr: anInteger\n\t<primitive: 135>\n\tself primitiveFailed\n",
          "leader:": "leader: pageAddress\n\tleader _ pageAddress\n",
          "sameAsStoredFile": "sameAsStoredFile\n\t| page s tname |\n\tpage _ self initPageNumber: 0.\n\tpage binary.\n\tpage address: leader.\n\t\"if any of the following tests fail, File will be reinitialized\"\n\t(((page doCommand: CCR error: nil) notNil and: [page pageNumber = 0])\n\t\tand: [s _ page asFileStream: ExternalStream new.\n\t\t\ts skip: 4.\n\t\t\twriteTime = (s next: 4)\n\t\t\t\tand:\n\t\t\t\t\t[s skip: 4.\n\t\t\t\t\ttname _ String new: s next.\n\t\t\t\t\t1 to: tname size do: [:i | tname at: i put: s next asCharacter].\n\t\t\t\t\tfileName sameAs: tname]])\n\t\tifTrue:\n\t\t\t[(lastPageNumber notNil and: [pageAddresses notNil])\n\t\t\t\tifTrue:\n\t\t\t\t\t[page pageNumber: lastPageNumber.\n\t\t\t\t\tpage address: (pageAddresses at: lastPageNumber).\n\t\t\t\t\t(page doCommand: CCR error: nil) isNil\n\t\t\t\t\t\tifTrue: [\"wrong file or page number\" ^false].\n\t\t\t\t\tpage lastPage ifFalse: [\"not last page anymore\"\n\t\t\t\t\t\tlastPageNumber _ nil].\n\t\t\t\t\t^true].\n\t\t\t^true].\n\t^false\n",
          "leader": "leader\n\t^leader\n",
          "writeTime": "writeTime\n\t^writeTime\n",
          "pageAddresses:": "pageAddresses: anArrayOrNil\n\tpageAddresses _ anArrayOrNil\n",
          "readFromDirectory:": "readFromDirectory: aFileStream\n\t\"read file description from SysDir\"\n\n\tserialNumber _ aFileStream next: 4.\n\taFileStream skip: 4.\n\tleader _ fileDirectory virtualToReal: aFileStream nextWord.\n\tfileName _ String new: aFileStream next.\n\t1 to: fileName size do: [:i | fileName at: i put: aFileStream next asCharacter].\n\taFileStream padToNextWord\n",
          "findLastPageNumber": "findLastPageNumber\n\tself readPageNumber: 20000.\n\t^lastPageNumber\n"
        },
        "nonhomogeneous accessing": {
          "readOrAdd:": "readOrAdd: aPage\n\t| page p pn |\n\tpage _ aPage.\n\tpn _ page pageNumber.\n\t(self read: page) notNil ifTrue: [^page].\n\t\"page now contains last page\"\n\t(lastPageNumber to: pn - 1) do:\n\t\t[:p |\n\t\tpage pageNumber: p.\n\t\tpage size: page dataSize.\n\t\t\"this writes current and allocates next (empty) page\"\n\t\tpage _ self write: page].\n\t^page\n",
          "read:": "read: page\n\t| pn p fp palen oldCursor |\n\tpn _ page pageNumber.\n\tpageAddresses isNil\n\t  ifTrue:\n\t\t[pn = 0 ifTrue: [palen _ 0] ifFalse: [^nil]]\n\t  ifFalse:\n\t\t[palen _ pageAddresses size].\n\n\tfp _ palen min: pn.\n\t\"set address of first page. next addresses are set later\"\n\tpage address: (fp = 0\n\t\t\t\t\tifTrue: [leader]\n\t\t\t\t\tifFalse: [pageAddresses at: fp]).\n\n\toldCursor _ Cursor currentCursor.\n\tpn-fp > 10 ifTrue: [Cursor wait show]. \"this may take a while...\"\n\n\tfp to: pn do:\n\t\t[:p | \"set up page for checking\"\n\t\tpage pageNumber: p.\n\t\t\"set by machine code:\n\t\t\tpage headerWordAt: Nextp put:\n\t\t\t\t(p < palen ifTrue: [pageAddresses at: (p+1)] ifFalse: [0]).\n\t\t\tpage headerWordAt: backp put:\n\t\t\t\t(p=0 ifTrue: [0] ifFalse: [p=1 ifTrue: [leader]\n\t\t\t\t\tifFalse: [pageAddresses at: (p-1)]]).\n\t\t\tpage size: (p < palen ifTrue: [page dataSize] ifFalse: [0]).\"\n\n\t\tpage doCommand: CCR error: 'read:'.\n\n\t\tpage lastPage\n\t\t  ifTrue:\n\t\t\t[lastPageNumber _ p.\n\t\t\tp < pn\n\t\t\t\tifTrue: [oldCursor show. ^nil]\n\t\t\t\tifFalse: [oldCursor show. ^page]].\n\n\t\t(pageAddresses ~~ nil and: [p >= palen])\n\t\t\tifTrue: [\"save address of next page if there is a page address table\n\t\t\t\tand address not already stored\"\n\t\t\t\tpageAddresses addLast: (page headerWordAt: Nextp)].\n\t\tp < pn\n\t\t\tifTrue: [\"set address of next page\"\n\t\t\t\tpage address: (page headerWordAt: Nextp)]].\n\toldCursor show.\n\t^page\n",
          "write:": "write: page\n\t| nextPage labelDirty returnPage |\n\t((labelDirty _ page lastPage) and: [page isFull])\n\t  ifTrue:\n\t\t[\"last page can't be full, so glue on another page\"\n\t\treturnPage _ nextPage _ self initPageNumber: 0.\n\t\tfileDirectory allocate: nextPage after: (fileDirectory realToVirtual: page address).\n\t\tnextPage reinitialize.\n\t\tnextPage headerWordAt: Backp put: page address.\n\t\tnextPage pageNumber: (lastPageNumber _ page pageNumber + 1).\n\t\tnextPage serialNumber: serialNumber.\n\t\tnextPage doCommand: CWW error: 'write: (allocate)'.\n\t\t\"link to current page\"\n\t\tpage headerWordAt: Nextp put: nextPage address.\n\t\tpageAddresses ~~ nil\n\t\t  ifTrue: [pageAddresses addLast: nextPage address]]\n\t  \t  ifFalse: [returnPage _ page].\n\n\t\"whenever a last (or second last) page is written, write label also\"\n\tself doCommand: (labelDirty\n\t  \t\t\t\t\tifTrue: [CWW]\n\t  \t\t\t\t\tifFalse: [CCW]) page: page error: 'write:'.\n\treadWrite _ Read + Write.\n\t^returnPage\n"
        },
        "error handling": {
          "errorString:": "errorString: status\n\t\"see Alto hardware manual for details on error word format\"\n\n\t| s |\n\tstatus = -1 ifTrue: [^'primitive failure, bad args?'].\n\ts _ WriteStream on: (String new: 50).\n\ts nextPutAll: (#('' 'hardware error or sector overflow' 'check error'\n\t\t\t\t\t 'disk command specified illegal sector' ) at: 1 + (status bitAnd: 3)).\n\t1 to: 6 do: [:t | (status allMask: (128 bitShift: 1 - t))\n\t\t\tifTrue:\n\t\t\t\t[s nextPut: $ .\n\t\t\t\ts nextPutAll: (#('seek failed, possible illegal track' 'seek in progress'\n\t\t\t\t\t\t\t\t'disk unit not ready' 'hardware late'\n\t\t\t\t\t\t\t\t 'hardware not transferring' 'checksum' ) at: t)]].\n\ts nextPut: $ .\n\ts nextPutAll: (status storeStringRadix: 8).\n\t^s contents\n"
        },
        "file/page/directory implementation": {
          "doCommand:page:error:": "doCommand: command page: filePage error: e\n\t| done |\n\tdone _ Semaphore new.\n\tself dskprim: fileDirectory diskNumber\n\t\taddress: filePage address\n\t\tcommand: command\n\t\tpage: filePage page\n\t\tsemaphore: done.\n\terror<0 ifFalse: [done wait].\n\terror ~= 0\n\t\tifTrue:\n\t\t\t[e isNil ifTrue: [^nil].\n\t\t\terror _ self errorString: error.\n\t\t\tself error: e]\n\t\tifFalse:\n\t\t\t[error _ ''.\n\t\t\t^filePage]\n"
        }
      }
    }
  },
  "Graphics-Display Objects": {
    "Form": {
      "comment": "This class is a rectangular pattern of dots represented as a Smalltalk Bitmap.\n",
      "class_name": "Form",
      "superclass": "DisplayMedium",
      "instanceVariables": "bits width height offset",
      "classInstanceVariables": "whiteMask darkGrayMask grayMask blackMask lightGrayMask veryLightGrayMask",
      "classVariables": "OneBitForm",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initializeMasks": "initializeMasks\n\t| anArray |\n\tanArray _ Array new: 16.\n\tanArray atAllPut: 0.\n\twhiteMask _ Form extent: 16 @ 16 fromArray: anArray offset: 0 @ 0.\n\tanArray atAllPut: 65535.\n\tblackMask _ Form extent: 16 @ 16 fromArray: anArray offset: 0 @ 0.\n\tanArray atAll: (1 to: anArray size by: 2) put: 21845.\n\tanArray atAll: (2 to: anArray size by: 2) put: 43690.\n\tgrayMask _ Form extent: 16 @ 16 fromArray: anArray offset: 0 @ 0.\n\tanArray atAll: (1 to: anArray size by: 2) put: 30583.\n\tanArray atAll: (2 to: anArray size by: 2) put: 56797.\n\tdarkGrayMask _ Form extent: 16 @ 16 fromArray: anArray offset: 0 @ 0.\n\tlightGrayMask _ darkGrayMask deepCopy reverse.\n\tanArray atAll: (1 to: anArray size by: 4) put: 34952.\n\tanArray atAll: (2 to: anArray size by: 2) put: 0.\n\tanArray atAll: (3 to: anArray size by: 4) put: 8738.\n\tveryLightGrayMask _  Form extent: 16 @ 16 fromArray: anArray offset: 0 @ 0\n\n\t\"Form initializeMasks\"\n",
          "initialize": "initialize\n\n\tself initializeMasks.\n\tOneBitForm _ Form new extent: 1 @ 1\n\n\t\"Form  initialize.\"\n"
        },
        "mask constants": {
          "darkGray": "darkGray\n\t\"Answer the form denoting dark gray mask.\"\n\t^darkGrayMask\n",
          "lightGray": "lightGray\n\t\"Answer the form denoting light gray mask.\"\n\t^lightGrayMask\n",
          "gray": "gray\n\t\"Answer the form denoting gray mask.\"\n\t^grayMask\n",
          "black": "black\n\t\"Answer the form denoting black mask.\"\n\t^blackMask\n",
          "veryLightGray": "veryLightGray\n\t\"Answer the form denoting very light gray mask.\"\n\t^veryLightGrayMask\n",
          "white": "white\n\t\"Answer the form denoting white mask.\"\n\t^whiteMask\n"
        },
        "instance creation": {
          "dotOfSize:": "dotOfSize: diameter\n\t\"Create a form which contains a round black dot.\"\n\n\t| radius form bite circle |\n\tradius _ diameter//2.\n\tform _ Form new extent: diameter@diameter offset: (0@0) - (radius@radius).\n\tdiameter <= 9 ifTrue: \"special case for speed\"\n\t\t[form black.\n\t\tdiameter <= 2 ifTrue: [^form].\n\t\tbite _ diameter//3.\n\t\tform white: (0@0 extent: bite@1).\n\t\tform white: (0@(diameter-1) extent: bite@1).\n\t\tform white: (diameter-bite@0 extent: bite@1).\n\t\tform white: (diameter-bite@(diameter-1) extent: bite@1).\n\t\tform white: (0@0 extent: 1@bite).\n\t\tform white: (0@(diameter-bite) extent: 1@bite).\n\t\tform white: (diameter-1@0 extent: 1@bite).\n\t\tform white: (diameter-1@(diameter-bite) extent: 1@bite).\n\t\t^form].\n\n\tradius _ diameter-1//2.  \"so circle fits entirely\"\n\t(Circle new center: radius@radius radius: radius) displayOn: form.\n\tform convexShapeFill: Form black.\t\"fill the circle with black\"\n\t^form\n\n\t\"(Form dotOfSize: 8) displayAt: Sensor cursorPoint\"\n",
          "fromDisplay:": "fromDisplay: aRectangle\n\t\"Answer an instance of me with bitmap initialized from the area of\n\tthe display screen defined by aRectangle.\"\n\t^self new fromDisplay: aRectangle\n",
          "extent:": "extent: extentPoint\n\t\"Answer an instance of me with blank bitmap.\"\n\t^self basicNew\n\t\tsetExtent: extentPoint\n\t\tfromArray: Array new\n\t\tsetOffset: 0@0\n",
          "fromUser": "fromUser\n\t\"Answer an instance of me with bitmap initialized from the area of\n\tthe display screen designated by the user.  The grid for selecting an area\n\tis 1@1.\"\n\t^self fromUser: 1 @ 1\n",
          "extent:fromCompactArray:offset:": "extent: extentPoint fromCompactArray: anArray offset: offsetPoint\n\t\"Answer an instance of me with bitmap initialized from anArray.\"\n\t^self basicNew\n\t\tsetExtent: extentPoint\n\t\tfromCompactArray: anArray\n\t\tsetOffset: offsetPoint\n",
          "stringScanLineOfWidth:": "stringScanLineOfWidth: width\n\t^self new extent: width@1 offset: 0@0 bits: (String new: width+15//16*2)\n",
          "readFrom:": "readFrom: fileName\n\t\"Answer an instance of me with bitmap initialized from the external file named fileName.\"\n\n\t| file code |\n\tfile _ FileStream oldFileNamed: fileName.\n\tfile readOnly; binary.\n\tcode _ file nextWord.\t\"reads fileCode\"\n\tcode = 1 ifTrue: [^self readFormFile: file].\n\tfile close.\n\t^nil\n",
          "readFormFile:": "readFormFile: file\n\t\"Answer an instance of me with bitmap initialized from the external file.  The file format is:  fileCode(1), extent, offset, bits.\"\n\n\t| newForm newWidth newHeight theBits filePosition offsetX offsetY |\n\tfile readOnly; binary.\n\tfile nextWord = 1 ifFalse: [^(Form new extent: 8 @ 8) black].\t\"reads fileCode\"\n\tnewForm _ self new.\n\tnewWidth _ file nextWord.\n\tnewHeight _ file nextWord.\n\tnewForm extent: newWidth @ newHeight.\n\toffsetX  _ file nextWord.\n\toffsetY _ file nextWord.\n\toffsetX > 32767 ifTrue: [offsetX _ offsetX - 65536]. \"stored two's-complement\"\n\toffsetY > 32767 ifTrue: [offsetY _ offsetY - 65536]. \"stored two's-complement\"\n\tnewForm offset: offsetX @ offsetY.\n\ttheBits _ WordArray new: newWidth + 15 // 16 * newHeight.\n\tfilePosition _ 0.\n\t1 to: newWidth + 15 // 16 do:\n\t\t[:j |\n\t\t1 to: newHeight do:\n\t\t\t[:i | theBits at: (filePosition _ filePosition + 1) put: file nextWord]].\n\tnewForm bits: theBits.\n\tfile close.\n\t^newForm\n",
          "extent:fromArray:offset:": "extent: extentPoint fromArray: anArray offset: offsetPoint\n\t\"Answer an instance of me with bitmap initialized from anArray.\"\n\t^self basicNew\n\t\tsetExtent: extentPoint\n\t\tfromArray: anArray\n\t\tsetOffset: offsetPoint\n",
          "fromUser:": "fromUser: aPoint\n\t\"Answer an instance of me with bitmap initialized from the area of\n\tthe display screen designated by the user.  The grid for selecting an area\n\tis aPoint.\"\n\t| aRectangle |\n\taRectangle _ Rectangle fromUser: aPoint.\n\t^self new fromDisplay: aRectangle\n"
        },
        "examples": {
          "exampleSpaceFill": "exampleSpaceFill\n\t\"This example demonstrates the area filling algorithm.\n\tThe example starts by having the user sketch on the screen and then select\n\ta rectangular area of the screen which includes all off the area to be filled.\n\tFinally, (with crosshair cursor), the user points as the interior of the region\n\tto be filled, and the filling begins with that place as its seed\"\n\n\t| f r interiorPoint |\n\tForm exampleSketch.\t\t\"sketch a little area with an enclosed region\"\n\tr _ Rectangle fromUser.\n\tf _ Form fromDisplay: r.\n\tCursor crossHair showWhile:\n\t\t[interiorPoint _ Sensor waitButton - r origin].\n\tCursor execute showWhile:\n\t\t[f shapeFill: Form gray interiorPoint: interiorPoint].\n\tf displayOn: Display at: r origin\n\n\t\"Form exampleSpaceFill.\"\n",
          "exampleShrink": "exampleShrink\n\t[Sensor redButtonPressed] whileFalse:\n\t\t[((Form fromDisplay: (Sensor cursorPoint extent: 150@150))\n\t\t\tshrinkBy: 3 @ 3)\n\t\t\t\tdisplayAt: 0 @ 0]\n\n\t\"Form exampleShrink.\"\n",
          "exampleSketch": "exampleSketch\n\t\"This is a simple drawing algorithm to get a sketch on the display screen.  After\n\texecuting, just keep the mouse button depressed and a pen will let you\n\tscribble.\"\n\n\t| aPen |\n\taPen _ Pen new.\n\tSensor waitButton.\n\taPen place: Sensor cursorPoint.\n\taPen down.\n\t[Sensor anyButtonPressed]\n\t\twhileTrue: [aPen goto: Sensor cursorPoint]\n\n\t\"Form exampleSketch.\"\n",
          "exampleMagnify": "exampleMagnify\n\t[Sensor redButtonPressed] whileFalse:\n\t\t[((Form fromDisplay: (Sensor cursorPoint extent: 50@50))\n\t\t\tmagnifyBy: 3 @ 3)\n\t\t\t\tdisplayAt: 0 @ 0]\n\n\t\"Form exampleMagnify.\"\n",
          "exampleEdits": "exampleEdits\n\t\"In Form category editing are messages edit and bitEdit that make it possible to\n\tcreate editors on instances of Form.\n\n\tThis is the general form editor--\n\n\t|f|\n\tf _ Form fromUser.\n\tf edit.\n\n\tand the bit editor\n\t|f |\n\tf _ Form fromUser.\n\tf bitEdit.\n\n\t\"\n"
        },
        "mode constants": {
          "erase": "erase\n\t\"Answer the integer denoting mode erase.\"\n\t^4\n",
          "and": "and\n\t\"Answer the integer denoting the logical 'and' combination rule.\"\n\t^1\n",
          "over": "over\n\t\"Answer the integer denoting mode over.\"\n\t^3\n",
          "under": "under\n\t\"Answer the integer denoting mode under.\"\n\t^7\n",
          "reverse": "reverse\n\t\"Answer the integer denoting mode reverse.\"\n\t^6\n",
          "paint": "paint\n\t\"Answer the integer denoting the 'paint' combination rule.\"\n\t^16\n"
        }
      },
      "instance_methods": {
        "image manipulation": {
          "shapeFill:interiorPoint:": "shapeFill: aMask interiorPoint: interiorPoint\n\t\"Fill the interior of some outlined region according to mask and rule.\n\tInteriorPoint marks a location in the interior or the region.  A mark is\n\tplaced at this point as a seed, then the seed is smeared into a blob\n\tuntil there is no change in the blob when it fills the region.\n\tUses the upper left corner of the display screen for computing the blob\"\n\n\t| dirs smearForm previousSmear all cycle noChange |\n\tall _ self boundingBox.\n\tsmearForm _ Form extent: self extent.\n\tsmearForm valueAt: interiorPoint put: 1.\t\t\"Place a seed in the interior\"\n\tpreviousSmear _ smearForm deepCopy.\n\tdirs _ Array with: 1@0 with: -1@0 with: 0@1 with: 0@-1.\n\tcycle _ 0.\n\t[(cycle _ cycle+1) \\\\ 10 = 0 and:   \"check for no change every 10 smears\"\n\t\t[previousSmear copy: all from: 0@0 in: smearForm rule: Form reverse.\n\t\tnoChange _ previousSmear isAllWhite.\n\t\tpreviousSmear copy: all from: 0@0 in: smearForm rule: Form over.\n\t\tnoChange]]\n\t\twhileFalse:\n\t\t\t[dirs do:\n\t\t\t\t[:dir |    \"smear in each of the four directions\"\n\t\t\t\tsmearForm copy: all from: dir in: smearForm rule: Form under.\n\t\t\t\t\"After each smear, trim around the region border\"\n\t\t\t\tsmearForm copy: all from: 0@0 in: self rule: Form erase]].\n\t\"Now paint the filled region in me with aMask\"\n\tsmearForm displayOn: self at: 0@0 clippingBox: self boundingBox\n\t\trule: Form under mask: aMask\n",
          "convexShapeFill:": "convexShapeFill: aMask\n\t\"Fill the interior of the outtermost outlined region in the receiver.  The outlined region must not be concave by more than 90 degrees.\"\n\n\t| destForm tempForm skew |\n\tdestForm _ Form extent: self extent.\n\ttempForm _ Form extent: self extent.\n\tself displayOn: tempForm at: (0@0) - self offset.\n\tskew _ 1.\n\t[skew < width] whileTrue:\n\t\t[tempForm displayOn: tempForm at: skew@0\n\t\t\tclippingBox: tempForm boundingBox rule: Form under mask: nil.\n\t\tskew _ skew+skew].\n\ttempForm displayOn: destForm.\n\n\tself displayOn: tempForm at: (0@0) - self offset.\n\tskew _ 1.\n\t[skew < width] whileTrue:\n\t\t[tempForm displayOn: tempForm at: skew negated@0\n\t\t\tclippingBox: tempForm boundingBox rule: Form under mask: nil.\n\t\tskew _ skew+skew].\n\ttempForm displayOn: destForm at: 0@0\n\t\tclippingBox: destForm boundingBox rule: Form and mask: nil.\n\n\tself displayOn: tempForm at: (0@0) - self offset.\n\tskew _ 1.\n\t[skew < height] whileTrue:\n\t\t[tempForm displayOn: tempForm at: 0@skew\n\t\t\tclippingBox: tempForm boundingBox rule: Form under mask: nil.\n\t\tskew _ skew+skew].\n\ttempForm displayOn: destForm at: 0@0\n\t\tclippingBox: destForm boundingBox rule: Form and mask: nil.\n\n\tself displayOn: tempForm at: (0@0) - self offset.\n\tskew _ 1.\n\t[skew < height] whileTrue:\n\t\t[tempForm displayOn: tempForm at: 0@skew negated\n\t\t\tclippingBox: tempForm boundingBox rule: Form under mask: nil.\n\t\tskew _ skew+skew].\n\ttempForm displayOn: destForm at: 0@0\n\t\tclippingBox: destForm boundingBox rule: Form and mask: nil.\n\n\tdestForm displayOn: self at: 0@0\n\t\t\tclippingBox: self boundingBox rule: Form over mask: aMask\n",
          "spread:from:by:spacing:direction:": "spread: rectangle from: sourceForm by: scale spacing: spacing direction: dir\n\t| slice sourcePt |\n\tslice _ 0 @ 0 corner: dir transpose * self extent + dir.\n\tsourcePt _ rectangle origin.\n\t1 to: (rectangle extent dotProduct: dir) do:\n\t\t[:i |\n\t\t\"slice up original area\"\n\t\tself copy: slice\n\t\t\tfrom: sourcePt\n\t\t\tin: sourceForm\n\t\t\trule: 3.\n\t\tsourcePt _ sourcePt + dir.\n\t\tslice moveBy: dir * scale].\n\t1 to: scale - spacing - 1 do:\n\t\t[:i | \"smear out the slices, leave white space\"\n\t\tself copy: (dir corner: self extent)\n\t\t\tfrom: 0 @ 0\n\t\t\tin: self\n\t\t\trule: 7]\n",
          "rotate2:": "rotate2: direction\n\t\"Destructively rotate a square Form of dimension 2^N by 90 degrees.\n\t\tdirection = 1 for clockwise, -1 for counterclockwise\"\n\t| mask temp all quad delta |\n\tall _ self boundingBox.\n\tmask _ Form extent: self extent.\n\ttemp _ Form extent: self extent.\n\tmask white.   \"set up the first mask\"\n\tmask black: (0@0 extent: mask extent//2).\n\tquad_ self width // 2.\n\t[quad >= 1] whileTrue:\n\t\t[delta _ direction=1 ifTrue: [quad@0] ifFalse: [0@quad].\n\t\ttemp copy: all from: 0@0 in: mask rule: 3.  \"First exchange left and right halves\"\n\t\ttemp copy: (all translateBy: delta transpose) from: 0@0 in: mask rule: 7.\n\t\ttemp copy: all from: 0@0 in: self rule: 1.\n\t\tself copy: all from: 0@0 in: temp rule: 6.\n\t\ttemp copy: all from: delta in: self rule: 6.\n\t\tself copy: all from: delta in: self rule: 7.\n\t\tself copy: (all translateBy: delta) from: 0@0 in: temp rule: 6.\n\t\ttemp copy: all from: 0@0 in: self rule: 3.  \"then flip the diagonals\"\n\t\ttemp copy: all from: quad@quad in: self rule: 6.\n\t\ttemp copy: all from: 0@0 in: mask rule: 1.\n\t\tself copy: all from: 0@0 in: temp rule: 6.\n\t\tself copy: all from: quad negated@quad negated in: temp rule: 6.\n\t\tmask copy: all from: (quad//2)@(quad//2) in: mask rule: 1. \"Now refine the mask\"\n\t\tmask copy: all from: quad negated@0 in: mask rule: 7.\n\t\tmask copy: all from: 0@quad negated in: mask rule: 7.\n\t\tquad_ quad//2]\n\"\n [Sensor redButtonPressed] whileFalse:\n\t[((Form fromDisplay: (Rectangle new origin: Sensor cursorPoint extent: 128@128))\n\t\trotate2: 1)\n\t\t\tdisplayAt: 0@0].\n\"\n",
          "nextLifeGeneration": "nextLifeGeneration\n\t| nbr1 nbr2 nbr4 carry2 carry4 all delta |\n\tnbr1 _ Form extent: self extent.\n\tnbr2 _ Form extent: self extent.\n\tnbr4 _ Form extent: self extent.\n\tcarry2 _ Form extent: self extent.\n\tcarry4 _ Form extent: self extent.\n\tall _ self boundingBox.\n\t1 to: 8 do:\n\t\t[:i |\n\t\tdelta _   \"delta is the offset of the eight neighboring cells\"\n\t\t\t((#(-1 0 1 1 1 0 -1 -1) at: i) @ (#(-1 -1 -1 0 1 1 1 0) at: i)).\n\t\tcarry2 copy: all from: 0@0 in: nbr1 rule: 3.\n\t\tcarry2 copy: all from: delta in: self rule: 1.  \"AND for carry into 2\"\n\t\tnbr1 copy: all from: delta in: self rule: 6.    \"XOR for sum 1\"\n\t\tcarry4 copy: all from: 0@0 in: nbr2 rule: 3.\n\t\tcarry4 copy: all from: 0@0 in: carry2 rule: 1. \"AND for carry into 4\"\n\t\tnbr2 copy: all from: 0@0 in: carry2 rule: 6.   \"XOR for sum 2\"\n\t\tnbr4 copy: all from: 0@0 in: carry4 rule: 6].   \"XOR for sum 4 (ignore carry into 8)\"\n\tself copy: all from: 0@0 in: nbr2 rule: 1.\n\tnbr1 copy: all from: 0@0 in: nbr2 rule: 1.\n\tself copy: all from: 0@0 in: nbr1 rule: 7.\n\tself copy: all from: 0@0 in: nbr4 rule: 4 \"compute next generation\"\n\"\n BitEditor magnifyOnScreen.\n\t| life |\n\tlife _ Form fromUser.\n\t[Sensor redButtonPressed] whileFalse:\n\t\t[(life nextLifeGeneration magnifyBy: 8@8) displayAt: 0@0]\n\"\n",
          "copy:from:in:rule:": "copy: destRectangle from: sourcePt in: sourceForm rule: rule\n\t\"Make up a BitBlt table and copy the bits\"\n\n\t(BitBlt\n\t\tdestForm: self\n\t\tsourceForm: sourceForm\n\t\thalftoneForm: nil\n\t\tcombinationRule: rule\n\t\tdestOrigin: destRectangle origin\n\t\tsourceOrigin: sourcePt\n\t\textent: destRectangle extent\n\t\tclipRect: (0@0 extent: width@height)) copyBits\n\"\n [Sensor redButtonPressed] whileFalse:\n\t[Display copy: (30@30 extent: 300@300) from: Sensor cursorPoint in: Display rule: Form over].\n\"\n",
          "magnifyBy:": "magnifyBy: scale\n\t\"Answer a new form created as a multiple of the receiver; the new form\n\tis larger, each bit in the receiver being blown up to extent=scale\"\n\n\t| wideForm bigForm spacing |\n\tspacing _ 0 @ 0.\n\twideForm _ Form new extent: (width * scale x) @ height.\n\twideForm\n\t\tspread: self boundingBox\n\t\tfrom: self\n\t\tby: scale x\n\t\tspacing: spacing x\n\t\tdirection: 1 @ 0.\n\tbigForm _ Form new extent: self extent * scale.\n\tbigForm\n\t\tspread: wideForm boundingBox\n\t\tfrom: wideForm\n\t\tby: scale y\n\t\tspacing: spacing y\n\t\tdirection: 0 @ 1.\n\t^bigForm\n\n\t\"Check consistency of shrink and magnify:\n\t[Sensor redButtonPressed] whileFalse:\n\t\t[(((Form fromDisplay: (Sensor cursorPoint extent: 50@50))\n\t\t\tmagnifyBy: 3@5) shrinkBy: 3@5)\n\t\t\t\tdisplayAt: 100@100]\n\t\"\n",
          "shrinkBy:": "shrinkBy: scale\n\t\"Answer a scaled-down copy of the receiver.  Each bit in the new form is a\n\tsample taken from the upper-left bit of a rectangle of extent = scale in the\n\treceiver.  A more involved algorithm would count the bits in the rectangle\n\tand produce black only if more than half were black\"\n\n\t| wideForm shrunkenForm saveOffset |\n\tsaveOffset _ self offset.\n\tself offset: 0 @ 0.\n\twideForm _ Form new extent: self width @ (self height // scale y).\n\t0 to: wideForm height-1 do:\n\t\t[:index |\n\t\twideForm copy: (0 @ index extent: wideForm width @ 1)\n\t\t\tfrom: 0 @ (index * scale y)\n\t\t\tin: self\n\t\t\trule: Form over].\n\tshrunkenForm _ Form new extent: self width // scale x @ wideForm height.\n\t0 to: shrunkenForm width-1 do:\n\t\t[:index |\n\t\tshrunkenForm\n\t\t\tcopy: (index @ 0 extent: 1 @ wideForm height)\n\t\t\tfrom: (index * scale x) @ 0\n\t\t\tin: wideForm\n\t\t\trule: Form over].\n\tself offset: saveOffset.\n\tshrunkenForm offset: offset // scale.\n\t^shrunkenForm\n",
          "wrapAround:": "wrapAround: aPoint\n\t\"Answer a new form which contains the image of the receiver, but translated by deltaPoint, with wrap-around.  Used for realigning halftone masks.  Assumes the receiver is 16x16 with zero offset.\"\n\n\t| newForm delta |\n\tnewForm _ Form extent: width@height.\n\tdelta _ (aPoint x\\\\16)@(aPoint y\\\\16).\n\tdelta = (0@0) ifTrue: [^self].\n\tself displayOn: newForm at: delta-(16@16).\n\tself displayOn: newForm at: delta-(16@0).\n\tself displayOn: newForm at: delta-(0@16).\n\tself displayOn: newForm at: delta.\n\t^newForm\n\n\t\"[Sensor anyButtonPressed] whileFalse:\n\t\t[((Cursor normal wrapAround: Sensor cursorPoint)\n\t\t\tmagnifyBy: 8@8) displayAt: 100@100]\"\n",
          "reflect:": "reflect: spec\n\t\"spec = 0@1 for vertical reflection, 1@0 for horizontal\"\n\t| mask temp all newForm full half |\n\tall _ self boundingBox.\n\tmask _ Form extent: self extent.\n\ttemp _ Form extent: self extent.\n\tfull _ self extent*spec.\n\tmask black: (0@0 extent: self extent // (spec+1)).\n\tnewForm _ self deepCopy.\n\t[full x + full y > 1] whileTrue:\n\t\t[half _ full // 2.\n\t\ttemp copy: all from: 0@0 in: newForm rule: 3.\n\t\ttemp copy: all from: full-half in: newForm rule: 6.\n\t\ttemp copy: all from: 0@0 in: mask rule: 1.\n\t\tnewForm copy: all from: 0@0 in: temp rule: 6.\n\t\tnewForm copy: (all translateBy: full-half) from: 0@0 in: temp rule: 6.\n\t\t\"Now refine the mask\"\n\t\tmask copy: all from: half - (half//2) in: mask rule: 1.\n\t\tmask copy: (all translateBy: full-half) from: 0@0 in: mask rule: 7.\n\t\tfull _ half].\n\t^ newForm\n\"\n [Sensor redButtonPressed] whileFalse:\n\t[((Form fromDisplay: (Rectangle new origin: Sensor cursorPoint extent: 113@37)) reflect: 1@0)\n\t\tdisplayAt: 0@0].\n\"\n",
          "rotateBy:": "rotateBy: angle\n\t\"Answer a copied Form rotated clockwise by angle in units of 90 degrees.\n\tangle = 0 means unchanged, 1 means clockwise 90 degrees, etc\"\n\t| angle4 rotSize newForm rotForm all destPt sourcePt sourceDelta destDelta rotOrigin |\n\tangle4 _ angle \\\\ 4.\n\tangle = 0 ifTrue: [^self deepCopy].  \"null rotation\"\n\tangle = 2 ifTrue: [^(self reflect: 0@1) reflect: 1@0].  \"two reflections does 180 degrees\"\n\n\t\"Break the problem up into squares of size 2^N, and rotate them\"\n\trotSize _ (width min: height)   \"minimum rotation size\"\n\t\t\t\tmax: 64.  \"but faster if we do larger chunks\"\n\trotSize _ 2 raisedTo: ((rotSize-1) asFloat floorLog: 2)+1.  \"force up to a power of 2\"\n\tnewForm _ Form extent: self extent transpose.\n\trotForm _ Form extent: rotSize asPoint.\n\tall _ rotForm boundingBox.\n\tsourcePt _ 0@0.\n\twidth >= height\n\t\tifTrue:\n\t\t\t[sourceDelta _ rotSize@0.\n\t\t\tangle=1\n\t\t\t\tifTrue:\n\t\t\t\t\t[destPt _ 0@0.\n\t\t\t\t\tdestDelta _ sourceDelta transpose.\n\t\t\t\t\trotOrigin _ (rotSize-height)@0]\n\t\t\t\tifFalse:\n\t\t\t\t\t[destPt _ 0@(width-rotSize).\n\t\t\t\t\tdestDelta _ (0@0) - sourceDelta transpose.\n\t\t\t\t\trotOrigin _ 0@0]]\n\t\tifFalse:\n\t\t\t[sourceDelta _ 0@rotSize.\n\t\t\tangle=1\n\t\t\t\tifTrue:\n\t\t\t\t\t[destPt _ (height-rotSize)@0.\n\t\t\t\t\tdestDelta _ (0@0) - sourceDelta transpose.\n\t\t\t\t\trotOrigin _ 0@0]\n\t\t\t\tifFalse:\n\t\t\t\t\t[destPt _ 0@0.\n\t\t\t\t\tdestDelta _ sourceDelta transpose.\n\t\t\t\t\trotOrigin _ 0@(rotSize-width)]].\n\t(width max: height) - 1 // rotSize + 1 timesRepeat:\n\t\t[rotForm copy: all from: sourcePt in: self rule: 3.\n\t\trotForm rotate2: (angle=1 ifTrue: [1] ifFalse: [-1]).\n\t\tnewForm copy: (all translateBy: destPt) from: rotOrigin in: rotForm rule: 3.\n\t\tsourcePt _ sourcePt + sourceDelta.\n\t\tdestPt _ destPt + destDelta].\n\t^ newForm\n\"\n\t| f |\n\t[Sensor redButtonPressed] whileFalse:\n\t\t[f_ Form fromDisplay: (Sensor cursorPoint extent: 100@15).\n\t\t(f rotateBy: 0) displayAt: 100@100.\n\t\t(f rotateBy: 1) displayAt: 85@100.\n\t\t(f rotateBy: 2) displayAt: 0@85.\n\t\t(f rotateBy: 3) displayAt: 100@0]\n\"\n"
        },
        "bordering": {
          "borderWidth:mask:": "borderWidth: anInteger mask: aMask\n\t\"Set the width of the border for the receiver to be anInteger and paint it\n\tusing aMask as the border color.\"\n\n\tself border: self boundingBox width: anInteger mask: aMask\n",
          "borderWidth:": "borderWidth: anInteger\n\t\"Set the width of the border for the receiver to be anInteger and paint it\n\tusing Form black as the border color.\"\n\n\tself border: self boundingBox width: anInteger mask: Form black\n"
        },
        "fileIn/Out": {
          "writeOn:": "writeOn: fileName\n\t\"Saves the receiver on the file fileName in the format--fileCode, extent, offset, bits.\"\n\n\t| file fileCode filePosition |\n\tfileCode _ 1.\n\t\"This indicates that the instance is a Form.  Should probably be changed\n\twhen better methods for permanent storage are devised.\"\n\tfile _ FileStream fileNamed: fileName.\n\tfile binary.\n\tfile nextWordPut: fileCode.\n\tfile nextWordPut: width.\n\tfile nextWordPut: height.\n\tfile nextWordPut: offset x.\n\tfile nextWordPut: offset y.\n\tfilePosition _ 0.\n\t1 to: width + 15 // 16 do:\n\t\t[:j |\n\t\t1 to: height do: [:i | file nextWordPut: (bits at: (filePosition _ filePosition + 1))]].\n\tfile close.\n"
        },
        "printing": {
          "storeOn:base:": "storeOn: aStream base: anInteger\n\t\"Store the receiver out in the form:  Form newExtent:fromArray:#()offset:\"\n\n\taStream nextPut: $(.\n\taStream nextPutAll: self species name.\n\taStream crtab: 1.\n\taStream nextPutAll: 'extent: '.\n\tself extent printOn: aStream.\n\taStream crtab: 1.\n\taStream nextPutAll: 'fromArray: #('.\n\t1 to: self bits size do:\n\t\t[:index |\n\t\tanInteger = 10\n\t\t\tifTrue: [aStream space]\n\t\t\tifFalse: [aStream crtab: 2; nextPutAll: anInteger printString; nextPut: $r].\n\t\t(self bits at: index) printOn: aStream base: anInteger].\n\taStream nextPut: $).\n\taStream crtab: 1.\n\taStream nextPutAll: 'offset: '.\n\tself offset printOn: aStream.\n\taStream nextPut: $)\n",
          "scanLineStringAt:": "scanLineStringAt: y\n\t| form |\n\tform _ Form stringScanLineOfWidth: width.\n\tform copy: form boundingBox from: 0@y in: self rule: Form over.\n \t^ form bits\n",
          "storeOn:": "storeOn: aStream\n\t\"Store the receiver out in the form:  Form extent:fromCompactArray:#()offset:\"\n\t| stripe bitsWidth word |\n\taStream nextPut: $(; nextPutAll: self species name; crtab: 1.\n\taStream nextPutAll: 'extent: '; print: self extent; crtab: 1.\n\taStream nextPutAll: 'fromCompactArray: #('.\n\t1 to: height do:\n\t\t[:i |\n\t\tstripe _ self scanLineStringAt: i-1.\n\t\tstripe oldRunEncoded storeOn: aStream.\n\t\taStream cr].\n\taStream nextPut: $); crtab: 1.\n\taStream nextPutAll: 'offset: '; print: self offset; nextPut: $)\n\"\n | s | s_ WriteStream on: (String new: 2000).\nForm fromUser storeOn: s.\n(Compiler evaluate: s contents) displayAt: 0@0.\n\n | f | f_ Disk file: 'screen.form'.\nDisplay storeOn: f.\nf close. f size\n\"\n"
        },
        "displaying": {
          "displayOn:transformation:clippingBox:align:with:rule:mask:": "displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle align: alignmentPoint with: relativePoint rule: ruleInteger mask: aForm\n\t\"Graphically, it means nothing to scale a Form by floating point values.\n\tBecause scales and other display parameters are kept in floating point to\n\tminimize round off errors, we are forced in this routine to round off to the\n\tnearest integer.\"\n\n\t| absolutePoint scale magnifiedForm |\n\tabsolutePoint _ displayTransformation applyTo: relativePoint.\n\tabsolutePoint _ absolutePoint x truncated @ absolutePoint y truncated.\n\tdisplayTransformation noScale\n\t\tifTrue: [magnifiedForm _ self]\n\t\tifFalse:\n\t\t\t[scale _ displayTransformation scale.\n\t\t\tscale _ scale x rounded @ scale y rounded.\n\t\t\t(1@1 = scale)\n\t\t\t\t\tifTrue: [scale _ nil. magnifiedForm _ self]\n\t\t\t\t\tifFalse: [magnifiedForm _ self magnifyBy: scale]].\n\tmagnifiedForm\n\t\tdisplayOn: aDisplayMedium\n\t\tat: absolutePoint - alignmentPoint\n\t\tclippingBox: clipRectangle\n\t\trule: ruleInteger\n\t\tmask: aForm\n",
          "drawLine:from:to:clippingBox:rule:mask:": "drawLine: sourceForm from: beginPoint to: endPoint clippingBox: clipRect rule: anInteger mask: aForm\n\n\t| dotSetter |\n\t\"set up an instance of BitBlt for display\"\n\tdotSetter _ BitBlt\n\t\tdestForm: self\n\t\tsourceForm: sourceForm\n\t\thalftoneForm: aForm\n\t\tcombinationRule: anInteger\n\t\tdestOrigin: beginPoint\n\t\tsourceOrigin: 0 @ 0\n\t\textent: sourceForm extent\n\t\tclipRect: clipRect.\n\tdotSetter drawFrom: beginPoint to: endPoint\n",
          "displayOn:at:clippingBox:rule:mask:": "displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger mask: aForm\n\taDisplayMedium copyBits: self boundingBox\n\t\tfrom: self\n\t\tat: aDisplayPoint + offset\n\t\tclippingBox: clipRectangle\n\t\trule: ruleInteger\n\t\tmask: aForm\n",
          "copyBits:from:at:clippingBox:rule:mask:": "copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule mask: aForm\n\t\"Make up a BitBlt table and copy the bits.\"\n\n\t(BitBlt\n\t\tdestForm: self\n\t\tsourceForm: sourceForm\n\t\thalftoneForm: aForm\n\t\tcombinationRule: rule\n\t\tdestOrigin: destOrigin\n\t\tsourceOrigin: sourceRect origin\n\t\textent: sourceRect extent\n\t\tclipRect: clipRect) copyBits\n"
        },
        "copying": {
          "deepCopy": "deepCopy\n\t| newForm |\n\tnewForm _ self shallowCopy.\n\tnewForm bits: (WordArray new: self size).\n\tnewForm copyBits: self boundingBox\n\t\tfrom: self\n\t\tat: 0 @ 0\n\t\tclippingBox: newForm boundingBox\n\t\trule: Form over\n\t\tmask: Form black.\n\t^newForm\n"
        },
        "editing": {
          "bitEditAt:": "bitEditAt: magnifiedLocation\n\t\"Create and schedule a view whose top left corner is magnifiedLocation and\n\tthat contains a view of the receiver magnified by 8@8 that can be modified\n\tusing the Bit Editor.  It also contains a view of the original form.\"\n\n\tBitEditor openOnForm: self at: magnifiedLocation\n",
          "bitEdit": "bitEdit\n\t\"Create and schedule a view located in an area designated by the user that\n\tcontains a view of the receiver magnified by 8@8 that can be modified\n\tusing the Bit Editor.  It also contains a view of the original form.\"\n\n\tBitEditor openOnForm: self\n\n\t\"Note that using direct messages to BitEditor, fixed locations and scales can be created.\t \tThat is, also try\n\t\tBitEditor openOnForm: self at: <some point>.\n\t\tBitEditor openOnForm: self at: <some point> scale: <some point>.\"\n",
          "editAt:": "editAt: originPoint\n\t\"Start up an instance of the FormEditor on this form in an area whose\n\ttop left corrner is originPoint. Typically the form is not visible on the\n\tscreen. The editor menu is located at the bottom of the form editing\n\tframe. The form is displayed centered in the frame. YellowBugMenu\n\taccept is used to modify the form to reflect the changes made on the\n\tscreen version; cancel restores the original form to the screen. Note that\n\tthe changes are clipped to the original size of the form.\"\n\n\tFormEditor openOnForm: self at: originPoint\n",
          "bitEditAt:scale:": "bitEditAt: magnifiedFormLocation scale: scaleFactor\n\t\"Create and schedule a view whose top left corner is magnifiedLocation and\n\tthat contains a view of the receiver magnified by scaleFactor that can be modified\n\tusing the Bit Editor.  It also contains a view of the original form.\"\n\n\tBitEditor openOnForm: self at: magnifiedFormLocation scale: scaleFactor\n",
          "edit": "edit\n\t\"Start up an instance of the FormEditor on this form. Typically the form\n\tis not visible on the screen. The editor menu is located at the bottom of\n\tthe form editing frame. The form is displayed centered in the frame.\n\tYellowButtonMenu accept is used to modify the form to reflect the\n\tchanges made on the screen version; cancel restores the original form to\n\tthe screen. Note that the changes are clipped to the original size of the\n\tform.\"\n\n\tFormEditor openOnForm: self\n"
        },
        "accessing": {
          "extent:offset:bits:": "extent: extent offset: aPoint bits: aBitmap\n\t\"Create a virtual bit map with width = (extent x) and height = (extent y)\n\twith the bits = aBitmap.\"\n\n\twidth _ extent x.\n\theight _ extent y.\n\toffset _ aPoint.\n\tbits _ aBitmap\n",
          "extent:": "extent: aPoint\n\t\"Create a virtual bit map with width = (extent x) and height = (extent y)\n\twith the bits all zeros (white).  The extent is guaranteed to be zero or a positive\n\tsize.\"\n\n\t| nonZeroExtent extentSize |\n\tnonZeroExtent _\n\t\taPoint >= (0 @ 0)\n\t\t\tifTrue: [aPoint]\n\t\t\tifFalse: [0 @ 0].\n\textentSize _ nonZeroExtent y * (nonZeroExtent x + 15 // 16).\n\tself extent: nonZeroExtent\n\t\toffset: 0 @ 0\n\t\tbits: (WordArray new: (extentSize min: WordArray maxSize))\n",
          "extent:offset:": "extent: extentPoint offset: offsetPoint\n\t\"Create a virtual bit map with width = (extent x) and height = (extent y)\n\twith the bits all zeros (white).\"\n\n\t| normalizedPoint |\n\tnormalizedPoint _ extentPoint >= (0 @ 0)\n\t\t\t\tifTrue: [extentPoint]\n\t\t\t\tifFalse: [0 @ 0].\n\tself extent: normalizedPoint\n\t\toffset: offsetPoint\n\t\tbits: (WordArray new: normalizedPoint y * (normalizedPoint x + 15 // 16))\n",
          "offset:": "offset: aPoint\n\toffset _ aPoint\n",
          "size": "size\n\t\"Answer the number of bits in the receiver's bitmap.\"\n\t^bits size\n",
          "offset": "offset\n\toffset == nil\n\t\tifTrue: [^0 @ 0]\n\t\tifFalse: [^offset]\n"
        },
        "private": {
          "setExtent:fromArray:setOffset:": "setExtent: extentPoint fromArray: anArray setOffset: offsetPoint\n\twidth _ extentPoint x.\n\theight _ extentPoint y.\n\toffset _ offsetPoint.\n\tbits _ WordArray new: width + 15 // 16 * height.\n\t1 to: anArray size do:\n\t\t[:index | bits at: index put: (anArray at: index)]\n",
          "setExtent:fromCompactArray:setOffset:": "setExtent: extentPoint fromCompactArray: anArray setOffset: offsetPoint\n\t| stripe index |\n\twidth _ extentPoint x.\n\theight _ extentPoint y.\n\toffset _ offsetPoint.\n\tbits _ WordArray new: width + 15 // 16 * height.\n\tstripe _ Form stringScanLineOfWidth: width.\n\t1 to: anArray size do:\n\t\t[:index |\n\t\t(anArray at: index) oldRunDecodeOn: (WriteStream on: stripe bits).\n\t\tself copy: (0@(index-1) extent: width@1) from: 0@0 in: stripe rule: Form over].\n",
          "isAllWhite": "isAllWhite\n\t| count |\n\tcount _ bits countBits.\n\tcount = 0 ifTrue: [^true].\n\tcount > 0 ifTrue: [^false].\n\tbits do: [:data | data ~= 0 ifTrue: [^false]].\n\t^true\n"
        },
        "initialize-release": {
          "fromDisplay:": "fromDisplay: aRectangle\n\t\"Create a virtual bit map from a user specified rectangular area on the\n\tdisplay screen. Reallocates bitmap only if aRectangle ~= the receiver's extent.\"\n\n\t(width = aRectangle width and: [height = aRectangle height])\n\t\tifFalse: [self extent: aRectangle extent].\n\tself\n\t\tcopyBits: (aRectangle origin extent: self extent)\n\t\tfrom: Display\n\t\tat: 0 @ 0\n\t\tclippingBox: Display boundingBox\n\t\trule: Form over\n\t\tmask: Form black\n"
        },
        "display box access": {
          "computeBoundingBox": "computeBoundingBox\n\t^0 @ 0 extent: width @ height\n"
        },
        "pattern": {
          "bits:": "bits: aBitmap\n\t\"Reset the Bitmap containing the receiver's bits.\"\n\n\tbits _ aBitmap\n",
          "bits": "bits\n\t\"Answer the receiver's Bitmap containing its bits.\"\n\t^bits\n",
          "valueAt:": "valueAt: aPoint\n\t\"Query whether a bit is on or off.... answer with 1 if the color at coordinate aPoint\n\tis black in the receiver and 0 if the color is white at coordinate aPoint\"\n\n\tOneBitForm copyBits: (aPoint extent: 1 @ 1)\n\t\tfrom: self\n\t\tat: 0 @ 0\n\t\tclippingBox: self boundingBox\n\t\trule: Form over\n\t\tmask: Form black.\n\t(OneBitForm bits at: 1) = 0\n\t\tifTrue: [^0]\n\t\tifFalse: [^1]\n",
          "valueAt:put:": "valueAt: aPoint put: maskCode\n\t\"Set the bit in the receiver at coordinate aPoint to be white (0) or black (1).\"\n\n\n\tmaskCode = 0\n\t  ifTrue: [OneBitForm white] \t\"OneBitForm is a class variable.\"\n\t  ifFalse: [OneBitForm black].\n\tself\n\t  copyBits: OneBitForm boundingBox\n\t  from: OneBitForm\n\t  at: aPoint\n\t  clippingBox: self boundingBox\n\t  rule: Form over\n\t  mask: Form black.\n"
        },
        "coloring": {
          "fill:rule:mask:": "fill: aRectangle rule: anInteger mask: aForm\n\t\"Replace a rectangular area of the receiver with the pattern described by aForm\n\taccording to the rule anInteger.\"\n\n\t\"Make up a BitBlt table and copy the bits\"\n\t(BitBlt\n\t\tdestForm: self\n\t\tsourceForm: nil\n\t\thalftoneForm: aForm\n\t\tcombinationRule: anInteger\n\t\tdestOrigin: aRectangle origin\n\t\tsourceOrigin: self boundingBox origin\n\t\textent: aRectangle extent\n\t\tclipRect: self boundingBox) copyBits\n"
        }
      }
    },
    "DisplayText": {
      "comment": "I get used two different ways in the system.\nIn the user interface I mainly hold onto some text which is viewed by some form of ParagraphEditor.  However, as a DisplayObject, I may need to display efficiently, so form caches the bits for that purpose.\n",
      "class_name": "DisplayText",
      "superclass": "DisplayObject",
      "instanceVariables": "text textStyle offset form",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "TextConstants",
      "class_methods": {
        "instance creation": {
          "text:textStyle:": "text: aText textStyle: aTextStyle\n\t\"Answer an instance of me such that the text displayed is aText\n\taccording to the style specified by aTextStyle.\"\n\t^self new\n\t\tsetText: aText\n\t\ttextStyle: aTextStyle\n\t\toffset: 0 @ 0\n",
          "text:textStyle:offset:": "text: aText textStyle: aTextStyle offset: aPoint\n\t\"Answer an instance of me such that the text displayed is aText\n\taccording to the style specified by aTextStyle.  The display of the\n\tinformation should be offset by the amount given as the argument, aPoint.\"\n\t^self new\n\t\tsetText: aText\n\t\ttextStyle: aTextStyle\n\t\toffset: aPoint\n",
          "text:": "text: aText\n\t\"Answer an instance of me such that the text displayed is aText\n\taccording to the system's default textstyle.\"\n\t^self new\n\t\tsetText: aText\n\t\ttextStyle: DefaultTextStyle copy\n\t\toffset: 0 @ 0\n"
        },
        "examples": {
          "example": "example\n\t\"Continually prints two lines of text wherever you point with the cursor.\n\tTerminate by pressing any mouse button.\"\n\n\t| t |\n\tt _ 'this is a line of characters and\nthis is the second line.' asDisplayText.\n\t[Sensor anyButtonPressed]\n\t\twhileFalse:\n\t\t\t[t displayOn: Display at: Sensor cursorPoint]\n\n\t\"DisplayText example.\"\n"
        }
      },
      "instance_methods": {
        "displaying": {
          "displayOn:transformation:clippingBox:align:with:rule:mask:": "displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle align: alignmentPoint with: relativePoint rule: ruleInteger mask: aForm\n\t| absolutePoint |\n\tabsolutePoint _ displayTransformation applyTo: relativePoint.\n\tabsolutePoint _ absolutePoint x truncated @ absolutePoint y truncated.\n\tself displayOn: aDisplayMedium\n\t\tat: absolutePoint - alignmentPoint\n\t\tclippingBox: clipRectangle\n\t\trule: ruleInteger\n\t\tmask: aForm\n",
          "displayOn:at:clippingBox:rule:mask:": "displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger mask: aForm\n\tself form\n\t\tdisplayOn: aDisplayMedium\n\t\tat: aDisplayPoint + offset\n\t\tclippingBox: clipRectangle\n\t\trule: ruleInteger\n\t\tmask: aForm\n"
        },
        "accessing": {
          "form": "form\n\tform == nil ifTrue: [self composeForm].\n\t^form\n",
          "textStyle:": "textStyle: aTextStyle\n\t\"Set the style by which the receiver should display its text.\"\n\n\ttextStyle _ aTextStyle.\n\tform _ nil.\n\tself changed.\n",
          "text": "text\n\t\"Answer the text displayed by the receiver.\"\n\t^text\n",
          "string": "string\n\t\"Answer the string of the characters displayed by the receiver.\"\n\t^text string\n",
          "textStyle": "textStyle\n\t\"Answer the style by which the receiver displays its text.\"\n\t^textStyle\n",
          "numberOfLines": "numberOfLines\n\t\"Answer the number of lines of text in the receiver.\"\n\t^self height // text lineGrid\n",
          "lineGrid": "lineGrid\n\t\"Answer the relative space between lines of the receiver's text.\"\n\t^textStyle lineGrid\n",
          "offset:": "offset: aPoint\n\toffset _ aPoint\n",
          "offset": "offset\n\t^offset\n",
          "text:": "text: aText\n\t\"Set the receiver to display the argument, aText.\"\n\n\ttext _ aText.\n\tform _ nil.\n\tself changed.\n"
        },
        "private": {
          "setText:textStyle:offset:": "setText: aText textStyle: aTextStyle offset: aPoint\n\ttext _ aText.\n\ttextStyle _ aTextStyle.\n\toffset _ aPoint.\n\tform _ nil\n",
          "composeForm": "composeForm\n\tform _ self asParagraph asForm\n"
        },
        "display box access": {
          "boundingBox": "boundingBox\n\t^self form boundingBox\n",
          "computeBoundingBox": "computeBoundingBox\n\t\"Compute minimum enclosing rectangle around characters.\"\n\n\t| character font width carriageReturn lineWidth lineHeight |\n\tcarriageReturn _ Character cr.\n\twidth _ lineWidth _ 0.\n\tfont _ textStyle defaultFont.\n\tlineHeight _ textStyle lineGrid.\n\t1 to: text size do:\n\t\t[:i |\n\t\tcharacter _ text at: i.\n\t\tcharacter = carriageReturn\n\t\t  ifTrue:\n\t\t\t[lineWidth _ lineWidth max: width.\n\t\t\tlineHeight _ lineHeight + textStyle lineGrid.\n\t\t\twidth _ 0]\n\t\t  ifFalse: [width _ width + (font widthOf: character)]].\n\tlineWidth _ lineWidth max: width.\n\t^offset extent: lineWidth @ lineHeight\n"
        },
        "converting": {
          "asParagraph": "asParagraph\n\t\"Answer a Paragraph whose text and style are identical to that of\n\tthe receiver.\"\n\t^Paragraph withText: text style: textStyle copy\n"
        }
      }
    },
    "Cursor": {
      "comment": "I am a 16 x 16 dot matrix suitable for use as the current cursor.\n",
      "class_name": "Cursor",
      "superclass": "Form",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "BlankCursor CornerCursor CrossHairCursor CurrentCursor DownCursor MarkerCursor NormalCursor OriginCursor ReadCursor SquareCursor UpCursor WaitCursor WriteCursor XeqCursor",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"Create all the standard cursors\n\t\tCursor blank\n\t\tCursor corner\n\t\tCursor crossHair\n\t\tCursor down\n\t\tCursor execute\n\t\tCursor marker\n\t\tCursor normal\n\t\tCursor origin\n\t\tCursor read\n\t\tCursor square\n\t\tCursor up\n\t\tCursor wait\n\t\tCursor write\"\n\n\tOriginCursor _\n\t\t(Cursor\n\t\t\textent: 16@16\n\t\t\tfromArray: #(\n\t\t2r1111111111111111\n\t\t2r1111111111111111\n\t\t2r1100000000000000\n\t\t2r1100000000000000\n\t\t2r1100000000000000\n\t\t2r1100000000000000\n\t\t2r1100000000000000\n\t\t2r1100000000000000\n\t\t2r1100000000000000\n\t\t2r1100000000000000\n\t\t2r1100000000000000\n\t\t2r1100000000000000\n\t\t2r1100000000000000\n\t\t2r1100000000000000\n\t\t2r1100000000000000\n\t\t2r1100000000000000)\n\t\t\toffset: -2@-2).\n\n\tCornerCursor _\n\t\t(Cursor\n\t\t\textent: 16@16\n\t\t\tfromArray: #(\n\t\t2r0000000000000011\n\t\t2r0000000000000011\n\t\t2r0000000000000011\n\t\t2r0000000000000011\n\t\t2r0000000000000011\n\t\t2r0000000000000011\n\t\t2r0000000000000011\n\t\t2r0000000000000011\n\t\t2r0000000000000011\n\t\t2r0000000000000011\n\t\t2r0000000000000011\n\t\t2r0000000000000011\n\t\t2r0000000000000011\n\t\t2r0000000000000011\n\t\t2r1111111111111111\n\t\t2r1111111111111111)\n\t\t\toffset: -14@-14).\n\n\tReadCursor _\n\t\t(Cursor\n\t\t\textent: 16@16\n\t\t\tfromArray: #(\n\t\t2r0000110000000110\n\t\t2r0001001000001001\n\t\t2r0001001000001001\n\t\t2r0010000000010000\n\t\t2r0100000000100000\n\t\t2r1111101111100000\n\t\t2r1000010000100000\n\t\t2r1000010000100000\n\t\t2r1011010110100000\n\t\t2r0111101111000000\n\t\t2r0\n\t\t2r0\n\t\t2r0\n\t\t2r0\n\t\t2r0\n\t\t2r0)\n\toffset: 0@0).\n\n\tWriteCursor _ (Cursor\n\textent: 16@16\n\tfromArray: #(\n\t\t2r0000000000000110\n\t\t2r0000000000001111\n\t\t2r0000000000010110\n\t\t2r0000000000100100\n\t\t2r0000000001001000\n\t\t2r0000000010010000\n\t\t2r0000000100100000\n\t\t2r0000001001000011\n\t\t2r0000010010000010\n\t\t2r0000100100000110\n\t\t2r0001001000001000\n\t\t2r0010010000001000\n\t\t2r0111100001001000\n\t\t2r0101000010111000\n\t\t2r0110000110000000\n\t\t2r1111111100000000)\n\toffset: 0@0).\n\n\tWaitCursor _\n\t\t  (Cursor\n\t\t\textent: 16@16\n\t\t\tfromArray: #(\n\t\t2r1111111111111111\n\t\t2r1000000000000001\n\t\t2r0100000000000010\n\t\t2r0010000000000100\n\t\t2r0001110000111000\n\t\t2r0000111101110000\n\t\t2r0000011011100000\n\t\t2r0000001111000000\n\t\t2r0000001111000000\n\t\t2r0000010110100000\n\t\t2r0000100010010000\n\t\t2r0001000110001000\n\t\t2r0010001101000100\n\t\t2r0100111111110010\n\t\t2r1011111111111101\n\t\t2r1111111111111111)\n\t\t\toffset: 0@0).\n\n\tBlankCursor _ Cursor new.\n\n\tXeqCursor _\n\t\t(Cursor\n\t\t\textent: 16@16\n\t\t\tfromArray: #(\n\t\t2r1000000000010000\n\t\t2r1100000000010000\n\t\t2r1110000000111000\n\t\t2r1111000111111111\n\t\t2r1111100011000110\n\t\t2r1111110001000100\n\t\t2r1111111001111100\n\t\t2r1111000001101100\n\t\t2r1101100011000110\n\t\t2r1001100010000010\n\t\t2r0000110000000000\n\t\t2r0000110000000000\n\t\t2r0000011000000000\n\t\t2r0000011000000000\n\t\t2r0000001100000000\n\t\t2r0000001100000000)\n\toffset: 0@0).\n\n\tSquareCursor _\n\t\t(Cursor\n\t\t\textent: 16@16\n\t\t\tfromArray: #(\n\t\t2r0\n\t\t2r0\n\t\t2r0\n\t\t2r0\n\t\t2r0\n\t\t2r0000001111000000\n\t\t2r0000001111000000\n\t\t2r0000001111000000\n\t\t2r0000001111000000\n\t\t2r0\n\t\t2r0\n\t\t2r0\n\t\t2r0\n\t\t2r0\n\t\t2r0\n\t\t2r0)\n\toffset: -8@-8).\n\n\tNormalCursor _\n\t\t(Cursor\n\t\t\textent: 16@16\n\t\t\tfromArray: #(\n\t\t2r1000000000000000\n\t\t2r1100000000000000\n\t\t2r1110000000000000\n\t\t2r1111000000000000\n\t\t2r1111100000000000\n\t\t2r1111110000000000\n\t\t2r1111111000000000\n\t\t2r1111100000000000\n\t\t2r1111100000000000\n\t\t2r1001100000000000\n\t\t2r0000110000000000\n\t\t2r0000110000000000\n\t\t2r0000011000000000\n\t\t2r0000011000000000\n\t\t2r0000001100000000\n\t\t2r0000001100000000)\n\toffset: 0@0).\n\n\tCrossHairCursor _\n\t\t(Cursor\n\t\t\textent: 16@16\n\t\t\tfromArray: #(\n\t\t2r0000000100000000\n\t\t2r0000000100000000\n\t\t2r0000000100000000\n\t\t2r0000000100000000\n\t\t2r0000000100000000\n\t\t2r0000000100000000\n\t\t2r0000000100000000\n\t\t2r1111111111111110\n\t\t2r0000000100000000\n\t\t2r0000000100000000\n\t\t2r0000000100000000\n\t\t2r0000000100000000\n\t\t2r0000000100000000\n\t\t2r0000000100000000\n\t\t2r0000000100000000\n\t\t2r0)\n\t\t\toffset: -7@-7).\n\n\tMarkerCursor _\n\t\tCursor\n\t\t\textent: 16@16\n\t\t\tfromArray: #(\n\t\t2r0\n\t\t2r0\n\t\t2r0\n\t\t2r0000001000000000\n\t\t2r0000001110000000\n\t\t2r0000001111100000\n\t\t2r1111111111111000\n\t\t2r1111111111111110\n\t\t2r1111111111111000\n\t\t2r0000001111100000\n\t\t2r0000001110000000\n\t\t2r0000001000000000\n\t\t2r0\n\t\t2r0\n\t\t2r0\n\t\t2r0)\n\t\t\toffset: -7@-7.\n\n\tUpCursor _\n\t\tCursor\n\t\t\textent: 16@16\n\t\t\tfromArray: #(\n\t\t2r1000000000000000\n\t\t2r1100000000000000\n\t\t2r1110000000000000\n\t\t2r1111000000000000\n\t\t2r1111100000000000\n\t\t2r1111110000000000\n\t\t2r1100000000000000\n\t\t2r1100000000000000\n\t\t2r1100000000000000\n\t\t2r1100000000000000\n\t\t2r1100000000000000\n\t\t2r1100000000000000\n\t\t2r1100000000000000\n\t\t2r1100000000000000\n\t\t2r1100000000000000\n\t\t2r1100000000000000)\n\t \t\toffset: 0@-7.\n\n\tDownCursor _\n\t\t Cursor\n\t\t\textent: 16@16\n\t\t\tfromArray: #(\n\t\t2r0000110000000000\n\t\t2r0000110000000000\n\t\t2r0000110000000000\n\t\t2r0000110000000000\n\t\t2r0000110000000000\n\t\t2r0000110000000000\n\t\t2r0000110000000000\n\t\t2r0000110000000000\n\t\t2r0000110000000000\n\t\t2r0000110000000000\n\t\t2r1111110000000000\n\t\t2r0111110000000000\n\t\t2r0011110000000000\n\t\t2r0001110000000000\n\t\t2r0000110000000000\n\t\t2r0000010000000000)\n\t\t\toffset: -5@-7.\n\n\"Cursor initialize\"\n"
        },
        "constants": {
          "corner": "corner\n\t\"Answer the instance of me that is the shape of the bottom right corner of\n\ta rectangle.\"\n\t^CornerCursor\n",
          "marker": "marker\n\t\"Answer the instance of me that is displayed when thumb-scrolling.\"\n\t^MarkerCursor\n",
          "origin": "origin\n\t\"Answer the instance of me that is the shape of the top left corner of a rectangle.\"\n\t^OriginCursor\n",
          "square": "square\n\t\"Answer the instance of me that is the shape of a square.\"\n\t^SquareCursor\n",
          "read": "read\n\t\"Answer the instance of me that is the shape of eyeglasses.\"\n\t^ReadCursor\n",
          "crossHair": "crossHair\n\t\"Answer the instance of me that is the shape of a cross.\"\n\t^CrossHairCursor\n",
          "blank": "blank\n\t\"Answer the instance of me that is all white.\"\n\t^BlankCursor\n",
          "write": "write\n\t\"Answer the instance of me that is the shape of a pen writing.\"\n\t^WriteCursor\n",
          "wait": "wait\n\t\"Answer the instance of me that is the shape of an hourglass.\"\n\t^WaitCursor\n",
          "down": "down\n\t\"Answer the instance of me that is the shape of an arrow facing downward.\"\n\t^DownCursor\n",
          "execute": "execute\n\t\"Answer the instance of me that is the shape of an arrow slanted left\n\twith a star next to it.\"\n\t^XeqCursor\n",
          "normal": "normal\n\t\"Answer the instance of me that is the shape of an arrow slanted left.\"\n\t^NormalCursor\n",
          "up": "up\n\t\"Answer the instance of me that is the shape of an arrow facing upward.\"\n\t^UpCursor\n"
        },
        "instance creation": {
          "new": "new\n\t^self\n\t\textent: 16 @ 16\n\t\tfromArray: Array new\n\t\toffset: 0 @ 0\n\t\"Cursor new bitEdit show.\"\n",
          "extent:fromArray:offset:": "extent: extentPoint fromArray: anArray offset: offsetPoint\n\t\"Answer a new instance of me with width and height specified by\n\textentPoint, offset by offsetPoint, and bits from anArray.\"\n\n\textentPoint = (16 @ 16)\n\t\tifTrue:\n\t\t\t[^super\n\t\t\t\textent: extentPoint\n\t\t\t\tfromArray: anArray\n\t\t\t\toffset: offsetPoint]\n\t\tifFalse: [self error: 'cursors must be 16@16']\n"
        },
        "current cursor": {
          "currentCursor": "currentCursor\n\t\"Answer the instance of Cursor that is the one currently displayed.\"\n\t^CurrentCursor\n",
          "currentCursor:": "currentCursor: aCursor\n\t\"Make the instance of cursor, aCursor, be the current cursor.  Display\n\tit.  Create an error if the argument is not a Cursor.\"\n\n\taCursor class == self\n\t\tifTrue:\n\t\t\t[CurrentCursor _ aCursor.\n\t\t\taCursor beCursor]\n\t\tifFalse: [self error: 'The new cursor must be an instance of class Cursor']\n",
          "cursorLink:": "cursorLink: boolean\n\t\"Cause the cursor to track the pointing device location if the argument is true.\n\tDecouple the cursor from the pointing device if the argument is false.\n\tEssential.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 92>\n\t^self primitiveFailed\n"
        }
      },
      "instance_methods": {
        "printing": {
          "printOn:": "printOn: aStream\n\tself storeOn: aStream base: 2\n"
        },
        "updating": {
          "changed:": "changed: aParameter\n\tself == CurrentCursor ifTrue: [self beCursor].\n\tsuper changed: aParameter\n"
        },
        "displaying": {
          "beCursor": "beCursor\n\t\"Tell the interpreter to use the receiver as the current cursor image.  Fail if the\n\treceiver does not match the size expected by the hardware.  Essential.  See\n\tObject documentation whatIsAPrimitive.\"\n\n\t<primitive: 101>\n\tself primitiveFailed\n",
          "showGridded:": "showGridded: gridPoint\n\t\"Make the current cursor shape be the receiver, forcing the location of cursor\n\tto the point nearest gridPoint.\"\n\tSensor primCursorLocPut: ((Sensor cursorPoint grid: gridPoint) + self offset).\n\tSensor currentCursor: self\n",
          "show": "show\n\t\"Make the current cursor shape be the receiver.\"\n\tSensor currentCursor: self\n",
          "showWhile:": "showWhile: aBlock\n\t\"While evaluating the argument, aBlock, make the receiver be the cursor shape.\"\n\n\t| oldcursor value |\n\toldcursor _ Sensor currentCursor.\n\tself show.\n\tvalue _ aBlock value.\n\toldcursor show.\n\t^value\n"
        }
      }
    },
    "Paragraph": {
      "comment": "The font and emphasis changes for text is fundamentally more complex than such graphical entities as a bar chart or pie chart.  Hence many of the methods associated with Paragraph tend to be, stylistically, longer and more complex than those in most other system classes.\n\nInstance Variables:\n\n\tclippingRectangle\n<Rectangle>  A Rectangle in CurrentDisplay coordinates. Its intersection with the compositionRectangle in turn intersected with the destinationForm is the area in which characters are constrained to display.\n\n\tcompositionRectangle\n<Rectangle>  Its offset serves as a relative offset similar to the offset field in Form.  The width of the compositionRectangle is the dimension, modified by indents and tabsLevels, against which line wraparound is measured.  The height of the compositionRectangle is reset each time recomposition is required.  This happens when the stylizedString is initially composed and whenever a replacement (copyReplaceFrom:to:with:) occurs.\n\n\tdestinationForm\n<Form>  The Form into which the characters are scanned.  Typically CurrentDisplay.\n\trule\n<Integer>  The rule according to which character display behaves. For example, rule may equal over, under, reverse, etc.\n\n\tmask\n<Form>  The form with which each character is combined by the scanner before applying the rule for display.\n\n\tmarginTabsLevel\n<Integer>  The margin tabs give the left and right indent values for a specified marginTabsLevel.  The marginTabsLevel is sometimes referred to as the nesting level and is an index into the marginTabsArray of the stringStyle.\n\n\tfirstIndent\n<Integer>  Amount to inset from the left margin for the first line of a paragraph. Initialized to value in the textStyle.\n\n\trestIndent\n<Integer>  Amount to inset from the left margin for all but the first line of a paragraph. Initialized to value in the textStyle.\n\n\trightIndent\n<Integer>  Amount to inset from the right margin for all the lines of the paragraph. Initialized to value in the textStyle.\n\n\tlines\n<Array>  This array is built during composition and modified when the stylizedString is modified (copyReplaceFrom:to:with:).  Each of its fields from 1 to lastLine contains a TextLineInterval which in turn contains the starting index and stopping index of a given line as well as its internal spaces and padding width, the latter two being used to support the management of padded spaces, tabs and changing margin alignments.\n\n\tlastLine\n<Integer>  The index of the last validly composed line in the lines array.\n\n\toutputMedium\n<Symbol>   Either #Display, #PressPrinter or #DisplayPrinterWidths as of 1/20/80.  Needed by CompositionScanner for determining the nature of the font to be used for character widths.  For the DisplayScanner there are several places where distinguishing between displaying and printing is required.  Also used for some margin and grid computations.\n",
      "class_name": "Paragraph",
      "superclass": "DisplayText",
      "instanceVariables": "clippingRectangle compositionRectangle destinationForm rule mask marginTabsLevel firstIndent restIndent rightIndent lines lastLine outputMedium",
      "classInstanceVariables": "",
      "classVariables": "DefaultCompositionRectangle",
      "poolDictionaries": "TextConstants",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t\"Do not allow an uninitialized view.  Create with text that has no characters.\"\n\n\t^self withText: '' asText\n",
          "withText:style:": "withText: aText style: aTextStyle\n\t\"Answer an instance of me with text set to aText and style set to aTextStyle.\"\n\t^super new\n\t\tcompositionRectangle: DefaultCompositionRectangle\n\t\ttext:\taText\n\t\tstyle: aTextStyle\n\t\toffset: (0@0)\n\t\toutputMedium: #Display\n\t\tfitWidth: true\n",
          "initialize": "initialize\t\"Paragraph initialize.\"\n\n\tDefaultCompositionRectangle _ 0@0 corner: 10000@10000.\n",
          "withText:style:compositionRectangle:clippingRectangle:": "withText: aText style: aTextStyle compositionRectangle: compRect clippingRectangle: clipRect\n\t| para |\n\n\tpara _ super new\n\t\tcompositionRectangle: compRect\n\t\ttext: aText\n\t\tstyle: aTextStyle\n\t\toffset: (0@0)\n\t\toutputMedium: #Display\n\t\tfitWidth: false.\n\tpara clippingRectangle: clipRect.\n\t^para\n",
          "withText:": "withText: aText\n\t\"Answer an instance of me with text set to aText and style set to\n\tthe system's default text style.\"\n\n\t^self withText: aText style: DefaultTextStyle copy\n"
        },
        "examples": {
          "example": "example\n\t\"This simple example illustrates how to display a few lines of text on the screen at\n\tthe current cursor point.\"\n\n\t| para point |\n\tpoint _ Sensor waitButton.\n\tpara _ 'this is the first line of characters\nand this is the second line comprising this TextForm.' asParagraph.\n\tpara displayOn: Display at: point.\n\tpara\n\t\tdisplayOn: Display at: point + (0 @ para height)\n\t\tclippingBox: Display boundingBox\n\t\trule: Form over\n\t\tmask: Form gray\n\n\t\"Paragraph example.\"\n"
        }
      },
      "instance_methods": {
        "selecting": {
          "dyForPoint:": "dyForPoint: pt\n\t\"See if pt is above or below clippingRectangle, return scroll amount\"\n\n\t| dy dyLim |\n\t((dy _ pt y - clippingRectangle top) < 0\n\t and: [(dyLim _ compositionRectangle top - clippingRectangle top) < 0])\n\t\tifTrue: [^(dy max: dyLim) - textStyle lineGrid].\n\t((dy _ pt y - clippingRectangle bottom) > 0\n\t and: [(dyLim _ compositionRectangle bottom - clippingRectangle bottom) > 0])\n\t\tifTrue: [^(dy min: dyLim) + textStyle lineGrid].\n\t^0\n",
          "displayCaretAt:": "displayCaretAt: aPoint\n\t\"Display CaretForm located at aPoint with default settings for rule and halftone.\"\n\n\tCaretForm\n\t\tdisplayOn: destinationForm\n\t\tat: aPoint\n\t\tclippingBox: clippingRectangle\n\t\trule: Form reverse\n\t\tmask: Form black\n",
          "reverseFrom:to:": "reverseFrom: characterBlock1 to: characterBlock2\n\t\"Reverse area between the two character blocks given as arguments.\"\n\n\t| start stop |\n\tcharacterBlock1 = characterBlock2 ifTrue: [^self].\n\tcharacterBlock1 < characterBlock2\n\t\tifTrue: [start _ characterBlock1. stop _ characterBlock2]\n\t\tifFalse: [start _ characterBlock2. stop _ characterBlock1].\n\tstart top = stop top ifTrue: [\n\t\t^self reverseRectangle: (start origin corner: stop bottomLeft)].\n\tself reverseRectangle:\n\t (start origin corner: compositionRectangle right @ start bottom).\n\tself reverseRectangle:\n\t (compositionRectangle left@start bottom corner: compositionRectangle right@stop top).\n\tself reverseRectangle: (compositionRectangle left@stop top corner: stop bottomLeft).\n",
          "selectWord:": "selectWord: stringIndex\n\t\"Select delimited text or word--the result of double-clicking.\"\n\n\t| openDelimiter closeDelimiter direction match level leftDelimiters rightDelimiters\n\tstring here hereChar start stop |\n\tstring _ text string.\n\there _ stringIndex.\n\t(here between: 2 and: string size)\n\t\tifFalse: [\"if at beginning or end, select entire string\"\n\t\t\t^ 1 to: string size + 1].\n\tleftDelimiters _ '([{<''\"\n'.\n\trightDelimiters _ ')]}>''\"\n'.\n\topenDelimiter _ string at: here - 1.\n\tmatch _ leftDelimiters indexOf: openDelimiter.\n\tmatch > 0\n\t\tifTrue:\n\t\t\t[\"delimiter is on left -- match to the right\"\n\t\t\tstart _ here.\n\t\t\tdirection _ 1.\n\t\t\there _ here - 1.\n\t\t\tcloseDelimiter _ rightDelimiters at: match]\n\t\tifFalse:\n\t\t\t[openDelimiter _ string at: here.\n\t\t\tmatch _ rightDelimiters indexOf: openDelimiter.\n\t\t\tmatch > 0\n\t\t\t\tifTrue:\n\t\t\t\t\t[\"delimiter is on right -- match to the left\"\n\t\t\t\t\tstop _ here - 1.\n\t\t\t\t\tdirection _ -1.\n\t\t\t\t\tcloseDelimiter _ leftDelimiters at: match]\n\t\t\t\tifFalse: [\"no delimiters -- select a token\"\n\t\t\t\t\tdirection _ -1]].\n\tlevel _ 1.\n\t[level > 0 and: [direction > 0\n\t\t\tifTrue: [here < string size]\n\t\t\tifFalse: [here > 1]]]\n\t\twhileTrue:\n\t\t\t[hereChar _ string at: (here _ here + direction).\n\t\t\tmatch = 0\n\t\t\t\tifTrue: [\"token scan goes left, then right\"\n\t\t\t\t\thereChar tokenish\n\t\t\t\t\t\tifTrue: [here = 1\n\t\t\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t\t\t[start _ 1.\n\t\t\t\t\t\t\t\t\t\"go right if hit string start\"\n\t\t\t\t\t\t\t\t\tdirection _ 1]]\n\t\t\t\t\t\tifFalse: [direction < 0\n\t\t\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t\t\t[start _ here + 1.\n\t\t\t\t\t\t\t\t\t\"go right if hit non-token\"\n\t\t\t\t\t\t\t\t\tdirection _ 1]\n\t\t\t\t\t\t\t\tifFalse: [level _ 0]]]\n\t\t\t\tifFalse: [\"bracket match just counts nesting level\"\n\t\t\t\t\thereChar = closeDelimiter\n\t\t\t\t\t\tifTrue: [level _ level - 1\"leaving nest\"]\n\t\t\t\t\t\tifFalse: [hereChar = openDelimiter\n\t\t\t\t\t\t\t\t\tifTrue: [level _ level + 1\"entering deeper nest\"]]]].\n\tlevel > 0 ifTrue: [\"in case ran off string end\"\there _ here + direction].\n\tdirection > 0\n\t\tifTrue: [^ start to: here]\n\t\tifFalse: [^ here + 1 to: stop + 1]\n",
          "reverseRectangle:": "reverseRectangle: aRectangle\n\t\"Highlight the part of aRectangle which is visible\"\n\t| rect |\n\trect _ aRectangle intersect: self visibleRectangle.\n\tdestinationForm fill: rect rule: Form reverse mask: mask.\n",
          "displayCaretForBlock:": "displayCaretForBlock: aCharacterBlock\n\t\"Show caret at proper place for aCharacterBlock\"\n\n\tself displayCaretAt: (aCharacterBlock topLeft + (0@textStyle baseline))\n",
          "mouseSelect:to:": "mouseSelect: previousStartBlock to: previousStopBlock\n\t\"Answer with an Array of two CharacterBlocks that represent the text selection that the user makes. Allow for scrolling to extend selections.\"\n\n\t| pivotBlock startBlock stopBlock showingCaret dy pt okToScroll scrollDelay word |\n\tstartBlock _ stopBlock _ pivotBlock _ self characterBlockAtPoint: Sensor cursorPoint.\n\tself displayCaretForBlock: pivotBlock.\n\tshowingCaret _ true.\n\tokToScroll _ true.\n\tscrollDelay _ Delay forMilliseconds: 250. \"For Dorados\"\n\t[Sensor redButtonPressed] whileTrue: [\n\t\tpt _ Sensor cursorPoint.\n\t\t(okToScroll\n\t\t and: [(dy _ self dyForPoint: pt) ~= 0]) ifTrue: [\n\t\t\t[okToScroll _ false. scrollDelay wait. okToScroll _ true]\n\t\t\t\tforkAt: Processor userInterruptPriority.\n\t\t\tshowingCaret\n\t\t\t\tifTrue: [\n\t\t\t\t\tself displayCaretForBlock: pivotBlock.\n\t\t\t\t\tshowingCaret _ false]\n\t\t\t\tifFalse: [self reverseFrom: startBlock to: pivotBlock].\n\t\t\tself scrollBy: dy.\n\t\t\tpt _ dy < 0\n\t\t\t\tifTrue: [clippingRectangle topLeft]\n\t\t\t\tifFalse: [clippingRectangle bottomRight].\n\t\t\tpivotBlock _ self characterBlockForIndex: pivotBlock stringIndex.\n\t\t\tstartBlock _ pivotBlock ].\n\t\tstopBlock _ self characterBlockAtPoint: pt.\n\t\tstopBlock = startBlock ifFalse: [\n\t\t\tshowingCaret ifTrue: [\n\t\t\t\tself displayCaretForBlock: pivotBlock. showingCaret _ false].\n\t\t\tself reverseFrom: startBlock to: stopBlock.\n\t\t\tstartBlock _ stopBlock] ].\n\t(showingCaret not and: [pivotBlock = stopBlock])\n\t\tifTrue: [self displayCaretForBlock: pivotBlock].\n\tscrollDelay disable.\n\t(previousStartBlock = previousStopBlock and:\n\t\t[pivotBlock = stopBlock and: [stopBlock = previousStopBlock]])\n\t\tifTrue:  \"select a word or bracketed range\"\n\t\t\t[word _ self selectWord: pivotBlock stringIndex.\n\t\t\tword first = word last ifFalse:\n\t\t\t\t[self displayCaretForBlock: pivotBlock.\n\t\t\t\tpivotBlock _ self characterBlockForIndex: word first.\n\t\t\t\tstopBlock _ self characterBlockForIndex: word last.\n\t\t\t\tself reverseFrom: pivotBlock to: stopBlock]].\n\tstopBlock < pivotBlock\n\t\tifTrue: [^Array with: stopBlock with: pivotBlock]\n\t\tifFalse: [^Array with: pivotBlock with: stopBlock]\n"
        },
        "tabs and margins": {
          "rightIndent": "rightIndent\n\t\"Answer the right margin indent for the lines of a paragraph in the style of the receiver.\"\n\t^rightIndent\n",
          "deltaMarginTabsLevel:": "deltaMarginTabsLevel: anInteger\n\t\"Delta the depth of 'nesting' for this paragraph -- an index into the marginTabsArray in the textStyle.\"\n\tself marginTabsLevel: anInteger + marginTabsLevel.\n",
          "marginTabsLevel:": "marginTabsLevel: anInteger\n\t\"Set the depth of 'nesting' for this paragraph -- an index into the marginTabsArray in the textStyle.\"\n\tmarginTabsLevel _ (anInteger max: 0) min: textStyle nestingDepth.\n\n\"Check if we've nested so far that there is no room between the effective margins.\"\n\t[(self leftMarginForCompositionForLine: 1) >= (self rightMarginForComposition)\n\t\tand: [marginTabsLevel > 0]]\n\t\twhileTrue:\n\t\t\t[marginTabsLevel _ (marginTabsLevel - 1 max: 0)].\n\t[(self leftMarginForCompositionForLine: 2) >= (self rightMarginForComposition)\n\t\tand: [marginTabsLevel > 0]]\n\t\twhileTrue:\n\t\t\t[marginTabsLevel _ (marginTabsLevel - 1 max: 0)].\n\tself composeAll.\n",
          "marginTabsLevel": "marginTabsLevel\n\t\"Answer the depth of 'nesting' for this paragraph -- an index into the marginTabsArray in the textStyle.\"\n\t^marginTabsLevel\n",
          "restIndent:": "restIndent: anInteger\n\t\"Set the indent for all but the first line of a paragraph in the style of the receiver to be anInteger.\"\n\trestIndent _\n\t\t(anInteger max: 0) min: (compositionRectangle width - DefaultSpace - rightIndent).\n\tself composeAll.\n",
          "firstIndent": "firstIndent\n\t\"Answer the horizontal indenting of the first line of a paragraph in the style of the receiver.\"\n\t^firstIndent\n",
          "firstIndent:": "firstIndent: anInteger\n\t\"Set the horizontal indenting of the first line of a paragraph in the style of the receiver to be anInteger.\"\n\tfirstIndent _\n\t\t(anInteger max: 0) min: (compositionRectangle width - DefaultSpace - rightIndent).\n\tself composeAll.\n",
          "clearIndents": "clearIndents\n\t\"Reset all the indention settings to be 0.\"\n\tself firstIndent: 0.\n\tself restIndent: 0.\n\tself rightIndent: 0\n",
          "restIndent": "restIndent\n\t\"Answer the indent for all but the first line of a paragraph in the style of the receiver.\"\n\t^restIndent\n",
          "rightIndent:": "rightIndent: anInteger\n\t\"Set the right margin indent for the lines of a paragraph in the style of the receiver to be anInteger.\"\n\t| maxRightIndent |\n\tfirstIndent > restIndent\n\t\tifTrue:\t[maxRightIndent _\n\t\t\t\t\t(compositionRectangle width- DefaultSpace - firstIndent) max: 1]\n\t\tifFalse:\t[maxRightIndent _\n\t\t\t\t\t(compositionRectangle width- DefaultSpace - restIndent) max: 1].\n\trightIndent _ anInteger min: maxRightIndent.\n\tself composeAll.\n"
        },
        "composition": {
          "composeAll": "composeAll\n\t\"Compose a collection of characters into a collection of lines.\"\n\n\t| startIndex stopIndex lineIndex maximumRightX compositionScanner |\n\tlines _ Array new: 32.\n\tlastLine _ 0.\n\tmaximumRightX _ 0.\n\ttext size = 0\n\t\tifTrue:\n\t\t\t[compositionRectangle height: 0.\n\t\t\t^maximumRightX].\n\tstartIndex _ lineIndex _ 1.\n\tstopIndex _ text size.\n\tcompositionScanner _ CompositionScanner new in: self.\n\t[startIndex > stopIndex] whileFalse:\n\t\t[self lineAt: lineIndex\n\t\t\t\tput: (compositionScanner composeLine: lineIndex\n\t\t\t\t\t\t\t\t\t\tfromCharacterIndex: startIndex\n\t\t\t\t\t\t\t\t\t\tinParagraph: self).\n\t\t maximumRightX _ compositionScanner rightX max: maximumRightX.\n\t\t startIndex _ (lines at: lineIndex) last + 1.\n\t\t lineIndex _ lineIndex + 1].\n\tself updateCompositionHeight.\n\tself trimLinesTo: lineIndex - 1.\n\t^maximumRightX\n",
          "recomposeIn:clippingBox:": "recomposeIn: compositionRect clippingBox: clippingRect\n\t\"Set the composition rectangle for the receiver so that the lines wrap\n\twithin the rectangle, compositionRect, and the display of the text is\n\tclipped by the rectangle, clippingRect.\"\n\n\tself compositionRectangle: compositionRect copy\n\t\ttext: text\n\t\tstyle: textStyle\n\t\toffset: offset\n\t\toutputMedium: #Display\n\t\tfitWidth: false.\n\tclippingRectangle _ clippingRect copy\n"
        },
        "displaying": {
          "displayOn:transformation:clippingBox:align:with:rule:mask:": "displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle align: alignmentPoint with: relativePoint rule: ruleInteger mask: aForm\n\n\tself\t\t\t\t\"Assumes offset has been set!!!!!\"\n\t  displayOn: aDisplayMedium\n\t  at: (offset\n\t\t\t+ (displayTransformation applyTo: relativePoint)\n\t\t\t- alignmentPoint) rounded\n\t  clippingBox: clipRectangle\n\t  rule: ruleInteger\n\t  mask: aForm.\n",
          "displayOn:at:clippingBox:rule:mask:": "displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger mask: aForm\n\t\"Default display message when aDisplayPoint is in absolute screen\n\tcoordinates. \"\n\n\tdestinationForm _ aDisplayMedium.\n\tclippingRectangle _ clipRectangle.\n\trule _ ruleInteger.\n\tmask _ aForm.\n\tcompositionRectangle moveTo: aDisplayPoint.\n\t(lastLine == nil or: [lastLine < 1]) ifTrue: [self composeAll].\n\tself displayLines: (1 to: lastLine)\n",
          "displayOn:": "displayOn: aDisplayMedium\n\t\"Display on a new destination medium -- typically a form.\"\n\n\tself displayOn: aDisplayMedium\n\t\tat: compositionRectangle topLeft\n\t\tclippingBox: clippingRectangle\n\t\trule: rule\n\t\tmask: mask\n",
          "displayAt:": "displayAt: aPoint\n\t\"Because Paragraphs cache so much information, computation is avoided and\n\tdisplayAt: 0@0 is not appropriate here\"\n\n\tself displayOn: destinationForm\n\t\tat: aPoint\n\t\tclippingBox: clippingRectangle\n\t\trule: rule\n\t\tmask: mask\n"
        },
        "indicating": {
          "outline": "outline\n\t\"Display a border around the visible area in which the receiver\n\tpresents its text.\"\n\n\tclippingRectangle bottom <= compositionRectangle bottom\n\t  ifTrue: [Display\n\t\t\t\tborder: (clippingRectangle intersect: compositionRectangle)\n\t\t\t\twidth: 2]\n\t  ifFalse: [Display\n\t\t\t\tborder: (clippingRectangle intersect: destinationForm boundingBox)\n\t\t\t\twidth: 2].\n",
          "flash": "flash\n\t\"Complement twice the visible area in which the receiver displays.\"\n\tDisplay flash: self visibleRectangle\n"
        },
        "utilities": {
          "gridWithLead:": "gridWithLead: leadInteger\n\t\"Set the line grid of the receiver's style for displaying text to the height\n\tof the first font in the receiver's style + the argument, leadInteger.\"\n\n\ttextStyle\n\t\tgridForFont: (text emphasisAt: 1)\n\t\twithLead: leadInteger.\t\t\"assumes only one font referred to by runs\"\n\tself updateCompositionHeight.\n",
          "fit": "fit\n\t\"Make the bounding rectangle of the receiver contain all the text without\n\tchanging the width of the receiver's composition rectangle.\"\n\n\t[(self lineIndexOfTop: clippingRectangle top) = 1]\n\t\twhileFalse: [self scrollBy: (0-1)*textStyle lineGrid].\n\tself updateCompositionHeight.\n\tclippingRectangle bottom: compositionRectangle bottom\n",
          "clearVisibleRectangle": "clearVisibleRectangle\n\t\"Display the area in which the receiver presents its text so that the area\n\tis all one tone--in this case, all white.\"\n\n\tdestinationForm\n\t  fill: self visibleRectangle\n\t  rule: rule\n\t  mask: Form white.\n"
        },
        "character location": {
          "characterBlockAtPoint:": "characterBlockAtPoint: aPoint\n\t\"Answer a CharacterBlock for characters in the text at point aPoint.\n\tIt is assumed that aPoint has been transformed into coordinates appropriate to\n\tthe receiver's destinationForm rectangle and the compositionRectangle.\"\n\n\t^CharacterBlockScanner new characterBlockAtPoint: aPoint in: self\n",
          "characterBlockForIndex:": "characterBlockForIndex: targetIndex\n\t\"Answer a CharacterBlock for character in the text at targetIndex.  The\n\tcoordinates in the CharacterBlock will be appropriate to the intersection of the\n\tdestinationForm rectangle and the compositionRectangle.\"\n\n\t^CharacterBlockScanner new characterBlockForIndex: targetIndex in: self\n"
        },
        "accessing": {
          "rule": "rule\n\t\"Answer the rule according to which character display behaves. For\n\texample, rule may equal over, under, reverse.\"\n\t^rule\n",
          "form": "form\n\t^form\n",
          "clippingRectangle": "clippingRectangle\n\t\"Answer the rectangle, defined in absolute coordinates, whose intersection with the\n\tdestinationForm is the area in which the characters are constrained to display.\"\n\t^clippingRectangle\n",
          "rule:": "rule: ruleInteger\n\t\"Set the rule according to which character display behaves.\"\n\trule _ ruleInteger.\n",
          "destinationForm": "destinationForm\n\t \"Answer the Form into which the characters are scanned.\"\n\t^destinationForm\n",
          "compositionRectangle:": "compositionRectangle: compRectangle\n\t\"Set the rectangle whose width is the dimension, modified by\n\tindents and tabsLevels, against which line wraparound is measured.\"\n\n\tcompositionRectangle _ compRectangle.\n\tself composeAll\n",
          "outputMedium": "outputMedium\n\t\"Answer the outputMedium for the receiver.\"\n\n\t^outputMedium\n",
          "outputMedium:": "outputMedium: aSymbol\n\t\"Set the argument to be the outputMedium for the receiver.\n\tAs of 1/20/80, #Display, #PressPrinter, #DisplayPrinterWidths are the possibilities.\"\n\toutputMedium _ aSymbol.\n\t\t\"Changing the outputMedium means that the text must be recomposed.\"\n\ttextStyle outputMedium: aSymbol.\n\tself composeAll\n",
          "numberOfLines": "numberOfLines\n\t\"Answer the number of lines of text in the receiver.\"\n\t^lastLine\n",
          "compositionRectangle": "compositionRectangle\n\t\"Answer the rectangle whose width is the dimension, modified by\n\tindents and tabsLevels, against which line wraparound is measured. The\n\theight of the compositionRectangle is reset each time recomposition is\n\trequired.\"\n\n\t^compositionRectangle\n",
          "replaceFrom:to:with:displaying:": "replaceFrom: start to: stop with: aText displaying: displayBoolean\n\t\"Replace the receiver's text starting at position start, stopping at stop, by the characters in aText. It is expected that most requirements for modifications to the receiver will call this code.  Certainly all cut's or paste's.\"\n\n\t| compositionScanner obsoleteLines obsoleteLastLine firstLineIndex lastLineIndex\n\tstartLine stopLine replacementRange visibleRectangle startIndex newLine done\n\tnewStop obsoleteY newY upOrDown moveRectangle |\n\n\ttext\t\t\t\"Update the text.\"\n\t  replaceFrom: start to: stop with: aText.\n\tlastLine = 0\n\t  ifTrue: \t[\"if lines have never been set up, measure them and display\n\t\t\t\t\tall the lines falling in the visibleRectangle\"\n\t\t\t\tself composeAll.\n\t\t\t\tdisplayBoolean\n\t\t\t\t\tifTrue:\t[self clearVisibleRectangle.\n\t\t\t\t\t\t\tself displayLines: (1 to: lastLine)].\n\t\t\t\t^self].\n\n\t\"save -- things get pretty mashed as we go along\"\n\tobsoleteLines _ lines copy.\n\tobsoleteLastLine _ lastLine.\n\n\t\t\"find the starting and stopping lines\"\n\tfirstLineIndex _ startLine _ self lineIndexOfCharacterIndex: start.\n\tstopLine _ self lineIndexOfCharacterIndex: stop.\n\t\t\"how many characters being inserted or deleted -- negative if\n\t\t\taText size is < characterInterval size.\"\n\treplacementRange _ aText size - (stop - start + 1).\n\t\t\"Give ourselves plenty of elbow room.\"\n\tcompositionRectangle height: textStyle lineGrid * 8196.\t\"max Vector length\"\n\t\t\"build a boundingBox of the actual screen space in question -- we'll need it later\"\n\tvisibleRectangle _ (clippingRectangle intersect: compositionRectangle)\n\t\t\t\t\t\t\tintersect: destinationForm boundingBox.\n\t\t\"Initialize a scanner.\"\n\tcompositionScanner _ CompositionScanner new in: self.\n\n\t\t\"If the starting line is not also the first line, then measuring must commence from line preceding the one in which characterInterval start appears.  For example, deleting a line with only a carriage return may move characters following the deleted portion of text into the line preceding the deleted line.\"\n\tstartIndex _ (lines at: firstLineIndex) first.\n\tstartLine > 1\n\t\tifTrue: \t[newLine _\n\t\t\t\t\tcompositionScanner\n\t\t\t\t\t\tcomposeLine: startLine - 1\n\t\t\t\t\t\tfromCharacterIndex: (lines at: startLine - 1) first\n\t\t\t\t\t\tinParagraph: self.\n\t\t\t\t(lines at: startLine - 1) = newLine\n\t\t\t\t\tifFalse:\t[\"start in line preceding the one with the starting character\"\n\t\t\t\t\t\t\tstartLine _ startLine - 1.\n\t\t\t\t\t\t\tself lineAt: startLine put: newLine.\n\t\t\t\t\t\t\tstartIndex _ newLine last + 1]].\n\tstartIndex > text size\n\t\tifTrue: \t[\"nil lines after a deletion -- remeasure last line below\"\n\t\t\t\tself trimLinesTo: (firstLineIndex - 1 max: 0).\n\t\t\t\ttext size = 0\n\t\t\t\t\tifTrue:\t[\"entire text deleted -- clear visibleRectangle and return.\"\n\t\t\t\t\t\t\tdestinationForm\n\t\t\t\t \t\t\t\tfill: visibleRectangle rule: rule mask: Form white.\n\t\t\t\t\t\t\tself updateCompositionHeight.\n\t\t\t\t\t\t\t^self]].\n\n\t\"Now we really get to it.\"\n\tdone _ false.\n\tlastLineIndex _ stopLine.\n\t[done or: [startIndex > text size]]\n\t\twhileFalse:\n\t\t[self lineAt: firstLineIndex put:\n\t\t\t(newLine _ compositionScanner composeLine: firstLineIndex\n\t\t\t\t\t\t\tfromCharacterIndex: startIndex inParagraph: self).\n\t\t[(lastLineIndex > obsoleteLastLine\n\t\t\tor: [\"no more old lines to compare with?\"\n\t\t\t\tnewLine last <\n\t\t\t\t\t(newStop _ (obsoleteLines at: lastLineIndex) last + replacementRange)])\n\t\t\t  \tor: [done]]\n\t\t\twhileFalse:\n\t\t\t[newStop = newLine last\n\t\t\t\tifTrue:\t[\"got the match\"\n\t\t\t\t\t\tupOrDown _ replacementRange < 0\n\t\t\t\t\t\t\tifTrue: [0] ifFalse: [1].\n\t\t\t\t\t\t\t\"get source and dest y's for moving the unchanged lines\"\n\t\t\t\t\t\tobsoleteY _ self topAtLineIndex: lastLineIndex + upOrDown.\n\t\t\t\t\t\tnewY _ self topAtLineIndex: firstLineIndex + upOrDown.\n\t\t\t\t\t\tstopLine _ firstLineIndex.\n\t\t\t\t\t\tdone _ true.\n\t\t\t\t\t\t\t\"Fill in the new line vector with the old unchanged lines.\n\t\t\t\t\t\t\tUpdate their starting and stopping indices on the way.\"\n\t\t\t\t\t\t((lastLineIndex _ lastLineIndex + 1) to: obsoleteLastLine) do:\n\t\t\t\t\t\t\t[:upDatedIndex |\n\t\t\t\t\t\t\tself lineAt: (firstLineIndex _ firstLineIndex + 1)\n\t\t\t\t\t\t\t\tput: ((obsoleteLines at: upDatedIndex)\n\t\t\t\t\t\t\t  \t\tslide: replacementRange)].\n\t\t\t\t\t\t\t\"trim off obsolete lines, if any\"\n\t\t\t\t\t\tself trimLinesTo: firstLineIndex]\n\t\t\t\tifFalse:\t[lastLineIndex _ lastLineIndex + 1]].\n\t\tstartIndex _ newLine last + 1.\n\t\tfirstLineIndex _ firstLineIndex + 1].\n\n\t\"Now the lines are up to date -- Whew!.  What remains is to move the 'unchanged' lines and display those which have changed.\"\n\tdisplayBoolean\n\tifTrue:\t[\n\tstartIndex > text size\n\t\tifTrue:\t[\"If at the end of previous lines simply display lines from the line in\n\t\t\t\twhich the first character of the replacement occured through the\n\t\t\t\tend of the paragraph.\"\n\t\t\t\tself updateCompositionHeight.\n\t\t\t\tself displayLines:\n\t\t\t\t\t(startLine to: (stopLine _ firstLineIndex min: lastLine))]\n\t\tifFalse:\t[\"Otherwise prepare to move the unchanged lines.  moveRectangle\n\t\t\t\tdefines the portion of the visibleRectangle containing the lines\n\t\t\t\twhich may be moved en masse.\n\t\t\t\tDeletion -- moving 'up' the screen or ...\"\n\t\t\t\tmoveRectangle _\n\t\t\t\t\tvisibleRectangle left @ (obsoleteY max: visibleRectangle top)\n\t\t\t\t\t\tcorner: visibleRectangle corner.\n\t\t\t\t\"Insertion -- moving 'down' the screen.\n\t\t\t\tShorten moveRectangle by height of insertion or ...\"\n\t\t\t\tobsoleteY <= newY\n\t\t\t\t\tifTrue:\t[moveRectangle corner:\n\t\t\t\t\t\t\t\tvisibleRectangle corner + (0 @ (obsoleteY - newY))]\n\t\t\t\t\tifFalse:\t[\"Deletion,\n\t\t\t\t\t\t\tand top of moveRectangle will fall above top of\n\t\t\t\t\t\t\tvisibleRectangle.  Increase the origin of moveRectangle\n\t\t\t\t\t\t\tby the amount that would fall above (hence outside)\n\t\t\t\t\t\t\tthe visibleRectangle.\"\n\t\t\t\t\t\t\tnewY < visibleRectangle top\n\t\t\t\t\t\t\t\tifTrue:\t[moveRectangle origin:\n\t\t\t\t\t\t\t\t\t\t\tvisibleRectangle left @\n\t\t\t\t\t\t\t\t\t\t\t\t(obsoleteY + visibleRectangle top - newY)]].\n\t\t\t\t\"Move'em.\"\n\t\t\t\tdestinationForm copyBits: moveRectangle from: destinationForm\n\t\t\t\t\tat: visibleRectangle left @ (newY max: visibleRectangle top)\n\t\t\t\t\t\tclippingBox: visibleRectangle rule: Form over mask: Form black.\n\t\t\t\t\"Display the new lines.\"\n\t\t\t\tself displayLines: (startLine to: stopLine).\n\t\t\t\t\"A deletion may have 'pulled' previously undisplayed lines into\n\t\t\t\tthe visibleRectangle.  If so, display them.\"\n\t\t\t\t(newY < obsoleteY and:\n\t\t\t\t\t[(self topAtLineIndex: obsoleteLastLine + 1) > visibleRectangle bottom])\n\t\t\t\t\tifTrue:\t[self displayLines:\n\t\t\t\t\t\t\t\t((self lineIndexOfTop:\n\t\t\t\t\t\t\t\t\t\tvisibleRectangle bottom - (obsoleteY - newY))\n\t\t\t\t\t\t\t\tto: (stopLine _\n\t\t\t\t\t\t\t\t\t\tself lineIndexOfTop: visibleRectangle bottom))]].\n\n\t\"If we have done a deletion, obsolete material may remain at the bottom of the visibleRectangle.  If so, clear it out.\"\n\tobsoleteLastLine >= lastLine\n\t\tifTrue:\t[\n\t\t\t\tnewY _ self topAtLineIndex: lastLine + 1.\n\t\t\t\tnewY < visibleRectangle top\n\t\t\t\t\tifTrue:\t[\"new lastLine is above visibleRectangle,\n\t\t\t\t\t\t\tclear entire visibleRectangle\"\n\t\t\t\t\t\t\tdestinationForm fill: visibleRectangle\n\t\t\t\t\t\t\t\trule: rule mask: Form white]\n\t\t\t\t\tifFalse:\t[destinationForm\n\t\t\t\t\t\t\t\tfill: ((visibleRectangle left @ newY\n\t\t\t\t\t\t\t\t\textent: visibleRectangle extent)\n\t\t\t\t\t\t\tintersect: visibleRectangle)\n\t\t\t\t\t\t\trule: rule mask: Form white]]].\n\tself updateCompositionHeight.\n",
          "destinationForm:": "destinationForm: aFormOrRectangle\n\t \"Set the Form or Rectangle into which the characters are scanned.  The destinationFrom is a Form when the outputMedium is #Display or #DisplayPrinterWidths, a Rectangle when the outputMedium is a #PressPrinter.\"\n\tdestinationForm _ aFormOrRectangle.\n",
          "mask": "mask\n\t\"Answer the form with which each character is combined by the scanner\n\tbefore applying the rule for display.\"\n\t^mask\n",
          "height": "height\n\t\"Answer the height of the composition rectangle.\"\n\t^compositionRectangle height\n",
          "baseline": "baseline\n\t\"Answer the baseline of my TextStyle.\"\n\t^textStyle baseline\n",
          "lineGrid": "lineGrid\n\t\"Answer the lineGrid of my TextStyle.\"\n\t^textStyle lineGrid\n",
          "clippingRectangle:": "clippingRectangle: aRectangle\n\t\"Set the rectangle, defined in absolute coordinates, whose intersection with the\n\tdestinationForm is the area in which the characters are constrained to display.\"\n\tclippingRectangle _ aRectangle.\n",
          "mask:": "mask: maskForm\n\t\"Set the argument, maskForm, to be the form with which each character is\n\tcombined by the scanner before applying the rule for display.\"\n\tmask _ maskForm.\n",
          "text:": "text: aText\n\t\"Set the argument, aText, to be the text for the receiver.\"\n\ttext _ aText.\n\tself composeAll\n"
        },
        "private": {
          "repositionAt:clippingBox:": "repositionAt: aPoint clippingBox: clippingBox\n\tcompositionRectangle moveTo: aPoint.\n\tclippingRectangle _ clippingBox.\n",
          "topAtLineIndex:": "topAtLineIndex: lineIndex\n\t\"top y of given line\"\n\n\t^compositionRectangle top + (lineIndex - 1 * textStyle lineGrid)\n",
          "lines:": "lines: anArray\n\t\"Install a new set of lines in the paragraph,  a tricky way to avoid recomposing when a press paragraph overflows a page.\"\n\tlines _ anArray.\n\t(lastLine _ (anArray indexOf: nil) - 1) = -1\n\t\tifTrue:\t[^ (lastLine _ anArray size)]\n\t\tifFalse:\t[^ lastLine].\n",
          "lines": "lines\n\t^lines\n",
          "visibleRectangle": "visibleRectangle\n\t^ (clippingRectangle intersect: compositionRectangle)\n\t\t\t\t\t\t\tintersect: destinationForm boundingBox\n",
          "trimLinesTo:": "trimLinesTo: lastLineInteger\n\t(lastLineInteger + 1 to: lastLine) do: [:i | lines at: i put: nil].\n\t(lastLine _ lastLineInteger) < (lines size // 2)\n\t\tifTrue: [lines _ lines copyFrom: 1 to: lines size - (lines size // 2)]\n",
          "lineAt:put:": "lineAt: indexInteger put: aTextLineInterval\n\t\"store a line, track last, and grow lines if necessary\"\n\n\tindexInteger > lastLine ifTrue: [lastLine _ indexInteger].\n\tlastLine > lines size ifTrue: [lines grow].\n\t^lines at: indexInteger put: aTextLineInterval\n",
          "rightMarginForDisplay": "rightMarginForDisplay\n\t\"Build the right margin for a line.\n\tDepends upon compositionRectangle rightSide, marginTabsLevel, and right indent.\"\n\n\t| scale |\n\tscale _ 1.\n\t^(compositionRectangle right -\n\t\trightIndent - (textStyle rightMarginTabAt: marginTabsLevel)) * scale\n",
          "compositionRectangleDelta": "compositionRectangleDelta\n\t\"A handy number -- mostly for scrolling\"\n\n\t^compositionRectangle top - clippingRectangle top\n",
          "lineIndexOfTop:": "lineIndexOfTop: top\n\t\"line index at a given top y\"\n\n\t^(top - compositionRectangle top // textStyle lineGrid + 1 max: 1)\n\t\tmin: lastLine\n",
          "leftMarginForDisplayForLine:": "leftMarginForDisplayForLine: lineIndex\n\t\"Build the left margin for display of a line.\n\tDepends upon leftMarginForComposition, compositionRectangle left, the outputMedium and\n\tthe alignment.\"\n\n\t| pad scale|\n\n\tscale _ 1.\n\t(textStyle alignment = LeftFlush or: [textStyle alignment = Justified])\n\t\tifTrue:\n\t\t\t[^((compositionRectangle left * scale)\n\t\t\t\t+ (self leftMarginForCompositionForLine: lineIndex))].\n\t\"When called from character location code and entire string has been cut,\n\tthere are no valid lines, hence following nil check.\"\n\t( lineIndex <= lines size and: [(lines at: lineIndex) ~~ nil])\n\t\tifTrue:\n\t\t\t[pad _ (lines at: lineIndex) paddingWidth]\n\t\tifFalse:\n\t\t\t[pad _\n\t\t\t\tcompositionRectangle width - firstIndent - rightIndent].\n\ttextStyle alignment = Centered\n\t\tifTrue:\n\t\t\t[^((compositionRectangle left * scale)\n\t\t\t\t+ (self leftMarginForCompositionForLine: lineIndex)) + (pad // 2)].\n\ttextStyle alignment = RightFlush\n\t\tifTrue:\n\t\t\t[^((compositionRectangle left * scale)\n\t\t\t\t+ (self leftMarginForCompositionForLine: lineIndex)) + pad].\n\tself error: ['no such alignment']\n",
          "compositionRectangle:text:style:offset:outputMedium:fitWidth:": "compositionRectangle: compositionRect text: aText style: aTextStyle offset: aPoint outputMedium: aSymbol fitWidth: aBoolean\n\t| paddingDelta lineIndex |\n\tcompositionRectangle _ compositionRect copy.\n\ttext _ aText.\n\ttextStyle _ aTextStyle.\n\tfirstIndent _ textStyle firstIndent.\n\trestIndent _ textStyle restIndent.\n\trightIndent _ textStyle rightIndent.\n\tmarginTabsLevel _ 0.\n\toutputMedium _ aSymbol.\n\tlines _ Array new: 32.\n\tlastLine _ 0.\n\trule _ DefaultRule.\n\tmask _ DefaultMask.\n\tdestinationForm _ Display.\n\tclippingRectangle _ destinationForm boundingBox.\n\toffset _ aPoint.\n\taBoolean\n\t\tifTrue:\t[\t\"save initial width of compositionRectangle\"\n\t\t\t\tpaddingDelta _ compositionRectangle width.\n\t\t\t\tcompositionRectangle width:\n\t\t\t\t\t(self composeAll \"returns fitted right margin\" - compositionRectangle left).\n\t\t\t\tpaddingDelta _ paddingDelta - compositionRectangle width.\n\t\t\t\t\t\"Have to shrink padding widths created when compositionRectangle was large.\"\n\t\t\t\t1 to: lastLine do:\n\t\t\t\t\t[:i | (lines at: i) paddingWidth: (lines at: i) paddingWidth - paddingDelta]]\n\t\tifFalse:\t[\"Composition rectangle sent in is the one desired no matter what the maximum\n\t\t\t\tright struck by the text.\"\n\t\t\t\tself composeAll].\n",
          "lineIndexOfCharacterIndex:": "lineIndexOfCharacterIndex: characterIndex\n\t\"line index for a given characterIndex\"\n\t1 to: lastLine do:\n\t\t[:lineIndex |\n\t\t(lines at: lineIndex) last >= characterIndex ifTrue: [^lineIndex]].\n\t^lastLine\n",
          "copyLines:": "copyLines: anInterval\n\t^lines copyFrom: anInterval first to: (anInterval last min: lastLine)\n",
          "leftMarginForCompositionForLine:": "leftMarginForCompositionForLine: lineIndex\n\t\"Build the left margin for composition of a line.\n\tDepends upon marginTabsLevel and the indent.\"\n\t| scale |\n\tscale _ 1.\n\tlineIndex = 1\n\t\tifTrue: [^(firstIndent + (textStyle leftMarginTabAt: marginTabsLevel)) * scale]\n\t\tifFalse: [^(restIndent + (textStyle leftMarginTabAt: marginTabsLevel)) * scale].\n",
          "removeFirstChars:": "removeFirstChars: numberOfChars\n\t\"Remove a number of characters from the beginning of the receiver, adjusting the composition rectangle so the displayed text moves as little as possible.  Special kludge for TextCollectorController.\"\n\t\"9/14/82 SBP\"\n\n\t| delta scrollDelta |\n\tdelta _ ((self lineIndexOfCharacterIndex: numberOfChars)-1)*self lineGrid.\n\tscrollDelta _ self compositionRectangleDelta negated.\n\tdelta > scrollDelta ifTrue:\n\t\t[delta _ scrollDelta. \t\"deleting some visible lines\"\n\t\tself clearVisibleRectangle].\n\tself replaceFrom: 1 to: numberOfChars with: '' asText displaying: false.\n\tcompositionRectangle moveBy: 0@delta.\n\tdelta = scrollDelta ifTrue: [self display]\n",
          "rightMarginForComposition": "rightMarginForComposition\n\t\"Build the right margin for a line.\n\tDepends upon compositionRectangle width, marginTabsLevel, and right\n\tindent.\"\n\t| scale |\n\n\tscale _ 1.\n\t^(compositionRectangle width\n\t\t- (textStyle rightMarginTabAt: marginTabsLevel) - rightIndent) * scale\n",
          "displayLines:": "displayLines: linesInterval\n\t\"This is the first level workhorse in the display portion of the TextForm routines.\n\tIt checks to see which lines in the interval are actually visible, has the\n\tDisplayScanner display only those, clears out the areas in which display will\n\toccur, and clears any space remaining in the visibleRectangle following the space\n\toccupied by lastLine.\"\n\n\t| lineGrid visibleRectangle topY firstLineIndex lastLineIndex lastLineIndexBottom |\n\tlineGrid _ textStyle lineGrid.\n\t\"Save some time by only displaying visible lines\"\n\tvisibleRectangle _\n\t\t(clippingRectangle intersect: compositionRectangle)\n\t\t\t  intersect: destinationForm boundingBox.\n\tfirstLineIndex _ self lineIndexOfTop: visibleRectangle top.\n\tfirstLineIndex < linesInterval first ifTrue: [firstLineIndex _ linesInterval first].\n\tlastLineIndex _ self lineIndexOfTop: visibleRectangle bottom - 1.\n\tlastLineIndex > linesInterval last\n\t\tifTrue:\n\t\t\t[linesInterval last > lastLine\n\t\t \t\tifTrue: [lastLineIndex _ lastLine]\n\t\t  \t\tifFalse: [lastLineIndex _ linesInterval last]].\n\t((Rectangle\n\t\torigin: visibleRectangle left @ (topY _ self topAtLineIndex: firstLineIndex)\n\t\tcorner: visibleRectangle right @\n\t\t\t\t\t(lastLineIndexBottom _ (self topAtLineIndex: lastLineIndex)\n\t\t\t\t\t  + lineGrid))\n\t  intersects: visibleRectangle)\n\t  \tifFalse: [\"None of lines in interval visible.\" ^self].\n\t\"Set boundingBox containing the lines in linesInterval to color for space surrounding\n\tthe characters.\"\n\tdestinationForm\n\t  fill: ((visibleRectangle left @ topY\n\t\t\t\textent: visibleRectangle width @ (lastLineIndexBottom - topY))\n\t\t  \tintersect: visibleRectangle)\n\t  rule: rule\n\t  mask: Form white.\n\tDisplayScanner new\n\t  displayLines: (firstLineIndex to: lastLineIndex)\n\t  in: self\n\t  clippedBy: visibleRectangle.\n\tlastLineIndex = lastLine\n\t\tifTrue:\n\t\t [destinationForm\n\t\t  fill: (visibleRectangle left @ lastLineIndexBottom\n\t\t\t\textent: visibleRectangle width @\n\t\t\t\t\t(visibleRectangle bottom - lastLineIndexBottom))\n\t\t  rule: rule\n\t\t  mask: Form white]\n",
          "textAt:": "textAt: lineIndex\n\t\"Return the text for the specified line (subclasses may override)\"\n\t^ text\n",
          "updateCompositionHeight": "updateCompositionHeight\n\t\"Mainly used to insure that intersections with compositionRectangle work.\"\n\n\tcompositionRectangle height: textStyle lineGrid * lastLine.\n\t(text size ~= 0 and: [(text at: text size) = CR])\n\t\tifTrue: [compositionRectangle\n\t\t\t\t\theight: compositionRectangle height + textStyle lineGrid]\n",
          "lineAt:": "lineAt: lineIndex\n\t\"Return the textLineInterval for the specified line\"\n\t^ lines at: lineIndex\n"
        },
        "display box access": {
          "boundingBox": "boundingBox\n\t^offset extent: compositionRectangle extent\n",
          "computeBoundingBox": "computeBoundingBox\n\t^offset extent: compositionRectangle extent\n"
        },
        "scrolling": {
          "scrollBy:grid:": "scrollBy: height grid: grid\n\t\"Change the composition rectangle such that the first line of text corresponds\n\tto the line at the current first line plus heightToMove, modulo the grid.\"\n\n\t| initialClippingRectangle heightToMove |\n\n\t\"keep from scrolling out of clippingRectangle\"\n\theightToMove _\n\t\t(height max: self compositionRectangleDelta).\n\t(heightToMove abs between: 0 and: grid)\n\t\tifTrue: [heightToMove _ heightToMove sign * grid]\n\t\tifFalse: [heightToMove _ heightToMove truncateTo: grid].\n\theightToMove  abs >= clippingRectangle height\n\t\tifTrue:\t[self clearVisibleRectangle.\n\t\t\t\t\"adjust compositionRectangle behind clippingRectangle\"\n\t\t\t\tcompositionRectangle moveBy:  (0 @ (0 - heightToMove)).\n\t\t\t\t\"If heightToMove >= clippingRectangle, all lines to be displayed are not\n\t\t\t\t\tcurrently displayed.\"\n\t\t\t\tself displayLines: (1 to: lastLine).\n\t\t\t\t^self].\n\n\t\"Adjust compositionRectangle behind clippingRectangle\"\n\tcompositionRectangle moveBy:  (0 @ (0 - heightToMove)).\n\t\"Need only to reshow part of clippingRectangle.\n\t\tSome of the lines are already on the display screen.\"\n\tinitialClippingRectangle _ clippingRectangle copy.\n\theightToMove  < 0\t\"Box the lines to be moved.\"\n\t\tifTrue:\t[\"Moving down.\"\n\t\t\t\tclippingRectangle _\n\t\t\t\t\tclippingRectangle insetOriginBy: (0 @ 0) cornerBy: (0 @ (0 - heightToMove ))]\n\t\t\tifFalse: [\"Moving up.\"\n\t\t\t\t\tclippingRectangle _\n\t\t\t\t\t\tclippingRectangle insetOriginBy: (0 @ heightToMove ) cornerBy: (0 @ 0)].\n\t\t\tdestinationForm\n\t\t\t\tcopyBits: clippingRectangle\n\t\t\t\tfrom: destinationForm\n\t\t\t\tat: clippingRectangle left @ (clippingRectangle top - heightToMove )\n\t\t\t\tclippingBox: initialClippingRectangle\n\t\t\t\trule: Form over\n\t\t\t\tmask: Form black.\n\n\t\"Make room in clippingRectangle for lines 'pulled' into view.\"\n\theightToMove < 0\n\t\tifTrue:\t[\"On the top.\"\n\t\t\t\t(clippingRectangle bottomRight) y: clippingRectangle top - heightToMove ]\n\t\tifFalse: [\"At the bottom.\"\n\t\t\t\t(clippingRectangle topLeft)\n\t\t\t\t\ty: (((self topAtLineIndex:\n\t\t\t\t\t\t\t(self lineIndexOfTop: clippingRectangle bottom - heightToMove)))\n\t\t\t\t\tmax: initialClippingRectangle topLeft y)].\n\n\t\t\"The reduced clippingRectangle informs the displayLines routine of what lines to actually display of those it is requested to display.  It only displays those actually falling in the clippingRectangle.\"\n\n\t\tself displayLines: (1 to: lastLine).\n\n\t\t\"If we've shortened so that bottom of compositionRectangle is < clippingRectangle, clear out the the potential garbage at the bottom of the clippingRectangle.\"\n\t\tcompositionRectangle bottom < initialClippingRectangle bottom\n\t\t\tifTrue:\t[destinationForm\n\t\t\t\t\t\tfill: (initialClippingRectangle left @ compositionRectangle bottom\n\t\t\t\t\t\t\t\tcorner: initialClippingRectangle bottomRight)\n\t\t\t\t\t\tmask: Form white].\n\n\t\"And the clippingRectangle needs to be set to its original value.\"\n\tclippingRectangle _ initialClippingRectangle.\n",
          "scrollBy:": "scrollBy: heightToMove\n\t\"Change the composition rectangle such that the first line of text corresponds\n\tto the line at the current first line plus heightToMove, modulo the grid of the\n\treceiver's textstyle.\"\n\tself scrollBy: heightToMove grid: textStyle lineGrid.\n"
        },
        "converting": {
          "asText": "asText\n\t\"Answer the receiver's text.\"\n\t^text\n",
          "asString": "asString\n\t\"Answer the string of characters of the receiver's text.\"\n\t^text string\n",
          "asForm": "asForm\n\t\"Answer a new Form made up of the bits that represent the receiver's\n\tdispayable text.\"\n\n\t| aForm saveDestinationForm |\n\taForm _ Form new extent: compositionRectangle extent.\n\tsaveDestinationForm _ destinationForm.\n\tself displayOn: aForm\n\t\tat: 0 @ 0\n\t\tclippingBox: aForm boundingBox\n\t\trule: Form over\n\t\tmask: Form black.\n\taForm offset: offset.\n\tdestinationForm _ saveDestinationForm.\n\t^aForm\n"
        },
        "alignment": {
          "rightFlush": "rightFlush\n\t\"Set the alignment for the style with which the receiver displays its text\n\tso that the characters in each of text end on an even border in the composition\n\trectangle but the beginning of each line does not (ragged-left).\"\n\ttextStyle alignment: RightFlush\n",
          "leftFlush": "leftFlush\n\t\"Set the alignment for the style with which the receiver displays its text\n\tso that the characters in each of text begin on an even border in the composition\n\trectangle.  This is also known as ragged-right.\"\n\ttextStyle alignment: LeftFlush.\n",
          "centered": "centered\n\t\"Set the alignment for the style with which the receiver displays its text\n\tso that text is centered in the composition rectangle.\"\n\ttextStyle alignment: Centered.\n",
          "justified": "justified\n\t\"Set the alignment for the style with which the receiver displays its text\n\tso that the characters in each of text end on an even border in the composition\n\trectangle.\"\n\ttextStyle alignment: Justified.\n",
          "toggleAlignment": "toggleAlignment\n\t\"Set the alignment for the style with which the receiver displays its text\n\tso that it moves from centered to justified to leftFlush to rightFlush and back\n\tto centered again.\"\n\ttextStyle alignment: textStyle alignment + 1.\n"
        }
      }
    },
    "InfiniteForm": {
      "comment": "I represent a Form obtained by replicating a pattern form indefinitely in all directions.\n",
      "class_name": "InfiniteForm",
      "superclass": "DisplayObject",
      "instanceVariables": "patternForm",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "with:": "with: aForm\n\t^self new form: aForm\n"
        }
      },
      "instance_methods": {
        "displaying": {
          "displayOn:at:clippingBox:rule:mask:": "displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger mask: aForm\n\t\"This is the real display message, but it doesn't get used until the new display protocol is installed.\"\n\t| targetBox patternBox |\n\t(aForm == Form black and: [patternForm extent = (16 @ 16)])\n\t\tifTrue:\n\t\t\t[\"Use patternForm as a mask for BitBlt\"\n\t\t\taDisplayMedium fill: clipRectangle rule: ruleInteger mask: patternForm]\n\t\tifFalse:\n\t\t\t[\"Do it iteratively\"\n\t\t\ttargetBox _ aDisplayMedium boundingBox intersect: clipRectangle.\n\t\t\tpatternBox _ patternForm boundingBox.\n\t\t\t(targetBox left truncateTo: patternBox width) to: targetBox right - 1 by: patternBox width do:\n\t\t\t\t[:x |\n\t\t\t\t(targetBox top truncateTo: patternBox height) to: targetBox bottom - 1 by: patternBox height do:\n\t\t\t\t\t[:y |\n\t\t\t\t\tpatternForm displayOn: aDisplayMedium\n\t\t\t\t\t\tat: x @ y\n\t\t\t\t\t\tclippingBox: clipRectangle\n\t\t\t\t\t\trule: ruleInteger\n\t\t\t\t\t\tmask: aForm]]]\n"
        },
        "accessing": {
          "form:": "form: aForm\n\tpatternForm _ aForm\n",
          "offset": "offset\n\t^0 @ 0\n"
        },
        "display box access": {
          "computeBoundingBox": "computeBoundingBox\n\t^0 @ 0 corner: SmallInteger maxVal @ SmallInteger maxVal\n"
        }
      }
    },
    "DisplayObject": {
      "comment": "The abstract protocol for most display primitives that are used by Views for presenting information on the screen.\n",
      "class_name": "DisplayObject",
      "superclass": "Object",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "displaying-Display": {
          "backgroundAt:": "backgroundAt: location\n\t\"Answer a Form containing the contents of the Display which will be altered\n\tif I am displayed at location.  The Form remembers location in its offset\"\n\n\t^ (Form fromDisplay: (location extent: self extent)) offset: location\n",
          "moveTo:restoring:": "moveTo: newLoc restoring: background\n\t\"Move an image to a new location on the Display, restoring the background\n\twithout causing flashing.  Background must be a Form containing\n\tthe bits to be restored at the previous location (its offset), and this method\n\twill update its bits and offset appropriately\"\n\n\t| location saveAll rect1 rect2 bothRects |\n\t\"This method should be rewritten to use the offset in background directly\"\n\t(location _ background offset) = newLoc ifTrue: [^background].\n\tbackground offset: 0@0.\n\trect1 _ location extent: self extent.\n\trect2 _ newLoc extent: self extent.\n\tbothRects _ rect1 merge: rect2.\n\t(rect1 intersects: rect2)\n\t\tifTrue:  \"When overlap, buffer background for both rectangles\"\n\t\t\t[saveAll _ Form fromDisplay: bothRects.\n\t\t\tbackground displayOn: saveAll at: rect1 origin - bothRects origin.\n\t\t\t\"now saveAll is clean background; get new bits for background\"\n\t\t\tbackground copy: (0@0 extent: self extent)\n\t\t\t\tfrom: rect2 origin - bothRects origin\n\t\t\t\tin: saveAll\n\t\t\t\trule: Form over.\n\t\t\tself displayOn: saveAll at: rect2 origin - bothRects origin.\n\t\t\tsaveAll displayOn: Display at: bothRects origin]\n\t\tifFalse: \"If no overlap, do the simple thing (bothrects might be too big)\"\n\t\t\t[background displayOn: Display at: location.\n\t\t\tbackground fromDisplay: rect2.\n\t\t\tself displayOn: Display at: newLoc].\n\t^ background offset: newLoc\n",
          "follow:while:": "follow: locationBlock while: durationBlock\n\t\"This method moves an image around on the Display.\n\tIt restores the background continuously without causing flashing.\n\tLocationBlock supplies each new location, and durationBlock supplies\n\ttrue to continue, and then false to stop.\n\tSee (or run) OpaqueForm example.\"\n\n\t| location background |\n\tlocation _ locationBlock value.\n\tbackground _ self backgroundAt: location.\n\tself displayAt: location.\n\t[durationBlock value] whileTrue:\n\t\t[self moveTo: locationBlock value restoring: background].\n\tbackground display\n",
          "display": "display\n\tself displayOn: Display\n",
          "displayAt:": "displayAt: aDisplayPoint\n\t\"Display the receiver located at aDisplayPoint with default settings for the\n\tdisplayMedium, rule and halftone.\"\n\n\tself displayOn: Display\n\t\tat: aDisplayPoint\n\t\tclippingBox: Display boundingBox\n\t\trule: Form over\n\t\tmask: Form black\n"
        },
        "truncation and round off": {
          "rounded": "rounded\n\t\"Convert the offset of the receiver to integer coordinates.\"\n\n\tself offset: self offset rounded\n"
        },
        "transforming": {
          "align:with:": "align: alignmentPoint with: relativePoint\n\t\"Translate the receiver's offset such that alignmentPoint aligns with relativePoint.\"\n\n\tself offset: (self offset translateBy: relativePoint - alignmentPoint)\n",
          "scaleBy:": "scaleBy: aPoint\n\t\"Scale the receiver's offset by aPoint.\"\n\n\tself offset: (self offset scaleBy: aPoint)\n",
          "translateBy:": "translateBy: aPoint\n\t\"Translate the receiver's offset.\"\n\n\tself offset: (self offset translateBy: aPoint)\n"
        },
        "displaying-generic": {
          "displayOn:at:": "displayOn: aDisplayMedium at: aDisplayPoint\n\t\"Display the receiver located at aDisplayPoint with default settings for rule and halftone.\"\n\n\tself displayOn: aDisplayMedium\n\t\tat: aDisplayPoint\n\t\tclippingBox: aDisplayMedium boundingBox\n\t\trule: Form over\n\t\tmask: Form black\n",
          "displayOn:transformation:clippingBox:align:with:rule:mask:": "displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle align: alignmentPoint with: relativePoint rule: ruleInteger mask: aForm\n\t\"Display the receiver where a DisplayTransformation is provided as an argument,\n\trule is ruleInteger and mask is aForm.  Translate by relativePoint-alignmentPoint.\n\tInformation to be displayed must be confined to the area that intersects with\n\tclipRectangle.\"\n\n\t| absolutePoint |\n\tabsolutePoint _ displayTransformation applyTo: relativePoint.\n\tself displayOn: aDisplayMedium\n\t\tat: (absolutePoint - alignmentPoint)\n\t\tclippingBox: clipRectangle\n\t\trule: ruleInteger\n\t\tmask: aForm\n",
          "displayOn:at:rule:": "displayOn: aDisplayMedium at: aDisplayPoint rule: ruleInteger\n\t\"Display the receiver located at aPoint with default setting for the halftone and clippingBox.\"\n\n\tself displayOn: aDisplayMedium\n\t\tat: aDisplayPoint\n\t\tclippingBox: aDisplayMedium boundingBox\n\t\trule: ruleInteger\n\t\tmask: Form black\n",
          "displayOn:transformation:clippingBox:rule:mask:": "displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle rule: ruleInteger mask: aForm\n\t\"Display the receiver where a DisplayTransformation is provided as an argument,\n\trule is ruleInteger and mask is aForm.  No translation.  Information to be displayed\n\tmust be confined to the area that intersects with clipRectangle.\"\n\n\tself displayOn: aDisplayMedium\n\t\ttransformation: displayTransformation\n\t\tclippingBox: clipRectangle\n\t\talign: self relativeRectangle origin\n\t\twith: self relativeRectangle origin\n\t\trule: ruleInteger\n\t\tmask: aForm\n",
          "displayOn:at:clippingBox:rule:mask:": "displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger mask: aForm\n\t\"This is the basic display primitive for graphic display objects.  Display\n\tthe receiver located at aDisplayPoint with rule, ruleInteger, and mask,\n\taForm.  Information to be displayed must be confined to the area that\n\tintersects with clipRectangle.\"\n\n\tself subclassResponsibility\n",
          "displayOn:at:clippingBox:": "displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle\n\t\"Display the receiver located at aDisplayPoint with default settings for rule and\n\thalftone.  Information to be displayed must be confined to the area that intersects\n\twith clipRectangle.\"\n\n\tself displayOn: aDisplayMedium\n\t\tat: aDisplayPoint\n\t\tclippingBox: clipRectangle\n\t\trule: Form over\n\t\tmask: Form black\n",
          "displayOn:transformation:clippingBox:align:with:": "displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle align: alignmentPoint with: relativePoint\n\t\"Display primitive where a DisplayTransformation is provided as an argument,\n\trule is over and mask is Form black.  Information to be displayed must be confined\n\tto the area that intersects with clipRectangle.\"\n\n\tself displayOn: aDisplayMedium\n\t\ttransformation: displayTransformation\n\t\tclippingBox: clipRectangle\n\t\talign: alignmentPoint\n\t\twith: relativePoint\n\t\trule: Form over\n\t\tmask: Form black\n",
          "displayOn:transformation:clippingBox:": "displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle\n\t\"Display primitive for the receiver where a DisplayTransformation is provided\n\tas an argument.  Alignment is defaulted to the receiver's rectangle.  Information\n\tto be displayed must be confined to the area that intersects with clipRectangle.\"\n\n\tself displayOn: aDisplayMedium\n\t\ttransformation: displayTransformation\n\t\tclippingBox: clipRectangle\n\t\talign: self relativeRectangle center\n\t\twith: self relativeRectangle center\n\t\trule: Form over\n\t\tmask: Form black\n",
          "displayOn:transformation:clippingBox:fixedPoint:": "displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle fixedPoint: aPoint\n\t\"Display the receiver where a DisplayTransformation is provided as an argument,\n\trule is over and mask is Form black.  No translation.  Information to be displayed\n\tmust be confined to the area that intersects with clipRectangle.\"\n\n\tself displayOn: aDisplayMedium\n\t\ttransformation: displayTransformation\n\t\tclippingBox: clipRectangle\n\t\talign: aPoint\n\t\twith: aPoint\n\t\trule: Form over\n\t\tmask: Form black\n",
          "displayOn:": "displayOn: aDisplayMedium\n\t\"Simple default display in order to see the receiver in the upper left corner of\n\tscreen.\"\n\n\tself displayOn: aDisplayMedium at: 0 @ 0\n"
        },
        "accessing": {
          "width": "width\n\t\"Answer the number that represents the width of the receiver's bounding box.\"\n\t^self boundingBox width\n",
          "extent": "extent\n\t\"Answer the point that represents the width and height of the\n\treceiver's bounding box.\"\n\t^self boundingBox extent\n",
          "height": "height\n\t\"Answer the number that represents the height of the receiver's bounding box.\"\n\t^self boundingBox height\n",
          "offset:": "offset: aPoint\n\t\"Set the amount by which the receiver's position is offset.\"\n\t^self\n",
          "offset": "offset\n\t\"Answer the amount by which the receiver should be offset when\n\tit is displayed or its position is tested.\"\n\n\tself subclassResponsibility\n",
          "relativeRectangle": "relativeRectangle\n\t\"Answer a Rectangle whose top left corner is the receiver's offset position\n\tand whose width and height are the same as the receiver.\"\n\n\t^Rectangle origin: self offset extent: self extent\n"
        },
        "display box access": {
          "boundingBox": "boundingBox\n\t\"Answer the rectangular area that represents the boundaries of the\n\treceiver's space of information.\"\n\n\t^self computeBoundingBox\n",
          "computeBoundingBox": "computeBoundingBox\n\t\"Answer the rectangular area that represents the boundaries of the\n\treceiver's area for displaying information.  This is the primitive for computing the\n\tarea if it is not already known.\"\n\n\tself subclassResponsibility\n"
        }
      }
    },
    "Path": {
      "comment": "This is the basic superclass of the Graphic Spatial Primitives.  Spatial Primitives are used to generate \"trajactories\" or paths like lines and circles.  The\ninstance variable form is the \"brush\" used for displaying the Path:  the image is accomplished by displaying the form at each point in the Path.\n",
      "class_name": "Path",
      "superclass": "DisplayObject",
      "instanceVariables": "form collectionOfPoints",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t^self basicNew initializeCollectionOfPoints\n",
          "new:": "new: anInteger\n\t^self basicNew initializeCollectionOfPoints: anInteger\n"
        },
        "examples": {
          "example": "example\n\t\"Creates a Path from mousePoints and displays it several ways on the display\n\tscreen.  Messes up the display. for learning about class Path.\n\tjust select the code below and execute it to create a path and see it redisplayed in\n\tanother place on the screen.  Each path displays using a different form.  A path\n\tis indicated by pressing the red mouse button in sequence;  press any other\n\tmouse button to terminate.\"\n\n\t| aPath aForm p1 f1 flag |\n\taForm _ Form new extent: 2 @ 40.\n\t\"creates a form one inch long\"\n\taForm black.\n\t\"turns it black\"\n\taPath _ Path new.\n\taPath form: aForm.\n\t\"use the long black form for display\"\n\tflag _ true.\n\t[flag]\n\t\twhileTrue:\n\t\t\t[Sensor waitButton.\n\t\t\tSensor redButtonPressed\n\t\t\t\tifTrue:\n\t\t\t\t\t[aPath add: Sensor waitButton.\n\t\t\t\t\tSensor waitNoButton.\n\t\t\t\t\taForm displayOn: Display at: aPath last]\n\t\t\t\tifFalse: [flag _ false]].\n\tDisplay white.\n\taPath displayOn: Display.\t\t\t\"the original path\"\n\tp1 _ aPath translateBy: 0 @ 300.\n\tf1 _ Form new extent: 40 @ 40.\n\tf1 gray.\n\tp1 form: f1.\n\tp1 displayOn: Display.\t\t\"the translated path\"\n\tSensor waitNoButton\n\n\t\"Path example.\"\n"
        }
      },
      "instance_methods": {
        "transforming": {
          "scaleBy:": "scaleBy: aPoint\n\t\"Answers with a new Path scaled by aPoint.  Does not effect the current data in\n\tthis Path.\"\n\n\t| newPath |\n\tnewPath _ Path new: self size.\n\tnewPath form: self form.\n\tcollectionOfPoints do:\n\t\t[:element |\n\t\tnewPath add:\n\t\t\t\t(aPoint x * element x) truncated @ (aPoint y * element y) truncated].\n\t^newPath\n",
          "translateBy:": "translateBy: aPoint\n\t\"Answers with a new instance of Path whose elements are translated by aPoint.\n\tDoes not effect the elements of this Path.\"\n\n\t| newPath |\n\tnewPath _ Path new: self size.\n\tnewPath form: self form.\n\tcollectionOfPoints do:\n\t\t[:element |\n\t\tnewPath add:\n\t\t\t(element x + aPoint x) truncated @ (element y + aPoint y) truncated].\n\t^newPath\n"
        },
        "displaying": {
          "displayOn:transformation:clippingBox:rule:mask:": "displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle rule: ruleInteger mask: aForm\n\t\"Displays this path, translated and scaled by aTransformation.\"\n\t\"get the scaled and translated Path.\"\n\n\t| newPath transformedPath |\n\ttransformedPath _ displayTransformation applyTo: self.\n\tnewPath _ Path new.\n\ttransformedPath do: [:point | newPath add: point].\n\tnewPath form: self form.\n\tnewPath\n\t\tdisplayOn: aDisplayMedium\n\t\tat: 0 @ 0\n\t\tclippingBox: clipRectangle\n\t\trule: ruleInteger\n\t\tmask: aForm\n",
          "displayOn:at:clippingBox:rule:mask:": "displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger mask: aForm\n\t\"Display this Path--offset by aPoint, clipped by clipRect and the form\n\tassociated with this Path will be displayedr according to one of the sixteen\n\tfunctions of two logical variables (rule). Also the source form will be first\n\tanded with aForm as a mask. Does not effect the state of the Path\"\n\n\tcollectionOfPoints do:\n\t\t[:element |\n\t\tself form\n\t\t\tdisplayOn: aDisplayMedium\n\t\t\tat: element + aDisplayPoint\n\t\t\tclippingBox: clipRectangle\n\t\t\trule: ruleInteger\n\t\t\tmask: aForm]\n"
        },
        "testing": {
          "isEmpty": "isEmpty\n\t^collectionOfPoints isEmpty\n"
        },
        "accessing": {
          "first": "first\n\t\"Answer the first point on the receiver's path.\"\n\t^collectionOfPoints first\n",
          "thirdPoint": "thirdPoint\n\t\"Answer the third element of the receiver.\"\n\t^collectionOfPoints at: 3\n",
          "form": "form\n\t\"Answer the receiver's form. If form is nil then a 1 x 1 black form (a\n\tblack dot) is answered.\"\n\n\t| aForm |\n\tform == nil\n\t\tifTrue:\n\t\t\t[aForm _ Form new extent: 1 @ 1.\n\t\t\taForm black.\n\t\t\t^aForm]\n\t\tifFalse:\n\t\t\t[^form]\n",
          "secondPoint": "secondPoint\n\t\"Answer the second element of the receiver.\"\n\n\t^collectionOfPoints at: 2\n",
          "firstPoint": "firstPoint\n\t\"Answer the first point on the receiver's path.\"\n\t^collectionOfPoints first\n",
          "secondPoint:": "secondPoint: aPoint\n\t\"Answer the argument aPoint.  Replace the second element of the receiver\n\twith the new value aPoint.\"\n\n\tcollectionOfPoints at: 2 put: aPoint.\n\t^aPoint\n",
          "firstPoint:": "firstPoint: aPoint\n\t\"Answer the argument aPoint.  Replace the first element of the receiver\n\twith the new value aPoint.\"\n\n\tcollectionOfPoints at: 1 put: aPoint.\n\t^aPoint\n",
          "at:put:": "at: index put: aPoint\n\t\"Store the argument, aPoint, as the point on the receiver's path at position index.\"\n\t^collectionOfPoints at: index put: aPoint\n",
          "at:": "at: index\n\t\"Answer the point on the receiver's path at position index.\"\n\t^collectionOfPoints at: index\n",
          "last": "last\n\t\"Answer the last point on the receiver's path.\"\n\t^collectionOfPoints last\n",
          "thirdPoint:": "thirdPoint: aPoint\n\t\"Answer the argument aPoint.  Replace the third element of the receiver\n\twith the new value aPoint.\"\n\n\tcollectionOfPoints at: 3 put: aPoint.\n\t^aPoint\n",
          "form:": "form: aForm\n\t\"Make the argument, aForm, the receiver's form.\"\n\tform _ aForm\n",
          "size": "size\n\t\"Answer the length of the receiver.\"\n\t^collectionOfPoints size\n",
          "offset": "offset\n\t\"There are basically two kinds of display objects in the system:  those that, when\n\tasked to transform themselves, create a new object;  and those that side effect\n\tthemselves by maintaining a record of the transformation request (typically\n\tan offset).  Path, like Rectangle and Point, is a display object of the first kind.\"\n\n\tself shouldNotImplement\n"
        },
        "private": {
          "initializeCollectionOfPoints": "initializeCollectionOfPoints\n\tcollectionOfPoints _ OrderedCollection new\n",
          "initializeCollectionOfPoints:": "initializeCollectionOfPoints: anInteger\n\tcollectionOfPoints _ OrderedCollection new: anInteger\n"
        },
        "display box access": {
          "computeBoundingBox": "computeBoundingBox\n\t| box |\n\tbox _ Rectangle origin: (self at: 1) extent: 0 @ 0.\n\tcollectionOfPoints do:\n\t\t[:aPoint | box _ box merge: (Rectangle origin: aPoint extent: 0 @ 0)].\n\t^box\n"
        },
        "enumerating": {
          "collect:": "collect: aBlock\n\t\"Evaluate aBlock with each of the receiver's elements as the argument.  Collect the\n\tresulting values into a collection that is like the receiver.  Answer the new\n\tcollection.\"\n\n\t| newCollection |\n\tnewCollection _ collectionOfPoints collect: aBlock.\n\tnewCollection form: self form.\n\t^newCollection\n",
          "select:": "select: aBlock\n\t\"Evaluate aBlock with each of the receiver's elements as the argument.\n\tCollect into a new collection like the receiver, only those elements for which\n\taBlock evaluates to true.  Answer the new collection.\"\n\n\t| newCollection |\n\tnewCollection _ collectionOfPoints select: aBlock.\n\tnewCollection form: self form.\n\t^newCollection\n"
        },
        "adding": {
          "add:": "add: aPoint\n\t\"Include aPoint as one of the receiver's elements.\"\n\tcollectionOfPoints add: aPoint\n"
        },
        "removing": {
          "removeAllSuchThat:": "removeAllSuchThat: aBlock\n\t\"Evaluate aBlock for each element of the receiver.  Remove each element for\n\twhich aBlock evaluates to true.\"\n\n\t| newCollection |\n\tnewCollection _ collectionOfPoints removeAllSuchThat: aBlock.\n\tnewCollection form: self form.\n\t^newCollection\n"
        }
      }
    },
    "DisplayScreen": {
      "comment": "There is only one instance of me, CurrentDisplay.  It is a global and is used to handle general user requests to deal with the whole display screen.  Although I offer no protocol, my name provides a way to distinguish this special instance from all other Forms.\n",
      "class_name": "DisplayScreen",
      "superclass": "Form",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "current display": {
          "currentDisplay:": "currentDisplay: form\n\t\"Make the argument, form, be the form representing the current display\n\tscreen.  Create an error if form is not an instance of me.\"\n\n\tform class == self\n\t\tifTrue:\n\t\t\t[form bits class == DisplayBitmap\n\t\t\t\tifTrue:\n\t\t\t\t\t[Display become: form.\n\t\t\t\t\tDisplay beDisplay]\n\t\t\t\tifFalse:\n\t\t\t\t\t[self error: 'bitmap should be DisplayBitmap']]\n\t\tifFalse: [self error: 'form should be DisplayForm']\n",
          "displayHeight:": "displayHeight: height\n\t\"Make the height of the current display screen form be the argument, height.\"\n\n\t^self displayExtent: self boundingBox width @ height\n",
          "displayExtent:": "displayExtent: extent\n\t\"Make the width and height of the current display screen form be extent.\"\n\n\t| w h |\n\tw _ extent x truncateTo: 32.\n\th _ extent y truncateTo: 2.\n\tDisplayScreen currentDisplay:\n\t\t(DisplayScreen new\n\t\t\textent: w @ 16\n\t\t\toffset: 0 @ 0\n\t\t\tbits: (DisplayBitmap new: w // 16 * 16)).\n\t\"shrink to 16 to release old bitmap\"\n\tDisplayScreen currentDisplay:\n\t\t(DisplayScreen new\n\t\t\textent: w @ h\n\t\t\toffset: 0 @ 0\n\t\t\tbits: (DisplayBitmap new: w // 16 * h)).\n\t\"now grow to new size\"\n\tScheduledControllers restore\n"
        },
        "display box access": {
          "boundingBox": "boundingBox\n\t\"Answer the bounding box for the form representing the current display screen.\"\n\t^Display boundingBox\n"
        }
      },
      "instance_methods": {
        "displaying": {
          "flash:": "flash: aRectangle\n\t\"Complement twice the area of the screen defined by the argument, aRectangle.\"\n\n\t2 timesRepeat:\n\t\t[self fill: aRectangle\n\t\t\trule: Form reverse\n\t\t\tmask: Form black.\n\t\t(Delay forMilliseconds: 60) wait]\n",
          "beDisplay": "beDisplay\n\t\"Tell the interpreter to use the receiver as the current display image.  Fail if the\n\tform is too wide to fit on the physical display.  Essential.  See Object\n\tdocumentation whatIsAPrimitive.\"\n\n\t<primitive: 102>\n\tself primitiveFailed\n"
        }
      }
    },
    "DisplayMedium": {
      "comment": "I am a display object which can both paint myself on a medium (displayOn: messages), and can act as a medium myself.  My chief subclass is Form.\n",
      "class_name": "DisplayMedium",
      "superclass": "DisplayObject",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "bordering": {
          "border:width:mask:": "border: aRectangle width: borderWidth mask: aHalfTone\n\t\"Paint a border whose rectangular area is defined by aRectangle.  The width of\n\tthe border of each side is borderWidth.  Uses aHalfTone for drawing the border.\"\n\tself border: aRectangle\n\t\twidthRectangle:\n\t\t\t(Rectangle\n\t\t\t\tleft: borderWidth\n\t\t\t\tright: borderWidth\n\t\t\t\ttop: borderWidth\n\t\t\t\tbottom: borderWidth)\n\t\tmask: aHalfTone\n",
          "border:widthRectangle:mask:clippingBox:": "border: aRectangle widthRectangle: insets mask: aHalfTone clippingBox: clipRect\n\t\"Paint a border whose rectangular area is defined by aRectangle.  The width of\n\teach edge of the border is determined by the four coordinates of insets.\n\tUses aHalfTone for drawing the border.\"\n\t(aRectangle areasOutside: (aRectangle insetBy: insets)) do:\n\t\t[:edgeStrip | self fill: (edgeStrip intersect: clipRect) mask: aHalfTone]\n",
          "border:width:": "border: aRectangle width: borderWidth\n\t\"Paint a border whose rectangular area is defined by aRectangle.  The width of\n\tthe border of each side is borderWidth.  Uses Form black for drawing the border.\"\n\tself border: aRectangle\n\t\twidth: borderWidth\n\t\tmask: Form black\n",
          "border:widthRectangle:mask:": "border: aRectangle widthRectangle: insets mask: aHalfTone\n\t\"Paint a border whose rectangular area is defined by aRectangle.  The width of\n\teach edge of the border is determined by the four coordinates of insets.\n\tUses aHalfTone for drawing the border.\"\n\t(aRectangle areasOutside: (aRectangle insetBy: insets)) do:\n\t\t[:edgeStrip | self fill: edgeStrip mask: aHalfTone]\n"
        },
        "displaying": {
          "drawLine:from:to:clippingBox:rule:mask:": "drawLine: sourceForm from: beginPoint to: endPoint clippingBox: clipRect rule: anInteger mask: aForm\n\tself subclassResponsibility\n",
          "copyBits:from:at:clippingBox:rule:mask:": "copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule mask: aForm\n\t\"Make up a BitBlt table and copy the bits.\"\n\tself subclassResponsibility\n"
        },
        "coloring": {
          "veryLightGray:": "veryLightGray: aRectangle\n\t\"Set all bits in the receiver's area defined by aRectangle to the veryLightGray mask.\"\n\tself fill: aRectangle rule: Form over mask: Form veryLightGray\n",
          "gray:": "gray: aRectangle\n\t\"Set all bits in the receiver's area defined by aRectangle to the gray mask.\"\n\tself fill: aRectangle rule: Form over mask: Form gray\n",
          "darkGray": "darkGray\n\t\"Set all bits in the receiver to darkGray.\"\n\tself fill: self boundingBox\n\t\tmask: Form darkGray\n",
          "fill:rule:mask:": "fill: aRectangle rule: anInteger mask: aForm\n\t\"Replace a rectangular area of the receiver with the pattern described by aForm\n\taccording to the rule anInteger.\"\n\tself subclassResponsibility\n",
          "lightGray": "lightGray\n\t\"Set all bits in the receiver to lightGray.\"\n\tself fill: self boundingBox\n\t\tmask: Form lightGray\n",
          "gray": "gray\n\t\"Set all bits in the receiver to gray.\"\n\tself fill: self boundingBox\n\t\tmask: Form gray\n",
          "black:": "black: aRectangle\n\t\"Set all bits in the receiver's area defined by aRectangle to black (ones).\"\n\tself fill: aRectangle rule: Form over mask: Form black\n",
          "fill:": "fill: aRectangle\n\t\"Fill aRectangle with the default background, Form gray.\"\n\tself fill: aRectangle rule: Form over mask: Form gray\n",
          "black": "black\n\t\"Set all bits in the receiver to black (ones).\"\n\n\tself fill: self boundingBox\n\t\tmask: Form black\n",
          "reverse:mask:": "reverse: aRectangle mask: aMask\n\t\"Change all the bits in the receiver's area that intersects with aRectangle\n\taccording to the mask.  Black does not necessarily turn to white, rather it\n\tchanges with respect to the rule and the bit in a corresponding mask location.\n\tBound to give a surprise.\"\n\tself fill: aRectangle rule: Form reverse mask: aMask\n",
          "fill:mask:": "fill: aRectangle mask: aForm\n\t\"Replace a rectangular area of the receiver with the pattern described by aForm\n\taccording to the rule over.\"\n\tself fill: aRectangle rule: Form over mask: aForm\n",
          "reverse:": "reverse: aRectangle\n\t\"Change all the bits in the receiver's area that intersects with aRectangle\n\tthat are white to black, and the ones that are black to white.\"\n\tself fill: aRectangle rule: Form reverse mask: Form black\n",
          "lightGray:": "lightGray: aRectangle\n\t\"Set all bits in the receiver's area defined by aRectangle to the lightGray mask.\"\n\tself fill: aRectangle rule: Form over mask: Form lightGray\n",
          "reverse": "reverse\n\t\"Change all the bits in the receiver that are white to black, and the ones\n\tthat are black to white.\"\n\tself fill: self boundingBox\n\t\trule: Form reverse\n\t\tmask: Form black\n",
          "darkGray:": "darkGray: aRectangle\n\t\"Set all bits in the receiver's area defined by aRectangle to the darkGray mask.\"\n\tself fill: aRectangle rule: Form over mask: Form darkGray\n",
          "veryLightGray": "veryLightGray\n\t\"Set all bits in the receiver to veryLightGray.\"\n\tself fill: self boundingBox\n\t\tmask: Form veryLightGray\n",
          "white:": "white: aRectangle\n\t\"Set all bits in the receiver's area defined by aRectangle to white (zeros).\"\n\tself fill: aRectangle rule: Form over mask: Form white\n",
          "white": "white\n\t\"Set all bits in the form to white ( to zeros).\"\n\tself fill: self boundingBox\n\t\tmask: Form white\n"
        }
      }
    },
    "OpaqueForm": {
      "comment": "OpaqueForms include a shape as well as a figure form.  The shape indicates what part of the background should get occluded in displaying, so that patterns other than black in the figure form will still appear opaque.\n",
      "class_name": "OpaqueForm",
      "superclass": "DisplayObject",
      "instanceVariables": "figure shape",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "shape:": "shape: aSolidForm\n\t\"Results in a form which is black where aSolidForm is black\n\tand transparent where aSolidForm is white.\"\n\t^ self new setFigure: aSolidForm shape: aSolidForm\n",
          "figure:shape:": "figure: figureForm shape: shapeForm\n\t^ self new setFigure: figureForm shape: shapeForm\n"
        },
        "examples": {
          "example": "example\n\tCursor blank showWhile:\n\t\t[self makeStar follow: [Sensor cursorPoint] while: [Sensor noButtonPressed]]\n\n\t\"OpaqueForm example\"\n\t\"OpaqueForm makeStar bitEdit\"\n",
          "makeStar": "makeStar\n\t| figure shape pen formRect |\n\tformRect_ 0@0 extent: 50@50.\n\tpen _ Pen new.\n\tpen defaultNib: 2.\n\tDisplay fill: formRect mask: Form white.\n\tpen north; place: formRect center; spiral: 45 angle: 144.\n\tshape _ Form fromDisplay: formRect.\n\tpen white; north; place: formRect center; spiral: 30 angle: 144.\n\tfigure _ Form fromDisplay: formRect.\n\t^ OpaqueForm figure: figure shape: shape\n"
        }
      },
      "instance_methods": {
        "printing": {
          "storeOn:": "storeOn: aStream\n\taStream nextPutAll: 'OpaqueForm figure: ('.\n\tfigure storeOn: aStream.\n\taStream nextPutAll: ') shape: ('.\n\tshape storeOn: aStream.\n\taStream nextPutAll: ')'\n"
        },
        "displaying": {
          "displayOn:transformation:clippingBox:align:with:rule:mask:": "displayOn: Display transformation: displayTransformation clippingBox: clipRectangle align: alignmentPoint with: relativePoint rule: ruleInteger mask: aForm\n\t\"See comment in Form.\"\n\tshape displayOn: Display transformation: displayTransformation clippingBox: clipRectangle align: alignmentPoint with: relativePoint rule: Form erase mask: nil.\n\tfigure displayOn: Display transformation: displayTransformation clippingBox: clipRectangle align: alignmentPoint with: relativePoint rule: Form under mask: aForm\n",
          "displayOn:at:clippingBox:rule:mask:": "displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger mask: aForm\n\t\"This is the real display message, but it doesn't get used until the new display protocol is installed.\"\n\tshape displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: Form erase mask: nil.\n\tfigure displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: Form under mask: aForm\n",
          "copyBits:from:at:clippingBox:rule:mask:": "copyBits: copyRect from: sourceForm at: destPoint clippingBox: clipRect rule: rule mask: mask\n\t| sourceFigure sourceShape |\n\t(sourceForm isMemberOf: OpaqueForm)\n\t\tifTrue:\n\t\t\t[sourceFigure _ sourceForm figure.\n\t\t\tsourceShape _ sourceForm shape]\n\t\tifFalse: [sourceFigure _ sourceShape _ sourceForm].\n\tfigure copyBits: copyRect\n\t\tfrom: sourceFigure\n\t\tat: destPoint\n\t\tclippingBox: clipRect\n\t\trule: rule\n\t\tmask: mask.\n\tshape copyBits: copyRect\n\t\tfrom: sourceShape\n\t\tat: destPoint\n\t\tclippingBox: clipRect\n\t\trule: rule\n\t\tmask: mask\n"
        },
        "copying": {
          "deepCopy": "deepCopy\n\t^ self shallowCopy setFigure: figure deepCopy shape: shape deepCopy\n"
        },
        "editing": {
          "bitEdit": "bitEdit\n\t\"Create and schedule a view located in an area designated by the user that\n\tcontains a view of the receiver magnified by 8@8 that can be modified\n\tusing the Bit Editor.  It also contains a view of the original form.\"\n\n\tBitEditor openOnForm: self\n\n\t\"OpaqueForm makeStar bitEdit.\"\n"
        },
        "accessing": {
          "shape": "shape\n\t^ shape\n",
          "offset": "offset\n\t^ figure offset\n",
          "figure": "figure\n\t^ figure\n"
        },
        "private": {
          "setFigure:shape:": "setFigure: figureForm shape: shapeForm\n\tfigure _ figureForm.\n\tshape _ shapeForm\n"
        },
        "display box access": {
          "computeBoundingBox": "computeBoundingBox\n\t^figure boundingBox\n"
        },
        "pattern": {
          "valueAt:": "valueAt: aPoint\n\t\"0 and 1 are white and black;  2 is transparent.\n\t3 is a weird value which look like 1\"\n\t(shape valueAt: aPoint) = 1\n\t\tifTrue: [^ figure valueAt: aPoint]  \"opaque\"\n\t\tifFalse: [^ 2 + (figure valueAt: aPoint)]  \"background shows through\"\n",
          "valueAt:put:": "valueAt: aPoint put: value\n\t\"0 and 1 are white and black;  2 is transparent.\n\t3 is a weird value which look like 1\"\n\tshape valueAt: aPoint put: 1 - (value//2).\n\tfigure valueAt: aPoint put: value\\\\2\n"
        }
      }
    }
  },
  "Graphics-Editors": {
    "FormMenuController": {
      "comment": "Adds keyboard mapping to the menu selection.\n",
      "class_name": "FormMenuController",
      "superclass": "Controller",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "control defaults": {
          "isControlWanted": "isControlWanted\n\t\"Answer true if the cursor is inside the inset display box (see\n\tView|insetDisplayBox) of the receiver's view, and answer false,\n\totherwise. It is sent by Controller|controlNextLevel in order to determine\n\twhether or not control should be passed to this receiver from the Controller of\n\tthe superView of this receiver's view.\"\n\n\t^sensor keyboardPressed | self viewHasCursor\n",
          "isControlActive": "isControlActive\n\t\"Answer false if the blue mouse button is pressed and the cursor is outside of\n\tthe inset display box of the Controller's view;  answer true, otherwise.\"\n\n\t^sensor keyboardPressed |\n\t\t(view containsPoint: sensor cursorPoint) & sensor blueButtonPressed not\n",
          "controlActivity": "controlActivity\n\t\"Pass control to a subView corresponding to a pressed keyboard key or to a mouse\n\tbutton pressed, if any.\"\n\n\tsensor keyboardPressed\n\t\tifTrue: [self processMenuKey]\n\t\tifFalse: [self controlToNextLevel]\n",
          "processMenuKey": "processMenuKey\n\t\"The user typed a key on the keyboard.  Give control to the subView that\n\tis selected by this key.\"\n\n\t| aView |\n\taView _ view subViewContainingCharacter: sensor keyboard.\n\taView ~~ nil\n\t\tifTrue: [aView controller sendMessage]\n"
        }
      }
    },
    "FormEditor": {
      "comment": "This is the basic Form Editor provided in Smalltalk for\n\t\t\t\tcreating and modifying Forms.  This is intended to be\n\t\t\t\tan easy to use general-purpose picture (bitMap) editor.\n",
      "class_name": "FormEditor",
      "superclass": "MouseMenuController",
      "instanceVariables": "form tool grid togglegrid mode previousTool color unNormalizedColor xgridOn ygridOn toolMenu underToolMenu",
      "classInstanceVariables": "",
      "classVariables": "BitEditKey BlackKey BlockKey ChangeGridsKey CurveKey DarkGrayKey EraseKey FlashCursor GrayKey InKey LightGrayKey LineKey OutKey OverKey RepeatCopyKey ReverseKey SelectKey SingleCopyKey TogglexGridKey ToggleyGridKey UnderKey WhiteKey YellowButtonMenu YellowButtonMessages",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "flashCursor:": "flashCursor: aBoolean\n\tFlashCursor _ aBoolean\n\t\"FormEditor flashCursor: true.\"\n",
          "initialize": "initialize\n\t\"FormEditor initialize.\"\n\n\tFlashCursor _ false.\n\tself setKeyboardMap.\n\tYellowButtonMenu _ PopUpMenu labels: 'accept\ncancel'.\n\tYellowButtonMessages _ #(accept cancel)\n\n\t\"FormEditor initialize\"\n"
        },
        "instance creation": {
          "openOnForm:": "openOnForm: aForm\n\t\"Create and schedule an instance of me on the form aForm.\"\n\n\t| topView |\n\ttopView _ self createOnForm: aForm.\n\ttopView controller open\n",
          "openFullScreenForm": "openFullScreenForm\n\t\"Create and schedule an instance of me on the form whose extent is the extent of\n\tthe display screen.\"\n\n\t| topView |\n\ttopView _ self createFullScreenForm.\n\ttopView controller\n\t\topenDisplayAt: (topView viewport extent//2)\n\n\t\"FormEditor openFullScreenForm.\"\n",
          "createOnForm:": "createOnForm: aForm\n\t\"Creates a StandardSystemView for a FormEditor on aForm.\"\n\n\t| formView formEditor menuView topView extent |\n\tformView _ FormHolderView new model: aForm.\n\tformEditor _ self new.\n\tformView controller: formEditor.\n\tmenuView _ FormMenuView new makeFormEditorMenu model: formEditor.\n\tmenuView insideColor: Form lightGray.\n\tmenuView borderWidth: 1.\n\tmenuView window: (menuView defaultWindow expandBy: 16).\n\tformEditor toolMenu: menuView controller.\n\ttopView _ StandardSystemView new.\n\ttopView model: aForm.\n\ttopView addSubView: formView.\n\ttopView label: 'Form Editor'.\n\ttopView borderWidth: 2.\n\textent _ topView viewport extent.\n\ttopView minimumSize: extent.\n\ttopView maximumSize: extent.\n\t^topView\n",
          "openOnForm:at:": "openOnForm: aForm at: originPoint\n\t\"Create and schedule an instance of me on the form aForm whose view origin is\n\toriginPoint.\"\n\n\t| topView |\n\ttopView _ self createOnForm: aForm.\n\ttopView controller\n\t\topenDisplayAt: originPoint + (topView viewport extent//2)\n"
        },
        "private": {
          "createFullScreenForm": "createFullScreenForm\n\t\"Create a StandardSystemView for a FormEditor on the form whole screen.\"\n\n\t^self createOnForm: (Form new extent: (Display extent x @ (Display extent y - 112)))\n",
          "setKeyboardMap": "setKeyboardMap\n\t\"Keyboard Mapping\"\n\n\tSelectKey_$a.\n\tSingleCopyKey_$s.\t\t\t\"tools\"\n\tRepeatCopyKey_$d.\n\tLineKey_$f.\n\tCurveKey_$g.\n\tBlockKey_$h.\n\tOverKey_$j.\t\t\t\t\"modes\"\n\tUnderKey_$k.\n\tReverseKey_$l.\n\tEraseKey_$;.\n\tInKey_$'.\t\t\t\t\t\"file In\"\n\tBitEditKey_$z.\n\tWhiteKey_$x.\t\t\t\t\"colors\"\n\tLightGrayKey_$c.\n\tGrayKey_$v.\n\tDarkGrayKey_$b.\n\tBlackKey_$n.\n\tTogglexGridKey_$m.\t\t\"gridding\"\n\tToggleyGridKey_$,.\n\tChangeGridsKey_$..\n\tOutKey_$/\t\t\t\t\t\"file Out\"\n"
        },
        "examples": {
          "formFromDisplay": "formFromDisplay\n\t\"Create an instance of me on a new form designated by the user at a location\n\tdesignated by the user.\"\n\n\tForm fromUser edit\n\n\t\"FormEditor formFromDisplay.\"\n",
          "fullScreen": "fullScreen\n\t\"Create an instance of me on a new form that fills the full size of the display\n\tscreen.\"\n\n\tFormEditor openFullScreenForm\n\n\t\"FormEditor fullScreen.\"\n",
          "newFormAtOrigin": "newFormAtOrigin\n\t\"Create an instance of me on a new form at location 100,100.\"\n\n\t(Form new extent: 300@300) editAt: 100@100\n\n\t\"FormEditor newFormAtOrigin.\"\n",
          "newForm": "newForm\n\t\"Create an instance of me on a new form at a location designated by the user.\"\n\n\t(Form new extent: 300@300) edit\n\n\t\"FormEditor newForm.\"\n"
        }
      },
      "instance_methods": {
        "editing tools": {
          "colorWhite": "colorWhite\n\t\"Set the mask (color) to white.  Leaves the tool set in its previous state.\"\n\n\tself normalizeColor: Form white.\n\ttool _ previousTool\n",
          "underMode": "underMode\n\t\"Sets the mode for the tools that copy the form onto the display to under.\n\tLeaves the tool set in its previous state.\"\n\n\tmode _ Form under.\n\ttool _ previousTool\n",
          "overMode": "overMode\n\t\"Set the mode for the tools that copy the form onto the display to over.\n\tLeaves the tool set in its previous state.\"\n\n\tmode _ Form over.\n\ttool _ previousTool\n",
          "togglexGridding": "togglexGridding\n\t\"Turns x (horizontal) gridding off, if it is on, and turns it on, if\n\tit is off.  Does not change the primary tool.\"\n\n\txgridOn\n\t\tifTrue:\n\t\t\t[grid x: 1.\n\t\t\txgridOn _ false]\n\t\tifFalse:\n\t\t\t[grid x: togglegrid x.\n\t\t\txgridOn _ true].\n\ttool _ previousTool\n",
          "curve": "curve\n\t\"Conic-section specified by three points from the mouse.\n\tthe resultant curve on the display is displayed according to the\n\tcurrent form and mode.\"\n\n\t| firstPoint secondPoint curve |\n\tfirstPoint _ self cursorPoint.\n\tform\n\t\tdisplayOn: Display\n\t\tat: firstPoint\n\t\tclippingBox: view insetDisplayBox\n\t\trule: mode\n\t\tmask: color.\n\tsecondPoint _ self trackFormUntil: [sensor noButtonPressed].\n\tcurve _ self rubberBandCurve: firstPoint to: secondPoint until: [sensor redButtonPressed].\n\tcurve\n\t\tdisplayOn: Display\n\t\tat: 0 @ 0\n\t\tclippingBox: view insetDisplayBox\n\t\trule: mode\n\t\tmask: color.\n\tsensor waitNoButton\n",
          "block": "block\n\t\"Allow the user to fill a rectangle with the gray tone and mode\n\tcurrently selected.\"\n\n\t| rectangle |\n\trectangle _ Rectangle fromUser: grid.\n\trectangle isNil\n\t\tifFalse: [Display\n\t\t\t\t\tfill: (rectangle intersect: view insetDisplayBox)\n\t\t\t\t\trule: mode\n\t\t\t\t\tmask: color]\n",
          "newSourceForm": "newSourceForm\n\t\"Allow the user to define a new sourceForm for the FormEditor. Copying the\n\tsourceForm onto the display is the primary graphical operation. Resets the tool to\n\tbe repeatCopy.\"\n\tform _ Form fromUser: grid.\n\ttool _ previousTool\n",
          "changeGridding": "changeGridding\n\t\"Allow the user to change the values of the horizontal and(or) vertical grid\n\tmodules.  Does not change the primary tool.\"\n\n\t| response gridInteger |\n\tresponse _\n\t\tself promptRequest: 'Current horizontal gridding is: '\n\t\t\t\t\t\t, togglegrid x printString\n\t\t\t\t\t\t, '.\nType new horizontal gridding.'.\n\tresponse isEmpty\n\t\tifFalse:\n\t\t\t[gridInteger _ Integer readFromString: response.\n\t\t\ttogglegrid x: ((gridInteger max: 1) min: Display extent x)].\n\tresponse _\n\t\tself promptRequest: 'Current vertical gridding is: '\n\t\t\t\t\t\t, togglegrid y printString\n\t\t\t\t\t\t, '.\nType new vertical gridding.'.\n\tresponse isEmpty\n\t\tifFalse:\n\t\t\t[gridInteger _ Integer readFromString: response.\n\t\t\ttogglegrid y: ((gridInteger max: 1) min: Display extent y)].\n\txgridOn ifTrue: [grid x: togglegrid x].\n\tygridOn ifTrue: [grid y: togglegrid y].\n\ttool _ previousTool\n",
          "eraseMode": "eraseMode\n\t\"Set the mode for the tools that copy the form onto the display to erase.\n\tLeaves the tool set in its previous state.\"\n\n\tmode _ 4.\n\ttool _ previousTool\n",
          "colorDarkGray": "colorDarkGray\n\t\"Set the mask (color) to dark gray.  Leaves the tool set in its previous state.\"\n\n\tself normalizeColor: Form darkGray.\n\ttool _ previousTool\n",
          "colorBlack": "colorBlack\n\t\"Set the mask (color) to black. Leaves the tool set in its previous state.\"\n\n\tself normalizeColor: Form black.\n\ttool _ previousTool\n",
          "singleCopy": "singleCopy\n\tform\n\t\tdisplayOn: Display\n\t\tat: self cursorPoint\n\t\tclippingBox: view insetDisplayBox\n\t\trule: mode\n\t\tmask: color.\n\tsensor waitNoButton\n",
          "magnify": "magnify\n\t\"Allow for bit editing of an area of the Form. The user designates a rectangular\n\tarea that is scaled by 5 to allow individual screens dots to be modified.\n\tred button is used to set a bit to black and yellow button is used to set a bit to\n\twhite. Editing continues until the user depresses any key on the keyboard.\"\n\n\t| smallRect smallForm scaleFactor tempRect |\n\tscaleFactor _ 8@8.\n\tsmallRect _ (Rectangle fromUser: grid) intersect: view insetDisplayBox.\n\tsmallRect isNil ifTrue: [^self].\n\tsmallForm _ Form fromDisplay: smallRect.\n\n\t\"Do this computation here in order to be able to save the existing display screen.\"\n\ttempRect _ BitEditor locateMagnifiedView: smallForm scale: scaleFactor.\n\tBitEditor\n\t\topenScreenViewOnForm: smallForm\n\t\tat: smallRect topLeft\n\t\tmagnifiedAt: tempRect topLeft\n\t\tscale: scaleFactor.\n\ttool _ previousTool\n",
          "changeTool:": "changeTool: aCharacter\n\t\"Changes the value of the instance variable tool to be the tool\n\tcorresponding to aCharacter. Typically sent from a Switch in a\n\tFormMenuView. \"\n\n\tpreviousTool _ tool.\n\ttool _ self selectTool: aCharacter.\n\t(#(singleCopy repeatCopy line curve block) includes: tool)\n\t\tifFalse:\n\t\t\t[self perform: tool]\n",
          "toggleyGridding": "toggleyGridding\n\t\"Turns y (vertical) gridding off, if it is on, and turns it on, if\n\tit is off.  Does not change the primary tool.\"\n\n\tygridOn\n\t\tifTrue:\n\t\t\t[grid y: 1.\n\t\t\tygridOn _ false]\n\t\tifFalse:\n\t\t\t[grid y: togglegrid y.\n\t\t\tygridOn _ true].\n\ttool _ previousTool\n",
          "line": "line\n\t\"Rubber-band line is specified by two points from the mouse. The resultant\n\tline on the display is displayed according to the current form and mode.\"\n\n\t| firstPoint endPoint |\n\tfirstPoint _ self cursorPoint.\n\tendPoint _ self rubberBandFrom: firstPoint until: [sensor noButtonPressed].\n\t(Line from: firstPoint to: endPoint withForm: form)\n\t\tdisplayOn: Display\n\t\tat: 0 @ 0\n\t\tclippingBox: view insetDisplayBox\n\t\trule: mode\n\t\tmask: color\n",
          "reverseMode": "reverseMode\n\t\"Set the mode for the tools that copy the form onto the display to reverse.\n\tLeaves the tool set in its previous state.\"\n\n\tmode _ Form reverse.\n\ttool _ previousTool\n",
          "repeatCopy": "repeatCopy\n\t\"As long as the red button is pressed, copy the source form onto the display screen.\"\n\t[sensor redButtonPressed]\n\t\twhileTrue:\n\t\t\t[form\n\t\t\t\tdisplayOn: Display\n\t\t\t\tat: self cursorPoint\n\t\t\t\tclippingBox: view insetDisplayBox\n\t\t\t\trule: mode\n\t\t\t\tmask: color]\n",
          "colorLightGray": "colorLightGray\n\t\"Set the mask (color) to light gray.  Leaves the tool set in its previous state.\"\n\n\tself normalizeColor: Form lightGray.\n\ttool _ previousTool\n",
          "fileInForm": "fileInForm\n\t\"Ask the user for a file name and then recalls the Form in that file as the\n\tcurrent source Form (form).  Does not change the tool.\"\n\n\t| inName directory localName trying newForm |\n\ttrying _ true.\n\t[trying] whileTrue:\n\t\t[inName _ self promptRequest: 'type a name for recalling a source Form . . . '.\n\t\tdirectory _ FileDirectory directoryFromName: inName setFileName: [:localName].\n\t\t(((directory isLegalFileName: localName)\n\t\t\tand: [directory includesKey: localName])\n\t\t\t\tand: [(newForm  _ Form readFrom: inName) ~~ nil])\n\t\t\t\tifTrue: [trying _ false]\n\t\t\t\tifFalse: [trying _ BinaryChoice message: 'File name illegal, or file not found, or file not valid form file.\nTry again?']].\n\tnewForm ~~ nil ifTrue: [form _ newForm].\n\ttool _ previousTool.\n",
          "colorGray": "colorGray\n\t\"Set the mask (color) to gray.  Leaves the tool set in its previous state.\"\n\n\tself normalizeColor: Form gray.\n\ttool _ previousTool\n",
          "fileOutForm": "fileOutForm\n\t\"Ask the user for a file name and then save the current source form (form)\n\tunder that name.  Does not change the tool.\"\n\n\t| outName answer directory localName trying |\n\ttrying _ true.\n\t[trying] whileTrue:\n\t\t[outName _ self promptRequest: 'type a name for saving the source Form . . . '.\n\t\tdirectory _ FileDirectory directoryFromName: outName setFileName: [:localName].\n\t\t(directory isLegalFileName: outName)\n\t\t\tifTrue:\n\t\t\t\t[(directory includesKey: localName)\n\t\t\t\t\tifTrue: [(BinaryChoice message: 'writing over old file--okay?')\n\t\t\t\t\t\t\t\tifTrue: [form writeOn: outName]]\n\t\t\t\t\tifFalse: [form writeOn: outName].\n\t\t\t\ttrying _ false]\n\t\t\tifFalse:\n\t\t\t\t[trying _ BinaryChoice message: 'Bad file name, try again?']].\n\ttool _ previousTool.\n"
        },
        "cursor": {
          "cursorPoint": "cursorPoint\n\t\"Answer the mouse coordinate data gridded according to the receiver's grid.\"\n\t^sensor cursorPoint grid: grid\n"
        },
        "control defaults": {
          "isControlWanted": "isControlWanted\n\n\t^(toolMenu notNil \"Galley compatibility\" and: [toolMenu isControlWanted])\n\t\tor: [self viewHasCursor]\n",
          "isControlActive": "isControlActive\n\n\t^(toolMenu notNil \"Galley compatibility\" and: [toolMenu isControlWanted])\n\t\tor: [sensor noButtonPressed\n\t\t\tor: [sensor blueButtonPressed not and: [self viewHasCursor]]]\n",
          "controlActivity": "controlActivity\n\n\t(toolMenu notNil \"Galley compatibility\" and: [toolMenu isControlWanted]) ifTrue: [^toolMenu startUp].\n\tself viewHasCursor ifTrue:\n\t\t[sensor redButtonPressed ifTrue: [^self redButtonActivity].\n\t\tsensor yellowButtonPressed ifTrue: [^self yellowButtonActivity].\n\t\tsensor blueButtonPressed ifTrue: [^self blueButtonActivity].\n\t\tself dragForm]\n"
        },
        "basic control sequence": {
          "controlInitialize": "controlInitialize\n\n\ttoolMenu notNil ifTrue:\t\t\"check for Galley compatibility\"\n\t\t[toolMenu view\n\t\t\talign: toolMenu view displayBox topCenter\n\t\t\twith: view displayBox bottomCenter+(0@1).\n\t\ttoolMenu view translateBy:\n\t\t\t(toolMenu view displayBox amountToTranslateWithin: Display boundingBox) x @ 0.\n\t\tunderToolMenu _ Form fromDisplay: toolMenu view displayBox.\n\t\ttoolMenu view display].\n\tself normalizeColor: unNormalizedColor.\n\tsensor waitNoButton\n",
          "controlTerminate": "controlTerminate\n\n\tview updateDisplay.\n\ttoolMenu notNil ifTrue:\t\t\"check for Galley compatibility\"\n\t\t[underToolMenu displayAt: toolMenu view displayBox origin.\n\t\tunderToolMenu _ nil].\n"
        },
        "menu messages": {
          "accept": "accept\n\t\"The edited information should now be accepted by the view.\"\n\tview updateDisplay.\n\tview accept\n",
          "redButtonActivity": "redButtonActivity\n\n\tCursor blank showWhile: [self perform: tool]\n",
          "cancel": "cancel\n\t\"The edited informatin should be forgotten by the view.\"\n\tview cancel\n"
        },
        "private": {
          "normalizeColor:": "normalizeColor: halftoneForm\n\tunNormalizedColor _ halftoneForm.\n\tcolor _ unNormalizedColor wrapAround: view insetDisplayBox origin.\n",
          "promptRequest:": "promptRequest: outputMessage\n\t\"Answers with a string typed by the user on the keyboard. keyboard input is\n\tterminated by a line feed character. Typing feedback happens in a window that\n\tis at least 100 bits wide and 50 bits high.\"\n\n\t| answer |\n\tFillInTheBlank\n\t\trequest: outputMessage\n\t\tdisplayAt: view insetDisplayBox topCenter + (0@80)\n\t\tcentered: true\n\t\taction: [:answer]\n\t\tinitialAnswer: ''.\n\t^answer\n",
          "trackFormUntil:": "trackFormUntil: aBlock\n\t| previousPoint cursorPoint |\n\tpreviousPoint  _ self cursorPoint.\n\tform displayOn: Display at: previousPoint rule: Form reverse.\n\t[aBlock value] whileFalse:\n\t\t[cursorPoint _ self cursorPoint.\n\t\t(FlashCursor or: [cursorPoint ~= previousPoint])\n\t\t\tifTrue:\n\t\t\t[form displayOn: Display at: previousPoint rule: Form reverse.\n\t\t\tform displayOn: Display at: cursorPoint rule: Form reverse.\n\t\t\tpreviousPoint  _ cursorPoint]].\n\tform displayOn: Display at: previousPoint rule: Form reverse.\n\t^ previousPoint\n",
          "rubberBandFrom:until:": "rubberBandFrom: startPoint until: aBlock\n\t\"Show an xor line from startPoint to the cursor point until aBlock evaluates to true, then remove the line and answer the endPoint.\"\n\n\t| line endPoint |\n\tline _ Line from: startPoint to: startPoint withForm: form.\n\tline displayOn: Display at: 0@0 clippingBox: view insetDisplayBox\n\t\trule: Form reverse mask: nil.\t\t\"display\"\n\t[aBlock value] whileFalse:\n\t\t[(endPoint _ self cursorPoint) = line endPoint ifFalse:\n\t\t\t[line displayOn: Display at: 0@0 clippingBox: view insetDisplayBox\n\t\t\t\trule: Form reverse mask: nil.\t\t\"erase\"\n\t\t\tline endPoint: endPoint.\n\t\t\tline displayOn: Display at: 0@0 clippingBox: view insetDisplayBox\n\t\t\t\trule: Form reverse mask: nil.\t\t\"display\"\n\t\t\t]].\n\tline displayOn: Display at: 0@0 clippingBox: view insetDisplayBox\n\t\trule: Form reverse mask: nil.\t\t\"erase\"\n\t^line endPoint\n",
          "rubberBandCurve:to:until:": "rubberBandCurve: startPoint to: endPoint until: aBlock\n\t| curve previousApex apex | \"Return a curve\"\n\tcurve _ Curve new.\n\tcurve firstPoint: startPoint.\n\tcurve secondPoint: (previousApex _ self cursorPoint).\n\tcurve thirdPoint: endPoint.\n\tcurve form: form.\n\tcurve\n\t\tdisplayOn: Display\n\t\tat: 0 @ 0\n\t\tclippingBox: view insetDisplayBox\n\t\trule: Form reverse\n\t\tmask: Form black.\n\n\t[aBlock value] whileFalse:\n\t\t[(apex _ self cursorPoint) = previousApex\n\t\t\tifFalse:\n\t\t\t[curve\n\t\t\t\tdisplayOn: Display\n\t\t\t\tat: 0 @ 0\n\t\t\t\tclippingBox: view insetDisplayBox\n\t\t\t\trule: Form reverse\n\t\t\t\tmask: Form black.\n\t\t\tcurve secondPoint: apex.\n\t\t\tcurve\n\t\t\t\tdisplayOn: Display\n\t\t\t\tat: 0 @ 0\n\t\t\t\tclippingBox: view insetDisplayBox\n\t\t\t\trule: Form reverse\n\t\t\t\tmask: Form black.\n\t\t\tpreviousApex  _ apex]].\n\t\tcurve\n\t\t\t\tdisplayOn: Display\n\t\t\t\tat: 0 @ 0\n\t\t\t\tclippingBox: view insetDisplayBox\n\t\t\t\trule: Form reverse\n\t\t\t\tmask: Form black.\n\t^ curve\n",
          "toolMenu:": "toolMenu: aController\n\ttoolMenu _ aController.  \"Note that the GalleyFormEditor does not set this\"\n",
          "initializeYellowButtonMenu": "initializeYellowButtonMenu\n\tself yellowButtonMenu: YellowButtonMenu\n\t\tyellowButtonMessages: YellowButtonMessages\n",
          "setVariables": "setVariables\n\ttool _ #repeatCopy.\n\tpreviousTool _ tool.\n\tgrid _ 1 @ 1.\n\ttogglegrid _ 8 @ 8.\n\txgridOn _ false.\n\tygridOn _ false.\n\tmode _ Form over.\n\tunNormalizedColor _ color _ Form black.\n\tform _ Form new extent: 8 @ 8.\n\tform black\n",
          "dragForm": "dragForm\n\n\ttool = #block\n\t\tifTrue:\n\t\t\t[Cursor origin showWhile:\n\t\t\t[[sensor anyButtonPressed\n\t\t\t\tor: [sensor keyboardPressed\n\t\t\t\tor: [self viewHasCursor not]]]\n\t\t\t\twhileFalse: []].\n\t\t\t^ self cursorPoint]\n\t\tifFalse:\n\t\t\t[^Cursor blank showWhile:\n\t\t\t[self trackFormUntil:\n\t\t\t\t[sensor anyButtonPressed\n\t\t\t\t\tor: [sensor keyboardPressed\n\t\t\t\t\tor: [self viewHasCursor not]]]]].\n",
          "selectTool:": "selectTool: aCharacter\n\t\"A new tool has been selected.  It is denoted by aCharacter.  Set the tool.\"\n\n\t\"This code is written out in long hand (i.e., rather than dispatching on a\n\ttable of options) so that it is obvious what is happening.\"\n\n\taCharacter =  SingleCopyKey\tifTrue: [^#singleCopy].\n\taCharacter =  RepeatCopyKey\tifTrue: [^#repeatCopy].\n\taCharacter =  LineKey\t\t\tifTrue: [^#line].\n\taCharacter =  CurveKey\t\t\tifTrue: [^#curve].\n\taCharacter =  BlockKey\t\t\tifTrue: [^#block].\n\taCharacter =  SelectKey\t\t\tifTrue: [^#newSourceForm].\n\taCharacter =  OverKey\t\t\tifTrue: [^#overMode].\n\taCharacter =  UnderKey\t\t\tifTrue: [^#underMode].\n\taCharacter =  ReverseKey\t\tifTrue: [^#reverseMode].\n\taCharacter =  EraseKey\t\t\tifTrue: [^#eraseMode].\n\taCharacter =  ChangeGridsKey\tifTrue: [^#changeGridding].\n\taCharacter =  TogglexGridKey\tifTrue: [^#togglexGridding].\n\taCharacter =  ToggleyGridKey\tifTrue: [^#toggleyGridding].\n\taCharacter =  BitEditKey\t\t\tifTrue: [^#magnify].\n\taCharacter =  WhiteKey\t\t\tifTrue: [^#colorWhite].\n\taCharacter =  LightGrayKey\t\tifTrue: [^#colorLightGray].\n\taCharacter =  GrayKey\t\t\tifTrue: [^#colorGray].\n\taCharacter =  DarkGrayKey\t\tifTrue: [^#colorDarkGray].\n\taCharacter =  BlackKey\t\t\tifTrue: [^#colorBlack].\n\taCharacter =  OutKey\t\t\tifTrue: [^#fileOutForm].\n\taCharacter =  InKey\t\t\t\tifTrue: [^#fileInForm].\n\t^ #singleCopy\n"
        },
        "initialize-release": {
          "initialize": "initialize\n\tsuper initialize.\n\tself setVariables.\n\tself initializeYellowButtonMenu\n",
          "release": "release\n\n\tsuper release.\n\ttoolMenu notNil ifTrue: [toolMenu view release].\n\ttoolMenu _ form _ nil\n"
        }
      }
    },
    "FormMenuView": {
      "comment": "I represent a View whose subViews are Switches (Buttons or OneOnSwitches) whose actions set the mode, color, and tool for editing a Form on the screen.  The default controller of my instances is FormMenuController.\n",
      "class_name": "FormMenuView",
      "superclass": "View",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "BorderForm FormButtons SpecialBorderForm",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"The forms for the menu are typically stored on files.  In order to avoid reading\n\tthem every time, they are stored in a collection that is a class variable,\n\talong with the offset, tool value, and initial visual state (on or off), that\n\tmakes up the view of the form in the menu view.\"\n\n\t| offsets keys names formButton states |\n\toffsets _ OrderedCollection new: 21.\n\t#( 0 64 96 128 160 192 256 288 320 352 420) do: [:i | offsets addLast: i@0]. \"First row\"\n\t#( 0 64 96 128 160 192 256 304 352 420) do: [:i | offsets addLast: i@48].\t\t\"Second row\"\n\toffsets _ offsets asArray.\n\tkeys _ #($a $s $d $f $g $h $j $k $l $; $' $z $x $c $v $b $n $m $, $. $/ ).\t\"Keyboard\"\n\tstates _\n\t\t#(false false true false false false true false false false false false false\n\t\tfalse false false true false false false false ).\t\t\"Initial states of buttons\"\n\tnames _\n\t\t#('select.form.' 'singlecopy.form.' 'repeatcopy.form.' 'line.form.' 'curve.form.'\n\t\t'block.form' 'over.form.' 'under.form.' 'reverse.form.' 'erase.form.' 'in.form.'\n\t\t'magnify.form.' 'white.form' 'lightgray.form' 'gray.form' 'darkgray.form' 'black.form'\n\t\t'xgrid.form.' 'ygrid.form.' 'togglegrids.form.' 'out.form.' ).\t\"Files of button images\"\n\tFormButtons _ OrderedCollection new.\n\t1 to: 21 do:\n\t\t[:index |\n\t\tformButton _ FormButtonCache new.\n\t\tformButton form: (Form readFrom: (names at: index)).\n\t\tformButton offset: (offsets at: index).\n\t\tformButton value: (keys at: index).\n\t\tformButton initialState: (states at: index).\n\t\tFormButtons addLast: formButton].\n\tSpecialBorderForm  _ Form readFrom: 'specialborderform.form'.\n\tBorderForm _ Form readFrom: 'borderform.form'\n\n\t\"FormMenuView initialize\"\n"
        }
      },
      "instance_methods": {
        "private": {
          "makeSwitch:": "makeSwitch: index\n\t| button buttonCache |\n\tbuttonCache _ FormButtons at: index.\n\tbuttonCache initialState = #true\n\t\tifTrue: [button _ Switch newOn]\n\t\tifFalse: [button _ Switch newOff].\n\tbutton onAction: [model changeTool: buttonCache value].\n\tself makeViews: buttonCache for: button\n",
          "makeConnections:": "makeConnections: indexInterval\n\t| connector button buttonCache aSwitchView |\n\tconnector _ Object new.\t\t\"A dummy model for connecting dependents.\"\n\tindexInterval do:\n\t\t[:index |\n\t\tbuttonCache _ FormButtons at: index.\n\t\tbuttonCache initialState = #true\n\t\t\tifTrue: [button _ OneOnSwitch newOn]\n\t\t\tifFalse: [button _ OneOnSwitch newOff].\n\t\tbutton onAction: [model changeTool: buttonCache value].\n\t\tbutton connection: connector.\n\t\taSwitchView _ self makeViews: buttonCache for: button.\n\t\taSwitchView borderWidthLeft: 1 right: 0 top: 1 bottom: 1.\n\t\taSwitchView controller selector: #turnOn].\n\taSwitchView borderWidth: 1.\n",
          "makeViews:for:": "makeViews: cache for: aSwitch\n\t| form aSwitchView |\n\tform _ cache form.\n\taSwitchView _ SwitchView new model: aSwitch.\n\taSwitchView key: cache value.\n\taSwitchView label: form.\n\taSwitchView window: (0@0 extent: form extent).\n\taSwitchView translateBy: cache offset.\n\taSwitchView borderWidth: 1.\n\taSwitchView insideColor: Form white.\n\tself addSubView: aSwitchView.\n\t^aSwitchView\n",
          "makeButton:": "makeButton: index\n\t| button buttonCache aSwitchView|\n\tbuttonCache _ FormButtons at: index.\n\tbutton _ Button newOff.\n\tbutton onAction: [model changeTool: buttonCache value].\n\taSwitchView _ self makeViews: buttonCache for: button.\n\taSwitchView controller: IndicatorOnSwitchController new\n",
          "makeGridSwitch:": "makeGridSwitch: index\n\t| button buttonCache |\n\tbuttonCache _ FormButtons at: index.\n\tbuttonCache initialState = #true\n\t\tifTrue: [button _ Switch newOn]\n\t\tifFalse: [button _ Switch newOff].\n\tbutton onAction: [model changeTool: buttonCache value].\n\tbutton offAction: [model changeTool: buttonCache value].\n\tself makeViews: buttonCache for: button\n",
          "makeColorConnections:": "makeColorConnections: indexInterval\n\t| connector button buttonCache aSwitchView |\n\tconnector _ Object new.\t\t\"A dummy model for connecting dependents\"\n\tindexInterval do:\n\t\t[:index |\n\t\tbuttonCache _ FormButtons at: index.\n\t\tbuttonCache initialState = #true\n\t\t\tifTrue: [button _ OneOnSwitch newOn]\n\t\t\tifFalse: [button _ OneOnSwitch newOff].\n\t\tbutton onAction: [model changeTool: buttonCache value].\n\t\tbutton connection: connector.\n\t\taSwitchView _ self makeViews: buttonCache for: button.\n\t\taSwitchView highlightForm: BorderForm.\n\t\taSwitchView borderWidthLeft: 1 right: 0 top: 1 bottom: 1.\n\t\taSwitchView controller selector: #turnOn].\n\taSwitchView highlightForm: SpecialBorderForm.\n\taSwitchView borderWidth: 1.\n"
        },
        "initialize-release": {
          "makeFormEditorMenu": "makeFormEditorMenu\n\t| button buttonCache form aSwitchView aSwitchController|\n\t\"Now get those forms into the subviews\"\n\tself makeButton: 1.\t\t\t\t\t\"form source\"\n\tself makeConnections: (2 to: 6).\t\t\"tools\"\n\tself makeConnections: (7 to: 10).\t\t\"modes\"\n\tself makeButton: 11.\t\t\t\t\t\"filing in\"\n\tself makeButton: 12.\t\t\t\t\t\"bit editing\"\n\tself makeColorConnections: (13 to: 17).\t\t\"colors\"\n\tself makeGridSwitch: 18.\t\t\t\t\t\"toggle x\"\n\tself makeGridSwitch: 19.\t\t\t\t\t\"toggle y\"\n\tself makeButton: 20.\t\t\t\t\t\"setting grid\"\n\tself makeButton: 21\t\t\t\t\t\"filing out\"\n"
        },
        "controller access": {
          "defaultControllerClass": "defaultControllerClass\n\t^FormMenuController\n"
        },
        "subView access": {
          "subViewContainingCharacter:": "subViewContainingCharacter: aCharacter\n\t\"Answer the receiver's subView that corresponds to the key, aCharacter.\n\tAnswer nil if no subView is selected by aCharacter.\"\n\n\tself subViews reverseDo:\n\t\t[:aSubView |\n\t\t(aSubView containsKey: aCharacter) ifTrue: [^aSubView]].\n\t^nil\n"
        }
      }
    },
    "BitEditor": {
      "comment": "A bit-magnifying tool for editing small Forms directly on the display screen.  Continue in blowup mode until the user depresses any key on the keyboard.\n",
      "class_name": "BitEditor",
      "superclass": "MouseMenuController",
      "instanceVariables": "scale squareForm color",
      "classInstanceVariables": "",
      "classVariables": "ColorButtons YellowButtonMenu YellowButtonMessages",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"The Bit Editor is the only controller to override the use of the blue button with\n\ta different pop-up menu.  Initialize this menu.\"\n\tYellowButtonMenu _ PopUpMenu labels:\n'accept\ncancel'.\n\tYellowButtonMessages _ #(accept cancel )\n\n\t\"BitEditor initialize.\"\n"
        },
        "instance creation": {
          "openScreenViewOnForm:at:magnifiedAt:scale:": "openScreenViewOnForm: aForm at: formLocation magnifiedAt: magnifiedLocation scale: scaleFactor\n\t\"Create and schedule a BitEditor on the form aForm.  Show the magnified\n\tview of aForm in a scheduled window.\"\n\n\t| smallFormView bitEditor savedForm |\n\tsmallFormView _ FormView new model: aForm.\n\tsmallFormView align: smallFormView viewport topLeft with: formLocation.\n\tbitEditor _ self bitEdit: aForm at: magnifiedLocation scale: scaleFactor remoteView: smallFormView.\n\tsavedForm _ Form fromDisplay: bitEditor displayBox.\n\tbitEditor controller blueButtonMenu: nil blueButtonMessages: nil.\n\tbitEditor controller startUp.\n\tsavedForm displayOn: Display at: bitEditor displayBox topLeft.\n\tbitEditor release.\n\tsmallFormView release\n",
          "openOnForm:at:scale:": "openOnForm: aForm at: magnifiedLocation scale: scaleFactor\n\t\"Create and schedule a BitEditor on the form aForm.  Show the small and\n\tmagnified view of aForm.\"\n\n\t| aScheduledView |\n\taScheduledView _ self\n\t\t\t\tbitEdit: aForm\n\t\t\t\tat: magnifiedLocation\n\t\t\t\tscale: scaleFactor\n\t\t\t\tremoteView: nil.\n\taScheduledView controller openDisplayAt:\n\t\taScheduledView displayBox topLeft + (aScheduledView displayBox extent / 2)\n",
          "openOnForm:": "openOnForm: aForm\n\t| scaleFactor |\n\tscaleFactor _ 8 @ 8.\n\t^ self openOnForm: aForm\n\t\tat: (self locateMagnifiedView: aForm scale: scaleFactor) topLeft\n\t\tscale: scaleFactor\n",
          "openOnForm:at:": "openOnForm: aForm at: magnifiedLocation\n\t^ self openOnForm: aForm\n\t\tat: magnifiedLocation\n\t\tscale: 8 @ 8\n"
        },
        "private": {
          "buildColorMenu:colorCount:": "buildColorMenu: extent colorCount: nColors  \"BitEditor magnifyWithSmall.\"\n\t| menuView index form aSwitchView connector\n\tbutton formExtent highlightForm color leftOffset |\n\tconnector _ Object new.\n\tmenuView _ FormMenuView new.\n\tmenuView window: (0@0 corner: extent).\n\tformExtent _ 30@30 min: extent//(nColors*2+1@2).  \"compute this better\"\n\tleftOffset _ extent x-(nColors*2-1*formExtent x)//2.\n\thighlightForm _ Form extent: formExtent.\n\thighlightForm borderWidth: 4 mask: Form black.\n\t1 to: nColors do:\n\t\t[:index |\n\t\tcolor _ (nColors=2\n\t\t\tifTrue: [#(white black)]\n\t\t\tifFalse: [#(white gray black)]) at: index.\n\t\tform _ Form extent: formExtent.\n\t\tform fill: form boundingBox mask: (Form perform: color).\n\t\tform borderWidth: 5 mask: Form black.\n\t\tcolor = #black ifTrue: [form borderWidth: 5 mask: Form white].\n\t\tform borderWidth: 4 mask: Form white.\n\t\tbutton _ color = #black\n\t\t\tifTrue: [OneOnSwitch newOn]\n\t\t\tifFalse: [OneOnSwitch newOff].\n\t\tbutton onAction: [menuView model setColor: color].\n\t\tbutton connection: connector.\n\n\t\taSwitchView _ SwitchView new model: button.\n\t\taSwitchView key: ((nColors=3 ifTrue: ['xvn'] ifFalse: ['xn']) at: index).\n\t\taSwitchView label: form.\n\t\taSwitchView window: (0@0 extent: form extent).\n\t\taSwitchView translateBy: (index-1*2*form width+leftOffset) @ (form height//2).\n\t\taSwitchView insideColor: Form white.\n\t\taSwitchView highlightForm: highlightForm.\n\n\t\taSwitchView borderWidth: 1.\n\t\taSwitchView controller selector: #turnOn.\n\t\tmenuView addSubView: aSwitchView].\n\t^menuView\n",
          "locateMagnifiedView:scale:": "locateMagnifiedView: aForm scale: scaleFactor\n\t\"Answers with a rectangle at the location where the scaled view of the form aForm\n\tshould be displayed.\"\n\n\t| tempExtent tempRect |\n\ttempExtent _ aForm extent * scaleFactor + (0@50).\n\ttempRect _ (Sensor cursorPoint\" grid: scaleFactor\") extent: tempExtent.\n\t\"show magnified form size until mouse is depressed\"\n\t[Sensor redButtonPressed]\n\t\twhileFalse:\n\t\t\t[Display reverse: tempRect.\n\t\t\tDisplay reverse: tempRect.\n\t\t\ttempRect _ (Sensor cursorPoint grid: scaleFactor)\n\t\t\t\t\t\textent: tempExtent].\n\t^tempRect\n",
          "bitEdit:at:scale:remoteView:": "bitEdit: aForm at: magnifiedFormLocation scale: scaleFactor remoteView: remoteView\n\t\"Creates a BitEditor on aForm. That is, aForm is a small image that will\n\tchange as a result of the BitEditor changing a second and magnified\n\tview of me. magnifiedFormLocation is where the magnified form is to be\n\tlocated on the screen. scaleFactor is the amount of magnification. This\n\tmethod implements a scheduled view containing both a small and\n\tmagnified view of aForm. Upon accept, aForm is updated.\"\n\n\t| aFormView scaledFormView bitEditor topView extent menuView lowerRightExtent |\n\tscaledFormView _ FormHolderView new model: aForm.\n\tscaledFormView scaleBy: scaleFactor.\n\tbitEditor _ self new.\n\tbitEditor setColor: #black.\n\tscaledFormView controller: bitEditor.\n\ttopView _ StandardSystemView new.\n\tremoteView == nil ifTrue: [topView label: 'Bit Editor'].\n\ttopView borderWidth: 2.\n\ttopView insideColor: Form white.\n\n\ttopView addSubView: scaledFormView.\n\tremoteView == nil\n\t\tifTrue:  \"If no remote view, then provide a local view of the form\"\n\t\t\t[aFormView _ FormView new model: scaledFormView workingForm.\n\t\t\taFormView controller: NoController new.\n\t\t\t(aForm isMemberOf: OpaqueForm) ifTrue:\n\t\t\t\t[scaledFormView insideColor: Form gray.\n\t\t\t\taFormView insideColor: Form white].\n\t\t\taForm height < 50\n\t\t\t\tifTrue: [aFormView borderWidthLeft: 0 right: 2 top: 2 bottom: 2]\n\t\t\t\tifFalse: [aFormView borderWidthLeft: 0 right: 2 top: 2 bottom: 0].\n\t\t\ttopView addSubView: aFormView below: scaledFormView]\n\t\t ifFalse:  \"Otherwise, the remote one should view the same form\"\n\t\t\t[remoteView model: scaledFormView workingForm].\n\tlowerRightExtent _ remoteView == nil\n\t\t\tifTrue:\n\t\t\t\t[(scaledFormView viewport width - aFormView viewport width) @\n\t\t\t\t\t(aFormView viewport height max: 50)]\n\t\t\tifFalse:\n\t\t\t\t[scaledFormView viewport width @ 50].\n\tmenuView _ self buildColorMenu: lowerRightExtent\n\t\tcolorCount: ((aForm isMemberOf: OpaqueForm) ifTrue: [3] ifFalse: [2]).\n\tmenuView model: bitEditor.\n\tmenuView borderWidthLeft: 0 right: 0 top: 2 bottom: 0.\n\ttopView\n\t\taddSubView: menuView\n\t\talign: menuView viewport topRight\n\t\twith: scaledFormView viewport bottomRight.\n\textent _ scaledFormView viewport extent + (0 @ lowerRightExtent y)\n\t\t\t+ (4 @ 4).  \"+4 for borders\"\n\ttopView minimumSize: extent.\n\ttopView maximumSize: extent.\n\ttopView translateBy: magnifiedFormLocation.\n\t^topView\n"
        },
        "examples": {
          "magnifyWithSmall": "magnifyWithSmall\n\t\"Bit editing of an area of the Form. User designates a rectangular area\n\tthat is magnified by 8 to allow individual screens dots to be modified.\n\tred button is used to set a bit to black and yellow button is used to set a bit to\n\twhite.  Editor is scheduled in a view, showing the magnified view only.\"\n\n\t| smallRect smallForm  |\n\tsmallRect _ Rectangle fromUser.\n\tsmallRect isNil ifTrue: [^self].\n\tsmallForm _ Form fromDisplay: smallRect.\n\tBitEditor openOnForm: smallForm\n\n\t\"BitEditor magnifyWithSmall.\"\n",
          "magnifyOnScreen": "magnifyOnScreen\n\t\"Bit editing of an area of the display screen. User designates a\n\trectangular area that is magnified by 8 to allow individual screens dots to be\n\tmodified. red button is used to set a bit to black and yellow button is used to set a\n\tbit to white. Editor is not scheduled in a view.  Original screen location is\n\tupdated immediately.  This is the same as FormEditor magnify.\"\n\n\t| smallRect smallForm scaleFactor tempRect |\n\tscaleFactor _ 8 @ 8.\n\tsmallRect _ Rectangle fromUser.\n\tsmallRect isNil ifTrue: [^self].\n\tsmallForm _ Form fromDisplay: smallRect.\n\ttempRect _ self locateMagnifiedView: smallForm scale: scaleFactor.\n\t\"show magnified form size until mouse is depressed\"\n\tBitEditor\n\t\topenScreenViewOnForm: smallForm\n\t\tat: smallRect topLeft\n\t\tmagnifiedAt: tempRect topLeft\n\t\tscale: scaleFactor\n\n\t\"BitEditor magnifyOnScreen.\"\n"
        }
      },
      "instance_methods": {
        "control defaults": {
          "isControlActive": "isControlActive\n\t^super isControlActive & sensor blueButtonPressed not\n\t\t& sensor keyboardPressed not\n",
          "controlActivity": "controlActivity\n\t| absoluteScreenPoint formPoint displayPoint |\n\tsuper controlActivity.\n\t[sensor redButtonPressed]\n\t  whileTrue:\n\t\t[absoluteScreenPoint _ sensor cursorPoint.\n\t\tformPoint _ (view inverseDisplayTransform: absoluteScreenPoint - (scale//2)) rounded.\n\t\tdisplayPoint _ view displayTransform: formPoint.\n\t\tsquareForm\n\t\t\tdisplayOn: Display\n\t\t\tat: displayPoint\n\t\t\tclippingBox: view insetDisplayBox\n\t\t\trule: Form over\n\t\t\tmask: (Form perform: color).\n\t\tview changeValueAt: formPoint put:\n\t\t\t(#(white black gray) indexOf: color)-1].\n"
        },
        "basic control sequence": {
          "controlInitialize": "controlInitialize\n\tsuper controlInitialize.\n\tCursor crossHair show\n",
          "controlTerminate": "controlTerminate\n\tCursor normal show\n"
        },
        "menu messages": {
          "accept": "accept\n\t\"The edited information should now be accepted by the view.\"\n\tview accept\n",
          "setColor:": "setColor: aSymbol\n\tcolor _ aSymbol\n",
          "cancel": "cancel\n\t\"The edited informatin should be forgotten by the view.\"\n\tview cancel\n"
        },
        "view access": {
          "view:": "view: aView\n\tsuper view: aView.\n\tscale _ aView transformation scale.\n\tscale _ scale x rounded @ scale y rounded.\n\tsquareForm _ Form new extent: scale.\n\tsquareForm black\n"
        },
        "private": {
          "initializeYellowButtonMenu": "initializeYellowButtonMenu\n\tself yellowButtonMenu: YellowButtonMenu\n\t\tyellowButtonMessages: YellowButtonMessages\n"
        },
        "initialize-release": {
          "initialize": "initialize\n\tsuper initialize.\n\tself initializeYellowButtonMenu\n",
          "release": "release\n\tsuper release.\n\tsquareForm release.\n\tsquareForm _ nil\n"
        }
      }
    },
    "FormButtonCache": {
      "comment": "I am used to save information needed to construct the menu for the form editor.  A collection of my instances is an class variable of FormMenuView.\n",
      "class_name": "FormButtonCache",
      "superclass": "Object",
      "instanceVariables": "offset form value initialState",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "accessing": {
          "form": "form\n\t\"Answer the receiver's form, the image of the button on the screen.\"\n\t^form\n",
          "initialState:": "initialState: aBoolean\n\t\"Set the receiver's initial state, on or off, to be the argument.\"\n\tinitialState _ aBoolean\n",
          "initialState": "initialState\n\t\"Answer the receiver's initial state, on or off.\"\n\t^initialState\n",
          "value": "value\n\t\"Answer the receiver's value, the keyboard key that selects the button.\"\n\t^value\n",
          "value:": "value: aCharacter\n\t\"Set the receiver's key character.\"\n\tvalue _ aCharacter\n",
          "offset:": "offset: anInteger\n\t\"Set the receiver's offset.\"\n\toffset _ anInteger\n",
          "form:": "form: aForm\n\t\"Set the receiver's form to be the argument.\"\n\tform _ aForm\n",
          "offset": "offset\n\t\"Answer the receiver's offset, its relative position for displaying the button.\"\n\t^offset\n"
        }
      }
    }
  },
  "Graphics-Paths": {
    "LinearFit": {
      "comment": "A subclass of Path that is a piece-wise linear\n\t\t\t\tapproximation to a set of points in the plane.\n",
      "class_name": "LinearFit",
      "superclass": "Path",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "examples": {
          "example": "example\n\t\"Select points on a Path using the red button.  Terminate by selecting any other\n\tbutton.  Creates a Path from the points and displays it as a piece-wise linear\n\tapproximation.\"\n\n\t| aLinearFit aForm flag |\n\taLinearFit _ LinearFit new.\n\taForm _ Form new extent: 1 @ 40.\n\taForm  black.\n\taLinearFit form: aForm.\n\tflag _ true.\n\t[flag] whileTrue:\n\t\t[Sensor waitButton.\n\t\t Sensor redButtonPressed\n\t\t\tifTrue: [aLinearFit add: Sensor waitButton. Sensor waitNoButton.\n\t\t\t\t\taForm displayOn: Display at: aLinearFit last]\n\t\t\tifFalse: [flag_false]].\n\taLinearFit displayOn: Display\n\n\t\"LinearFit example.\"\n"
        }
      },
      "instance_methods": {
        "displaying": {
          "displayOn:transformation:clippingBox:rule:mask:": "displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger mask: aForm\n\n\t| newLinearFit transformedPath |\n\t\"get the scaled and translated Path.\"\n\ttransformedPath _ aTransformation applyTo: self.\n\tnewLinearFit _ LinearFit new.\n\ttransformedPath do: [:point | newLinearFit add: point].\n\tnewLinearFit form: self form.\n\tnewLinearFit\n\t\tdisplayOn: aDisplayMedium\n\t\tat: 0 @ 0\n\t\tclippingBox: clipRect\n\t\trule: anInteger\n\t\tmask: aForm\n",
          "displayOn:at:clippingBox:rule:mask:": "displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger mask: aForm\n\t| pt line |\n\tline _ Line new.\n\tline form: self form.\n\t1 to: self size - 1 do:\n\t\t[:i |\n\t\tline beginPoint: (self at: i).\n\t\tline endPoint: (self at: i + 1).\n\t\tline displayOn: aDisplayMedium\n\t\t\tat: aPoint\n\t\t\tclippingBox: clipRect\n\t\t\trule: anInteger\n\t\t\tmask: aForm]\n"
        }
      }
    },
    "Curve": {
      "comment": "A subclass of Path that is a conic section determined by\n\t\t\t\tthree points p1,p2 and p3 that interpolates p1 and p3\n\t\t\t\tand is tangent to p1,p2 and p3,p2 at p1 and p3 respectively.\n",
      "class_name": "Curve",
      "superclass": "Path",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t| newSelf |\n\tnewSelf _ super new: 3.\n\tnewSelf add: 0@0.\n\tnewSelf add: 0@0.\n\tnewSelf add: 0@0.\n\t^newSelf\n"
        },
        "examples": {
          "example": "example\n\t\"Designate three locations on the screen by clicking any button.  The curve\n\tdetermined by the points will be displayed with a long black form.\"\n\n\t| aCurve aForm |\n\taForm _ Form new extent: 1@30.\t\t\t\"make a long thin Form for display \"\n\taForm black.\t\t\t\t\t\t\t\t\"turn it black\"\n\taCurve _ Curve new.\n\taCurve form: aForm.\t\t\t\t\t\t\"set the form for display\"\n\t\t\t\t\"collect three Points and show them on the dispaly\"\n\taCurve firstPoint: Sensor waitButton. Sensor waitNoButton.\n\taForm displayOn: Display at: aCurve firstPoint.\n\taCurve secondPoint: Sensor waitButton. Sensor waitNoButton.\n\taForm displayOn: Display at: aCurve secondPoint.\n\taCurve thirdPoint: Sensor waitButton. Sensor waitNoButton.\n\taForm displayOn: Display at: aCurve thirdPoint.\n\n\taCurve displayOn: Display\t\t\t\t\t\"display the Curve\"\n\n\t\"Curve example.\"\n"
        }
      },
      "instance_methods": {
        "displaying": {
          "displayOn:transformation:clippingBox:rule:mask:": "displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger mask: aForm\n\t| transformedPath newCurve |\n\ttransformedPath _ aTransformation applyTo: self.\n\tnewCurve _ Curve new.\n\tnewCurve firstPoint: transformedPath firstPoint.\n\tnewCurve secondPoint: transformedPath secondPoint.\n\tnewCurve thirdPoint: transformedPath thirdPoint.\n\tnewCurve form: self form.\n\tnewCurve\n\t\tdisplayOn: aDisplayMedium\n\t\tat: 0 @ 0\n\t\tclippingBox: clipRect\n\t\trule: anInteger\n\t\tmask: aForm\n",
          "displayOn:at:clippingBox:rule:mask:": "displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger mask: aForm\n\t| pa pb k s p1 p2 p3 line |\n\tline _ Line new.\n\tline form: self form.\n\tcollectionOfPoints size < 3 ifTrue: [self error: 'Curve must have three points'].\n\tp1 _ self firstPoint.\n\tp2 _ self secondPoint.\n\tp3 _ self thirdPoint.\n\ts _ Path new.\n\ts add: p1.\n\tpa _ p2 - p1.\n\tpb _ p3 - p2.\n\tk _ 5 max: pa x abs + pa y abs + pb x abs + pb y abs // 20.\n\t\"k is a guess as to how many line segments to use to approximate\n\tthe curve.\"\n\t1 to: k do:\n\t\t[:i |\n\t\ts add: pa * i // k + p1 * (k - i) + (pb * (i - 1) // k + p2 * (i - 1)) // (k - 1)].\n\ts add: p3.\n\t1 to: s size - 1 do:\n\t\t[:i |\n\t\tline beginPoint: (s at: i).\n\t\tline endPoint: (s at: i + 1).\n\t\tline displayOn: aDisplayMedium\n\t\t\tat: aPoint\n\t\t\tclippingBox: clipRect\n\t\t\trule: anInteger\n\t\t\tmask: aForm]\n"
        }
      }
    },
    "Line": {
      "comment": "This Class is a Line specified by two points. This is a sub-class of path though the two points that determine the line are called begin and end.\n",
      "class_name": "Line",
      "superclass": "Path",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t| newSelf |\n\tnewSelf _ super new: 2.\n\tnewSelf add: 0@0.\n\tnewSelf add: 0@0.\n\t^newSelf\n",
          "from:to:withForm:": "from: beginPoint to: endPoint withForm: aForm\n\t| newSelf |\n\tnewSelf _ super new: 2.\n\tnewSelf add: beginPoint.\n\tnewSelf add: endPoint.\n\tnewSelf form: aForm.\n\t^newSelf\n"
        },
        "examples": {
          "example": "example\n\t\"Designate two places on the screen by clicking any mouse button.\n\tA straight path with a square black form will be displayed connecting the\n\ttwo selected points.\"\n\n\t| aLine aForm |\n\taForm _ Form new extent: 20@20.\t\t\"make a form one quarter of inch square\"\n\taForm black.\t\t\t\t\t\t\t\"turn it black\"\n\taLine _ Line new.\n\taLine form: aForm.\t\t\t\t\t\t\"use the black form for display\"\n\taLine beginPoint: Sensor waitButton. Sensor waitNoButton.\n\taForm displayOn: Display at: aLine beginPoint.\n\taLine endPoint: Sensor waitButton.\n\taLine displayOn: Display.\t\t\t\t\"display the line\"\n\n\t\"Line example.\"\n"
        }
      },
      "instance_methods": {
        "displaying": {
          "displayOn:transformation:clippingBox:rule:mask:": "displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger mask: aForm\n\t| newPath newLine |\n\tnewPath _ aTransformation applyTo: self.\n\tnewLine _ Line new.\n\tnewLine beginPoint: newPath firstPoint.\n\tnewLine endPoint: newPath secondPoint.\n\tnewLine form: self form.\n\tnewLine\n\t\tdisplayOn: aDisplayMedium\n\t\tat: 0 @ 0\n\t\tclippingBox: clipRect\n\t\trule: anInteger\n\t\tmask: aForm\n",
          "displayOn:at:clippingBox:rule:mask:": "displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger mask: aForm\n\t\"The form associated with this Path will be displayed, according\n\tto one of the sixteen functions of two logical variables (rule), at\n\teach point on the Line. Also the source form will be first anded\n\twith aForm as a mask. Does not effect the state of the Path.\"\n\tcollectionOfPoints size < 2 ifTrue: [self error: 'a line must have two points'].\n\taDisplayMedium\n\t\tdrawLine: self form\n\t\tfrom: self beginPoint + aPoint\n\t\tto: self endPoint + aPoint\n\t\tclippingBox: clipRect\n\t\trule: anInteger\n\t\tmask: aForm\n"
        },
        "accessing": {
          "endPoint": "endPoint\n\t\"Answer the first end point of the receiver.\"\n\n\t^self last\n",
          "beginPoint:": "beginPoint: aPoint\n\t\"Set the first end point of the receiver. Answer the argument, aPoint.\"\n\n\tself at: 1 put: aPoint.\n\t^aPoint\n",
          "beginPoint": "beginPoint\n\t\"Answer the first end point of the receiver.\"\n\t^self first\n",
          "endPoint:": "endPoint: aPoint\n\t\"Set the first end point of the receiver.\"\n\n\tself at: 2 put: aPoint.\n\t^aPoint\n"
        }
      }
    },
    "Spline": {
      "comment": "This is a subclass of Path.  Basically, a collection of Points through\n\t\t\t\twhich a cubic spline curve is fitted.\n",
      "class_name": "Spline",
      "superclass": "Path",
      "instanceVariables": "derivatives",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "examples": {
          "example": "example\n\t\"Designate points on the Path by clicking the red button.  Terminate by pressing any other button.  A curve will be displayed, through the selected points, using a square black form.\"\n\n\t| splineCurve aForm flag|\n\taForm _ Form new extent: 8@8.\n\taForm black.\n\tsplineCurve _ Spline new.\n\tsplineCurve form: aForm.\n\tflag _ true.\n\t[flag] whileTrue:\n\t\t[Sensor waitButton.\n\t\t Sensor redButtonPressed\n\t\t\tifTrue:\n\t\t\t\t[splineCurve add: Sensor waitButton.\n\t\t\t\t Sensor waitNoButton.\n\t\t\t\t aForm displayOn: Display at: splineCurve last]\n\t\t\tifFalse: [flag_false]].\n\tsplineCurve computeCurve.\n\tsplineCurve isEmpty\n\t\tifFalse: [splineCurve displayOn: Display.\n\t\t\t\tSensor waitNoButton].\n \t^splineCurve\n\t\"Spline example.\"\n"
        }
      },
      "instance_methods": {
        "displaying": {
          "displayOn:transformation:clippingBox:rule:mask:": "displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger mask: aForm\n\t\"get the scaled and translated path of newKnots.\"\n\n\t| newKnots newSpline |\n\tnewKnots _ aTransformation applyTo: self.\n\tnewSpline _ Spline new.\n\tnewKnots do: [:knot | newSpline add: knot].\n\tnewSpline form: self form.\n\tnewSpline\n\t\tdisplayOn: aDisplayMedium\n\t\tat: 0 @ 0\n\t\tclippingBox: clipRect\n\t\trule: anInteger\n\t\tmask: aForm\n",
          "displayOn:at:clippingBox:rule:mask:": "displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger mask: aForm\n\t\"Method for display of a Spline curve approximated by straight line segments.\"\n\n\t| segment steps a b c d t |\n\tsegment _ Line new.\n\tsegment form: self form.\n\tsegment beginPoint: self first.\n\t1 to: self size-1 do:\t\t\"for each knot\"\n\t\t[:k |\n\t\t\t\"taylor series coefficients\"\n\t\td _ self at: k.\n\t\tc _ (derivatives at: 1) at: k.\n\t\tb _ ((derivatives at: 2) at: k) / 2.0.\n\t\ta _ ((derivatives at: 3) at: k) / 6.0.\n\t\t\t\"guess stepping parameter\"\n\t\tsteps _ ((derivatives at: 2) at: k) abs + ((derivatives at: 2) at: k+1) abs.\n\t\tsteps _ 5 max: (steps x + steps y) // 100.\n\t\t1 to: steps - 1 do:\n\t\t\t[:j |\n\t\t\tt _ j asFloat / steps.\n\t\t\tsegment endPoint: a * t + b * t + c * t + d.\n\t\t\tsegment\n\t\t\t\tdisplayOn: aDisplayMedium\n\t\t\t\tat: aPoint\n\t\t\t\tclippingBox: clipRect\n\t\t\t\trule: anInteger\n\t\t\t\tmask: aForm.\n\t\t\tsegment beginPoint: segment endPoint].\n\t\tsegment endPoint: (self at: k+1).\n\t\tsegment\n\t\t\tdisplayOn: aDisplayMedium\n\t\t\tat: aPoint\n\t\t\tclippingBox: clipRect\n\t\t\trule: anInteger\n\t\t\tmask: aForm]\n"
        },
        "accessing": {
          "derivativePointsAt:": "derivativePointsAt: knot\n\n\t^Array\twith: ((derivatives at: 1) at: knot)\n\t\t\twith: ((derivatives at: 2) at: knot)\n\t\t\twith: ((derivatives at: 3) at: knot)\n",
          "isCyclic": "isCyclic\n\t^self size > 3 and: [self first = self last]\n"
        },
        "private": {
          "computeCurve": "computeCurve\n\t\"Compute an array for the derivatives at each knot.\"\n\n\t| size extras values |\n\tsize _ self size.\n\tself isCyclic\n\t\tifTrue:\t\"for cyclic curves\"\n\t\t\t[extras _ 2.\t\t\"add 2 extra points to each end.\"\n\t\t\tvalues _ Array new: 2*extras + size.\n\t\t\t1 to: extras do:\n\t\t\t\t[:i |\n\t\t\t\tvalues at: i put: (self at: size-extras+i-1).\n\t\t\t\tvalues at: size+extras+i put: (self at: i+1)].\n\t\t\tvalues replaceFrom: extras+1 to: extras+size with: collectionOfPoints]\n\t\tifFalse: [extras _ 0.\n\t\t\t\tvalues _ collectionOfPoints].\n\n\tderivatives _ Array new: 3.\n\t1 to: 3 do: [:i | derivatives at: i put: (Array new: values size)].\n\tself derivs: values\n\t\tfirst: (derivatives at: 1)\n\t\tsecond: (derivatives at: 2)\n\t\tthird: (derivatives at: 3).\n\n\textras > 0 ifTrue:\t\t\"remove extra points\"\n\t\t[1 to: 3 do:\n\t\t\t[:i | derivatives at: i put: ((derivatives at: i) copyFrom: extras+1 to: extras+size)]]\n",
          "derivs:first:second:third:": "derivs: values first: first second: second third: third\n\t\"Computes the first, second and third derivitives at each point in the array values.\"\n\n\t| size v b |\n\tsize _ values size.\n\tsize > 2 ifTrue:\n\t\t[v _ Array new: size.\n\t\tv at: 1 put: 4.0.\n\t\tb _ Array new: size.\n\t\tb at: 1 put: 6.0*(values first-((values at: 2)*2.0)+(values at: 3)).\n\t\t2 to: size-2 do:\n\t\t\t[:i |\n\t\t\tv at: i put: 4.0-(1.0/(v at: i-1)).\n\t\t\tb at: i put: 6.0*((values at: i)-((values at: i+1)*2.0)\n\t\t\t\t+(values at: i+2))-((b at: i-1)/(v at: i-1))].\n\t\tsecond at: size-1 put: (b at: size-2)/(v at: size-2).\n\t\tsize-2 to: 2 by: -1 do:\n\t\t\t[:i |\n\t\t\tsecond at: i put: (b at: i-1)-(second at: i+1)/(v at: i-1)]].\n\n\tsecond at: 1 put: 0.0 asPoint.\n\tsecond at: size put: 0.0 asPoint.\n\n\t1 to: size-1 do:\n\t\t[:i |\n\t\tfirst at: i put: (values at: i+1)-(values at: i)-((second at: i)*2.0\n\t\t\t+(second at: i+1)/6.0).\n\t\tthird at: i put: (second at: i+1)-(second at: i)].\n"
        }
      }
    },
    "Circle": {
      "comment": "A full circle is made from four arcs.\n",
      "class_name": "Circle",
      "superclass": "Arc",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "examples": {
          "exampleOne": "exampleOne\n\t\"Click any button somewhere on the screen.  The point will be the\n\tcenter of the circcle of radius 150.\"\n\n\t| aCircle aForm |\n\taForm _ Form new extent: 1@30.\n\taForm black.\n\taCircle _ Circle new.\n\taCircle form: aForm.\n\taCircle radius: 150.\n\taCircle center: Sensor waitButton.\n\taCircle displayOn: Display\n\n\t\"Circle exampleOne.\"\n",
          "exampleTwo": "exampleTwo\n\t\"Designate a rectangular area that should be used as the brush for displaying the\n\tcircle. Click any button at a point on the screen which will be the center location\n\tfor the circle.  The curve will be displayed with a long black form.\"\n\n\t| aCircle aForm |\n\taForm _ Form fromUser.\n\taCircle _ Circle new.\n\taCircle form: aForm.\n\taCircle radius: 150.\n\taCircle center: Sensor waitButton.\n\taCircle displayOn: Display at: 0 @ 0 rule: Form reverse\n\n\t \"Circle exampleTwo.\"\n"
        }
      },
      "instance_methods": {
        "displaying": {
          "displayOn:transformation:clippingBox:rule:mask:": "displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger mask: aForm\n\t1 to: 4 do:\n\t\t[:i |\n\t\tsuper quadrant: i.\n\t\tsuper displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger mask: aForm]\n",
          "displayOn:at:clippingBox:rule:mask:": "displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger mask: aForm\n\t1 to: 4 do:\n\t\t[:i |\n\t\tsuper quadrant: i.\n\t\tsuper displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger mask: aForm]\n"
        },
        "display box access": {
          "computeBoundingBox": "computeBoundingBox\n\t^center - radius + form offset extent: form extent + (radius * 2) asPoint\n"
        }
      }
    },
    "Arc": {
      "comment": "A quarter of a Circle, the quadrant is specified by 1, 2, 3 or 4 points which indicate which part of the circle is to be displayed. Quadrants are numbered 1 - 4 counter clockwise.\n",
      "class_name": "Arc",
      "superclass": "Path",
      "instanceVariables": "quadrant radius center",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "examples": {
          "example": "example\n\t\"Click the button somewhere on the screen.  The designated point will\n\tbe the center of an Arc with radius 50 in the 4th quadrant.\"\n\n\t| anArc aForm |\n\taForm _ Form new extent: 1 @ 30.\t\"make a long thin Form for display\"\n\taForm black.\t\t\t\t\t\t\"turn it black\"\n\tanArc _ Arc new.\n\tanArc form: aForm.\t\t\t\t\t\"set the form for display\"\n\tanArc radius: 50.0.\n\tanArc center: Sensor waitButton.\n\tanArc quadrant: 4.\n\tanArc displayOn: Display.\n\tSensor waitButton\n\n\t\"Arc example.\"\n"
        }
      },
      "instance_methods": {
        "displaying": {
          "displayOn:transformation:clippingBox:rule:mask:": "displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger mask: aForm\n\t| newArc tempCenter |\n\tnewArc _ Arc new.\n\ttempCenter _ aTransformation applyTo: self center.\n\tnewArc center: tempCenter x truncated @ tempCenter y truncated.\n\tnewArc quadrant: self quadrant.\n\tnewArc radius: (self radius * aTransformation scale x) truncated.\n\tnewArc form: self form.\n\tnewArc\n\t\tdisplayOn: aDisplayMedium\n\t\tat: 0 @ 0\n\t\tclippingBox: clipRect\n\t\trule: anInteger\n\t\tmask: aForm\n",
          "displayOn:at:clippingBox:rule:mask:": "displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger mask: aForm\n\t| nSegments line angle sin cos xn yn xn1 yn1 |\n\tnSegments _ 12.0.\n\tline _ Line new.\n\tline form: self form.\n\tangle _ 90.0 / nSegments.\n\tsin _ (angle * (2 * Float pi / 360.0)) sin.\n\tcos _ (angle * (2 * Float pi / 360.0)) cos.\n\tquadrant = 1\n\t\tifTrue:\n\t\t\t[xn _ radius asFloat.\n\t\t\tyn _ 0.0].\n\tquadrant = 2\n\t\tifTrue:\n\t\t\t[xn _ 0.0.\n\t\t\tyn _ 0.0 - radius asFloat].\n\tquadrant = 3\n\t\tifTrue:\n\t\t\t[xn _ 0.0 - radius asFloat.\n\t\t\tyn _ 0.0].\n\tquadrant = 4\n\t\tifTrue:\n\t\t\t[xn _ 0.0.\n\t\t\tyn _ radius asFloat].\n\tnSegments truncated\n\t\ttimesRepeat:\n\t\t\t[xn1 _ xn * cos + (yn * sin).\n\t\t\tyn1 _ yn * cos - (xn * sin).\n\t\t\tline beginPoint: center + (xn truncated @ yn truncated).\n\t\t\tline endPoint: center + (xn1 truncated @ yn1 truncated).\n\t\t\tline\n\t\t\t\tdisplayOn: aDisplayMedium\n\t\t\t\tat: aPoint\n\t\t\t\tclippingBox: clipRect\n\t\t\t\trule: anInteger\n\t\t\t\tmask: aForm.\n\t\t\txn _ xn1.\n\t\t\tyn _ yn1]\n"
        },
        "accessing": {
          "radius": "radius\n\t\"Answer the receiver's radius.\"\n\t^radius\n",
          "radius:": "radius: anInteger\n\t\"Set anInteger to be the receiver's radius.\"\n\tradius _ anInteger\n",
          "center:": "center: aPoint\n\t\"Set aPoint to be the receiver's center.\"\n\tcenter _ aPoint\n",
          "center": "center\n\t\"Answer the point at the center of the receiver.\"\n\t^center\n",
          "quadrant:": "quadrant: section\n\t\"Set section to be the part of the circle represented by the receiver.\"\n\tquadrant _ section\n",
          "center:radius:quadrant:": "center: aPoint radius: anInteger quadrant: section\n\t\"The receiver is an Arc for the quadrant specified by section.  The size of\n\tthe arc is defined by the center and its radius.\"\n\n\tcenter _ aPoint.\n\tradius _ anInteger.\n\tquadrant _ section\n",
          "quadrant": "quadrant\n\t\"Answer the section of a circle represented by the receiver.\"\n\t^quadrant\n",
          "center:radius:": "center: aPoint radius: anInteger\n\t\"The receiver is defined by a point at the center and a radius.\n\tThe quadrant is not reset.\"\n\tcenter _ aPoint.\n\tradius _ anInteger\n"
        }
      }
    }
  },
  "Graphics-Primitives": {
    "Quadrangle": {
      "comment": "I represent a particular kind of Rectangle that has a border and inside color.\n\nInstance Variables:\n\tborderWidth\t\t<Rectangle> the left, right, top, bottom border widths\n\tborderColor\t\t<Form>\n\tinsideColor \t\t<Form>\n",
      "class_name": "Quadrangle",
      "superclass": "Rectangle",
      "instanceVariables": "borderWidth borderColor insideColor",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t\"Answer an instance of me, initialized to a null Rectangle,\n\twith borderWidth of 1, borderColor of black, and insideColor of white.\"\n\n\t^super new initialize\n",
          "region:borderWidth:borderColor:insideColor:": "region: aRectangle borderWidth: anInteger borderColor: aMask1 insideColor: aMask2\n\t\"Answer an instance of me with rectangle, border width and color, and\n\tinside color determined by the arguments.\"\n\n\t^super new\n\t\tregion: aRectangle\n\t\tborderWidth: anInteger\n\t\tborderColor: aMask1\n\t\tinsideColor: aMask2\n"
        }
      },
      "instance_methods": {
        "displaying-Display": {
          "display": "display\n\tself displayOn: Display\n"
        },
        "bordering": {
          "borderColor:": "borderColor: aColor\n\t\"Set the borderColor of the receiver to aColor.\"\n\tborderColor _ aColor\n",
          "region:": "region: aRectangle\n\t\"Set the rectangular area of the receiver to aRectangle.\"\n\n\torigin _ aRectangle origin.\n\tcorner _ aRectangle corner\n",
          "borderColor": "borderColor\n\t\"Answer the borderColor of the receiver.\"\n\t^borderColor\n",
          "borderWidthLeft:right:top:bottom:": "borderWidthLeft: anInteger1 right: anInteger2 top: anInteger3 bottom: anInteger4\n\t\"Set the border width of the receiver to a Rectangle that represents the left,\n\tright, top, and bottom border widths.\"\n\n\tborderWidth _ anInteger1 @ anInteger3 corner: anInteger2 @ anInteger4\n",
          "insideColor": "insideColor\n\t\"Answer the insideColor of the receiver.\"\n\t^insideColor\n",
          "inside": "inside\n\t\"Answer a Rectangle that is the receiver inset by the borderWidth.\"\n\t^self insetBy: borderWidth\n",
          "borderWidth:": "borderWidth: anInteger\n\t\"Set the borderWidth of the receiver to anInteger.\"\n\tborderWidth _ anInteger\n",
          "region": "region\n\t\"Answer a Rectangle that defines the area of the receiver.\"\n\t^origin corner: corner\n",
          "insideColor:": "insideColor: aColor\n\t\"Set the insideColor of the receiver to aColor.\"\n\tinsideColor _ aColor\n",
          "borderWidth": "borderWidth\n\t\"Answer the borderWidth of the receiver.\"\n\t^borderWidth\n"
        },
        "transforming": {
          "align:with:": "align: aPoint1 with: aPoint2\n\t\"Answer a new Quadrangle translated by aPoint2 - aPoint1.\"\n\n\t^ Quadrangle\n\t\tregion: (super translateBy: aPoint2 - aPoint1)\n\t\tborderWidth: borderWidth\n\t\tborderColor: borderColor\n\t\tinsideColor: insideColor\n",
          "scaleBy:": "scaleBy: aPoint\n\t\"Answer a new Quadrangle scaled by aPoint.\"\n\n\t^ Quadrangle\n\t\tregion: (super scaleBy: aPoint)\n\t\tborderWidth: borderWidth\n\t\tborderColor: borderColor\n\t\tinsideColor: insideColor\n",
          "translateBy:": "translateBy: aPoint\n\t\"Answer a new Quadrangle translated by aPoint.\"\n\n\t^ Quadrangle\n\t\tregion: (super translateBy: aPoint)\n\t\tborderWidth: borderWidth\n\t\tborderColor: borderColor\n\t\tinsideColor: insideColor\n"
        },
        "displaying-generic": {
          "displayOn:align:with:clippingBox:": "displayOn: aDisplayMedium align: aPoint1 with: aPoint2 clippingBox: aRectangle\n\t\"Display the border and region of the reciever so that its position at\n\taPoint1 is aligned with position aPoint2.  The displayed information should\n\tbe clipped so that only information with the area determined by aRectangle\n\tis displayed.\"\n\n\t| savedRegion |\n\tsavedRegion _ self region.\n\tself region: ((savedRegion align: aPoint1 with: aPoint2) intersect: aRectangle).\n\tself displayOn: aDisplayMedium.\n\tself region: savedRegion\n",
          "displayOn:transformation:clippingBox:": "displayOn: aDisplayMedium transformation: aWindowingTransformation clippingBox: aRectangle\n\t\"Display the border and region of the reciever so that it is scaled and translated\n\twith respect to aWindowingTransformation.  The displayed information should\n\tbe clipped so that only information with the area determined by aRectangle\n\tis displayed.\"\n\n\t| screenRectangle |\n\tscreenRectangle _\n\t\t(aWindowingTransformation applyTo: self) intersect: aRectangle.\n\tborderWidth ~~ 0 & (insideColor ~~ nil)\n\t\tifTrue:\n\t\t\t[aDisplayMedium fill: screenRectangle mask: borderColor.\n\t\t\taDisplayMedium\n\t\t\t\tfill: (screenRectangle insetBy: borderWidth)\n\t\t\t\tmask: insideColor]\n",
          "displayOn:": "displayOn: aDisplayMedium\n\t\"Display the border and insideRegion of the receiver.\"\n\n\tinsideColor ~~ nil ifTrue: [aDisplayMedium fill: self inside mask: insideColor].\n\tborderWidth ~~ 0 & (insideColor ~~ nil)\n\t\tifTrue:\n\t\t\t[aDisplayMedium fill: self region mask: borderColor.\n\t\t\taDisplayMedium fill: self inside mask: insideColor]\n"
        },
        "displaying": {
          "displayAlign:with:clippingBox:": "displayAlign: aPoint1 with: aPoint2 clippingBox: aRectangle\n\t\"Display the border and region of the reciever so that its position at\n\taPoint1 is aligned with position aPoint2.  The displayed information should\n\tbe clipped so that only information with the area determined by aRectangle\n\tis displayed.\"\n\n\t| savedRegion |\n\tsavedRegion _ self region.\n\tself region: ((savedRegion align: aPoint1 with: aPoint2) intersect: aRectangle).\n\tself displayOn: Display.\n\tself region: savedRegion\n"
        },
        "private": {
          "region:borderWidth:borderColor:insideColor:": "region: aRectangle borderWidth: anInteger borderColor: aMask1 insideColor: aMask2\n\torigin _ aRectangle origin.\n\tcorner _ aRectangle corner.\n\tborderWidth _ anInteger.\n\tborderColor _ aMask1.\n\tinsideColor _ aMask2.\n"
        },
        "initialize-release": {
          "initialize": "initialize\n\t\"Initialize the region to a null Rectangle, the borderWidth to 1, the\n\tborderColor to black, and the insideColor to white.\"\n\n\torigin _ 0 @ 0.\n\tcorner _ 0 @ 0.\n\tborderWidth _ 1.\n\tborderColor _ Form black.\n\tinsideColor _ Form white\n"
        },
        "rectangle functions": {
          "intersect:": "intersect: aRectangle\n\t\"Answer a new Quadrangle whose region is the intersection of the\n\treceiver's area and aRectangle.\"\n\n\t^ Quadrangle\n\t \tregion: (super intersect: aRectangle)\n\t\tborderWidth: borderWidth\n\t\tborderColor: borderColor\n\t\tinsideColor: insideColor\n"
        }
      }
    },
    "Point": {
      "comment": "I am an x-y pair of numbers usually designating a location on the screen\n",
      "class_name": "Point",
      "superclass": "Object",
      "instanceVariables": "x y",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "x:y:": "x: xInteger y: yInteger\n\t\"Answer a new instance of me with coordinates xInteger and yInteger.\"\n\t^self new setX: xInteger setY: yInteger\n"
        }
      },
      "instance_methods": {
        "point functions": {
          "transpose": "transpose\n\t\"Answer a new Point whose x is the receiver's y and whose y is the receiver's x.\"\n\n\t^y @ x\n",
          "pointNearestLine:to:": "pointNearestLine: point1 to: point2\n\t\"Answers the closest integer point to the receiver on the line determined by (point1, point2).\"\n\n\t| relPoint delta |\n\tdelta _ point2 - point1. \t\t\t\"normalize coordinates\"\n\trelPoint _ self - point1.\n\tdelta x = 0 ifTrue: [^point1 x@y].\n\tdelta y = 0 ifTrue: [^x@point1 y].\n\tdelta x abs > delta y abs \t\t\"line more horizontal?\"\n\t\tifTrue: [^x@(point1 y + (x * delta y // delta x))]\n\t\tifFalse: [^(point1 x + (relPoint y * delta x // delta y))@y]\n\n\t\"43@55 pointNearestLine: 10@10 to: 100@200\"\n",
          "dist:": "dist: aPoint\n\t\"Answer the distance between aPoint and the receiver.\"\n\n\t^(aPoint - self) r\n",
          "dotProduct:": "dotProduct: aPoint\n\t\"Answer a Number that is the dot product of the receiver and the argument, aPoint.\n\tThat is, the two points are multipled and the coordinates of the result summed.\"\n\n\t| temp |\n\ttemp _ self * aPoint.\n\t^temp x abs + temp y abs\n",
          "truncatedGrid:": "truncatedGrid: aPoint\n\t\"Answer a new Point to the nearest truncated grid modules specified\n\tby aPoint.\"\n\n\t^(x truncateTo: aPoint x) @ (y truncateTo: aPoint y)\n",
          "grid:": "grid: aPoint\n\t\"Answer a new Point to the nearest rounded grid modules specified\n\tby aPoint.\"\n\n\t| newX newY |\n\n\taPoint x = 0\n\t\tifTrue:\t[newX _ 0]\n\t\tifFalse:\t[newX _ x roundTo: aPoint x].\n\taPoint y = 0\n\t\tifTrue:\t[newY _ 0]\n\t\tifFalse:\t[newY _ y roundTo: aPoint y].\n\t^newX @ newY\n",
          "unitVector": "unitVector\n\t\"Answer the receiver scaled to unit length.\"\n\t^self / self r\n",
          "normal": "normal\n\t\"Answer a new Point representing the unit vector rotated 90 deg toward the y axis.\"\n\n\t^(y negated @ x) unitVector\n"
        },
        "comparing": {
          "min:": "min: aPoint\n\t\"Answer the upper left corner of the rectangle uniquely defined\n\tby the receiver and aPoint.\"\n\n\t^Point\n\t\tx: (x min: aPoint x)\n\t\ty: (y min: aPoint y)\n",
          "hash": "hash\n\t^(x hash bitShift: 2) bitXor: y hash\n",
          ">": "> aPoint\n\t\"Answer whether the receiver is 'below and to the right' of aPoint.\"\n\n\t^x > aPoint x and: [y > aPoint y]\n",
          "max:": "max: aPoint\n\t\"Answer the lower right corner of the rectangle uniquely defined\n\tby the receiver and aPoint.\"\n\n\t^Point\n\t\tx: (x max: aPoint x)\n\t\ty: (y max: aPoint y)\n",
          "<": "< aPoint\n\t\"Answer whether the receiver is 'above and to the left' of aPoint.\"\n\t^x < aPoint x and: [y < aPoint y]\n",
          "=": "= aPoint\n\tself species = aPoint species\n\t\tifTrue: [^x = aPoint x and: [y = aPoint y]]\n\t\tifFalse: [^false]\n",
          "hashMappedBy:": "hashMappedBy: map\n\t\"My hash is independent of my oop\"\n\t^ self hash\n",
          ">=": ">= aPoint\n\t\"Answer whether the receiver is 'neither above nor to the left' of aPoint.\"\n\n\t^x >= aPoint x and: [y >= aPoint y]\n",
          "<=": "<= aPoint\n\t\"Answer whether the receiver is 'neither below nor to the right' of aPoint.\"\n\n\t^x <= aPoint x and: [y <= aPoint y]\n"
        },
        "coercing": {
          "coerce:": "coerce: aNumber\n\t^aNumber@aNumber\n",
          "generality": "generality\n\t^90\n"
        },
        "truncation and round off": {
          "truncateTo:": "truncateTo: grid\n\t\"Answer a new Point that is the receiver's x and y truncated to grid x and grid y.\"\n\n\t^(x truncateTo: grid) @ (y truncateTo: grid)\n",
          "rounded": "rounded\n\t\"Answer a new Point that is the receiver's x and y rounded.\"\n\n\t^x rounded @ y rounded\n"
        },
        "transforming": {
          "scaleBy:": "scaleBy: factor\n\t\"Answer a new Point scaled by factor (an instance of Point).\"\n\n\t^(factor x * x) @ (factor y * y)\n",
          "translateBy:": "translateBy: delta\n\t\"Answer a new Point translated by delta (an instance of Point).\"\n\n\t^(delta x + x) @ (delta y + y)\n"
        },
        "printing": {
          "printOn:": "printOn: aStream\n\t\"The receiver prints on aStream in terms of infix notation.\"\n\n\tx printOn: aStream.\n\taStream nextPut: $@.\n\ty printOn: aStream\n",
          "storeOn:": "storeOn: aStream\n\n\taStream nextPut: $(;\n\tnextPutAll: self species name;\n\tnextPutAll: ' x: ';\n\tstore: x;\n\tnextPutAll: ' y: ';\n\tstore: y;\n\tnextPut: $).\n"
        },
        "copying": {
          "deepCopy": "deepCopy\n\t\"Implemented here for better performance.\"\n\t^x deepCopy @ y deepCopy\n",
          "shallowCopy": "shallowCopy\n\t\"Implemented here for better performance.\"\n\t^x @ y\n"
        },
        "polar coordinates": {
          "theta": "theta\n\t\"Answer the angle the receiver makes with origin in radians.\n\tright is 0; down is 90.\"\n\n\t| tan theta |\n\tx = 0\n\t\tifTrue: [y >= 0\n\t\t\t\tifTrue: [^1.5708\"90.0 degreesToRadians\"]\n\t\t\t\tifFalse: [^4.71239\"270.0 degreesToRadians\"]]\n\t\tifFalse:\n\t\t\t[tan _ y asFloat / x asFloat.\n\t\t\ttheta _ tan arcTan.\n\t\t\tx >= 0\n\t\t\t\tifTrue: [y >= 0\n\t\t\t\t\t\tifTrue: [^theta]\n\t\t\t\t\t\tifFalse: [^360.0 degreesToRadians + theta]]\n\t\t\t\tifFalse: [^180.0 degreesToRadians + theta]]\n",
          "r": "r\n\t\"Answer the receiver's radius in polar coordinate system.\"\n\n\t^(self dotProduct: self) sqrt\n"
        },
        "accessing": {
          "y:": "y: yInteger\n\t\"Set the y coordinate.\"\n\ty _ yInteger\n",
          "x:": "x: xInteger\n\t\"Set the x coordinate.\"\n\tx _ xInteger\n",
          "y": "y\n\t\"Answer the y coordinate.\"\n\t^y\n",
          "x": "x\n\t\"Answer the x coordinate.\"\n\t^x\n"
        },
        "private": {
          "setX:setY:": "setX: xPoint setY: yPoint\n\tx _ xPoint.\n\ty _ yPoint\n"
        },
        "converting": {
          "extent:": "extent: aPoint\n\t\"Answer a new Rectangle whose origin is the receiver and whose extent is aPoint.\n\tThis is one of the infix ways of expressing the creation of a rectangle.\"\n\n\t^Rectangle origin: self extent: aPoint\n",
          "corner:": "corner: aPoint\n\t\"Answer a new Rectangle whose origin is the receiver and whose corner is aPoint.\n\tThis is one of the infix ways of expressing the creation of a rectangle.\"\n\n\t^Rectangle origin: self corner: aPoint\n",
          "asPoint": "asPoint\n\t\"Answer the receiver itself.\"\n\t^self\n"
        },
        "arithmetic": {
          "-": "- delta\n\t\"Answer a new Point that is the difference of the receiver and delta (which is a\n\tPoint or Number).\"\n\n\t| deltaPoint |\n\tdeltaPoint _ delta asPoint.\n\t^x - deltaPoint x @ (y - deltaPoint y)\n",
          "/": "/ scale\n\t\"Answer a new Point that is the quotient of the receiver and scale (which is a\n\tPoint or Number).\"\n\n\t| scalePoint |\n\tscalePoint _ scale asPoint.\n\t^x / scalePoint x @ (y / scalePoint y)\n",
          "*": "* scale\n\t\"Answer a new Point that is the product of the receiver and scale (which is a\n\tPoint or Number).\"\n\n\t| scalePoint |\n\tscalePoint _ scale asPoint.\n\t^x * scalePoint x @ (y * scalePoint y)\n",
          "//": "// scale\n\t\"Answer a new Point that is the quotient of the receiver and scale (which is a\n\tPoint or Number).\"\n\n\t| scalePoint |\n\tscalePoint _ scale asPoint.\n\t^x // scalePoint x @ (y // scalePoint y)\n",
          "+": "+ delta\n\t\"Answer a new Point that is the sum of the receiver and delta (which is a Point\n\tor Number).\"\n\n\t| deltaPoint |\n\tdeltaPoint _ delta asPoint.\n\t^x + deltaPoint x @ (y + deltaPoint y)\n",
          "abs": "abs\n\t\"Answer a new Point whose x and y are the absolute values of the receiver's\n\tx and y.\"\n\n\t^Point x: x abs y: y abs\n"
        }
      }
    },
    "Rectangle": {
      "comment": "I usually represent a rectangular area on the screen.  Arithmetic functions take points as arguments and carry out scaling and translating operations to create new Rectangles.  Rectangle functions create new Rectangles by determining intersections of rectangles with rectangles.\n",
      "class_name": "Rectangle",
      "superclass": "Object",
      "instanceVariables": "origin corner",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "fromUserAspectRatio:": "fromUserAspectRatio: aspectPoint\n\t\"Answer an instance of Rectangle that is determined by having the user designate the top left and bottom right corners, constrained so the aspect ratio is determined by aspectPoint.\"\n\n\t| rectangle extent ratio |\n\tCursor origin showWhile:\n\t\t[rectangle _ Sensor waitButton extent: 1@1].\n\tratio _ aspectPoint y/aspectPoint x.\n\tCursor corner showWhile:\n\t\t[Sensor cursorPoint: rectangle corner.\n\t\t[Sensor anyButtonPressed] whileTrue:\n\t\t\t[extent _ Sensor cursorPoint-rectangle origin max: 1@1.\n\t\t\t(extent y*aspectPoint x) > (aspectPoint y*extent x)\n\t\t\t\tifTrue: [extent x: (extent y/ratio) rounded] \t\"contrain width\"\n\t\t\t\tifFalse: [extent y: (extent x*ratio) rounded]. \t\"constrain height\"\n\t\t\trectangle extent: extent.\n\t\t\tDisplay flash: rectangle]].\n\t^rectangle\n\n\t\"Rectangle fromUserAspectRatio: Sensor waitButton\"\n",
          "originFromUser:grid:": "originFromUser: extentPoint grid: scaleFactor\n\t\"Answer an instance of me that is determined by having the\n\tuser designate the top left corner.  The width and height are determined\n\tby extentPoint.  The gridding for user selection is scaleFactor. Assumes that the\n\tsender has determined an extent that is a proper multiple of scaleFactor.\"\n\n\t| tempRect |\n\ttempRect _ (Sensor cursorPoint grid: scaleFactor) extent: extentPoint.\n\t[Sensor redButtonPressed]\n\t\twhileFalse:\n\t\t\t[Display reverse: tempRect.\n\t\t\tDisplay reverse: tempRect.\n\t\t\ttempRect _ (Sensor cursorPoint grid: scaleFactor) extent: extentPoint].\n\t^tempRect\n",
          "fromUser": "fromUser\n\t\"Answer an instance of me that is determined by having the\n\tuser designate the top left and bottom right corners.  The gridding for\n\tuser selection is 1@1.\"\n\t^self fromUser: 1 @ 1\n",
          "origin:corner:": "origin: originPoint corner: cornerPoint\n\t\"Answer an instance of me whose corners (top left and bottom right) are\n\tdetermined by the arguments.\"\n\n\t^self new origin: originPoint corner: cornerPoint\n",
          "originFromUser:": "originFromUser: extentPoint\n\t\"Answer an instance of me that is determined by having the\n\tuser designate the top left corner.  The width and height are determined\n\tby extentPoint.  The gridding for user selection is 1@1.\"\n\n\t^self originFromUser: extentPoint grid: 1 @ 1\n",
          "fromUser:": "fromUser: gridPoint\n\t\"Answer an instance of me that is determined by having the\n\tuser designate the top left and bottom right corners.  The gridding for\n\tuser selection is gridPoint.\"\n\n\t| originPoint newSelf minCorner oldCursor|\n\toldCursor _ Sensor currentCursor.\n\tCursor cursorLink: false.\n\toriginPoint _ Sensor cursorPoint grid: gridPoint.\n\t[Sensor redButtonPressed]\n\t\twhileFalse:\n\t\t\t[Processor yield.\n\t\t\tCursor origin showGridded: gridPoint.\n\t\t\toriginPoint _ Sensor cursorPoint grid: gridPoint].\n\tnewSelf _ self new origin: originPoint.\n\tminCorner _ originPoint + gridPoint.\n\tSensor cursorPoint: minCorner.\n\t[Sensor redButtonPressed]\n\t\t\twhileTrue:\n\t\t\t\t[Processor yield.\n\t\t\t\tCursor corner showGridded: gridPoint.\n\t\t\t\tnewSelf corner: ((Sensor cursorPoint grid: gridPoint) max: minCorner).\n\t\t\t\tDisplay flash: newSelf].\n\tCursor cursorLink: true.\n\toldCursor show.\n\t^newSelf\n\n\t\"Rectangle fromUser: 100@100.\"\n",
          "left:right:top:bottom:": "left: leftNumber right: rightNumber top: topNumber bottom: bottomNumber\n\t\"Answer an instance of me whose left, right, top, and bottom coordinates are\n\tdetermined by the arguments.\"\n\n\t^self origin: leftNumber @ topNumber corner: rightNumber @ bottomNumber\n",
          "origin:extent:": "origin: originPoint extent: extentPoint\n\t\"Answer an instance of me whose top left corner is originPoint and width by\n\theight is extentPoint.\"\n\n\t^self new origin: originPoint extent: extentPoint\n"
        }
      },
      "instance_methods": {
        "comparing": {
          "hash": "hash\n\t^origin hash bitXor: corner hash\n",
          "=": "= aRectangle\n\t\"Answer true if the receiver's species, origin and corner match aRectangle's.\"\n\n\tself species = aRectangle species\n\t\tifTrue: [^origin = aRectangle origin and: [corner = aRectangle corner]]\n\t\tifFalse: [^false]\n",
          "hashMappedBy:": "hashMappedBy: map\n\t\"My hash is independent of my oop\"\n\t^ self hash\n"
        },
        "truncation and round off": {
          "rounded": "rounded\n\t\"Answer a Rectangle whose origin and corner are rounded.\"\n\n\t^Rectangle origin: origin rounded corner: corner rounded\n"
        },
        "transforming": {
          "align:with:": "align: aPoint1 with: aPoint2\n\t\"Answer a new Rectangle that is a translated by aPoint2 - aPoint1.\"\n\t^self translateBy: aPoint2 - aPoint1\n",
          "moveBy:": "moveBy: aPoint\n\t\"Change the corner positions of the receiver so that its area translates by\n\tthe amount defined by the argument, aPoint.\"\n\torigin _ origin + aPoint.\n\tcorner _ corner + aPoint\n",
          "scaleBy:": "scaleBy: scale\n\t\"Answer a new Rectangle scaled by scale, a Point or a scalar.\"\n\n\t^Rectangle origin: origin * scale corner: corner * scale\n",
          "moveTo:": "moveTo: aPoint\n\t\"Change the corners of the receiver so that its top left position is aPoint.\"\n\n\tcorner _ corner + aPoint - origin.\n\torigin _ aPoint\n",
          "translateBy:": "translateBy: factor\n\t\"Answer a new Rectangle translated by factor, a Point or a scalar.\"\n\n\t^Rectangle origin: origin + factor corner: corner + factor\n"
        },
        "printing": {
          "printOn:": "printOn: aStream\n\torigin printOn: aStream.\n\taStream nextPutAll: ' corner: '.\n\tcorner printOn: aStream\n",
          "storeOn:": "storeOn: aStream\n\n\taStream nextPut: $(;\n\tnextPutAll: self species name;\n\tnextPutAll: ' origin: ';\n\tstore: origin;\n\tnextPutAll: ' corner: ';\n\tstore: corner;\n\tnextPut: $).\n"
        },
        "testing": {
          "intersects:": "intersects: aRectangle\n\t\"Answer whether aRectangle intersects the receiver anywhere.\"\n\n\t^(origin max: aRectangle origin) < (corner min: aRectangle corner)\n",
          "containsPoint:": "containsPoint: aPoint\n\t\"Answer whether aPoint is within the receiver.\"\n\n\t^origin <= aPoint and: [aPoint < corner]\n",
          "contains:": "contains: aRectangle\n\t\"Answer whether the receiver is equal to aRectangle or whether aRectangle\n\tis contained within the receiver.\"\n\n\t^aRectangle origin >= origin and: [aRectangle corner <= corner]\n"
        },
        "copying": {
          "copy": "copy\n\t^self deepCopy\n"
        },
        "accessing": {
          "corner": "corner\n\t\"Answer the point at the bottom right corner of the receiver.\"\n\t^corner\n",
          "topLeft:": "topLeft: topLeftPoint\n\t\"Set the point at the top left corner of the receiver's top horizontal line.\"\n\torigin _ topLeftPoint\n",
          "width:": "width: widthInteger\n\t\"Change the receiver's right vertical line to make its width widthInteger.\"\n\tcorner x: origin x + widthInteger\n",
          "width": "width\n\t\"Answer the width of the receiver.\"\n\t^corner x - origin x\n",
          "topCenter": "topCenter\n\t\"Answer the point at the center of the receiver's top horizontal line.\"\n\t^self center x @ self top\n",
          "topLeft": "topLeft\n\t\"Answer the point at the top left corner of the receiver's top horizontal line.\"\n\t^origin\n",
          "origin": "origin\n\t\"Answer the point at the top left corner of the receiver.\"\n\t^origin\n",
          "extent": "extent\n\t\"Answer with a rectangle with origin 0@0 and corner the receiver's\n\twidth @ the receiver's height.\"\n\t^corner - origin\n",
          "bottom:": "bottom: anInteger\n\t\"Set the position of the bottom horizontal line of the receiver.\"\n\tcorner y: anInteger\n",
          "extent:": "extent: extentPoint\n\t\"Set the extent (width and height) of the receiver to be extentPoint.\"\n\tcorner _ origin + extentPoint\n",
          "topRight": "topRight\n\t\"Answer the point at the top right corner of the receiver's top horizontal line.\"\n\t^corner x @ origin y\n",
          "origin:": "origin: originPoint\n\t\"Set the point at the top left corner of the receiver.\"\n\torigin _ originPoint\n",
          "area": "area\n\t\"Answer the receiver's area, the product of width and height.\"\n\t^self width * self height\n",
          "bottomRight": "bottomRight\n\t\"Answer the point at the right edge of the bottom horizontal line of the receiver.\"\n\t^corner\n",
          "origin:corner:": "origin: originPoint corner: cornerPoint\n\t\"Set the points at the top left corner and the bottom right corner of the receiver.\"\n\torigin _ originPoint.\n\tcorner _ cornerPoint\n",
          "left:": "left: anInteger\n\t\"Set the position of the receiver's left vertical line.\"\n\torigin x: anInteger\n",
          "top:": "top: anInteger\n\t\"Set the position of the receiver's top horizontal line.\"\n\torigin y: anInteger\n",
          "bottomCenter": "bottomCenter\n\t\"Answer the point at the center of the bottom horizontal line of the receiver.\"\n\t^self center x @ self bottom\n",
          "height": "height\n\t\"Answer the height of the receiver.\"\n\t^corner y - origin y\n",
          "bottomRight:": "bottomRight: bottomRightPoint\n\t\"Set the position of the right corner of the bottom horizontal line of the receiver.\"\n\tcorner _ bottomRightPoint\n",
          "height:": "height: heightInteger\n\t\"Change the receiver's bottom y to make its height heightInteger.\"\n\tcorner y: origin y + heightInteger\n",
          "left": "left\n\t\"Answer the position of the receiver's left vertical line.\"\n\t^origin x\n",
          "center": "center\n\t\"Answer the point at the center of the receiver.\"\n\t^self topLeft + self bottomRight // 2\n",
          "rightCenter": "rightCenter\n\t\"Answer the point at the center of the receiver's right vertical line.\"\n\t^self right @ self center y\n",
          "leftCenter": "leftCenter\n\t\"Answer the point at the center of the receiver's left vertical line.\"\n\t^self left @ self center y\n",
          "bottom": "bottom\n\t\"Answer the position of the receiver's bottom horizontal line.\"\n\t^corner y\n",
          "corner:": "corner: cornerPoint\n\t\"Set the point at the bottom right corner of the receiver.\"\n\tcorner _ cornerPoint\n",
          "bottomLeft": "bottomLeft\n\t\"Answer the point at the left edge of the bottom horizontal line of the receiver.\"\n\t^origin x @ corner y\n",
          "top": "top\n\t\"Answer the position of the receiver's top horizontal line.\"\n\t^origin y\n",
          "right:": "right: anInteger\n\t\"Set the position of the receiver's right vertical line.\"\n\tcorner x: anInteger\n",
          "origin:extent:": "origin: originPoint extent: extentPoint\n\t\"Set the point at the top left corner of the receiver to be originPoint and\n\tset the width and height of the receiver to be extentPoint.\"\n\torigin _ originPoint.\n\tcorner _ origin + extentPoint\n",
          "right": "right\n\t\"Answer the position of the receiver's right vertical line.\"\n\t^corner x\n"
        },
        "rectangle functions": {
          "amountToTranslateWithin:": "amountToTranslateWithin: aRectangle\n\t\"Answer a Point, delta, such that self + delta is forced within aRectangle.\"\n\n\t| delta |\n\tdelta _ 0@0.\n\tself left < aRectangle left ifTrue: [delta x: aRectangle left - self left].\n\tself top < aRectangle top ifTrue: [delta y: aRectangle top - self top].\n\tself right > aRectangle right ifTrue: [delta x: aRectangle right - self right].\n\tself bottom > aRectangle bottom ifTrue: [delta y: aRectangle bottom - self bottom].\n\t^delta\n",
          "expandBy:": "expandBy: delta\n\t\"Answer a Rectangle that is outset from the receiver by delta.\n\t delta is a Rectangle, Point, or scalar.\"\n\n\t(delta isKindOf: Rectangle)\n\t\tifTrue: [^Rectangle\n\t\t\t\t\torigin: origin - delta origin\n\t\t\t\t\tcorner: corner + delta corner]\n\t\tifFalse: [^Rectangle\n\t\t\t\t\torigin: origin - delta\n\t\t\t\t\tcorner: corner + delta]\n",
          "areasOutside:": "areasOutside: aRectangle\n\t\"Answer with a Collection of Rectangles comprising the parts of me\n\twhich do not lie within aRectangle.\"\n\t| areas yOrigin yCorner |\n\t\"Make sure the intersection is non-empty\"\n\t(origin <= aRectangle corner and: [aRectangle origin <= corner])\n\t\tifFalse: [^Array with: self].\n\tareas _ OrderedCollection new.\n\taRectangle origin y > origin y\n\t\tifTrue: [areas add: (origin corner: corner x @ (yOrigin _ aRectangle origin y))]\n\t\tifFalse: [yOrigin _ origin y].\n\taRectangle corner y < corner y\n\t\tifTrue: [areas add: (origin x @ (yCorner _ aRectangle corner y) corner: corner)]\n\t\tifFalse: [yCorner _ corner y].\n\taRectangle origin x > origin x\n\t\tifTrue: [areas add: (origin x @ yOrigin corner: aRectangle origin x @ yCorner)].\n\taRectangle corner x < corner x\n\t\tifTrue: [areas add: (aRectangle corner x @ yOrigin corner: corner x @ yCorner)].\n\t^areas\n",
          "merge:": "merge: aRectangle\n\t\"Answer a Rectangle that contains both the receiver and aRectangle.\"\n\n\t^Rectangle\n\t\torigin: (origin min: aRectangle origin)\n\t\tcorner: (corner max: aRectangle corner)\n",
          "insetOriginBy:cornerBy:": "insetOriginBy: originDeltaPoint cornerBy: cornerDeltaPoint\n\t\"Answer a Rectangle that is inset from the receiver by a given amount in the\n\torigin and corner.\"\n\n\t^Rectangle\n\t\torigin: origin + originDeltaPoint\n\t\tcorner: corner - cornerDeltaPoint\n",
          "intersect:": "intersect: aRectangle\n\t\"Answer a Rectangle that is the area in which the receiver overlaps with\n\taRectangle. \"\n\n\t^Rectangle\n\t\torigin: (origin max: aRectangle origin)\n\t\tcorner: (corner min: aRectangle corner)\n",
          "insetBy:": "insetBy: delta\n\t\"Answer a Rectangle that is inset from the receiver by delta.\n\t delta is a Rectangle, Point, or scalar.\"\n\n\t(delta isKindOf: Rectangle)\n\t\tifTrue: [^Rectangle\n\t\t\t\t\torigin: origin + delta origin\n\t\t\t\t\tcorner: corner - delta corner]\n\t\tifFalse: [^Rectangle\n\t\t\t\t\torigin: origin + delta\n\t\t\t\t\tcorner: corner - delta]\n"
        }
      }
    },
    "Pen": {
      "comment": "Pens can scribble on the screen, drawing and printing at any angle.\n",
      "class_name": "Pen",
      "superclass": "BitBlt",
      "instanceVariables": "frame location direction penDown",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t| quill |\n\tquill _ super new.\n\tquill destForm: Display.\n\tquill frame: Display boundingBox.\n\tquill sourceOrigin: 0@0.\n\tquill mask: Form black.\n\tquill defaultNib: 1.\n\tquill combinationRule: Form paint.\n\tquill down.\n\tquill home.\n\tquill north.\n\t^quill\n"
        },
        "examples": {
          "example": "example\n\t\"Draws a spiral in gray with a pen that is 4 pixels wide.\"\n\n\t| bic |\n\tbic _ Pen new.\n\tbic mask: Form gray.\n\tbic defaultNib: 4.\n\tbic combinationRule: Form under.\n\t1 to: 50 do: [:i | bic go: i*4. bic turn: 89]\n\t\"Pen example\"\n"
        }
      },
      "instance_methods": {
        "moving": {
          "goto:": "goto: aPoint\n\t\"Move the receiver to position aPoint.  If the pen is down, a line will be drawn\n\tfrom the current position to the new one using the receiver's form source as the\n\tshape of the drawing brush.  The receiver's set direction does not change.\"\n\n\t| old |\n\told _ location.\n\tlocation _ aPoint.\n\tpenDown ifTrue: [self drawFrom: old to: location]\n",
          "place:": "place: aPoint\n\t\"Set the receiver at position aPoint.  No lines are drawn.\"\n\tlocation _ aPoint\n",
          "fillIn:": "fillIn: aBlock\n\t\"Just draw the outline; PressPens fill it in\"\n\n\t^ aBlock value\n",
          "north": "north\n\t\"Set the receiver's direction to facing toward the top of the display screen.\"\n\tdirection _ 270.0\n",
          "go:": "go: distance\n\t\"Move the receiver in its current direction a number of bits equal to\n\tthe argument, distance.  If the pen is down, a line will be drawn using\n\tthe receiver's form source as the shape of the drawing brush.\"\n\n\t| dir |\n\tdir _ direction degreesToRadians.\n\tdir _ dir cos @ dir sin.\n\tself goto: dir * distance + location\n",
          "home": "home\n\t\"Place the receiver at the center of its frame.\"\n\tlocation _ frame center\n",
          "down": "down\n\t\"Set the state of the receiver's pen to down (drawing).\"\n\n\tpenDown _ true\n",
          "turn:": "turn: degrees\n\t\"Change the direction that the receiver faces by an amount equal to the argument, degrees.\"\n\tdirection _ (direction + degrees) \\\\ 360\n",
          "up": "up\n\t\"Set the state of the receiver's pen to up (not drawing).\"\n\tpenDown _ false\n"
        },
        "accessing": {
          "location": "location\n\t\"Answer where the receiver is currently located.\"\n\t^location\n",
          "width:": "width: anInteger\n\t\"Setting width with this message is not allowed.\"\n\n\tself error: 'Pen widths cannot be reset this way;  use defaultNib: or specify a new source form using sourceForm: '\n",
          "sourceForm:": "sourceForm: aForm\n\tsourceForm _ aForm.\n\twidth _ aForm width.\n\theight _ aForm height.\n",
          "frame": "frame\n\t\"Answer with the rectangle in which the receiver can draw.\"\n\t^frame\n",
          "direction": "direction\n\t\"Answer the receiver's current direction. 0 is towards the top of the screen.\"\n\t^direction\n",
          "frame:": "frame: aRectangle\n\t\"Set the rectangle in which the receiver can draw.\"\n\tframe _ aRectangle.\n\tself clipRect: aRectangle\n"
        },
        "initialize-release": {
          "defaultNib:": "defaultNib: widthInteger\n\t\"Nib is the tip of a pen.  This is an easy way to set up a default pen.\"\n\n\tself sourceForm: (Form dotOfSize: widthInteger)\n"
        },
        "coloring": {
          "black": "black\n\t\"Set the receiver's mask to the black form.\"\n\tself mask: Form black\n",
          "color:": "color: ignored\n\t\"Only meaningful for PressPens\"\n",
          "white": "white\n\t\"Set the receiver's mask to the white form.\"\n\tself mask: Form white\n"
        },
        "geometric designs": {
          "filberts:side:": "filberts: n side: s\n\t\"Two Hilbert curve fragments back to back form a Hilbert tile.  Draw four\n\tinterlocking tiles of order n directly on the display.  (Can you fix this algorithm?)\"\n\n\t| n2 |\n\tDisplay white.\n\tn2 _ 1 bitShift: n - 1.\n\tself up; go: 0 - n2 * s; down.\n\t1 to: 4 do:\n\t\t[:i |\n\t\tself color: i - 1 * 40.\n\t\tself\n\t\t\tfillIn:\n\t\t\t\t[self hilbert: n side: s.\n\t\t\t\tself go: s.\n\t\t\t\tself hilbert: n side: s.\n\t\t\t\tself go: s].\n\t\tself black.\n\t\tself hilbert: n side: s.\n\t\tself go: s.\n\t\tself hilbert: n side: s.\n\t\tself go: s.\n\t\tself up.\n\t\tself go: n2 - 1 * s.\n\t\tself turn: -90.\n\t\tself go: n2 * s.\n\t\tself turn: 180.\n\t\tself down]\n\t\"\n\tPen new filberts: 3 side: 10.\n\t\"\n",
          "spiral:angle:": "spiral: n angle: a\n\t\"Draw a double squiral directly on the display.\"\n\t1 to: n do:\n\t\t[:i |\n\t\tself color: i * 2 \\\\ 256.\n\t\tself go: i; turn: a]\n\t\"\n\tDisplay white.  Pen new spiral: 200 angle: 89; home; spiral: 200\n\t\tangle: -89.\n\t\"\n",
          "mandala:diameter:": "mandala: npoints diameter: d\n\t\"On a circle of diameter d, place n points.  Draw all possible connecting\n\tlines directly on the display.\"\n\n\t| l points |\n\tDisplay white.\n\tl _ (3.14 * d / npoints) rounded.\n\tself home; up; turn: -90; go: d // 2; turn: 90; go: 0 - l // 2.\n\tpoints _ Array new: npoints.\n\t1 to: npoints do:\n\t\t[:i |\n\t\tpoints at: i put: location.\n\t\tself go: l; turn: 360 // npoints].\n\tself down.\n\tnpoints // 2\n\t\tto: 1\n\t\tby: -1\n\t\tdo:\n\t\t\t[:i |\n\t\t\tself color: npoints // 2 - i * 20 \\\\ 250.\n\t\t\t1 to: npoints do:\n\t\t\t\t[:j |\n\t\t\t\tself place: (points at: j).\n\t\t\t\tself goto: (points at: j + i - 1 \\\\ npoints + 1)]]\n\t\"\n\tPen new mandala: 30 diameter: 400.\n\t\"\n",
          "dragon:": "dragon: order\n\t\"Draws a dragon curve of order order in the center of the screen.  Writes\n\tdirectly into the display bitmap.\"\n\n\torder = 0\n\t\tifTrue: [self go: 10]\n\t\tifFalse: [order > 0\n\t\t\t\tifTrue: [self dragon: order - 1; turn: 90; dragon: 1 - order]\n\t\t\t\tifFalse: [self dragon: -1 - order; turn: -90; dragon: 1 + order]]\n\t\"\n\tPen new dragon: 8.\n\t\"\n",
          "hilberts:": "hilberts: n\n\t\"Demonstrates the space-filling nature of Hilbert curves by drawing n\n\tlevers of nested curves on the screen.\"\n\n\t| s |\n\tself up; go: 128; down.\n\t1 to: n do:\n\t\t[:i |\n\t\ts _ 256 bitShift: 0 - i.\n\t\tself color: n - i * 40.\n\t\tself defaultNib: n - i + 1.\n\t\tself up; go: 0 - s // 2; turn: -90; go: s // 2; turn: 90; down.\n\t\tself hilbert: i side: s.\n\t\tself go: s.\n\t\tself hilbert: i side: s.\n\t\tself go: s]\n\t\"\n\tDisplay white.  Pen new hilberts: 4.\n\t\"\n",
          "hilbert:side:": "hilbert: n side: s\n\t\"Draws an nth lever Hilbert curve directly into the display bitmap.  A\n\tHilbert curve is a space-filling curve.\"\n\n\t| a m |\n\tn = 0 ifTrue: [^self turn: 180].\n\tn > 0\n\t\tifTrue:\n\t\t\t[a _ 90.\n\t\t\tm _ n - 1]\n\t\tifFalse:\n\t\t\t[a _ -90.\n\t\t\tm _ n + 1].\n\tself turn: a.\n\tself hilbert: 0 - m side: s.\n\tself turn: a; go: s.\n\tself hilbert: m side: s.\n\tself turn: 0 - a; go: s; turn: 0 - a.\n\tself hilbert: m side: s.\n\tself go: s; turn: a.\n\tself hilbert: 0 - m side: s.\n\tself turn: a\n\t\"\n\t(Pen new) hilbert: 3 side: 8.\n\t(Pen new sourceForm: Cursor wait) combinationRule: Form under;\n\thilbert: 3 side: 25.\n\t\"\n"
        }
      }
    }
  },
  "Graphics-Support": {
    "DisplayScanner": {
      "comment": "My instances hold the state of CharacterScanner in addition to the following required only for displaying or printing.  They are used to scan text and display it on the screen or in a hidden form.\n\nInstance Variables\n\n\tlineY\t<Integer>  Top of line currently being displayed or scanned.  The textStyle lineGrid is added or subtracted to discover the top of the next line.  May differ from destY when fonts of differing height fall on the same line.\n\n\trunX\t<Integer>  Left of first character in the current run -- allows for creating underlining or similar emphasis.\n",
      "class_name": "DisplayScanner",
      "superclass": "CharacterScanner",
      "instanceVariables": "lineY runX",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "TextConstants",
      "instance_methods": {
        "scanning": {
          "displayLines:in:clippedBy:": "displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle\n\t\"The central display routine.  The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to the StopConditions array passed to the primitive at which time the code to handle the stopCondition is run and the call on the primitive continued until a stopCondition returns true which means the line has terminated.\"\n\n\t| runLength done lineGrid lineIndex stopCondition displaying|\n\n\tself initializeFromParagraph: aParagraph clippedBy: visibleRectangle.\n\trightMargin _ aParagraph rightMarginForDisplay.\n\tlineGrid _ textStyle lineGrid.\n\t\"assume outputMedium Display\"\n\tlineY _ destY _\n\t\t\t\t\taParagraph topAtLineIndex: linesInterval first.\n\tdisplaying _ self doesDisplaying.\n\tlinesInterval do:\n\t\t[:lineIndex |\n\t\trunX _ destX _ leftMargin _\n\t\t\taParagraph leftMarginForDisplayForLine: lineIndex.\n\t\tline _ aParagraph lineAt: lineIndex.\n\t\ttext _ aParagraph textAt: lineIndex.\n\t\tlastIndex _ line first.\n\t\tself setStopConditions.\t\"also sets the font\"\n\t\tdestY _ lineY + self fontAscentDelta.\t\t\"fontAscent delta\".\n\n\t\trunLength _ text runLengthFor: line first.\n\t\t(runStopIndex _ lastIndex + (runLength - 1)) > line last\n\t\t\tifTrue: [runStopIndex _ line last].\n\t\tspaceCount _ 0.\n\t\tdone _ false.\n\t\t[done]\n\t\t\twhileFalse:\n\t\t\t\t[stopCondition _\n\t\t\t\t\t\t\t\tself scanCharactersFrom: lastIndex\n\t\t\t\t\t\t\t\t\tto: runStopIndex\n\t\t\t\t\t\t\t\t\tin: text string\n\t\t\t\t\t\t\t\t\trightX: rightMargin\n\t\t\t\t\t\t\t\t\tstopConditions: stopConditions\n\t\t\t\t\t\t\t\t\tdisplaying: displaying.\n\t\t\t\t\"see setStopConditions for stopping conditions for displaying.\"\n\t\t\t\tdone _ self perform: stopCondition].\n\t\t\t\"Y origin upper left -- increases as moving down page.\"\n\t\t\t\t\tlineY _ lineY + lineGrid].\n\t\t^lineIndex\n"
        },
        "private": {
          "initializeFromParagraph:clippedBy:": "initializeFromParagraph: aParagraph clippedBy: clippingRectangle\n\n\tsuper initializeFromParagraph: aParagraph clippedBy: clippingRectangle\n",
          "doesDisplaying": "doesDisplaying\n\t^true\n",
          "checkEmphasis": "checkEmphasis\n\t| emphasis sourceRect italicY lineSegment displayDestX displayRunX |\n\n\t(emphasis _ (font emphasis bitAnd: 7)) = 0\n\t\tifTrue: [^self].\n\tdisplayDestX _ destX.\n\t\t\t\t\tdisplayRunX _ runX.\n\temphasis >= 8\t\"overstrike\"\n\t\tifTrue:\t[destForm\n\t\t\t\t\t\t\tfill: ((displayRunX @ (lineY + textStyle baseline-3))\n\t\t\t\t\t\t\textent: (displayDestX - displayRunX) @ 1)\n\t\t\t\t\t\t\trule: combinationRule mask: halftoneForm.\n\t\t\t\temphasis _ emphasis - 8].\n\temphasis >= 4\t\"underlined\"\n\t\tifTrue:\t[lineSegment _\n\t\t\t\t\t\t\t\t((displayRunX @ (lineY + textStyle baseline + 1))\n\t\t\t\t\t\t\t\t\textent: (displayDestX - displayRunX) @ 1).\n\t\t\t\t\t\t\tlineSegment bottom <= (clipY+clipHeight) ifTrue:\n\t\t\t\t\t\t\t\t[destForm fill: lineSegment\n\t\t\t\t\t\t\t\t\trule: combinationRule\n\t\t\t\t\t\t\t\t\tmask: halftoneForm].\n\t\t\t\t\temphasis _ emphasis - 4].\n\temphasis >= 2\t\"italic\"\n\t\tifTrue:\t[italicY _ lineY + textStyle lineGrid - 4.\n\t\t\t\t\t\t\t[italicY > lineY]\n\t\t\t\t\t\t\twhileTrue:\n\t\t\t\t\t\t\t[sourceRect _\n\t\t\t\t\t\t\t\tdisplayRunX @ lineY\n\t\t\t\t\t\t\t\t\textent: (displayDestX - displayRunX - 1)\n\t\t\t\t\t\t\t\t\t\t\t\t@ (italicY - lineY).\n\t\t\t\t\t\t\tdestForm\n\t\t\t\t\t\t\tcopyBits: sourceRect\n\t\t\t\t\t\t\tfrom: destForm\n\t\t\t\t\t\t\tat: (displayRunX+1) @ lineY\n\t\t\t\t\t\t\tclippingBox: sourceRect\n\t\t\t\t\t\t\trule: Form over mask: nil.\n\t\t\t\t\t\t\titalicY _ italicY - 4].\n\t\t\t\t\temphasis _ emphasis - 2].\n\temphasis >= 1\t\"bold face\"\n\t\tifTrue:\t[sourceRect _ displayRunX @ lineY\n\t\t\t\t\t\t\t\textent: (displayDestX - displayRunX - 1)\n\t\t\t\t\t\t\t\t\t\t\t@ textStyle lineGrid.\n\t\t\t\t\t\t\tdestForm\n\t\t\t\t\t\t\tcopyBits: sourceRect\n\t\t\t\t\t\t\tfrom: destForm\n\t\t\t\t\t\t\tat: (displayRunX+1) @ lineY\n\t\t\t\t\t\t\tclippingBox: sourceRect rule: Form under mask: nil]\n",
          "fontAscentDelta": "fontAscentDelta\n\t| currentFont previousFont actualAscent scriptFudge |\n\n\tscriptFudge _ 2.\n\tpreviousFont _ (textStyle fontAt: (text emphasisAt: ((lastIndex - 1) max: 1))).\n\tcurrentFont _ font.\n\n\t((currentFont emphasis bitAt: SubscriptedBit) = 1)\n\t\tifTrue:\t[^ textStyle baseline - scriptFudge]\n\t\tifFalse:\t[((currentFont emphasis bitAt: SuperscriptedBit) = 1)\n\t\t\t\t\tifTrue:\t[^ textStyle baseline\n\t\t\t\t\t\t\t\t- previousFont ascent - currentFont ascent + scriptFudge]\n\t\t\t\t\tifFalse:\t[^ textStyle baseline - currentFont ascent]].\n"
        },
        "stop conditions": {
          "cr": "cr\n\t\"When a carriage return is encountered, simply increment the pointer into the paragraph.\"\n\n\t\"When displaying line stopped in endOfRun, primitive hasn't incremented\n\t\t\t\tlastIndex when cr stop occurs, hence, \"\n\t\t\t\tlastIndex_ lastIndex + 1.\n\t\t\t\t^false\n",
          "paddedSpace": "paddedSpace\n\t\"Each space is a stop condition when the alignment = justified.  Padding must be added to the base width of the space according to which space in the line this space is and according to the amount of space that remained at the end of the line when it was composed.\"\n\n\tspaceCount _ spaceCount + 1.\n\tdestX _ destX + spaceWidth + (line justifiedPadFor: spaceCount).\n\tlastIndex _ lastIndex + 1.\n\t^false\n",
          "tab": "tab\n\t\"This awfulness attempts to handle leading and internal tabs in a justified line.  Leading tabs are considered legal and should be reflected on the display gracefully.  Internal tabs (when the line is justified) are considered at the very best a misguided use of the character, and are reflected on the display the best we can.\"\n\n\t| leadingTab |\n\tleadingTab _ true.\n\t(line first to: lastIndex) do:\n\t\t[:index | (text at: index) = Space ifTrue: [leadingTab _ false]].\n\t(textStyle alignment ~= Justified or: [leadingTab])\n\t\tifTrue: \t[\"if a leading tab, just like a tab on a non-jusitified line\"\n\t\t\t\tdestX _ textStyle\n\t\t\t\t\t\tnextTabXFrom: destX\n\t\t\t\t\t\tleftMargin: leftMargin\n\t\t\t\t\t\trightMargin: rightMargin]\n\t\tifFalse:\t[\"otherwise\"\n\t\t\t\tdestX _ destX +\n\t\t\t\t\t\t(textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount))\n\t\t\t\t\t\t\tmax: destX].\n\tlastIndex _ lastIndex + 1.\n\t^false\n",
          "crossedX": "crossedX\n\t\"This condition will sometimes be reached 'legally' during printing, when, for instance the space that caused the line to wrap actually extends over the right  boundary.  This character is allowed to print, even though it is technically outside or straddling the clippingRectangle since it is in the normal case not visible and is in any case appropriately clipped by the scanner.\"\n\n\tself checkEmphasis.\n\t^true\n",
          "endOfRun": "endOfRun\n\t\"The end of a run in the display case either means that there is actually a change in the style (run code) to be associated with the string or the end of this line has been reached.  A check for any emphasis (underlining, for example) that may run the length of the run is done here before returning to displayLines: to do the next line\"\n\n\t| runLength lastCharacter|\n\tlastIndex = line last\n\t\tifTrue: [ \"just displaying and at end of line\".\n\t\t\t\tself checkEmphasis. ^true].\n\tself checkEmphasis.\n\t\t\t\trunLength _ text runLengthFor: (lastIndex _ lastIndex + 1).\n\t\t\t\tself setStopConditions.\n\t\t\t\trunX _ destX.\n\t\t\t\tdestY _ lineY + self fontAscentDelta.\t\t\"fontAscent delta\".\n\t(runStopIndex _ lastIndex + (runLength - 1)) > line last\n\t\tifTrue: [runStopIndex _ line last].\n\n\t^false\n",
          "setStopConditions": "setStopConditions\n\t\"Set the font and the stop conditions for the current run.\"\n\t| fontIndex displayFont |\n\tfont _ textStyle fontAt: (text emphasisAt: lastIndex).\n\tsuper setStopConditions.\n\tstopConditions\n\t\tat: Space asInteger + 1\n\t\tput: (textStyle alignment = Justified\n\t\t\t\tifTrue: [#paddedSpace]\n\t\t\t\tifFalse: [nil])\n",
          "onePixelBackspace": "onePixelBackspace\n\t\"Increment destX by 1\"\n\n\tdestX _ (destX - 1) max: runX.\n\tlastIndex _ lastIndex + 1.\n\t^false\n",
          "onePixelSpace": "onePixelSpace\n\t\"Increment destX by 1\"\n\n\tdestX _ destX + 1.\n\tlastIndex _ lastIndex + 1.\n\t^false\n"
        }
      }
    },
    "WordArray": {
      "comment": "WordArrays provide contiguous storage of data, primarily to hold the graphical data of Forms.  Forms and their subclasses provide the additional structural information as to how the bits should be interpreted in two dimensions.\n",
      "class_name": "WordArray",
      "superclass": "ArrayedCollection",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "constants": {
          "maxSize": "maxSize\n\t\"The maximum size of a WordArray is 64640 elements.\"\n\t^64640\n"
        }
      },
      "instance_methods": {
        "bit counting": {
          "countBits": "countBits\n\t\"Answer the number of on bits (1's) in me.\"\n\t| count bitMask |\n\tcount _ 0.\n\tself do:\n\t\t[:word |\n\t\tbitMask _ 1.\n\t\tword highBit timesRepeat:\n\t\t\t[(word bitAnd: bitMask) ~= 0\n\t\t\t\tifTrue: [count _ count + 1]]].\n\t^count\n"
        },
        "printing": {
          "printOn:": "printOn: aStream\n\taStream nextPutAll: 'a WordArray of length '.\n\tself size printOn: aStream\n"
        },
        "initialize-release": {
          "fromByteStream:": "fromByteStream: aStream\n\t\"Initialize the array of bits by reading integers from the Stream, aStream.\"\n\n\t| high low |\n\t1 to: self size do:\n\t\t[:i |\n\t\thigh _ aStream next asInteger.\n\t\t\t\t\t\"be cautious, it may be a char\"\n\t\tlow _ aStream next asInteger.\n\t\tself at: i put: (high bitShift: 8) + low]\n"
        },
        "filing": {
          "toStream:": "toStream: aStream\n\t\"Store the array of bits onto the Stream, aStream.\"\n\n\t1 to: self size do:\n\t\t[:i |\n\t\taStream nextPut: ((self at: i) bitShift: -8).\n\t\taStream nextPut: ((self at: i) bitAnd: 255)]\n"
        }
      }
    },
    "CharacterBlockScanner": {
      "comment": "Instance Variables\n\n\tcharacterPoint\n<Point>  Used in character location domain.  The topLeft of the character to be returned in a CharacterBlock.\n\n\tcharacterIndex\n<Integer>  Used in character location domain.  The index in the stylizedString of the character to be returned in a CharacterBlock.\n\n\tlastCharacter\n<Character>  Used in character location domain.  The character to be returned in a CharacterBlock.\n\n\tlastCharacterExtent\n<Point>  Used in character location domain.  The extent of the character to be returned in a CharacterBlock.  The height is usually the stringStyle*s lineGrid.\n\n\tlastSpaceOrTabExtent\n<Point>  Used in character location domain.  If the lastCharacter is a space or a tab, this will be its extent, an unexpected value when justification is turned on, and a variable value in the case of tab no matter what the alignment value is.\n\n\tnextLeftMargin\n<Integer>  When, as in the case of cr, the left margin of the succeeding line is what is desired, this value, known to the paragraph is needed.  Since the paragraph is not available to the stop conditions, this value is set when the line of the character is discovered and before access to the paragraph is lost.\n\nCharacterBlockScanners are used to scan text to compute the CharacterBlock for a character specified by its index in the text or its proximity to the cursor location\n",
      "class_name": "CharacterBlockScanner",
      "superclass": "CharacterScanner",
      "instanceVariables": "characterPoint characterIndex lastCharacter lastCharacterExtent lastSpaceOrTabExtent nextLeftMargin",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "TextConstants",
      "instance_methods": {
        "scanning": {
          "characterBlockForIndex:in:": "characterBlockForIndex: targetIndex in: aParagraph\n\t\"Answer a CharacterBlock for character in aParagraph at targetIndex.  The coordinates in the CharacterBlock will be appropriate to the intersection of the destinationForm rectangle and the compositionRectangle.\"\n\n\tsuper\n\t\tinitializeFromParagraph: aParagraph\n\t\tclippedBy: aParagraph clippingRectangle.\n\tcharacterIndex _ targetIndex.\n\tcharacterPoint _\n\t\taParagraph rightMarginForDisplay @\n\t\t\t(aParagraph topAtLineIndex:\n\t\t\t\t(aParagraph lineIndexOfCharacterIndex: characterIndex)).\n\t^self buildCharacterBlockIn: aParagraph\n",
          "characterBlockAtPoint:in:": "characterBlockAtPoint: aPoint in: aParagraph\n\t\"Answer a CharacterBlock for character in aParagraph at point aPoint.  It is assumed that aPoint has been transformed into coordinates appropriate to the text's destinationForm rectangle and the compositionRectangle.\"\n\n\tsuper initializeFromParagraph: aParagraph clippedBy: aParagraph clippingRectangle.\n\tcharacterPoint _ aPoint.\n\t^self buildCharacterBlockIn: aParagraph\n",
          "characterNotInFont": "characterNotInFont\n\t\"This does not handle character selection nicely, i.e., illegal characters are a little tricky to select.  Since the end of a run or line is subverted here by actually having the scanner scan a different string in order to manage the illegal character, things are not in an absolutely correct state for the character location code.  If this becomes too odious in use, logic will be added to accurately manage the situation.\"\n\n\tlastCharacterExtent _\n\t\t(font widthOf: (font maxAscii + 1) asCharacter) @ textStyle lineGrid.\n\t^super characterNotInFont\n"
        },
        "private": {
          "buildCharacterBlockIn:": "buildCharacterBlockIn: aParagraph\n\t| lineIndex runLength lineStop characterBlock done stopCondition |\n\t\"handle nullText\"\n\t(aParagraph numberOfLines = 0 or: [text size = 0])\n\t\tifTrue:\t[leftMargin _ (aParagraph leftMarginForDisplayForLine: 1).\n\t\t\t\t^CharacterBlock\n\t\t\t\t\tstringIndex: 1\t\"like being off end of string\"\n\t\t\t\t\tcharacter: nil\n\t\t\t\t\ttopLeft: (leftMargin @\n\t\t\t\t\t\t\t\t(aParagraph compositionRectangle) top)\n\t\t\t\t\textent: (0 @ textStyle lineGrid)].\n\n\t\"find the line\"\n\tlineIndex _ aParagraph lineIndexOfTop: characterPoint y.\n\tdestY _ (aParagraph topAtLineIndex: lineIndex).\n\tline _ aParagraph lineAt: lineIndex.\n\ttext _ aParagraph textAt: lineIndex.\n\trightMargin _ aParagraph rightMarginForDisplay.\n\n\t(lineIndex = aParagraph numberOfLines and:\n\t\t[(destY + textStyle lineGrid) < characterPoint y])\n\t\t\tifTrue:\t[\"if beyond lastLine, force search to last character\"\n\t\t\t\t\tcharacterPoint x: rightMargin]\n\t\t\tifFalse:\t[characterPoint y < (aParagraph compositionRectangle) top\n\t\t\t\t\t\tifTrue: [\"force search to first line\"\n\t\t\t\t\t\t\t\tcharacterPoint _\n\t\t\t\t\t\t\t\t(aParagraph compositionRectangle) topLeft].\n\t\t\t\t\tcharacterPoint x > rightMargin\n\t\t\t\t\t\tifTrue:\t[characterPoint x: rightMargin]].\n\tdestX _ leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.\n\tnextLeftMargin_ aParagraph leftMarginForDisplayForLine: lineIndex+1.\n\tlastIndex _ line first.\n\n\tself setStopConditions.\t\t\"also sets font\"\n\trunLength _ (text runLengthFor: line first).\n\tcharacterIndex ~~ nil\n\t\tifTrue:\t[lineStop _ characterIndex\t\"scanning for index\"]\n\t\tifFalse:\t[lineStop _ line last].\n\t(runStopIndex _ lastIndex + (runLength - 1)) > lineStop\n\t\tifTrue:\t[runStopIndex _ lineStop].\n\tlastCharacterExtent _ 0 @ textStyle lineGrid.\n\tspaceCount _ 0. done  _ false.\n\n\t[done]\n\twhileFalse:\n\t[stopCondition _\n\t\t\t\t\tself scanCharactersFrom: lastIndex\n\t\t\t\t\t\tto: runStopIndex\n\t\t\t\t\t\tin: text string\n\t\t\t\t\t\trightX: characterPoint x\n\t\t\t\t\t\tstopConditions: stopConditions\n\t\t\t\t\t\tdisplaying: false.\n\n\t\t\"see setStopConditions for stopping conditions for character block \toperations.\"\n\tlastCharacterExtent x: (font widthOf: (text at: lastIndex)).\n\t(self perform: stopCondition)\n\t\tifTrue:\t[^CharacterBlock\n\t\t\t\t\tstringIndex: lastIndex\n\t\t\t\t\tcharacter: lastCharacter\n\t\t\t\t\ttopLeft: characterPoint\n\t\t\t\t\textent: lastCharacterExtent]]\n"
        },
        "stop conditions": {
          "cr": "cr\n\t\"Answer an instance of CharacterBlock that specifies the current location of the mouse relative to a carriage return stop condition that has just been encountered.  The ParagraphEditor convention is to denote selections by CharacterBlocks, sometimes including the carriage return (cursor is at the end) and sometimes not (cursor is in the middle of the text). \"\n\n\t((characterIndex ~= nil\n\t\tand: [characterIndex > text size])\n\t\t\tor: [(line last = text size)\n\t\t\t\tand: [(destY + textStyle lineGrid) < characterPoint y]])\n\t\tifTrue:\t[\"When off end of string, give data for next character\"\n\t\t\t\tdestY _ destY +  textStyle lineGrid.\n\t\t\t\tlastCharacter _ nil.\n\t\t\t\tcharacterPoint _\n\t\t\t\t\tPoint\n\t\t\t\t\t\tx: ((text at: lastIndex) = CR\n\t\t\t\t\t\t\t\tifTrue: [leftMargin]\n\t\t\t\t\t\t\t\tifFalse: [nextLeftMargin])\n\t\t\t\t\t\ty: destY.\n\t\t\t\tlastIndex _ lastIndex + 1.\n\t\t\t\tlastCharacterExtent x: 0.\n\t\t\t\t^ true].\n\t\tlastCharacter _ CR.\n\t\tcharacterPoint _ destX @ destY.\n\t\tlastCharacterExtent x: rightMargin - destX.\n\t\t^true\n",
          "paddedSpace": "paddedSpace\n\t\"When the line is justified, the spaces will not be the same as the font's space character.  A padding of extra space must be considered in trying to find which character the cursor is pointing at.  Answer true if the scanning has crossed the cursor, false otherwise.\"\n\n\t| pad |\n\tspaceCount _ spaceCount + 1.\n\tpad _ line justifiedPadFor: spaceCount.\n\tlastSpaceOrTabExtent _ lastCharacterExtent copy.\n\tlastSpaceOrTabExtent x:  spaceWidth + pad.\n\t(destX + lastSpaceOrTabExtent x)  >= characterPoint x\n\t\tifTrue: [lastCharacterExtent _ lastSpaceOrTabExtent copy.\n\t\t\t\t^self crossedX].\n\tlastIndex _ lastIndex + 1.\n\tdestX _ destX + lastSpaceOrTabExtent x.\n\t^ false\n",
          "tab": "tab\n\t\"Handle leading and internal tabs in a justified line.  Leading tabs are considered legal and should be reflected on the display gracefully.  Internal tabs (when the line is justified) are considered at the very best a misguided use of the character, and are reflected on the display the best we can.\"\n\n\n\t| leadingTab currentX |\n\tcurrentX _ destX.\n\tleadingTab _ true.\n\t(line first to: lastIndex)\n\t\tdo: [:index | (text at: index) = Space ifTrue: [leadingTab _ false]].\n\t(textStyle alignment ~= Justified or: [leadingTab])\n\t\tifTrue: [currentX _\n\t\t\t\t\ttextStyle\n\t\t\t\t\t\tnextTabXFrom: currentX\n\t\t\t\t\t\tleftMargin: leftMargin\n\t\t\t\t\t\trightMargin: rightMargin]\n\t\tifFalse: [currentX _\n\t\t\t\t\tcurrentX + (textStyle tabWidth -\n\t\t\t\t\t\t(line justifiedTabDeltaFor: spaceCount)) max: destX].\n\tlastSpaceOrTabExtent _ lastCharacterExtent copy.\n\tlastSpaceOrTabExtent x: (currentX - destX max: 0).\n\tcurrentX >= characterPoint x\n\t\tifTrue:\n\t\t\t[lastCharacterExtent _ lastSpaceOrTabExtent copy.\n\t\t\t^self crossedX].\n\tdestX _ currentX.\n\tlastIndex _ lastIndex + 1.\n\t^false\n",
          "crossedX": "crossedX\n\t\"Text display has wrapping.  The scanner just found a character past the x location of the cursor.  We know that the cursor is pointing at a character or before one.\"\n\n\t| leadingTab currentX |\n\t((characterPoint x <= (destX + ((lastCharacterExtent x) // 2)))\n\t\tor: [line last = lastIndex])\n\t\tifTrue:\t[lastCharacter _ (text at: lastIndex).\n\t\t\t\t((lastCharacter = Space and: [textStyle alignment = Justified])\n\t\t\t\t\tand: [destX + lastCharacterExtent x > rightMargin])\n\t\t\t\t\tifTrue:\t[characterPoint _ nextLeftMargin @ (destY + textStyle lineGrid).\n\t\t\t\t\t\t\tcharacterIndex notNil\n\t\t\t\t\t\t\t\tifTrue:\t[lastIndex _ (characterIndex min: (line last + 1))]\n\t\t\t\t\t\t\t\tifFalse:\t[lastIndex _ (lastIndex + 1) min: (line last + 1)]]\n\t\t\t\t\tifFalse:\t[((lastCharacter = Tab) and: [line last = lastIndex])\n\t\t\t\t\t\t\t\tifTrue:\t[(characterPoint x <= (destX + ((lastCharacterExtent x) // 2)))\n\t\t\t\t\t\t\t\t\t\t\tifFalse:\n\t\t\t\t\t\t\t\t\t\t\t\t[destX _ (destX + lastCharacterExtent x).\n\t\t\t\t\t\t\t\t\t\t\t\tcharacterPoint _ destX @ destY.\n\t\t\t\t\t\t\t\t\t\t\t\t^ self endOfRun]].\n\t\t\t\t\t\t\t\tcharacterPoint _ destX @ destY].\n\t\t\t\t^true].\n\t\"Pointing past middle of a character, return the next character.\"\n\tlastIndex _ lastIndex + 1.\n\tlastCharacter _ text at: lastIndex.\n\tcurrentX _ destX + lastCharacterExtent x.\n\tlastCharacterExtent x: (font widthOf: lastCharacter).\n\tcharacterPoint _ currentX @ destY.\n\n\t\"Yukky if next character is space or tab.\"\n\t(lastCharacter = Space and: [textStyle alignment = Justified])\n\t\tifTrue:\t[lastCharacterExtent x:\n\t\t\t\t\t(lastCharacterExtent x + (line justifiedPadFor: (spaceCount + 1))).\n\t\t\t\t^true].\n\tlastCharacter = Tab\n\t\tifTrue:\n\t\t\t[\"See tabForDisplay for illumination on the following awfulness.\"\n\t\t\tleadingTab _ true.\n\t\t\t(line first to: lastIndex - 1) do:\n\t\t\t[:index |\n\t\t\t(text at: index) = Space\n\t\t\t\tifTrue: [leadingTab _ false]].\n\t\t\t(textStyle alignment ~= Justified or: [leadingTab])\n\t\t\t\tifTrue:\t[lastCharacterExtent x: (textStyle nextTabXFrom: currentX\n\t\t\t\t\t\t\tleftMargin: leftMargin rightMargin: rightMargin) -\n\t\t\t\t\t\t\t\tcurrentX]\n\t\t\t\tifFalse:\t[lastCharacterExtent x:  (((currentX + (textStyle tabWidth -\n\t\t\t\t\t\t\t\t(line justifiedTabDeltaFor: spaceCount))) -\n\t\t\t\t\t\t\t\t\tcurrentX) max: 0)]].\n\t^ true\n",
          "endOfRun": "endOfRun\n\t\"Before arriving at the cursor location, the selection has encountered an end of run.  Answer false if the selection continues, true otherwise.  Set up indexes for building the appropriate CharacterBlock.\"\n\n\t| runLength lineStop |\n\t((characterIndex ~~ nil and:\n\t\t[runStopIndex < characterIndex and: [runStopIndex < text size]])\n\t\t\tor:\t[characterIndex == nil and: [lastIndex < line last]])\n\t\tifTrue:\t[\"We're really at the end of a real run.\"\n\t\t\t\trunLength _ (text runLengthFor: (lastIndex _ lastIndex + 1)).\n\t\t\t\tcharacterIndex ~~ nil\n\t\t\t\t\tifTrue:\t[lineStop _ characterIndex\t\"scanning for index\"]\n\t\t\t\t\tifFalse:\t[lineStop _ line last\t\t\t\"scanning for point\"].\n\t\t\t\t(runStopIndex _ lastIndex + (runLength - 1)) > lineStop\n\t\t\t\t\tifTrue: \t[runStopIndex _ lineStop].\n\t\t\t\tself setStopConditions.\n\t\t\t\t^false].\n\n\tlastCharacter _ text at: lastIndex.\n\tcharacterPoint _ destX @ destY.\n\t((lastCharacter = Space and: [textStyle alignment = Justified])\n\t\tor: [lastCharacter = Tab])\n\t\tifTrue: [lastCharacterExtent _ lastSpaceOrTabExtent].\n\tcharacterIndex ~~ nil\n\t\tifTrue:\t[\"If scanning for an index and we've stopped on that index,\n\t\t\t\tthen we back destX off by the width of the character stopped on\n\t\t\t\t(it will be pointing at the right side of the character) and return\"\n\t\t\t\trunStopIndex = characterIndex\n\t\t\t\t\tifTrue:\t[characterPoint x: destX - lastCharacterExtent x.\n\t\t\t\t\t\t\t^true].\n\t\t\t\t\"Otherwise the requested index was greater than the length of the\n\t\t\t\tstring.  Return string size + 1 as index, indicate further that off the\n\t\t\t\tstring by setting character to nil and the extent to 0.\"\n\t\t\t\tlastIndex _  lastIndex + 1.\n\t\t\t\tlastCharacter _ nil.\n\t\t\t\tlastCharacterExtent x: 0.\n\t\t\t\t^true].\n\n\t\"Scanning for a point and either off the end of the line or off the end of the string.\"\n\trunStopIndex = text size\n\t\tifTrue:\t[\"off end of string\"\n\t\t\t\tlastIndex _  lastIndex + 1.\n\t\t\t\tlastCharacter _ nil.\n\t\t\t\tlastCharacterExtent x: 0.\n\t\t\t\t^true].\n\t\"just off end of line without crossing x\"\n\tlastIndex _ lastIndex + 1.\n\t^true\n",
          "setStopConditions": "setStopConditions\n\t\"Set the font and the stop conditions for the current run.\"\n\t| fontIndex displayFont |\n\tfont _ textStyle fontAt: (text emphasisAt: lastIndex).\n\tsuper setStopConditions.\n\tstopConditions\n\t\tat: Space asInteger + 1\n\t\tput: (textStyle alignment = Justified\n\t\t\t\tifTrue: [#paddedSpace]\n\t\t\t\tifFalse: [nil])\n",
          "onePixelBackspace": "onePixelBackspace\n\t\"Decrement destX by 1 pixel size.\"\n\n\t| characterWidth |\n\tcharacterWidth _ 1.\n\tlastCharacterExtent x: characterWidth.\n\tlastIndex _ lastIndex + 1.\n\tdestX _ (destX - characterWidth) max: leftMargin.\n\t^ false\n",
          "onePixelSpace": "onePixelSpace\n\t\"Increment destX by 1 pixel size.\"\n\n\t| characterWidth |\n\tcharacterWidth _ 1.\n\tlastCharacterExtent x: characterWidth.\n\t(destX + characterWidth)  >= characterPoint x\n\t\tifTrue: [^self crossedX].\n\tlastIndex _ lastIndex + 1.\n\tdestX _ destX + characterWidth.\n\t^ false\n"
        }
      }
    },
    "CharacterBlock": {
      "comment": "CharacterBlocks contain information about displayed characters.  They are used to return the results of methods\n\tParagraph characterBlockAtPoint: aPoint and\n\tParagraph characterBlockForIndex: stringIndex.\nAny recomposition or movement of a Paragraph can make the information obsolete.\n",
      "class_name": "CharacterBlock",
      "superclass": "Rectangle",
      "instanceVariables": "stringIndex character",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "TextConstants",
      "class_methods": {
        "instance creation": {
          "stringIndex:character:topLeft:extent:": "stringIndex: anInteger character: aCharacter topLeft: originPoint extent: extentPoint\n\t\"Answer an instance of me with values set to the arguments.\"\n\t^self new\n\t\tnewStringIndex: anInteger\n\t\tCharacter: aCharacter\n\t\tTopLeft: originPoint\n\t\tExtent: extentPoint\n",
          "stringIndex:character:boundingRectangle:": "stringIndex: anInteger character: aCharacter boundingRectangle: aRectangle\n\t\"Answer an instance of me with values set to the arguments.\"\n\t^self new\n\t\tnewStringIndex: anInteger\n\t\tCharacter: aCharacter\n\t\tBoundingRectangle: aRectangle\n"
        }
      },
      "instance_methods": {
        "comparing": {
          ">": "> aCharacterBlock\n\t\"Answer whether the string index of the receiver comes after that of\n\taCharacterBlock.\"\n\t^aCharacterBlock < self\n",
          "<": "< aCharacterBlock\n\t\"Answer whether the string index of the receiver precedes that of aCharacterBlock.\"\n\t^stringIndex < aCharacterBlock stringIndex\n",
          "=": "= aCharacterBlock\n\tself species = aCharacterBlock species\n\t\tifTrue: [^stringIndex = aCharacterBlock stringIndex]\n\t\tifFalse: [^false]\n",
          ">=": ">= aCharacterBlock\n\t\"Answer whether the string index of the receiver does not precede that of\n\taCharacterBlock.\"\n\t^(self < aCharacterBlock) not\n",
          "<=": "<= aCharacterBlock\n\t\"Answer whether the string index of the receiver does not come after that of\n\taCharacterBlock.\"\n\t^(self > aCharacterBlock) not\n"
        },
        "printing": {
          "printOn:": "printOn: aStream\n\taStream nextPutAll: 'a CharacterBlock with index '.\n\tstringIndex printOn: aStream.\n\taStream nextPutAll: ' and character '.\n\tcharacter printOn: aStream.\n\taStream nextPutAll: ' and rectangle '.\n\tsuper printOn: aStream\n"
        },
        "copying": {
          "copy": "copy\n\t^self deepCopy\n"
        },
        "accessing": {
          "character": "character\n\t\"Answer the character in the receiver.\"\n\t^character\n",
          "stringIndex": "stringIndex\n\t\"Answer the position of the receiver in the string it indexes.\"\n\t^stringIndex\n"
        },
        "private": {
          "newStringIndex:": "newStringIndex: anInteger Character: aCharacter TopLeft: originPoint Extent: extentPoint\n\tstringIndex _ anInteger.\n\tcharacter _ aCharacter.\n\tsuper origin: originPoint.\n\tsuper extent: extentPoint\n"
        }
      }
    },
    "TextLineInterval": {
      "comment": "A TextLineInterval specifies the starting and stopping points in a String of a composed line.  The step is always 1.  The internalSpaces is the number of spaces in the line, and the paddingWidth is the amount to be added to the font\n",
      "class_name": "TextLineInterval",
      "superclass": "Interval",
      "instanceVariables": "internalSpaces paddingWidth",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "TextConstants",
      "class_methods": {
        "instance creation": {
          "start:stop:internalSpaces:paddingWidth:": "start: startInteger stop: stopInteger internalSpaces: spacesInteger paddingWidth: padWidthInteger\n\t\"Answer an instance of me with the arguments as the start, stop points, number of\n\tspaces in the line, and width of the padding.\"\n\t| newSelf |\n\tnewSelf _ super from: startInteger to: stopInteger by: 1.\n\t^newSelf internalSpaces: spacesInteger paddingWidth: padWidthInteger\n"
        }
      },
      "instance_methods": {
        "comparing": {
          "=": "= line\n\tself species = line species\n\t\tifTrue: [^((start = line first and: [stop = line last])\n\t\t\t\tand: [internalSpaces = line internalSpaces])\n\t\t\t\tand: [paddingWidth = line paddingWidth]]\n\t\tifFalse: [^false]\n"
        },
        "scanning": {
          "justifiedTabDeltaFor:": "justifiedTabDeltaFor: spaceIndex\n\t\"Compute the delta for a tab in a line of justified text.  So tab falls somewhere\n\tplausible when line is justified.\"\n\n\t| pad extraPad |\n\tinternalSpaces = 0 ifTrue: [^0].\n\tpad _ paddingWidth // internalSpaces.\n\textraPad _ paddingWidth \\\\ internalSpaces.\n\tspaceIndex <= extraPad\n\t\tifTrue: [^spaceIndex * (pad + 1)]\n\t\tifFalse: [^extraPad * (pad + 1) + (spaceIndex - extraPad * pad)]\n",
          "justifiedPadFor:": "justifiedPadFor: spaceIndex\n\t\"Compute the width of pad for a given space in a line of justified text.\"\n\n\t| pad |\n\tinternalSpaces = 0 ifTrue: [^0].\n\tpad _ paddingWidth // internalSpaces.\n\tspaceIndex <= (paddingWidth \\\\ internalSpaces)\n\t\tifTrue: [^pad + 1]\n\t\tifFalse: [^pad]\n"
        },
        "updating": {
          "slide:": "slide: delta\n\t\"Change the starting and stopping points of the line by delta.\"\n\tstart _ start + delta.\n\tstop _ stop + delta\n"
        },
        "copying": {
          "deepCopy": "deepCopy\n\t^TextLineInterval start: start stop: stop internalSpaces: internalSpaces paddingWidth: paddingWidth\n"
        },
        "accessing": {
          "stop:": "stop: stopInteger\n\t\"Set the stopping point in the string of the line to be stopInteger.\"\n\tstop _ stopInteger\n",
          "paddingWidth:": "paddingWidth: padWidthInteger\n\t\"Set the amount of space to be added to the font to be padWidthInteger.\"\n\tpaddingWidth _ padWidthInteger\n",
          "internalSpaces:": "internalSpaces: spacesInteger\n\t\"Set the number of spaces in the line to be spacesInteger.\"\n\tinternalSpaces _ spacesInteger\n",
          "paddingWidth": "paddingWidth\n\t\"Answer the amount of space to be added to the font.\"\n\t^paddingWidth\n",
          "internalSpaces": "internalSpaces\n\t\"Answer the number of spaces in the line.\"\n\t^internalSpaces\n"
        },
        "private": {
          "internalSpaces:paddingWidth:": "internalSpaces: spacesInteger paddingWidth: padWidthInteger\n\tinternalSpaces _ spacesInteger.\n\tpaddingWidth _ padWidthInteger\n"
        }
      }
    },
    "BitBlt": {
      "comment": "The BitBlt operation copies bits from one rectangle within a Form (source) to another (dest).  The result is stored according to a combination rule which specifies one of the sixteen possibilities for how white and black should be combined.\n\nIf halftoneForm is not nil, it is a halftone screen which masks (is ANDed with) the source during the operation.  Halftones are 16x16 bit Forms which are repeated indefinitely as needed by the BitBlt operation. with the two forms and a halftoneForm.\n\nIf sourceForm is nil, the halftone is taken by itself to be the source, as for filling with a constant pattern.\n\nThe clipping parameters specify a rectangle in the destination outside of which BitBlt will not make any changes\n",
      "class_name": "BitBlt",
      "superclass": "Object",
      "instanceVariables": "destForm sourceForm halftoneForm combinationRule destX destY width height sourceX sourceY clipX clipY clipWidth clipHeight",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "toReverse:": "toReverse: aRectangle\n\t\"Return an instance which will reverse a particular rectangle in the\n\tdestination (which must be supplied later).  This is currently used only\n\tfor the Ethernet 'lights'.\"\n\n\t^self\n\t\tdestForm: nil\n\t\tsourceForm: nil\n\t\thalftoneForm: nil\n\t\tcombinationRule: Form reverse\n\t\tdestOrigin: aRectangle origin\n\t\tsourceOrigin: 0 @ 0\n\t\textent: aRectangle extent\n\t\tclipRect: aRectangle\n",
          "destForm:sourceForm:halftoneForm:combinationRule:destOrigin:sourceOrigin:extent:clipRect:": "destForm: df sourceForm: sf halftoneForm: hf combinationRule: cr destOrigin: destOrigin sourceOrigin: sourceOrigin extent: extent clipRect: clipRect\n\t\"Answer an instance of me with values set according to the\n\targuments. \"\n\n\t^self new\n\t\tsetDestForm: df\n\t\tsourceForm: sf\n\t\thalftoneForm: hf\n\t\tcombinationRule: cr\n\t\tdestOrigin: destOrigin\n\t\tsourceOrigin: sourceOrigin\n\t\textent: extent\n\t\tclipRect: clipRect\n"
        },
        "private": {
          "exampleAt:rule:mask:": "exampleAt: originPoint rule: rule mask:  mask\n\t\"This builds a source and destination form and copies the source to the destination\n\tusing the specifed rule and mask.  It is called from the method named exampleOne.\"\n\n\t| s d border aBitBlt |\n\tborder_Form new extent: 32@32.\n\tborder black.\n\tborder fill: (1@1 extent: 30@30) mask: Form white.\n\ts_Form new extent: 32@32.\n\ts white.\n\ts fill: (7@7 corner: 25@25) mask: Form black.\n\td_Form new extent: 32@32.\n\td white.\n\td fill: (0@0 corner: 32@16) mask: Form black.\n\n\ts displayOn: Display at: originPoint.\n\tborder displayOn: Display at: originPoint rule: Form under.\n\td displayOn: Display at: originPoint + (s width @0).\n\tborder displayOn: Display at: originPoint + (s width @0) rule: Form under.\n\n\td displayOn: Display at: originPoint + (s extent // (2 @ 1)).\n\taBitBlt _ BitBlt\n\t\tdestForm: Display\n\t\tsourceForm: s\n\t\thalftoneForm: mask\n\t\tcombinationRule: rule\n\t\tdestOrigin: originPoint + (s extent // (2 @ 1))\n\t\tsourceOrigin: 0 @ 0\n\t\textent: s extent\n\t\tclipRect: Display computeBoundingBox.\n\taBitBlt copyBits.\n\tborder\n\t\tdisplayOn: Display at: originPoint + (s extent // (2 @ 1))\n\t\trule: Form under.\n\n\t\"BitBlt exampleAt: 100@100 rule: 3 mask: Form gray.\"\n"
        },
        "examples": {
          "exampleOne": "exampleOne\n\t\"This tests BitBlt by displaying the result of all sixteen combination rules\n\tthat BitBlt is capable of using.  (Please see the Byte magazine article by D. Ingalls\n\tfor the meaning of the combination rules and the complete documentation for\n\tBitBlt in SmallTalk-80.)\"\n\n\t| path |\n\tpath _ Path new.\n\t0 to: 3 do: [:i | 0 to: 3 do: [:j | path add: j * 100 @ (i * 100)]].\n\tDisplay white.\n\tpath _ path translateBy: 100 @ 100.\n\t1 to: 16 do: [:index | BitBlt\n\t\t\texampleAt: (path at: index)\n\t\t\trule: index - 1\n\t\t\tmask: Form gray]\n\n\t\"BitBlt exampleOne.\"\n",
          "exampleTwo": "exampleTwo\n\t\"This is to test painting with a gray tone. It also tests that the seaming with gray\n\tpatterns is correct in the microcode.  Lets you paint for awhile and then\n\tautomatically stops.\"\n\n\t| f pt aBitBlt |\n\t\"create a small black Form source as a brush.\"\n\tf _ Form new extent: 20 @ 20.\n\tf black.\n\t\"create a BitBlt which will OR gray into the display\"\n\taBitBlt _ BitBlt\n\t\tdestForm: Display\n\t\tsourceForm: f\n\t\thalftoneForm: Form gray\n\t\tcombinationRule: Form under\n\t\tdestOrigin: Sensor cursorPoint\n\t\tsourceOrigin: 0 @ 0\n\t\textent: f extent\n\t\tclipRect: Display computeBoundingBox.\n\n\t\"paint the gray Form on the screen for a while\"\n\t1 to: 5000 do:\n\t\t[:i |\n\t\taBitBlt destOrigin: Sensor cursorPoint.\n\t\taBitBlt copyBits]\n\n\t\"BitBlt exampleTwo.\"\n"
        }
      },
      "instance_methods": {
        "line drawing": {
          "drawLoopX:": "drawLoopX: xDelta Y: yDelta\n\t\"This is the Bresenham plotting algorithm (IBM Systems Journal Vol\n\t4 No. 1, 1965). It chooses a principal direction, and maintains\n\ta potential, P.  When P's sign changes, it is time to move in the\n\tminor direction as well.  Optional.  See Object documentation whatIsAPrimitive.\"\n\n\t| dx dy px py P i |\n\t<primitive: 104>\n\tdx _ xDelta sign.\n\tdy _ yDelta sign.\n\tpx _ yDelta abs.\n\tpy _ xDelta abs.\n\tself copyBits.\n\tpy > px\n\t\tifTrue:\n\t\t\t[\"more horizontal\"\n\t\t\tP _ py // 2.\n\t\t\ti _ 0.\n\t\t\t[(i _ i + 1) <= py]\n\t\t\t\twhileTrue:\n\t\t\t\t\t[destX _ destX + dx.\n\t\t\t\t\t(P _ P - px) < 0\n\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t[destY _ destY + dy.\n\t\t\t\t\t\t\tP _ P + py].\n\t\t\t\t\tself copyBits]]\n\t\tifFalse:\n\t\t\t[\"more vertical\"\n\t\t\tP _ px // 2.\n\t\t\ti _ 0.\n\t\t\t[(i _ i + 1) <= px]\n\t\t\t\twhileTrue:\n\t\t\t\t\t[destY _ destY + dy.\n\t\t\t\t\t(P _ P - py) < 0\n\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t[destX _ destX + dx.\n\t\t\t\t\t\t\tP _ P + px].\n\t\t\t\t\tself copyBits]]\n",
          "drawFrom:to:": "drawFrom: startPoint to: stopPoint\n\t| offset point1 point2 |\n\t\"Always draw down, or at least left-to-right\"\n\t((startPoint y = stopPoint y and: [startPoint x < stopPoint x])\n\t\tor: [startPoint y < stopPoint y])\n\t\tifTrue: [point1 _ startPoint. point2 _ stopPoint]\n\t\tifFalse: [point1 _ stopPoint. point2 _ startPoint].\n\twidth _ sourceForm width.\n\theight _ sourceForm height.\n\toffset _ sourceForm offset.\n\tdestX _ (point1 x + offset x) rounded.\n\tdestY _ (point1 y + offset y) rounded.\n\tself drawLoopX: (point2 x - point1 x) rounded\n\t\t\t\t  Y: (point2 y - point1 y) rounded\n"
        },
        "copying": {
          "copyBits": "copyBits\n\t\"Perform the movement of bits from one From to another described by the instance variables of the receiver.  Fail if any instance variables are not of the right type (Integer or Form) or if combinationRule is not between 0 and 15 inclusive.  Set the variables and try again (BitBlt|copyBitsAgain).  Essential.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 96>\n\tcombinationRule = Form paint\n\t\tifTrue: [^self paintBits]\n\t\tifFalse:\n\t\t\t[destX _ destX truncated.\n\t\t\tdestY _ destY truncated.\n\t\t\twidth _ width truncated.\n\t\t\theight _ height truncated.\n\t\t\tsourceX _ sourceX truncated.\n\t\t\tsourceY _ sourceY truncated.\n\t\t\tclipX _ clipX truncated.\n\t\t\tclipY _ clipY truncated.\n\t\t\tclipWidth _ clipWidth truncated.\n\t\t\tclipHeight _ clipHeight truncated.\n\t\t\t^self copyBitsAgain]\n"
        },
        "accessing": {
          "width:": "width: anInteger\n\t\"Set the width instance variable in BitBlt.\"\n\n\twidth _ anInteger\n",
          "sourceForm:": "sourceForm: aForm\n\t\"Set the sourceForm instance variable in BitBlt.\"\n\n\tsourceForm _ aForm\n",
          "destY:": "destY: anInteger\n\t\"Set the destY instance variable in BitBlt.\"\n\n\tdestY _ anInteger\n",
          "destRect:": "destRect: aRectangle\n\t\"Set the destination coordinates to be those of aRectangle top left and\n\tthe width and height of the receiver to be the width and height of aRectangle.\"\n\tdestX _ aRectangle left.\n\tdestY _ aRectangle top.\n\twidth _ aRectangle width.\n\theight _ aRectangle height\n",
          "destX:": "destX: anInteger\n\t\"Set the destX instance variable in BitBlt.\"\n\n\tdestX _ anInteger\n",
          "clipHeight:": "clipHeight: anInteger\n\t\"Set the clipHeight instance variable in BitBlt.\"\n\n\tclipHeight _ anInteger\n",
          "sourceOrigin:": "sourceOrigin: aPoint\n\t\"Set the source form coordinats to be those of aPoint.\"\n\tsourceX _ aPoint x.\n\tsourceY _ aPoint y\n",
          "destOrigin:": "destOrigin: aPoint\n\t\"Set the destination coordinates to be those of aPoint.\"\n\tdestX _ aPoint x.\n\tdestY _ aPoint y\n",
          "sourceRect:": "sourceRect: aRectangle\n\t\"Set the sourceX, sourceY width and height instance variables in BitBlt.  This\n\tis a shorthand way to set four of the parameters to BitBlt.\"\n\n\tsourceX _ aRectangle left.\n\tsourceY _ aRectangle top.\n\twidth _ aRectangle width.\n\theight _ aRectangle height\n",
          "combinationRule:": "combinationRule: anInteger\n\t\"Set the combinationRule instance variable in BitBlt.  anInteger is in the range 0-16.\"\n\n\tcombinationRule _ anInteger\n",
          "clipRect": "clipRect\n\t\"Answer the clipX, clipY clipWidth and clipHeight instance variables in\n\tBitBlt.\"\n\n\t^clipX @ clipY extent: clipWidth @ clipHeight\n",
          "clipWidth:": "clipWidth: anInteger\n\t\"Set the clipWidth instance variable in BitBlt.\"\n\n\tclipWidth _ anInteger\n",
          "clipRect:": "clipRect: aRectangle\n\t\"Set the clipX, clipY clipWidth andclipHeight instance variables in BitBlt.\n\tThis is a shorthand way to set four of the parameters to BitBlt.\"\n\n\tclipX _ aRectangle left.\n\tclipY _ aRectangle top.\n\tclipWidth _ aRectangle width.\n\tclipHeight _ aRectangle height\n",
          "height:": "height: anInteger\n\t\"Set the height instance variable in BitBlt .\"\n\n\theight _ anInteger\n",
          "mask:": "mask: aForm\n\t\"Set the halftoneForm instance variable in BitBlt.\"\n\n\thalftoneForm _ aForm\n",
          "destForm:": "destForm: aForm\n\t\"Set the destinationForm instance variable in BitBlt.\"\n\n\tdestForm _ aForm\n",
          "sourceY:": "sourceY: anInteger\n\t\"Set the sourceY instance variable in BitBlt.\"\n\n\tsourceY _ anInteger\n",
          "clipY:": "clipY: anInteger\n\t\"Set the clipY instance variable in BitBlt.\"\n\n\tclipY _ anInteger\n",
          "clipX:": "clipX: anInteger\n\t\"Set the clipX instance variable in BitBlt.\"\n\n\tclipX _ anInteger\n",
          "sourceX:": "sourceX: anInteger\n\t\"Set the sourceX instance variable in BitBlt.\"\n\n\tsourceX _ anInteger\n"
        },
        "private": {
          "setDestForm:sourceForm:halftoneForm:combinationRule:destOrigin:sourceOrigin:extent:clipRect:": "setDestForm: df sourceForm: sf halftoneForm: hf combinationRule: cr destOrigin: destOrigin sourceOrigin: sourceOrigin extent: extent clipRect: clipRect\n\t| aPoint |\n\tdestForm _ df.\n\tsourceForm _ sf.\n\thalftoneForm _ hf.\n\tcombinationRule _ cr.\n\tdestX _ destOrigin x.\n\tdestY _ destOrigin y.\n\tsourceX _ sourceOrigin x.\n\tsourceY _ sourceOrigin y.\n\twidth _ extent x.\n\theight _ extent y.\n\taPoint _ clipRect origin.\n\tclipX _ aPoint x.\n\tclipY _ aPoint y.\n\taPoint _ clipRect corner.\n\tclipWidth _ aPoint x - clipX.\n\tclipHeight _ aPoint y - clipY\n",
          "paintBits": "paintBits\n\t\"Perform the paint operation, which may require two calls to BitBlt.\"\n\t| oldMask |\n\n\t(halftoneForm == nil or: [halftoneForm == Form black]) ifFalse: \t\t\"optimization\"\n\t\t[oldMask _ halftoneForm.\n\t\tcombinationRule _ Form erase.\n\t\thalftoneForm _ nil.\n\t\tself copyBits. \t\t\t\"first erase hole in dest\"\n\t\thalftoneForm _ oldMask].\n\thalftoneForm == Form white ifFalse: \t\t\"optimization\"\n\t\t[combinationRule _ Form under.\n\t\tself copyBits].\n\tcombinationRule _ Form paint. \t\"restore rule\"\n\n\t\"(Form dotOfSize: 32)\n\t\tdisplayOn: Display\n\t\tat: Sensor cursorPoint\n\t\tclippingBox: Display boundingBox\n\t\trule: Form paint\n\t\tmask: Form lightGray\"\n",
          "copyBitsAgain": "copyBitsAgain\n\t<primitive: 96>\n\t\"don't fail the primitive if no intersection with clipping rectangle (possible LargeIntegers).\"\n\t(self clipRect intersects: (destX@destY extent: width@height))\n\t\tifTrue: [self primitiveFailed]\n"
        }
      }
    },
    "TextStyle": {
      "comment": "TextStyle is the repository of information which may be shared by a number of paragraphs.  What values it contains are still the subject of some experimentation and experience.  It presently is used for both display and printing operations.\n\nInstance Variables:\n\tfontArray\n<Array>  A collection of fonts available to the paragraph.  These may be either StrikeFonts or PressFonts.  The emphasis portion of a Text returns a value for indexing the font.\n\n\tlineGrid\n<Integer>  The amount to be added to the top of a line to find the top of the next line.  Will frequently be the greatest height in the fonts in fontArray.\n\n\tbaseline\n<Integer>  The amount to be added to the top of a line to find the baseline of the line.  The baseline is the point from which the ascent of a font should rise.\n\n\talignment\n<Integer>  Indicates the mode for first level placement from the margins\n\t-- 0=left flush, 1=centered, 2=right flush, 3=justified.\n\n\tfirstIndent\n<Integer>  Amount to inset from the left margin for the first line of a paragraph.  Initial value for paragraph associated with this TextStyle.\n\n\trestIndent\n<Integer>  Amount to inset from the left margin for all but the first line of a paragraph.  Initial value for paragraph associated with this TextStyle.\n\n\trightIndent\n<Integer>  Amount to inset from the right margin for all the lines of the paragraph.  Initial value for paragraph associated with this TextStyle.\n\n\ttabsArray\n<Array>  Tab stops.  Values are relative to the left margin of the paragraph.\n\n\tmarginTabsArray\n<Array>  Each value in the array is a tuple indicating an inset from the left and right margin of this paragraph.  Allows for inset paragraphs.\n\n\toutputMedium\n<Symbol>  Currently only #Display.  Allows for use of TextStyle in both display and printing mode.\n",
      "class_name": "TextStyle",
      "superclass": "Object",
      "instanceVariables": "fontArray lineGrid baseline alignment firstIndent restIndent rightIndent tabsArray marginTabsArray outputMedium",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "TextConstants",
      "class_methods": {
        "constants": {
          "default": "default\n\t\"Answer the system default text style.\"\n\t^DefaultTextStyle copy\n"
        },
        "instance creation": {
          "fontArray:": "fontArray: anArray\n\t\"Answer an instance of me with fonts those in anArray.\"\n\t^self new newFontArray: anArray\n"
        }
      },
      "instance_methods": {
        "tabs and margins": {
          "nextTabXFrom:leftMargin:rightMargin:": "nextTabXFrom: anX leftMargin: leftMargin rightMargin: rightMargin\n\t\"Tab stops are distances from the leftMargin.  Set the distance into anX normalized for the paragraph's left margin.  Scale makes the routine usable for printing.  On the display the scale is 1.\"\n\n\t| normalizedX tabX scale |\n\n\tscale _ 1.\n\tnormalizedX _ anX - leftMargin.\n\t1 to: tabsArray size do:\n\t\t\t\t\t[:i | (tabX _ ((tabsArray at: i) * scale) asInteger) > normalizedX\n\t\t\t\t\t\tifTrue: [^leftMargin + tabX min: rightMargin]].\n\t^rightMargin\n",
          "rightMarginTabAt:": "rightMarginTabAt: marginIndex\n\t\"Set the 'nesting' level of right margin indents of the paragraph in the style of the receiver to be marginIndex.\"\n\n\t^ self marginTabAt: marginIndex side: 2\t\t\"1= leftSide, 2 = rightSide\"\n\n\t\"The marginTabsArray is an Array of tuples.  The Array is indexed according\n\tto the marginIndex, the 'nesting' level of the requestor.\"\n",
          "leftMarginTabAt:": "leftMarginTabAt: marginIndex\n\t\"Set the 'nesting' level of left margin indents of the paragraph in the style of the receiver to be marginIndex.\"\n\n\t^ self marginTabAt: marginIndex side: 1\t\t\"1= leftSide, 2 = rightSide\"\n\n\t\"The marginTabsArray is an Array of tuples.  The Array is indexed according\n\tto the marginIndex, the 'nesting' level of the requestor.\"\n",
          "clearIndents": "clearIndents\n\t\"Reset all the margin (index) settings to be 0.\"\n\tself firstIndent: 0.\n\tself restIndent: 0.\n\tself rightIndent: 0\n",
          "tabWidth": "tabWidth\n\t\"Answer the width of standard tab.\"\n\n\t^ DefaultTab\n"
        },
        "fonts and font indexes": {
          "flushFonts": "flushFonts\n\t\"Clean out the fonts, an aid when snapshotting claims too many are holding onto Display.\"\n\tBinaryChoice\n\t\tmessage:\n'This is very dangerous and should only be used if you know what\nyou are doing and understand the system integrity issue.'\n\t\tdisplayAt: Display boundingBox center\n\t\tifTrue: [1 to: fontArray size do: [:index | fontArray at: index put: nil]]\n\t\tifFalse: [Transcript cr; show: 'flushFonts cancelled']\n\n\n\t\"TextStyle default flushFonts.\"\n"
        },
        "accessing": {
          "defaultFont": "defaultFont\n\t\"Answer the first font in the font family.\"\n\t^self fontAt: 1\n",
          "rightIndent": "rightIndent\n\t\"Answer the right margin indent for the lines of a paragraph in the style of the receiver.\"\n\t^rightIndent\n",
          "alignment:": "alignment: anInteger\n\t\"Set the current setting of the alignment to be anInteger--\n\t0=left flush, 1=centered, 2=right flush, 3=justified.\"\n\talignment _ anInteger \\\\ (Justified + 1)\n",
          "descent": "descent\n\t\"Answer the distance from the bottom of the line to the bottom of most of the characters (by convention, bottom of A).\"\n\t^ self lineGrid - self baseline\n",
          "restIndent:": "restIndent: anInteger\n\t\"Set the indent for all but the first line of a paragraph in the style of the receiver to be anInteger.\"\n\trestIndent _ anInteger\n",
          "baseline:": "baseline: anInteger\n\t\"Set the distance from the top of the line to the bottom of most of the characters.\"\n\tbaseline _ anInteger\n",
          "firstIndent": "firstIndent\n\t\"Answer the horizontal indenting of the first line of a paragraph in the style of the receiver.\"\n\t^firstIndent\n",
          "outputMedium": "outputMedium\n\t\"Answer the outputMedium for this style\"\n\t^outputMedium\n",
          "lineGrid:": "lineGrid: anInteger\n\t\"Set the relative space between lines of a paragraph in the style of the receiver to be anInteger.\"\n\tlineGrid _ anInteger\n",
          "outputMedium:": "outputMedium: aSymbol\n\t\"Set the outputMedium for this style -- currently only Display\"\n\toutputMedium _ aSymbol.\n\toutputMedium = #Display\n\t\tifTrue:\t[lineGrid _ DefaultLineGrid.\n\t\t\t\tbaseline _ DefaultBaseline]\n\t\tifFalse:\t[self outputMedium: #Display].\n",
          "firstIndent:": "firstIndent: anInteger\n\t\"Set the horizontal indenting of the first line of a paragraph in the style of the receiver to be anInteger.\"\n\tfirstIndent _ anInteger\n",
          "fontAt:": "fontAt: index\n\t\"This is private because no object outside TextStyle should depend on the representation of the font family in fontArray\"\n\t| fontIndex |\n\n\tfontIndex _ index.\n\tfontIndex > fontArray size\n\t\tifTrue:\t[fontIndex _ fontArray size].\n\tfontIndex < 0\n\t\tifTrue:\t[fontIndex _ 1].\n\t((fontArray at: fontIndex) isMemberOf: StrikeFont)\n\t\tifTrue: [^fontArray at: fontIndex].\n\t((fontArray at: 1)\n\t\tisMemberOf: StrikeFont)\n\t\t\tifTrue: [^fontArray at: 1].\n\tself error: 'No valid fonts in font array'.\n",
          "nestingDepth": "nestingDepth\n\t\"Number of entries in the marginTabsArray\"\n\n\t^ marginTabsArray size\n",
          "alignment": "alignment\n\t\"Answer the code for the current setting of the alignment.\"\n\t^alignment\n",
          "baseline": "baseline\n\t\"Answer the distance from the top of the line to the bottom of most of the characters (by convention, bottom of A).\"\n\t^baseline\n",
          "lineGrid": "lineGrid\n\t\"Answer the relative space between lines of a paragraph in the style of the receiver.\"\n\t^lineGrid\n",
          "fontAt:put:": "fontAt: index put: font\n\tfontArray at: index put: font\n",
          "restIndent": "restIndent\n\t\"Answer the indent for all but the first line of a paragraph in the style of the receiver.\"\n\t^restIndent\n",
          "rightIndent:": "rightIndent: anInteger\n\t\"Answer the right margin indent for the lines of a paragraph in the style of the receiver to be anInteger.\"\n\trightIndent _ anInteger\n"
        },
        "private": {
          "isFontItalic:": "isFontItalic: fontIndex\n\n\t ^ ((fontArray at: fontIndex) familySizeFace at: Face) = Italic\n",
          "isFontBold:": "isFontBold: fontIndex\n\n\t ^ ((fontArray at: fontIndex) familySizeFace at: Face) = Bold\n",
          "fontFor:face:": "fontFor: fontIndex face: face\n\t| currentFont currentFamilySizeFace family size emphasis newFamilySizeFace |\n\tcurrentFamilySizeFace _ (currentFont _ fontArray at: fontIndex) familySizeFace.\n\tfamily _ currentFamilySizeFace at: FamilyName.\n\tsize _ currentFamilySizeFace at: PointSize.\n\temphasis _ currentFont emphasis.\n\t(1 to: fontArray size)\n\t\tdo:\t[:faceFontIndex |\n\t\t\tnewFamilySizeFace _ (currentFont _ fontArray at: faceFontIndex) familySizeFace.\n\t\t\t((((family = (newFamilySizeFace at: FamilyName))\n\t\t\t\tand: [size = (newFamilySizeFace at: PointSize)])\n\t\t\t\t\tand: [face = (newFamilySizeFace at: Face)])\n\t\t\t\t\t\tand: [(emphasis bitAnd: NonFaceEmphasisMask) =\n\t\t\t\t\t\t\t\t(currentFont emphasis bitAnd: NonFaceEmphasisMask)])\n\t\t\t\tifTrue:\t[^faceFontIndex]].\n\t^ fontIndex\n",
          "marginTabAt:side:": "marginTabAt: marginIndex side: sideIndex\n\t\"The marginTabsArray is an Array of tuples.  The Array is indexed\n\taccording to the marginIndex, the 'nesting' level of the requestor.\n\tsideIndex is 1 for left, 2 for right\"\n\n\t| scale |\n\tscale _ 1.\n\t(marginIndex > 0 and: [marginIndex < marginTabsArray size])\n\t\tifTrue: [^((marginTabsArray at: marginIndex) at: sideIndex) * scale]\n\t\tifFalse: [^0]\n",
          "basalFontFor:": "basalFontFor: fontIndex\n\t^self fontFor: fontIndex face: Basal\n",
          "gridForFont:withLead:": "gridForFont: fontIndex withLead: leadInteger\n\t\"Force whole style to suit one of its fonts. Assumes only one font referred to by runs. \"\n\n\t| font |\n\tfont _ self fontAt: fontIndex.\n\tself lineGrid: font height + leadInteger.\n\tself baseline: font ascent\n",
          "boldItalicFontFor:": "boldItalicFontFor: fontIndex\n\t^self fontFor: fontIndex face: BoldItalic\n",
          "boldFontFor:": "boldFontFor: fontIndex\n\t^self fontFor: fontIndex face: Bold\n",
          "unSuperscriptedFontFor:": "unSuperscriptedFontFor: fontIndex\n\t| name thisFont unSuperscriptedFontIndex unSuperscriptedFont |\n\tname _ (thisFont _ fontArray at: fontIndex) name.\n\t(1 to: fontArray size)\n\t\tdo:\t[:unSuperscriptedFontIndex |\n\t\t\t(unSuperscriptedFont _\n\t\t\t\tfontArray at: unSuperscriptedFontIndex) name = name\n\t\t\t\tifTrue:\t[(((unSuperscriptedFont emphasis bitAt: SuperscriptedBit) = 0)\n\t\t\t\t\t\t\tand: [(thisFont emphasis bitAt: Underlined) =\n\t\t\t\t\t\t\t\t\t(unSuperscriptedFont emphasis bitAt: Underlined)])\n\t\t\t\t\t\t\tifTrue:\t[^unSuperscriptedFontIndex]]].\n\t^ fontIndex\n",
          "isFontBoldItalic:": "isFontBoldItalic: fontIndex\n\n\t ^ ((fontArray at: fontIndex) familySizeFace at: Face) = BoldItalic\n",
          "isFontUnderlined:": "isFontUnderlined: fontIndex\n\n\t^ (((self fontAt: fontIndex) emphasis) bitAt: UnderlinedBit) = 1\n",
          "italicFontFor:": "italicFontFor: fontIndex\n\t^self fontFor: fontIndex face: Italic\n",
          "unUnderlinedFontFor:": "unUnderlinedFontFor: fontIndex\n\t| name thisFont unUnderlinedFontIndex unUnderlinedFont |\n\tname _ (thisFont _ fontArray at: fontIndex) name.\n\t(1 to: fontArray size)\n\t\tdo:\t[:unUnderlinedFontIndex |\n\t\t\t(unUnderlinedFont _\n\t\t\t\tfontArray at: unUnderlinedFontIndex) name = name\n\t\t\t\tifTrue:\t[(((unUnderlinedFont emphasis bitAt: UnderlinedBit) = 0)\n\t\t\t\t\t\t\tand: [(thisFont emphasis bitAnd: SubSuperscriptMask) =\n\t\t\t\t\t\t\t\t\t(unUnderlinedFont emphasis bitAnd: SubSuperscriptMask)])\n\t\t\t\t\t\t\tifTrue:\t[^unUnderlinedFontIndex]]].\n\t^ fontIndex\n",
          "superscriptedFontFor:": "superscriptedFontFor: fontIndex\n\t| name thisFont superscriptedFontIndex superscriptedFont |\n\tname _ (thisFont _ fontArray at: fontIndex) name.\n\t(1 to: fontArray size)\n\t\tdo:\t[:superscriptedFontIndex |\n\t\t\t(superscriptedFont _\n\t\t\t\tfontArray at: superscriptedFontIndex) name = name\n\t\t\t\tifTrue:\t[(((superscriptedFont emphasis bitAt: SuperscriptedBit) = 1)\n\t\t\t\t\t\t\tand: [(thisFont emphasis bitAt: Underlined) =\n\t\t\t\t\t\t\t\t\t(superscriptedFont emphasis bitAt: Underlined)])\n\t\t\t\t\t\t\tifTrue:\t[^superscriptedFontIndex]]].\n\t^ fontIndex\n",
          "unSubscriptedFontFor:": "unSubscriptedFontFor: fontIndex\n\t| name thisFont unSubscriptedFontIndex unSubscriptedFont |\n\tname _ (thisFont _ fontArray at: fontIndex) name.\n\t(1 to: fontArray size)\n\t\tdo:\t[:unSubscriptedFontIndex |\n\t\t\t(unSubscriptedFont _\n\t\t\t\tfontArray at: unSubscriptedFontIndex) name = name\n\t\t\t\tifTrue:\t[(((unSubscriptedFont emphasis bitAt: SubscriptedBit) = 0)\n\t\t\t\t\t\t\tand: [(thisFont emphasis bitAt: Underlined) =\n\t\t\t\t\t\t\t\t\t(unSubscriptedFont emphasis bitAt: Underlined)])\n\t\t\t\t\t\t\tifTrue:\t[^unSubscriptedFontIndex]]].\n\t^ fontIndex\n",
          "fontNamed:": "fontNamed: aString\n\t(1 to: fontArray size)\n\t\tdo:\t[:faceFontIndex |\n\t\t\taString = (fontArray at: faceFontIndex) name\n\t\t\tifTrue:\t[^faceFontIndex]].\n\t^ self basalFontFor: 1\n",
          "underlinedFontFor:": "underlinedFontFor: fontIndex\n\t| name thisFont underlinedFontIndex underlinedFont |\n\tname _ (thisFont _ fontArray at: fontIndex) name.\n\t(1 to: fontArray size)\n\t\tdo:\t[:underlinedFontIndex |\n\t\t\t(underlinedFont _\n\t\t\t\tfontArray at: underlinedFontIndex) name = name\n\t\t\t\tifTrue:\t[(((underlinedFont emphasis bitAt: UnderlinedBit) = 1)\n\t\t\t\t\t\t\tand: [(thisFont emphasis bitAnd: SubSuperscriptMask) =\n\t\t\t\t\t\t\t\t\t(underlinedFont emphasis bitAnd: SubSuperscriptMask)])\n\t\t\t\t\t\t\tifTrue:\t[^underlinedFontIndex]]].\n\t^ fontIndex\n",
          "isFontSubscripted:": "isFontSubscripted: fontIndex\n\n\t^ (((self fontAt: fontIndex) emphasis) bitAt: SubscriptedBit) = 1\n",
          "subscriptedFontFor:": "subscriptedFontFor: fontIndex\n\n\t| name thisFont subscriptedFontIndex subscriptedFont |\n\tname _ (thisFont _ fontArray at: fontIndex) name.\n\t(1 to: fontArray size)\n\t\tdo:\t[:subscriptedFontIndex |\n\t\t\t(subscriptedFont _\n\t\t\t\tfontArray at: subscriptedFontIndex) name = name\n\t\t\t\tifTrue:\t[(((subscriptedFont emphasis bitAt: SubscriptedBit) = 1)\n\t\t\t\t\t\t\tand: [(thisFont emphasis bitAt: Underlined) =\n\t\t\t\t\t\t\t\t\t(subscriptedFont emphasis bitAt: Underlined)])\n\t\t\t\t\t\t\tifTrue:\t[^subscriptedFontIndex]]].\n\t^ fontIndex\n",
          "fontArray": "fontArray\n\t^fontArray\n",
          "isFontSuperscripted:": "isFontSuperscripted: fontIndex\n\n\t^ (((self fontAt: fontIndex) emphasis) bitAt: SuperscriptedBit) = 1\n",
          "newFontArray:": "newFontArray: anArray\n\tfontArray _ anArray.\n\tlineGrid _ DefaultLineGrid.\n\tbaseline _ DefaultBaseline.\n\talignment _ 0.\n\tfirstIndent _ 0.\n\trestIndent _ 0.\n\trightIndent _ 0.\n\toutputMedium _ #Display.\n\ttabsArray _ DefaultTabsArray.\n\tmarginTabsArray _ DefaultMarginTabsArray\n\n\t\"Currently there is no supporting protocol for changing these arrays.  If an editor wishes to implement margin setting, then a copy of the default should be stored as these instance variables.\"\n"
        }
      }
    },
    "DisplayBitmap": {
      "comment": "This subclass of Bitmap is used to indicate the particular bitmap which is being displayed, so that various implementations can treat it specially\n",
      "class_name": "DisplayBitmap",
      "superclass": "WordArray",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": ""
    },
    "StrikeFont": {
      "comment": "Instance Variables:\n\n\txTable\t<Array>  Of left x-coordinate of character in glyphs.\n\n\tglyphs\t<Form>  Containing bits representing the characters.\n\n\tname\t<String>  Name of this font.\n\n\tstopConditions\t<Array>  Of selectors to be performed in scanning text.\n\n\ttype\t<Integer>  Code for strike fonts files.\n\n\tminAscii, maxAscii\t<Integer>  Giving range supported by this font.\n\n\tmaxWidth\t<Integer>  Width of widest char. Not presently used, but may be for font modification.\n\n\tstrikeLength\t<Integer>  Not used.\n\n\tascent, descent\t<Integer>  Max extent of chars above and below the baseline\n\n\txOffset\t<Integer>  For kerning (not presently used)\n\n\traster\t<Integer>  Specifies layout of the glyphs form\n\n\tsubscript, superscript\t<Integer>  Further vertical offset relative to baseline\n\n\temphasis\t<Integer>  code for synthetic bold, italic, underline, strike-out\n\nStrikeFonts are a compact encoding of a set of Forms corresponding to characters in the ASCII character set.  All the forms are placed side by side in a large form whose height is the font height, and whose width is the sum of all the character widths.  The xTable gives the left-x coordinates of the subForms corresponding to the characters.\n",
      "class_name": "StrikeFont",
      "superclass": "Object",
      "instanceVariables": "xTable glyphs name stopConditions type minAscii maxAscii maxWidth strikeLength ascent descent xOffset raster subscript superscript emphasis",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "TextConstants",
      "instance_methods": {
        "printing": {
          "printOn:": "printOn: aStream\n\taStream nextPutAll: self class name, ' name ', name, ' emphasis ';\n\t\tprint: emphasis; nextPut: Character cr.\n"
        },
        "displaying": {
          "characters:in:displayAt:clippedBy:rule:mask:": "characters: anInterval in: sourceString displayAt: aPoint clippedBy: clippingRectangle rule: ruleInteger mask: aForm\n\t\"Simple, slow, primitive method for displaying a line of characters.  No\n\twrap-around is handled.\"\n\n\t| ascii character characterForm |\n\tanInterval do:\n\t\t[:i |\n\t\tascii _ (character _ sourceString at: i) asciiValue.\n\t\t(ascii < minAscii or: [ascii > maxAscii])\n\t\t\tifTrue: [character _ (ascii _ maxAscii) asCharacter].\n\t\tcharacterForm _ self characterForm: character.\n\t\tcharacterForm\n\t\t\tdisplayOn: Display\n\t\t\tat: aPoint\n\t\t\tclippingBox: clippingRectangle\n\t\t\trule: ruleInteger\n\t\t\tmask: aForm.\n\t\taPoint x: aPoint x + (self widthOf: character)].\n\t^aPoint x\n",
          "displayLine:at:": "displayLine: aString at: aPoint\n\t\"Display the characters in aString, starting at position aPoint.\"\n\n\tself characters: (1 to: aString size)\n\t\tin: aString\n\t\tdisplayAt: aPoint\n\t\tclippedBy: Display boundingBox\n\t\trule: Form over\n\t\tmask: Form black\n",
          "composeWord:in:beginningAt:": "composeWord: aTextLineInterval in: sourceString beginningAt: xInteger\n\t\"Non-primitive composition of a word -- add up widths of characters, add sum to\n\tbeginning x and answer the resulting x.  Similar to performance of scanning\n\tprimitive, but without stop conditions.\"\n\n\t| character resultX |\n\tresultX _ xInteger.\n\taTextLineInterval do:\n\t\t[:i |\n\t\tcharacter _ sourceString at: i.\n\t\tresultX _ resultX + (self widthOf: character)].\n\t^resultX\n"
        },
        "testing": {
          "checkCharacter:": "checkCharacter: character\n\t\"Answer a character that is within the ascii range of the receiver--either character\n\tor the last character in the receiver.\"\n\n\t| ascii |\n\tascii _ character asciiValue.\n\t((ascii < minAscii) or: [ascii > maxAscii])\n\t\t\tifTrue: [^maxAscii asCharacter]\n\t\t\tifFalse:\t[^character]\n"
        },
        "accessing": {
          "minAscii": "minAscii\n\t\"Answer the integer that is the first Ascii character value of the receiver.\"\n\t^minAscii\n",
          "characterForm:": "characterForm: character\n\t\"Answer a Form copied out of the glyphs for this character.\"\n\n\t| characterForm ascii |\n\tascii _ character asciiValue.\n\tascii > maxAscii ifTrue: [ascii _maxAscii].\n\tcharacterForm _ Form new extent: (self widthOf: character) @ self height.\n\tcharacterForm\n\t\tcopyBits: (Rectangle origin: (xTable at: ascii + 1)\n\t\t\t\t\t@ 0 extent: (self widthOf: character)\n\t\t\t\t\t@ self height)\n\t\tfrom: glyphs\n\t\tat: 0 @ 0\n\t\tclippingBox: characterForm boundingBox\n\t\trule: Form over\n\t\tmask: Form black.\n\t^characterForm\n",
          "subscript": "subscript\n\t\"Answer an integer that is the further vertical offset relative to the\n\tbaseline for positioning characters as subscripts.\"\n\t^subscript\n",
          "maxWidth": "maxWidth\n\t\"Answer the integer that is the width of the receiver's widest character.\"\n\t^maxWidth\n",
          "descent": "descent\n\t\"Answer the font's maximum extent of characters below the baseline.\"\n\t^descent\n",
          "raster": "raster\n\t\"Answer an integer that specifies the layout of the glyphs' form.\"\n\t^raster\n",
          "name": "name\n\t\"Answer the receiver's name.\"\n\t^name\n",
          "xTable": "xTable\n\t\"Answer an array of the left x-coordinate of characters in glyphs.\"\n\t^xTable\n",
          "glyphs": "glyphs\n\t\"Answer a Form containing the bits representing the characters of the receiver.\"\n\t^glyphs\n",
          "subscript:": "subscript: anInteger\n\t\"Answer an integer that is the further vertical offset relative to the\n\tbaseline for positioning characters as subscripts.\"\n\tsubscript _ anInteger.\n",
          "familySizeFace": "familySizeFace\n\t\"Return an array with familyName <String> pointSize <Integer> faceCode <Integer>\"\n\n\t| fontName firstDigit lastDigit |\n\tfontName_ name asUppercase.\n\tfirstDigit _ fontName findFirst: [:char | char isDigit].\n\tlastDigit _ fontName findLast: [:char | char isDigit].\n\t^Array with: (fontName copyFrom: 1 to: firstDigit-1)\n\t\twith: (Integer readFromString: (fontName copyFrom: firstDigit to: lastDigit))\n\t\twith: (#('B' 'I' 'BI') indexOf:\n\t\t\t\t\t(fontName copyFrom: lastDigit+1 to: fontName size))\n\n\" (1 to: 12) collect: [:x | (TextStyle default fontAt: x) familySizeFace] \"\n",
          "height": "height\n\t\"Answer the height of the font, total of maximum extents of characters\n\tabove and below the baseline.\"\n\t^self ascent + self descent\n",
          "widthOf:": "widthOf: aCharacter\n\t\"Answer the width of the argument as a character in the receiver.\"\n\n\t| ascii |\n\tascii _ (aCharacter asciiValue min: maxAscii + 1) max: minAscii.\n\t^(xTable at: ascii + 2) - (xTable at: ascii + 1)\n",
          "ascent": "ascent\n\t\"Answer the font's maximum extent of characters above the baseline.\"\n\t^ascent\n",
          "stopConditions": "stopConditions\n\t\"Answer the array of selectors to be performed in scanning text made\n\tup of the receiver's characters.\"\n\t^stopConditions\n",
          "name:": "name: aString\n\t\"Set the receiver's name.\"\n\tname _ aString.\n",
          "superscript": "superscript\n\t\"Answer an integer that is the further vertical offset relative to the\n\tbaseline for positioning characters as superscripts.\"\n\t^superscript\n",
          "superscript:": "superscript: anInteger\n\t\"Answer an integer that is the further vertical offset relative to the\n\tbaseline for positioning characters as superscripts.\"\n\tsuperscript _ anInteger.\n",
          "maxAscii": "maxAscii\n\t\"Answer the integer that is the last Ascii character value of the receiver.\"\n\t^maxAscii\n"
        },
        "private": {
          "ascent:": "ascent: anInteger\n\t\"Set the font's maximum extent of characters above the baseline.\"\n\tascent _ anInteger.\n",
          "glyphs:": "glyphs: aForm\n\t\"Set the Form containing the bits representing the characters of the receiver.\"\n\tglyphs _ aForm.\n"
        },
        "emphasis": {
          "emphasized:named:": "emphasized: code named: aString\n\t\"Answer a copy of the receiver with emphasis set to code.\"\n\t| copy |\n\n\tcopy _ self copy emphasis: (code + emphasis).\n\tcopy name: aString.\n\t^copy\n\n\t\"TextStyle default fontAt: 9\n\t\tput: ((TextStyle default fontAt: 1) emphasized: 4 named: 'TimesRoman10i')\"\n",
          "emphasis": "emphasis\n\t\"Answer the integer code for synthetic bold, itallic, underline, and strike-out.\"\n\t^emphasis\n",
          "emphasized:": "emphasized: code\n\t\"Answer a copy of the receiver with emphasis set to code.\"\n\t^self copy emphasis: code + emphasis\n\n\t\"TextStyle default fontAt: 9 put: ((TextStyle default fontAt: 1) emphasized: 4)\"\n",
          "emphasis:": "emphasis: code\n\t\"Set the integer code for synthetic bold, itallic, underline, and strike-out,\n\twhere bold=1, itallic=2, underlined=4, struck out=8, subscript=16, superscript=32.\"\n\temphasis _ code\n"
        }
      }
    },
    "CharacterScanner": {
      "comment": "My instances hold the state associated with scanning text.\n\n\nInstance Variables\n\n\tlastIndex\n<Integer>  String index of last character scanned.\n\n\txTable\n<Array>  Array left x-coordinates of character glyphs (cached from font).\n\n\tstopConditions\n<Array>  Array of selectors to perform when scanning various characters.\n\t----\n\ttext\n<Text>  The text being scanned.\n\n\ttextStyle\n<TextStyle>  The style (font set, etc.) being used with this text.\n\n\tleftMargin, rightMargin\n<Integers>  Screen coordinates delimiting the text.\n\n\tfont\n<StrikeFont>  The font currently in use.\n\n\tline\n<TextLineInterval>  Giving the current range in text.\n\n\trunStopIndex\n<Integer>  Where the current run ends in text.\n\n\tspaceCount\n<Integer>  How many spaces have been scanned in this line.\n\n\tspaceWidth\n<Integer>  How wide spaces should be in this line.\n\n\toutputMedium\n<Symbol>  Either #Display, #PressPrinter or #DisplayPrinterWidths as of 1/20/80.  Needed by CompositionScanner for determining the nature of the font to be used for character widths.  For the DisplayScanner there are several places where distinguishing between displaying and printing is required.\n\nThe first three variables are required (in addition to inherited BitBlt state) by the primitive scanning operation.\n",
      "class_name": "CharacterScanner",
      "superclass": "BitBlt",
      "instanceVariables": "lastIndex xTable stopConditions text textStyle leftMargin rightMargin font line runStopIndex spaceCount spaceWidth outputMedium",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "TextConstants",
      "instance_methods": {
        "scanning": {
          "characterNotInFont": "characterNotInFont\n\t\"All fonts have an illegal character to be used when a character is not within the font's legal range.  When characters out of ranged are encountered in scanning text, then this special character indicates the appropriate behavior.  The character is usually treated as a unary message understood by a subclass of CharacterScanner.\"\n\n\t| illegalAsciiString saveIndex stopCondition |\n\tsaveIndex _ lastIndex.\n\tillegalAsciiString _ String with: (font maxAscii + 1) asCharacter.\n\t(self isMemberOf: CompositionScanner) not\n\tifTrue: [\n\tstopCondition _\n\t\t\t\t\tself scanCharactersFrom: 1\n\t\t\t\t\t\tto: 1\n\t\t\t\t\t\tin: illegalAsciiString\n\t\t\t\t\t\trightX: rightMargin\n\t\t\t\t\t\tstopConditions: stopConditions\n\t\t\t\t\t\tdisplaying: self doesDisplaying]\n\tifFalse:\t[\n\tstopCondition _\n\t\tself scanCharactersFrom: 1 to: 1\n\t\t\tin: illegalAsciiString\n\t\t\trightX: rightMargin stopConditions: stopConditions\n\t\t\tdisplaying: self doesDisplaying].\n\tlastIndex _ saveIndex + 1.\n\tstopCondition ~= (stopConditions at: EndOfRun)\n\t\tifTrue:\t[^self perform: stopCondition]\n\t\tifFalse: [lastIndex = runStopIndex\n\t\t\t\t\tifTrue:\t[^self perform: (stopConditions at: EndOfRun)].\n\t\t\t\t^false]\n",
          "scanCharactersFrom:to:in:rightX:stopConditions:displaying:": "scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops displaying: display\n\n\t\"This is the inner loop of text display -- but consider scanCharactersFrom: to:rightX: which would get the string, stopConditions and displaying from the instance. March through source String from startIndex to stopIndex. If any character is flagged with a non-nil entry in stops, then return the corresponding value. Determine width of each character from xTable. If dextX would exceed rightX, then return stops at: 258. If displaying is true, then display the character. Advance destX by the width of the character. If stopIndex has been reached, then return stops at: 257. Fail under the same conditions that the Smalltalk code below would cause an error. Optional. See Object documentation whatIsAPrimitive. \"\n\n\t| ascii nextDestX |\n\t<primitive: 103>\n\tlastIndex _ startIndex.\n\t[lastIndex <= stopIndex]\n\t\twhileTrue:\n\t\t\t[ascii _ (sourceString at: lastIndex) asciiValue.\n\t\t\t(stopConditions at: ascii + 1) ~~ nil ifTrue: [^stops at: ascii + 1].\n\t\t\tsourceX _ xTable at: ascii + 1.\n\t\t\tnextDestX _ destX + (width _ (xTable at: ascii + 2) - sourceX).\n\t\t\tnextDestX > rightX ifTrue: [^stops at: CrossedX].\n\t\t\tdisplay ifTrue: [self copyBits].\n\t\t\tdestX _ nextDestX.\n\t\t\tlastIndex _ lastIndex + 1].\n\tlastIndex _ stopIndex.\n\t^stops at: EndOfRun\n"
        },
        "private": {
          "initializeFromParagraph:clippedBy:": "initializeFromParagraph: aParagraph clippedBy: clippingRectangle\n\ttext _ aParagraph text.\n\ttextStyle _ aParagraph textStyle.\n\tdestForm _ aParagraph destinationForm.\n\toutputMedium _ aParagraph outputMedium.\n\thalftoneForm _ aParagraph mask.\n\tself combinationRule: aParagraph rule.\n\tself clipRect: clippingRectangle.\n\tsourceY _ 0.\n",
          "doesDisplaying": "doesDisplaying\n\t^false\n"
        },
        "stop conditions": {
          "setStopConditions": "setStopConditions\n\t\"Set default stop conditions for the font.\"\n\n\tspaceWidth _ font widthOf: Space.\n\tsourceForm _ font glyphs.\n\txTable _ font xTable.\n\theight _ font height.\n\tstopConditions _ font stopConditions.\n\tstopConditions at: Space asInteger + 1 put: #space.\n\tstopConditions at: Tab asInteger + 1 put: #tab.\n\tstopConditions at: CR asInteger + 1 put: #cr.\n\tstopConditions at: EndOfRun put: #endOfRun.\n\tstopConditions at: CrossedX put: #crossedX.\n\n\tstopConditions at: Ctrls asInteger + 1 put: #onePixelSpace.\n\tstopConditions at: CtrlS asInteger + 1 put: #onePixelBackspace.\n\tstopConditions at: Ctrlz asInteger + 1 put: #characterNotInFont.\n"
        }
      }
    },
    "CompositionScanner": {
      "comment": "My instances hold the state of CharacterScanner in addition to the following required only for composition.\n\nInstance Variables\n\n\tspaceX\n<Integer>  Left edge of last space scanned.  When line overflows this value is substracted from the rightMargin to determine how much padding is available for justification, centering, etc.\n\n\tspaceIndex\n<Integer>  Character index of last space scanned in line.  Installed as stop in the TextLineInterval for the line being composed.\n\nCompositionScanners are used to measure text and determine where line breaks and space padding should occur.\n",
      "class_name": "CompositionScanner",
      "superclass": "CharacterScanner",
      "instanceVariables": "spaceX spaceIndex",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "TextConstants",
      "instance_methods": {
        "scanning": {
          "composeLine:fromCharacterIndex:inParagraph:": "composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph\n\t\"Answer an instance of TextLineInterval that represents the next line in the paragraph.\"\n\n\t| runLength done stopCondition |\n\tlastIndex _ startIndex.\t\t\"scanning sets last index\"\n\tself setStopConditions.\t\t\"also sets font\"\n\tspaceX _ destX _ leftMargin _\n\t\t(aParagraph leftMarginForCompositionForLine: lineIndex).\n\trightMargin _ aParagraph rightMarginForComposition.\n\tleftMargin >= rightMargin ifTrue:\n\t\t[self error: 'No room between margins to compose'].\n\trunLength _ text runLengthFor: startIndex.\n\trunStopIndex _ (lastIndex _ startIndex) + (runLength - 1).\n\tline _\n\t\tTextLineInterval\n\t\t\tstart: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0.\n\tspaceCount _ 0.\n\tdone _ false.\n\t[done]\n\t\twhileFalse:\n\t\t\t[stopCondition _\n\t\t\t\tself\n\t\t\t\t\tscanCharactersFrom: lastIndex\n\t\t\t\t\tto: runStopIndex\n\t\t\t\t\tin: text string\n\t\t\t\t\trightX: rightMargin\n\t\t\t\t\tstopConditions: stopConditions\n\t\t\t\t\tdisplaying: false.\n\t\t\t\"See setStopConditions for stopping conditions for composing.\"\n\t\t\t(self perform: stopCondition) ifTrue: [^line]]\n"
        },
        "accessing": {
          "rightX": "rightX\n\t\"Meaningful only when a line has just been composed -- refers to the line most recently composed.  This is a subtrefuge to allow for easy resizing of a composition rectangle to the width of the maximum line.  Useful only when there is only one line in the form or when each line is terminated by a carriage return.  Handy for sizing menus and lists.\"\n\n\t^spaceX\n"
        },
        "private": {
          "resetFont": "resetFont\n\t\"Mainly to allow the stop condition crossedX to be shared by display and printer media.\"\n\t^ textStyle fontAt: (text emphasisAt: spaceIndex)\n"
        },
        "initialize-release": {
          "in:": "in: aParagraph\n\t\"Initialize the paragraph to be scanned as the argument, aParagraph.  Set the composition frame for the paragraph.\"\n\n\tsuper initializeFromParagraph: aParagraph clippedBy: aParagraph clippingRectangle\n"
        },
        "stop conditions": {
          "cr": "cr\n\t\"Answer true.  Sets up values for the text line interval currently being composed.\"\n\n\tline stop: lastIndex.\n\tspaceX _ destX.\n\tline paddingWidth: rightMargin - destX.\n\t^true\n",
          "tab": "tab\n\t\"Advance destination x according to tab settings in the paragraph's textStyle.  Answer whether the character has crossed the right edge of the composition rectangle of the paragraph.  Scale allows use of same code for display and printing composition\"\n\n\tdestX _ textStyle\n\t\t\t\tnextTabXFrom: destX leftMargin: leftMargin rightMargin: rightMargin.\n\tdestX > rightMargin ifTrue:\t[^self crossedX].\n\tlastIndex _ lastIndex + 1.\n\t^false\n",
          "space": "space\n\t\"Record left x and character index of the space character just encounted.  Used for wrap-around.  Answer whether the character has crossed the right edge of the composition rectangle of the paragraph.\"\n\n\tspaceX _ destX.\n\tdestX _ spaceX + spaceWidth.\n\tlastIndex _ (spaceIndex _ lastIndex) + 1.\n\tspaceCount _ spaceCount + 1.\n\tdestX > rightMargin ifTrue: \t[^self crossedX].\n\t^false\n",
          "crossedX": "crossedX\n\t\"There is a word that has fallen across the right edge of the composition rectangle.  This signals the need for wrapping which is done to the last space that was encountered, as recorded by the space stop condition.\"\n\tline stop: spaceIndex.\n\tspaceCount > 1\n\t\tifTrue:\t[\"The common case. First back off the space at which we wrap.\"\n\t\t\t\tspaceCount _ spaceCount - 1.\n\t\t\t\tspaceIndex _ spaceIndex - 1.\n\t\t\t\t[\"Check to see if any spaces preceding the one at which we wrap.\n\t\t\t\t\tDouble space after a period, most likely.\"\n\t\t\t\t(spaceCount > 1 and: [(text at: spaceIndex) = Space])]\n\t\t\t\t\twhileTrue:\n\t\t\t\t\t\t[spaceCount _ spaceCount - 1.\n\t\t\t\t\t\tspaceIndex _ spaceIndex - 1.\n\t\t\t\t\t\t\"Account for backing over a run which might\n\t\t\t\t\t\t\tchange width of space.\"\n\t\t\t\t\t\tfont _ self resetFont.\n\t\t\t\t\t\tspaceX _ spaceX - (font widthOf: Space)].\n\t\t\t\t\t\tline paddingWidth: rightMargin - spaceX.\n\t\t\t\t\t\tline internalSpaces: spaceCount]\n\t\tifFalse:\t[spaceCount = 1\n\t\t\t\t\tifTrue:\t[\"wrap at space, but no internal spaces\"\n\t\t\t\t\t\t\tline internalSpaces: 0.\n\t\t\t\t\t\t\tline paddingWidth: rightMargin - spaceX]\n\t\t\t\t\tifFalse:\t[\"Neither internal nor trailing spaces, almost never happen,\n\t\t\t\t\t\t\t\tshe says confidently.\"\n\t\t\t\t\t\t\tlastIndex _ lastIndex - 1.\n\t\t\t\t\t\t\t[destX <= rightMargin]\n\t\t\t\t\t\t\twhileFalse:\n\t\t\t\t\t\t\t\t[destX _ destX - (font widthOf:\n\t\t\t\t\t\t\t\t\t\t\t\t\t(text at: lastIndex)).\n\t\t\t\t\t\t\t\t\t\t\"bug --doesn't account for backing over\n\t\t\t\t\t\t\t\t\t\t run and changing actual width of\n\t\t\t\t\t\t\t\t\t\tcharacters. Also doesn't account for\n\t\t\t\t\t\t\t\t\t\tbacking over a tab.  Happens only\n\t\t\t\t\t\t\t\t\t\twhen no spaces in line, presumably rare.\"\n\t\t\t\t\t\t\t\tlastIndex _ lastIndex - 1].\n\t\t\t\t\t\t\tspaceX _ destX.\n\t\t\t\t\t\t\tline paddingWidth: rightMargin - destX.\n\t\t\t\t\t\t\tlastIndex < line first\n\t\t\t\t\t\t\t\tifTrue:\t[line stop: line first]\n\t\t\t\t\t\t\t\tifFalse:\t[line stop: lastIndex]]].\n\t^true\n",
          "endOfRun": "endOfRun\n\t\"Answer true if scanning has reached the end of the paragraph.  Otherwise set stop conditions (mostly install potential new font) and answer false.\"\n\n\t| runLength |\n\tlastIndex = text size\n\tifTrue:\t[line stop: lastIndex.\n\t\t\tspaceX _ destX.\n\t\t\tline paddingWidth: rightMargin - destX.\n\t\t\t^true]\n\tifFalse:\t[runLength _ (text runLengthFor: (lastIndex _ lastIndex + 1)).\n\t\t\trunStopIndex _ lastIndex + (runLength - 1).\n\t\t\tself setStopConditions.\n\t\t\t^false]\n",
          "setStopConditions": "setStopConditions\n\t\"Set the font and the stop conditions for the current run.\"\n\n\tfont _ textStyle fontAt: (text emphasisAt: lastIndex).\n\tsuper setStopConditions.\n",
          "onePixelBackspace": "onePixelBackspace\n\t\"Decrement destX by 1. \"\n\n\tdestX _ (destX - 1) max: leftMargin.\n\tlastIndex _ lastIndex + 1.\n\t^false\n",
          "onePixelSpace": "onePixelSpace\n\t\"Increment destX by 1. \"\n\n\tdestX _ destX+1.\n\tlastIndex _ lastIndex + 1.\n\tdestX > rightMargin ifTrue: \t[^self crossedX].\n\t^false\n"
        }
      }
    }
  },
  "Graphics-Views": {
    "FormHolderView": {
      "comment": "I represent a view of a Form.  Editing takes place by modifying a working version of the Form.  The message accept is used to copy the working version into the Form;  the message cancel copies the Form into the working version.\n\nInstance Variables:\n\tdisplayedForm <Form> a working version of the Form for cancelable editing\n",
      "class_name": "FormHolderView",
      "superclass": "FormView",
      "instanceVariables": "displayedForm",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "model access": {
          "model:": "model: aForm\n\tsuper model: aForm.\n\tdisplayedForm _ aForm deepCopy\n",
          "changeValueAt:put:": "changeValueAt: location put: anInteger\n\tdisplayedForm valueAt: location put: anInteger.\n\tdisplayedForm changed: self\n",
          "workingForm": "workingForm\n\t\"Answer the Form that is currently being displayed--the working version\n\tin which edits are carried out.\"\n\t^displayedForm\n"
        },
        "menu messages": {
          "accept": "accept\n\tmodel\n\t\tcopyBits: displayedForm boundingBox\n\t\tfrom: displayedForm\n\t\tat: 0 @ 0\n\t\tclippingBox: model boundingBox\n\t\trule: Form over\n\t\tmask: Form black.\n\tmodel changed: self\n",
          "cancel": "cancel\n\tdisplayedForm become: model deepCopy.\n\tdisplayedForm changed: self.\n\tself display\n"
        },
        "displaying": {
          "displayView": "displayView\n\t\"This method displays the Form associated with this View according to the rule and mask specifed by this class.\"\n\n\t| oldOffset |\n\toldOffset _ displayedForm offset.\n\tdisplayedForm offset: 0@0.\n\tdisplayedForm\n\t\tdisplayOn: Display\n\t\ttransformation: self displayTransformation\n\t\tclippingBox: self insetDisplayBox\n\t\trule: self rule\n\t\tmask: self mask.\n\tdisplayedForm offset: oldOffset\n",
          "updateDisplay": "updateDisplay\n\t\"The working version is redefined by copying the bits displayed in the receiver's display area.\"\n\n\tdisplayedForm fromDisplay: self insetDisplayBox.\n\tdisplayedForm changed: self.\n"
        },
        "initialize-release": {
          "release": "release\n\tsuper release.\n\tdisplayedForm release.\n\tdisplayedForm _ nil\n"
        }
      }
    },
    "FormView": {
      "comment": "This class has as its model a Form.  It is used mainly\n\t\t\tto allow display of Forms on the display screen in the\n\t\t\tmodel-view-controller metaphor.\n",
      "class_name": "FormView",
      "superclass": "View",
      "instanceVariables": "rule mask",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "examples": {
          "exampleOne": "exampleOne\n\t\"Frame a Form (specified by the user) with a border of 5 bits in width and\n\tdisplay it offset 100 x 100 from the corner of the display screen.\"\n\n\t| f view |\n\tf _ Form fromUser.\n\tview _ self new model: f.\n\tview translateBy: 100 @ 100.\n\tview borderWidth: 2.\n\tview insideColor: Form white.\n\tview display.\n\tview release\n\n\t\"FormView exampleOne.\"\n",
          "exampleTwo": "exampleTwo\n\t\"Frame a Form (specified by the user) that is scaled by 2.  The border is\n\t2 bits in width.  Displays at locatoin 100,100.\"\n\n\t| f view |\n\tf _ Form fromUser.\n\tview _ self new model: f.\n\tview scaleBy: 2.0.\n\t\"if you eliminate this message, no inside border displays\"\n\tview translateBy: 100 @ 100.\n\tview borderWidth: 2.\n\tview insideColor: Form white.\n\tview display.\n\tview release\n\n\t\"FormView exampleTwo.\"\n"
        }
      },
      "instance_methods": {
        "model access": {
          "changeValueAt:put:": "changeValueAt: location put: anInteger\n\t\"The receiver's model is a Form which has an array of bits.  Change\n\tthe bit at index location to be anInteger (either 1 or 0).  Inform all\n\tobjects that depend on the model that it has changed.\"\n\n\tmodel valueAt: location put: anInteger.\n\tmodel changed: self\n"
        },
        "window access": {
          "defaultWindow": "defaultWindow\n\t^(Rectangle origin: 0 @ 0 extent: model extent)\n\t\texpandBy: borderWidth\n"
        },
        "menu messages": {
          "accept": "accept\n\t\"The receiver's model is set to the working version, the one in which edits\n\tare carried out.\"\n\t^self\n",
          "cancel": "cancel\n\t\"Set the working form to be a copy of the model.\"\n\t^self\n"
        },
        "updating": {
          "update:": "update: aFormView\n\tself == aFormView ifFalse: [self display]\n"
        },
        "displaying": {
          "displayView": "displayView\n\t| oldOffset |\n\tsuper displayView.\n\tinsideColor == nil ifFalse: [Display fill: self insetDisplayBox mask: insideColor].\n\toldOffset _ model offset.\n\tmodel offset: 0@0.\n\tmodel\n\t\tdisplayOn: Display\n\t\ttransformation: self displayTransformation\n\t\tclippingBox: self insetDisplayBox\n\t\trule: self rule\n\t\tmask: self mask.\n\tmodel offset: oldOffset\n"
        },
        "accessing": {
          "rule": "rule\n\t\"Answer a number from 0 to 15 that indicates which of the sixteen display rules\n\t(logical function of two boolean values) is to be used when copying the receiver's\n\tmodel (a Form) onto the display screen.\"\n\n\trule == nil\n\t\tifTrue: [^self defaultRule]\n\t\tifFalse: [^rule]\n",
          "rule:": "rule: anInteger\n\t\"Set the display rule for the receiver.\"\n\trule _ anInteger\n",
          "mask": "mask\n\t\"Answer an instance of class Form that is the mask used when displaying\n\tthe receiver's model (a Form) on the display screen (see BitBlt for the\n\tmeaning of this mask).\"\n\n\tmask == nil\n\t\tifTrue: [^self defaultMask]\n\t\tifFalse: [^mask]\n",
          "mask:": "mask: aForm\n\t\"Set the display mask for displaying the receiver's model.\"\n\tmask _ aForm\n"
        },
        "private": {
          "defaultMask": "defaultMask\n\t\"The default display mask, blackMask, is a 16x16 Form that is all ones\"\n\n\t^Form black\n",
          "defaultRule": "defaultRule\n\t\"This is the default display rule (3=over or storing)\"\n\n\t^Form over\n"
        },
        "controller access": {
          "defaultControllerClass": "defaultControllerClass\n\t^FormEditor\n"
        }
      }
    },
    "DisplayTextView": {
      "comment": "I represent a view of an instance of DisplayText.\n\nInstance Variables:\n\trule\t\t<Integer> according to which character display behaves:  equal over, under,\n\t\t\tand reverse.\n\tmask\t<Form> with which each character is combined by the display scanner\n\t\t\tbefore applying the rule.\n\teditParagraph\t<Paragraph> the composed text ready for display\n",
      "class_name": "DisplayTextView",
      "superclass": "View",
      "instanceVariables": "rule mask editParagraph centered",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "examples": {
          "example3": "example3\n\t\"Creates a passive view of some text on the screen.\"\n\n\t| view |\n\tview_ self new model: 'this is a test of one line\nand the second line' asDisplayText.\n\tview translateBy: 100@100.\n\tview borderWidth: 2.\n\tview insideColor: Form white.\n\tview display.\n\tview release\n\n\t\"DisplayTextView example3.\"\n",
          "example2": "example2\n\t\"Creates a standarad system view with two parts, one editable, the other not.\"\n\t| topView aDisplayTextView |\n\ttopView _ StandardSystemView new.\n\ttopView label: 'Text Editor'.\n\taDisplayTextView _ self new model: 'test string label' asDisplayText.\n\taDisplayTextView controller: NoController new.\n\taDisplayTextView window: (0 @ 0 extent: 100 @ 100).\n\taDisplayTextView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.\n\taDisplayTextView insideColor: Form white.\n\ttopView addSubView: aDisplayTextView.\n\n\taDisplayTextView _ self new model: 'test string' asDisplayText.\n\taDisplayTextView window: (0 @ 0 extent: 100 @ 100).\n\taDisplayTextView borderWidth: 2.\n\taDisplayTextView insideColor: Form white.\n\ttopView\n\t\taddSubView: aDisplayTextView\n\t\talign: aDisplayTextView viewport topLeft\n\t\twith: topView lastSubView viewport topRight.\n\ttopView controller open\n\n\t\"DisplayTextView example2.\"\n",
          "example1": "example1\n\t\"Creates a system view with a paragraph editor in it\"\n\n\t| topView aDisplayTextView |\n\taDisplayTextView _ DisplayTextView new model: 'test string' asDisplayText.\n\taDisplayTextView insideColor: Form white.\n\taDisplayTextView borderWidth: 2.\n\ttopView _ StandardSystemView new.\n\ttopView label: 'Text Editor'.\n\ttopView addSubView: aDisplayTextView.\n\ttopView controller open\n\n\t\"DisplayTextView example1.\"\n",
          "example4": "example4\n\t\"Creates four passive views of some text on the screen with fat borders.\"\n\n\t| view |\n\tview_ self new model: 'this is a test of one line\nand the second line' asDisplayText.\n\tview translateBy: 100@100.\n\tview borderWidth: 5.\n\tview insideColor: Form white.\n\tview display.\n\t3 timesRepeat: [view translateBy: 100@100. view display].\n\tview release\n\n\t\"DisplayTextView example4.\"\n"
        }
      },
      "instance_methods": {
        "deEmphasizing": {
          "deEmphasizeView": "deEmphasizeView\n\t(self controller isKindOf: ParagraphEditor)\n\t \tifTrue: [controller deselect]\n"
        },
        "model access": {
          "model:": "model: aDisplayText\n\tsuper model: aDisplayText.\n\teditParagraph _ model asParagraph.\n\tself centerText\n"
        },
        "window access": {
          "defaultWindow": "defaultWindow\n\t^((0@0 extent: editParagraph extent) expandBy: self paragraphInset)\n\t\texpandBy: borderWidth\n",
          "window:": "window: aWindow\n\tsuper window: aWindow.\n\tself centerText\n"
        },
        "displaying": {
          "displayView": "displayView\n\tself clearInside.\n\t(self controller isKindOf: ParagraphEditor )\n\t\tifTrue: [controller changeParagraph: editParagraph].\n\tself isCentered\n\t\tifTrue:\n\t\t\t[editParagraph\n\t\t\t\tdisplayOn: Display\n\t\t\t\ttransformation: self displayTransformation\n\t\t\t\tclippingBox: self insetDisplayBox\n\t\t\t\tfixedPoint: editParagraph boundingBox center]\n\t\tifFalse:\n\t\t\t[editParagraph displayOn: Display]\n",
          "display": "display\n\tself isUnlocked ifTrue: [self positionText].\n\tsuper display\n"
        },
        "accessing": {
          "rule": "rule\n\t\"Answer a number from 0 to 15 that indicates which of the sixteen display rules\n\tis to be used when blting the receiver's model (a DisplayText) onto the display\n\tscreen.\"\n\n\trule == nil\n\t\tifTrue: [^self defaultRule]\n\t\tifFalse: [^rule]\n",
          "rule:": "rule: anInteger\n\t\"Set anInteger to be the rule used when displaying the receiver's model.\"\n\trule _ anInteger\n",
          "centered": "centered\n\tcentered _ true.\n\tself centerText\n",
          "isCentered": "isCentered\n\t^centered\n",
          "mask": "mask\n\t\"Answer an instance of class Form that is to be used as the mask when displaying\n\tthe receiver's model (a DisplayText).\"\n\n\tmask == nil\n\t\tifTrue: [^self defaultMask]\n\t\tifFalse: [^mask]\n",
          "mask:": "mask: aForm\n\t\"Set aForm to be the mask used when displaying the receiver's model.\"\n\tmask _ aForm\n"
        },
        "private": {
          "paragraphInset": "paragraphInset\n\t\"Answer the amount to inset the paragraph from the border\"\n\t^6@0\n",
          "positionText": "positionText\n\t| box |\n\tbox _ self insetDisplayBox origin + self paragraphInset\n\t\t\textent: editParagraph boundingBox extent.\n\teditParagraph recomposeIn: box clippingBox: box.\n\tself centerText\n",
          "defaultMask": "defaultMask\n\t^Form black\n",
          "centerText": "centerText\n\tself isCentered\n\t\tifTrue:\n\t\t\t[editParagraph\n\t\t\t\talign: editParagraph boundingBox center\n\t\t\t\twith: self getWindow center]\n",
          "defaultRule": "defaultRule\n\t^Form over\n"
        },
        "initialize-release": {
          "initialize": "initialize\n\tsuper initialize.\n\tcentered _ false\n"
        },
        "controller access": {
          "defaultControllerClass": "defaultControllerClass\n\t^ParagraphEditor\n",
          "defaultController": "defaultController\n\t^self defaultControllerClass newParagraph: editParagraph\n"
        }
      }
    }
  },
  "Interface-Browser": {
    "BrowserView": {
      "comment": "I am a StandardSystemView that provides initialization methods (messages to myself) to create and schedule the various system browsers:  System Browser, System Category Browser, Class Browser, Message Category Browser, Message Browser.\n",
      "class_name": "BrowserView",
      "superclass": "StandardSystemView",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "openMethodBrowserOn:withController:": "openMethodBrowserOn: aBrowser withController: aController\n\t\"aController may contain changes that haven't already been accepted\"\n\t| topView textView |\n\ttopView _ self model: aBrowser\n\t\t\tlabel: 'Method Browser on ' , aBrowser selectedClass name\n\t\t\tminimumSize: 250@120.\n\ttopView addSelectorView: (0@0 extent: 1@0.15) on: aBrowser readOnly: true.\n\ttextView _ CodeView on: aBrowser aspect: #text change: #acceptText:from:\n\t\t\t\tmenu: #textMenu initialSelection: nil.\n\ttextView controller: aController.\n\ttopView addSubView: textView in: (0@0.15 extent: 1@0.85) borderWidth: 1.\n\ttopView controller open\n",
          "openListBrowserOn:label:initialSelection:": "openListBrowserOn: aCollection label: labelString initialSelection: sel\n\t\"Create and schedule a Method List browser for the methods in aCollection.\n\tIf the collection is empty, print -Nobody- in the System Transcript.\"\n\t| topView aBrowser label |\n\taCollection isEmpty ifTrue: [^ Transcript cr; show: 'Nobody'].\n\taBrowser _ MethodListBrowser new on: aCollection.\n\tlabel _ (labelString isKindOf: LookupKey)\n\t\t\t\tifTrue: [labelString key]\n\t\t\t\tifFalse: [labelString asString].\n\ttopView _ self model: aBrowser label: label minimumSize: 300@100.\n\ttopView\n\t\taddMethodView: (0@0 extent: 1.0@0.25) on: aBrowser readOnly: false;\n\t\taddTextView: (0@0.25 extent: 1@0.75) on: aBrowser initialSelection: sel.\n\ttopView controller open\n",
          "openOn:withController:": "openOn: aBrowser withController: aController\n\t\"aController may contain changes that haven't already been accepted\"\n\t| topView textView |\n\t(topView _ self model: aBrowser label: 'System Browser' minimumSize: 400@250)\n\t\taddCategoryView: (0@0 extent: 0.25@0.4) on: aBrowser readOnly: false;\n\t\taddClassView: (0.25@0 extent: 0.25@0.34) on: aBrowser readOnly: false;\n\t\taddMetaView: (0.25@0.34 extent: 0.25@0.06) on: aBrowser readOnly: false;\n\t\taddProtocolView: (0.5@0 extent: 0.25@0.4) on: aBrowser readOnly: false;\n\t\taddSelectorView: (0.75@0 extent: 0.25@0.4) on: aBrowser readOnly: false.\n\ttextView _ CodeView on: aBrowser aspect: #text change: #acceptText:from:\n\t\t\t\tmenu: #textMenu initialSelection: nil.\n\ttextView controller: aController.\n\ttopView addSubView: textView in: (0@0.4 extent: 1@0.6) borderWidth: 1.\n\ttopView controller open\n",
          "openListBrowserOn:label:": "openListBrowserOn: aCollection label: labelString\n\tself openListBrowserOn: aCollection label: labelString initialSelection: nil\n",
          "openClassBrowserOn:": "openClassBrowserOn: aBrowser\n\t| topView |\n\t(topView _ self model: aBrowser label: 'Class Browser' minimumSize: 400@250)\n\t\taddClassView: (0@0 extent: 0.5@0.1) on: aBrowser readOnly: true;\n\t\taddMetaView: (0.5@0 extent: 0.5@0.1) on: aBrowser readOnly: false;\n\t\taddProtocolView: (0@0.1 extent: 0.5@0.3) on: aBrowser readOnly: false;\n\t\taddSelectorView: (0.5@0.1 extent: 0.5@0.3) on: aBrowser readOnly: false;\n\t\taddTextView: (0@0.4 extent: 1.0@0.6) on: aBrowser initialSelection: nil.\n\ttopView controller open\n",
          "openCategoryBrowserOn:": "openCategoryBrowserOn: aBrowser\n\t| topView |\n\t(topView _ self model: aBrowser label: 'Category Browser' minimumSize: 400@250)\n\t\taddCategoryView: (0@0 extent: 0.3@0.06) on: aBrowser readOnly: true;\n\t\taddClassView: (0@0.06 extent: 0.3@0.28) on: aBrowser readOnly: false;\n\t\taddMetaView: (0@0.34 extent: 0.3@0.06) on: aBrowser readOnly: false;\n\t\taddProtocolView: (0.3@0 extent: 0.3@0.4) on: aBrowser readOnly: false;\n\t\taddSelectorView: (0.6@0 extent: 0.4@0.4) on: aBrowser readOnly: false;\n\t\taddTextView: (0@0.4 extent: 1.0@0.6) on: aBrowser initialSelection: nil.\n\ttopView controller open\n",
          "openProtocolBrowserOn:": "openProtocolBrowserOn: aBrowser\n\t| topView |\n\t(topView _ self model: aBrowser label: 'Protocol Browser on ' , aBrowser selectedClass name\n\t\t\t\t\tminimumSize: 400@200)\n\t\taddProtocolView: (0@0 extent: 1@0.1) on: aBrowser readOnly: true;\n\t\taddSelectorView: (0@0.1 extent: 1@0.3) on: aBrowser readOnly: false;\n\t\taddTextView: (0@0.4 extent: 1.0@0.6) on: aBrowser initialSelection: nil.\n\ttopView controller open\n",
          "openMethodBrowserOn:": "openMethodBrowserOn: aBrowser\n\t| topView |\n\t(topView _ self model: aBrowser label: 'Method Browser on ' , aBrowser selectedClass name\n\t\t\t\t\tminimumSize: 250@120)\n\t\taddSelectorView: (0@0 extent: 1@0.15) on: aBrowser readOnly: true;\n\t\taddTextView: (0@0.15 extent: 1@0.85) on: aBrowser initialSelection: nil.\n\ttopView controller open\n",
          "openOn:": "openOn: anOrganizer\n\t\"BrowserView openOn: SystemOrganization.\"\n\t| topView aBrowser topY bottomY metaY |\n\taBrowser _ Browser new on: anOrganizer.\n\ttopY _ 0.35.\t\t\"change this to re-proportion system browser\"\n\tbottomY _ 1 - topY.\n\tmetaY _ 0.05.\t\t\"change this to re-proportion system browser\"\n\t(topView _ self model: aBrowser label: 'System Browser' minimumSize: 400@250)\n\t\taddCategoryView: (0@0 extent: 0.25@topY) on: aBrowser readOnly: false;\n\t\taddClassView: (0.25@0 extent: 0.25@(topY - metaY)) on: aBrowser readOnly: false;\n\t\taddMetaView: (0.25@(topY - metaY) extent: 0.25@metaY) on: aBrowser readOnly: false;\n\t\taddProtocolView: (0.5@0 extent: 0.25@topY) on: aBrowser readOnly: false;\n\t\taddSelectorView: (0.75@0 extent: 0.25@topY) on: aBrowser readOnly: false;\n\t\taddTextView: (0@topY extent: 1.0@bottomY) on: aBrowser initialSelection: nil.\n\ttopView controller open\n"
        }
      },
      "instance_methods": {
        "subview creation": {
          "addSelectorView:on:readOnly:": "addSelectorView: area on: aBrowser readOnly: RO\n\tself addSubView:\n\t\t(SelectionInListView on: aBrowser printItems: false oneItem: RO\n\t\t\taspect: #selector change: #selector: list: #selectorList\n\t\t\tmenu: #selectorMenu initialSelection: #selector)\n\t\tin: area borderWidth: 1\n",
          "addCategoryView:on:readOnly:": "addCategoryView: area on: aBrowser readOnly: RO\n\tself addSubView:\n\t\t(SelectionInListView on: aBrowser printItems: false oneItem: RO\n\t\t\taspect: #category change: #category: list: #categoryList\n\t\t\tmenu: #categoryMenu initialSelection: #category)\n\t\tin: area borderWidth: 1\n",
          "addMetaView:on:readOnly:": "addMetaView: area on: aBrowser readOnly: ingored\n\t| mid |\n\tmid _ (area left + area right) * 0.5.\n\tself addSubView: (BooleanView on: aBrowser aspect: #meta\n\t\t\tlabel: 'instance' asText change: #meta: value: false)\n\t\tin: (area copy right: mid) borderWidth: 1.\n\tself addSubView: (BooleanView on: aBrowser aspect: #meta\n\t\t\tlabel: 'class' asText change: #meta: value: true)\n\t\tin: (area copy left: mid) borderWidth: 1\n",
          "addProtocolView:on:readOnly:": "addProtocolView: area on: aBrowser readOnly: RO\n\tself addSubView:\n\t\t(SelectionInListView on: aBrowser printItems: false oneItem: RO\n\t\t\taspect: #protocol change: #protocol: list: #protocolList\n\t\t\tmenu: #protocolMenu initialSelection: #protocol)\n\t\tin: area borderWidth: 1\n",
          "addClassView:on:readOnly:": "addClassView: area on: aBrowser readOnly: RO\n\tself addSubView:\n\t\t(SelectionInListView on: aBrowser printItems: false oneItem: RO\n\t\t\taspect: #className change: #className: list: #classList\n\t\t\tmenu: #classMenu initialSelection: #className)\n\t\tin: area borderWidth: 1\n",
          "addTextView:on:initialSelection:": "addTextView: area on: aBrowser initialSelection: sel\n\tself addSubView:\n\t\t\t(CodeView on: aBrowser aspect: #text change: #acceptText:from:\n\t\t\t\tmenu: #textMenu initialSelection: sel)\n\t\tin: area borderWidth: 1\n",
          "addMethodView:on:readOnly:": "addMethodView: area on: aBrowser readOnly: RO\n\tself addSubView:\n\t\t(SelectionInListView on: aBrowser printItems: false oneItem: RO\n\t\t\taspect: #methodName change: #methodName: list: #methodList\n\t\t\tmenu: #methodMenu initialSelection: #methodName)\n\t\tin: area borderWidth: 1\n"
        }
      }
    },
    "MethodListBrowser": {
      "comment": "I represent a list of methods to be browsed.\n",
      "class_name": "MethodListBrowser",
      "superclass": "Browser",
      "instanceVariables": "methodList methodName",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "method functions": {
          "removeMethod": "removeMethod\n\t(super removeMethod) ifTrue:\n\t\t[methodList _ methodList copyWithout: methodName.\n\t\tself changed: #methodName]\n"
        },
        "method list": {
          "methodMenu": "methodMenu\n\tselector == nil ifTrue: [^ nil].\n\t^ super selectorMenu\n",
          "methodName:": "methodName: selection\n\t| aStream aSymbol |\n\tmethodName _ selection.\n\tselection == nil ifTrue: [selector _ nil. ^ self textMode: #unclassified].\n\taStream _ ReadStream on: selection.\n\tclassName _ (aStream upTo: $ ) asSymbol.\n\taSymbol _ (aStream upTo: $ ) asSymbol.\n\t(meta _ (aSymbol == #class) & aStream atEnd not) ifTrue:\n\t\t[aSymbol _ (aStream upTo: $ ) asSymbol].\n\tprotocol _ self selectedClass organization categoryOfElement: aSymbol.\n\tself selector: aSymbol\n",
          "methodName": "methodName\n\t^ methodName\n",
          "methodList": "methodList\n\t^ methodList\n"
        },
        "initialization": {
          "on:": "on: aList\n\tmethodList _ aList\n"
        },
        "doIt/accept/explain": {
          "acceptText:from:": "acceptText: aText from: aController\n\ttextMode == #unclassified ifTrue:\n\t\t[self notify: 'A method must be selected to suggest class and protocol'.\n\t\t^ false].\n\t^ super acceptText: aText from: aController\n"
        }
      }
    },
    "Browser": {
      "comment": "A browser represents a hierarchical query path which identifies a method to be examined.\n\norganization - a SystemOrganizer\ncategory - a selection from all categories in the organization.\nclassName - a selection from all classes in the category.\nmeta - false for viewing normal methods, true for class methods.\nprotocol - a selection from all protocols in the class.\nselector - a selection from all messages in the protocol.\ntextMode - symbol indicating the nature of the currently viewed text.\n",
      "class_name": "Browser",
      "superclass": "Object",
      "instanceVariables": "organization category className meta protocol selector textMode",
      "classInstanceVariables": "",
      "classVariables": "CategoryMenu ClassMenu MessageMenu MethodMoveCategory MethodMoveProtocol ProtocolMenu TextMenu",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "flushMenus": "flushMenus  \"Browser flushMenus.\"\n\t\"Causes all menus to be newly created (so changes appear)\"\n\tMethodMoveProtocol _ 'protocol name'.\n\tCategoryMenu _ nil.\n\tClassMenu _ nil.\n\tMessageMenu _ nil.\n\tProtocolMenu _ nil.\n\tTextMenu _ nil\n"
        },
        "instance creation": {
          "newOnClass:": "newOnClass: aClass\n\tBrowserView openClassBrowserOn: (self new onClass: aClass)\n"
        }
      },
      "instance_methods": {
        "change management": {
          "logProtocolChange:": "logProtocolChange: aString\n\t\"Add aString, which is an executable account of the last protocol change (rename,\n\tremove, selector move) to the changes file.\"\n\t| file |\n\tSourceFiles == nil\n\t\tifFalse:\n\t\t\t[file _ SourceFiles at: 2.\n\t\t\tfile setToEnd; readWriteShorten.\n\t\t\tfile cr; nextChunkPut: aString.\n\t\t\tfile cr; readOnly].\n"
        },
        "category functions": {
          "editCategories": "editCategories\n\tself changeRequest ifFalse: [^self].\n\tself textMode: #categories\n",
          "printOutCategory": "printOutCategory\n\torganization printOutCategory: category\n",
          "fileOutCategory": "fileOutCategory\n\torganization fileOutCategory: category\n",
          "spawnCategory": "spawnCategory\n\tBrowserView openCategoryBrowserOn: self copy\n",
          "removeCategory": "removeCategory\n\t| classes |\n\tself changeRequest ifFalse: [^self].\n\tclasses _ organization superclassOrder: category.\n\tclasses isEmpty ifFalse:\n\t\t[(self confirm: 'Are you certain that you want to\nremove all classes in this category?') ifFalse: [^self].\n\t\tclasses reverseDo: [:cls | cls removeFromSystem]].\n\torganization removeCategory: category.\n\tSmalltalk changes reorganizeSystem.\n\tself newCategoryList: nil\n",
          "renameCategory": "renameCategory\n\t| aString newCategory |\n\tself changeRequest ifFalse: [^self].\n\taString _ self prompt: 'Enter new category name' initially: category.\n\taString isEmpty ifTrue: [^ self].\n\tnewCategory _ aString asSymbol.\n\t(organization renameCategory: category to: newCategory)\n\t\tifTrue:\n\t\t\t[Smalltalk changes reorganizeSystem.\n\t\t\tself newCategoryList: newCategory]\n",
          "updateCategories": "updateCategories\n\tself changeRequest ifFalse: [^self].\n\tself newCategoryList: category\n",
          "addCategory": "addCategory\n\t| aString newCategory |\n\tself changeRequest ifFalse: [^self].\n\taString _ self prompt: 'Enter new category name' initially: 'category name'.\n\taString isEmpty ifTrue: [^ self].\n\tnewCategory _ aString asSymbol.\n\torganization addCategory: newCategory before: category.\n\tSmalltalk changes reorganizeSystem.\n\tself newCategoryList: newCategory\n"
        },
        "class/inst switch": {
          "meta": "meta\n\t^ meta\n",
          "meta:": "meta: aBoolean\n\tself changeRequest ifFalse: [^ self changed: #meta].\n\tmeta _ aBoolean.\n\tself changed: #meta.\n\tself newProtocolList: protocol.\n\tself classMode ifTrue: [self changed: #text]\n"
        },
        "protocol functions": {
          "addProtocol": "addProtocol\n\t| aString newProtocol |\n\tself changeRequest ifFalse: [^self].\n\taString _ self prompt: 'Enter new protocol name' initially: 'protocol name'.\n\taString isEmpty ifTrue: [^ self].\n\tnewProtocol _ aString asSymbol.\n\tself selectedClass organization addCategory: newProtocol before: protocol.\n\tself logProtocolChange: self selectedClass name, ' organization addCategory: ', newProtocol storeString, ' before: ', protocol storeString.\n\tself selectedClass reorganize.\n\tself newProtocolList: newProtocol\n",
          "removeProtocol": "removeProtocol\n\t| selectors |\n\tself changeRequest ifFalse: [^self].\n\tselectors _ self selectedClass organization listAtCategoryNamed: protocol.\n\tselectors isEmpty ifFalse:\n\t\t[(self confirm: 'Are you certain that you want to\nremove all methods in this protocol?') ifFalse: [^self].\n\t\tselectors do: [:sel | self selectedClass removeSelector: sel]].\n\tself selectedClass organization removeCategory: protocol.\n\tself logProtocolChange: self selectedClass name, ' organization removeCategory: ', protocol storeString.\n\tself selectedClass reorganize.\n\tself newProtocolList: nil\n",
          "renameProtocol": "renameProtocol\n\t| aString newProtocol |\n\tself changeRequest ifFalse: [^self].\n\taString _ self prompt: 'Enter new protocol name' initially: protocol.\n\taString isEmpty ifTrue: [^ self].\n\tnewProtocol _ aString asSymbol.\n\t(self selectedClass organization renameCategory: protocol to: newProtocol)\n\t\tifTrue:\n\t\t\t[self logProtocolChange: self selectedClass name, ' organization renameCategory: ', protocol storeString, ' to: ', newProtocol storeString.\nself selectedClass reorganize.\n\t\t\tself newProtocolList: newProtocol]\n",
          "spawnProtocol": "spawnProtocol\n\tBrowserView openProtocolBrowserOn: self copy\n",
          "fileOutProtocol": "fileOutProtocol\n\tself selectedClass fileOutCategory: protocol\n",
          "printOutProtocol": "printOutProtocol\n\tself selectedClass printOutCategory: protocol\n"
        },
        "class functions": {
          "spawnHierarchy": "spawnHierarchy\n\tBrowserView openCategoryBrowserOn: self copy browseHierarchy\n",
          "editClass": "editClass\n\tself changeRequest ifFalse: [^self].\n\tself textMode: #classDefinition.\n\tself newProtocolList: nil\n",
          "editProtocols": "editProtocols\n\tself changeRequest ifFalse: [^self].\n\tself textMode: #protocols.\n\tself newProtocolList: nil\n",
          "editComment": "editComment\n\tself changeRequest ifFalse: [^self].\n\tself textMode: #comment.\n\tself newProtocolList: nil\n",
          "fileOutClass": "fileOutClass\n\tself nonMetaClass fileOut\n",
          "nonMetaClass": "nonMetaClass\n\t^ meta\n\t\tifTrue: [self selectedClass soleInstance]\n\t\tifFalse: [self selectedClass]\n",
          "renameClass": "renameClass\n\t| aString newName cleanString |\n\tself changeRequest ifFalse: [^self].\n\taString _ self prompt: 'Enter new ClassName' initially: self selectedClass name.\n\taString isEmpty ifTrue: [^self].\n\tcleanString _ aString select: [:char | char isAlphaNumeric].\n\tcleanString = aString\n\t\tifFalse: [aString _ cleanString.\n\t\t\t\t(self confirm: 'Invalid characters in class name.  Should I use ', aString, '?')\n\t\t\t\t\tifFalse: [^self]].\n\taString first isUppercase\n\t\tifFalse: [aString at: 1 put: (aString at: 1) asUppercase.\n\t\t\t\t(self confirm: 'Class names must be capitalized.  Should I use ', aString, '?')\n\t\t\t\t\tifFalse: [^self]].\n\tnewName _ aString asSymbol.\n\taString = self selectedClass name\n\t\tifFalse:\n\t\t\t[self selectedClass rename: newName.\n\t\tself newClassList: newName.\n\t\tTranscript cr; show: 'Searching for references to this class...'.\n\t\tself browseClassReferences]\n",
          "showHierarchy": "showHierarchy\n\tself changeRequest ifFalse: [^self].\n\tself textMode: #hierarchy.\n\tself newProtocolList: nil\n",
          "spawnClass": "spawnClass\n\tBrowserView openClassBrowserOn: self copy\n",
          "browseClassVariables": "browseClassVariables\n\t\"Show a menu of all class variables of the currently selected class\n\tand its superclasses.  Browse all methods which refer to the variable selected.\"\n\t| association |\n\tassociation _ self selectedClass\n\t\tshowVariableMenu: [:class | class classPool associations asSortedCollection]\n\t\tcollect: [:association | association key].\n\tassociation notNil ifTrue:\n\t\t[BrowserView\n\t\t\topenListBrowserOn: (self selectedClass allCallsOn: association)\n\t\t\tlabel: 'Users of ' , association key\n\t\t\tinitialSelection: association key]\n",
          "removeClass": "removeClass\n\t| class |\n\tself changeRequest ifFalse: [^self].\n\tclass _ self nonMetaClass.\n\t(self confirm: 'Are you certain that you\nwant to remove the class ', class name, '?')\n\t\tifTrue:\n\t\t[class subclasses size > 0\n\t\t\tifTrue: [self notify: class name , ' has subclasses'].\n\t\tclass removeFromSystem.\n\t\tself newClassList: nil]\n",
          "browseClassReferences": "browseClassReferences\n\tSmalltalk browseAllCallsOn: (Smalltalk associationAt: className)\n",
          "browseHierarchy": "browseHierarchy\n\t\"I am a copy; put me in the right state to browse a hierarchy\"\n\tcategory _ '**Hierarchy**'.\n\tself meta: false\n",
          "promptClass": "promptClass\n\tself newClassList: nil.\n\tself textMode: #classDefinition\n",
          "classMode": "classMode\n\t^#(classDefinition hierarchy comment protocols) includes: textMode\n",
          "browseFieldReferences": "browseFieldReferences\n\t\"Show a menu of all instance variables of the currently selected class\n\tand its superclasses.  Browse all methods which refer to the variable selected.\"\n\t| name |\n\tname _ self selectedClass showVariableMenu: [:class | class instVarNames]\n\t\t\t\tcollect: [:name | name].\n\tname notNil ifTrue:\n\t\t[BrowserView\n\t\t\topenListBrowserOn: (self selectedClass allAccessesTo: name)\n\t\t\tlabel: name\n\t\t\tinitialSelection: name]\n",
          "printOutClass": "printOutClass\n\tself nonMetaClass printOut\n",
          "acceptClass:from:": "acceptClass: aText from: aController\n\t| oldClass class |\n\toldClass _ className == nil ifTrue: [Object] ifFalse: [self selectedClass].\n\tclass _ oldClass subclassDefinerClass\n\t\t\t\tevaluate: aText string\n\t\t\t\tnotifying: aController\n\t\t\t\tlogged: true.\n\t(class isKindOf: Behavior)\n\t\tifTrue: [self newClassList: class name.  ^true]\n\t\tifFalse: [^false]\n"
        },
        "class list": {
          "classList": "classList\n\tcategory == nil ifTrue: [^ nil].\n\tcategory = '**Hierarchy**' ifTrue:\n\t\t[^ (self selectedClass withAllSuperclasses reverse , self selectedClass allSubclasses)\n\t\t\tcollect: [:cls | cls name]].\n\t^ organization listAtCategoryNamed: category\n",
          "selectedClass": "selectedClass\n\tclassName == nil ifTrue: [^ nil].\n\tmeta\n\t\tifTrue: [^ (Smalltalk at: className) class]\n\t\tifFalse: [^ Smalltalk at: className]\n",
          "className:": "className: selection\n\tclassName _ selection.\n\tself newProtocolList: protocol.\n\tselection isNil & category notNil\n\t\tifTrue: [self textMode: #classDefinition]\n\t\tifFalse: [self classMode ifTrue: [self changed: #text]]\n",
          "newClassList:": "newClassList: initialSelection\n\tclassName _ initialSelection.\n\tself changed: #className\n",
          "classMenu": "classMenu\n\t\"Browser flushMenus\"\n\tclassName == nil ifTrue: [^nil].\n\tClassMenu == nil ifTrue:\n\t\t[ClassMenu _ ActionMenu\n\t\t\tlabels: 'file out\\print out\\spawn\\spawn hierarchy\nhierarchy\\definition\\comment\\protocols\ninst var refs\\class var refs\\class refs\nrename\\remove' withCRs\n\t\t\tlines: #(4 8 11)\n\t\t\tselectors: #(fileOutClass printOutClass spawnClass spawnHierarchy\nshowHierarchy editClass editComment editProtocols\nbrowseFieldReferences browseClassVariables browseClassReferences\n renameClass removeClass)].\n\t^ ClassMenu\n",
          "className": "className\n\t^ className\n"
        },
        "protocol list": {
          "protocol:": "protocol: selection\n\tprotocol _ selection.\n\tself classMode ifTrue: [^ self newSelectorList: nil].\n\tselection isNil & className notNil ifTrue: [self textMode: #classDefinition].\n\tself newSelectorList: selector\n",
          "protocolList": "protocolList\n\tclassName == nil ifTrue: [^ nil].\n\t^ self selectedClass organization categories\n",
          "newProtocolList:": "newProtocolList: initialSelection\n\tprotocol _ initialSelection.\n\tself changed: #protocol\n",
          "protocol": "protocol\n\t^ protocol\n",
          "protocolMenu": "protocolMenu\n\t\"Browser flushMenus\"\n\tprotocol == nil ifTrue:\n\t\t[^ ActionMenu labels: 'add protocol' selectors: #(addProtocol)].\n\tProtocolMenu == nil ifTrue:\n\t\t[ProtocolMenu _ ActionMenu\n\t\t\tlabels: 'file out\\print out\\spawn\\add protocol\\rename\\remove' withCRs\n\t\t\tlines: #(3)\n\t\t\tselectors: #(fileOutProtocol printOutProtocol spawnProtocol addProtocol renameProtocol removeProtocol)].\n\t^ ProtocolMenu\n"
        },
        "category list": {
          "category:": "category: selection\n\tcategory _ selection.\n\tselection isNil ifTrue: [self textMode: nil].\n\tself newClassList: className\n",
          "categoryList": "categoryList\n\t^ organization categories\n",
          "category": "category\n\t^ category\n",
          "newCategoryList:": "newCategoryList: initialSelection\n\tcategory _ initialSelection.\n\tself changed: #category\n",
          "categoryMenu": "categoryMenu\n\t\"Browser flushMenus\"\n\tcategory == nil ifTrue:\n\t\t[^ ActionMenu labels: 'add category\\update\\edit all' withCRs\n\t\t\t\t\tlines: #(1)\n\t\t\t\t\tselectors: #(addCategory updateCategories editCategories )].\n\tCategoryMenu == nil ifTrue:\n\t\t[CategoryMenu _ ActionMenu\n\t\t\tlabels: 'file out\\print out\\spawn\\add category\\rename\\remove\\update\\edit all' withCRs\n\t\t\tlines: #(3 6)\n\t\t\tselectors: #(fileOutCategory printOutCategory spawnCategory addCategory renameCategory removeCategory updateCategories editCategories)].\n\t^ CategoryMenu\n"
        },
        "initialization": {
          "on:": "on: anOrganizer\n\torganization _ anOrganizer.\n\tmeta _ false\n",
          "onClass:": "onClass: aClass\n\torganization _ SystemOrganization.\n\tclassName _ aClass isMeta\n\t\t\tifTrue: [aClass soleInstance name]\n\t\t\tifFalse: [aClass name].\n\tmeta _ aClass isMeta\n"
        },
        "doIt/accept/explain": {
          "doItContext": "doItContext\n\t^ nil\n",
          "explainSpecial:": "explainSpecial: string\n\t\"Answer with a string explaining the code pane selection if it is\n\tdisplaying one of the special edit functions.\"\n\n\t| classes whole lits reply |\n\t(textMode == #classDefinition)\n\t\tifTrue:\n\t\t\t[\"Selector parts in class definition\"\n\t\t\tstring last == $: ifFalse: [^nil].\n\t\t\tlits _ Array with: #subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:.\n\t\t\t(whole _ lits detect: [:each | (each keywords\n\t\t\t\t\tdetect: [:frag | frag = string] ifNone: []) ~~ nil]\n\t\t\t\t\t\tifNone: []) ~~ nil\n\t\t\t\tifTrue: [reply _ '\"' , string , ' is one part of the message selector ' , whole , '.']\n\t\t\t\tifFalse: [^nil].\n\t\t\tclasses _ Smalltalk allClassesImplementing: whole.\n\t\t\tclasses _ 'these classes ' , classes printString.\n\t\t\t^reply , '  It is defined in ' , classes , '.\"\nSmalltalk browseAllImplementorsOf: #' , whole].\n\n\ttextMode == #hierarchy\n\t\tifTrue:\n\t\t\t[\"Instance variables in subclasses\"\n\t\t\tclasses _ self selectedClass allSubclasses.\n\t\t\tclasses _ classes detect: [:each | (each instVarNames\n\t\t\t\t\t\tdetect: [:name | name = string] ifNone: []) ~~ nil]\n\t\t\t\t\tifNone: [^nil].\n\t\t\tclasses _ classes printString.\n\t\t\t^'\"is an instance variable in class ' , classes , '.\"\n' , classes , ' browseAllAccessesTo: ''' , string , '''.'].\n\t^nil\n",
          "doItReceiver": "doItReceiver\n\t^ nil\n",
          "acceptText:from:": "acceptText: aText from: aController\n\ttextMode == #classDefinition ifTrue:\n\t\t[^ self acceptClass: aText from: aController].\n\ttextMode == #methodDefinition ifTrue:\n\t\t[^ self acceptMethod: aText from: aController].\n\ttextMode == #categories ifTrue:\n\t\t[organization changeFromString: aText string.\n\t\tself newCategoryList: category.\n\t\t^true].\n\ttextMode == #protocols ifTrue:\n\t\t[self selectedClass organization changeFromString: aText string.\n\t\tself selectedClass reorganize.\n\t\tself selectedClass logOrganizationChange.\n\t\tself textMode: #protocol; newProtocolList: nil.\n\t\t^ true].\n\ttextMode == #comment ifTrue:\n\t\t[self selectedClass comment: aText string.\n\t\tself textMode: #comment; newProtocolList: nil.\n\t\t^ true].\n\ttextMode == #hierarchy ifTrue:\n\t\t[aController flash].\n\t^ false\n"
        },
        "selector functions": {
          "browseSenders": "browseSenders\n\tSmalltalk browseAllCallsOn: selector\n",
          "spawnMethod": "spawnMethod\n\tBrowserView openMethodBrowserOn: self copy\n",
          "spawnEdits:from:": "spawnEdits: aText from: aController\n\t| newController |\n\tnewController _ aController copy.  \"Copy gets the changes\"\n\taController cancel; controlTerminate.   \"Cancel changes in spawning browser\"\n\tselector == nil  \"spawn full browser if not in a specific method\"\n\t\tifTrue: [BrowserView openOn: self copy withController: newController]\n\t\tifFalse: [BrowserView openMethodBrowserOn: self copy withController: newController]\n",
          "printOutMessage": "printOutMessage\n\tself selectedClass printOutMessage: selector\n",
          "browseImplementors": "browseImplementors\n\tSmalltalk browseAllImplementorsOf: selector\n",
          "browseMessages": "browseMessages\n\tSmalltalk showMenuThenBrowse:\n\t\t(self selectedClass compiledMethodAt: selector)\n\t\t\tmessages asSortedCollection\n",
          "removeMethod": "removeMethod\n\t(self changeRequest and: [self confirm: 'Are you certain that you\nwant to remove this method?'])\n\t\tifTrue:\n\t\t\t[self selectedClass removeSelector: selector.\n\t\t\tself newSelectorList: nil.\n\t\t\t^ true].\n\t^ false\n",
          "acceptMethod:from:": "acceptMethod: aText from: aController\n\t| newSelector |\n\tnewSelector _ self selectedClass\n\t\t\t\tcompile: aText\n\t\t\t\tclassified: protocol\n\t\t\t\tnotifying: aController.\n\tnewSelector == nil ifTrue: [^false].\n\tnewSelector == selector\n\t\tifFalse: [self newSelectorList: newSelector].\n\t^true\n",
          "fileOutMessage": "fileOutMessage\n\tself selectedClass fileOutMessage: selector\n",
          "moveMethod": "moveMethod\n\t| newProtocol classPart destClass protStart moved destClassName |\n\tself changeRequest ifFalse: [^self].\n\tnewProtocol _ self prompt: 'Type destination protocol\n(Class>protocol will copy)' initially: MethodMoveProtocol.\n\tnewProtocol isEmpty ifTrue: [^self].\n\tMethodMoveProtocol _ newProtocol.\n\tmoved _ false.\n\t(newProtocol includes: $>)\n\t\tifTrue:\n\t\t\t[\"copy to another class\"\n\t\t\tclassPart _ newProtocol copyUpTo: $>.\n\t\t\tdestClassName _ classPart copyUpTo: Character space.\n\t\t\tdestClass _ Smalltalk at: destClassName asSymbol ifAbsent: [nil].\n\t\t\t(destClass isKindOf: ClassDescription)\n\t\t\t\tifFalse: [(Display flash: Display boundingBox). ^nil].\n\t\t\tclassPart size = destClassName size\n\t\t\t\tifFalse:\n\t\t\t\t\t[(classPart size-destClassName size = 6\n\t\t\t\t\t\tand: [(classPart copyFrom: classPart size - 5 to: classPart size) = ' class'])\n\t\t\t\t\t\t\t\tifTrue: [destClass _ destClass class]\n\t\t\t\t\t\t\t\tifFalse: [(Display flash: Display boundingBox). ^nil]].\n\t\t\tprotStart _ classPart size + 2.\n\t\t\t[(newProtocol at: protStart) = $ ]\n\t\t\t\twhileTrue: [protStart _ protStart + 1].\n\t\t\tnewProtocol _ (newProtocol copyFrom: protStart to: newProtocol size) asSymbol.\n\t\t\tdestClass == self selectedClass\n\t\t\t\tifFalse:\n\t\t\t\t\t[moved _ true.\n\t\t\t\t\tdestClass compile: self text classified: newProtocol notifying: nil]]\n\t\tifFalse:\n\t\t\t[\"move within this class\"\n\t\t\tdestClass _ self selectedClass.\n\t\t\tnewProtocol _ newProtocol asSymbol].\n\tmoved\n\t\tifFalse:\n\t\t\t[(destClass organization categories includes: newProtocol)\n\t\t\t\tifFalse:\n\t\t\t\t\t[destClass organization addCategory: newProtocol.\n\t\t\t\t\tself newProtocolList: protocol].\n\t\t\tdestClass organization classify: selector under: newProtocol.\n\t\t\tself logProtocolChange: destClass name , ' organization classify: '\n\t\t\t\t\t\t\t\t, selector storeString , ' under: ' , newProtocol storeString.\n\t\t\tdestClass reorganize].\n\tself newSelectorList: selector\n"
        },
        "selector list": {
          "selector:": "selector: selection\n\tselector _ selection.\n\t(selection == nil and: [protocol == nil]) ifTrue: [^ self].\n\tself textMode: #methodDefinition\n",
          "selectorList": "selectorList\n\tprotocol == nil ifTrue: [^ nil].\n\t^ self selectedClass organization listAtCategoryNamed: protocol\n",
          "newSelectorList:": "newSelectorList: initialSelection\n\tselector _ initialSelection.\n\tself changed: #selector\n",
          "selector": "selector\n\t^ selector\n",
          "selectorMenu": "selectorMenu\n\t\"Browser flushMenus\"\n\tselector == nil ifTrue: [^ nil].\n\tMessageMenu == nil ifTrue:\n\t\t[MessageMenu _ ActionMenu\n\t\t\tlabels: 'file out\\print out\\spawn\\senders\\implementors\\messages\\move\\remove' withCRs\n\t\t\tlines: #(3 6)\n\t\t\tselectors: #(fileOutMessage printOutMessage spawnMethod browseSenders browseImplementors browseMessages moveMethod removeMethod)].\n\t^ MessageMenu\n"
        },
        "text": {
          "text": "text\n\t| text |\n\ttextMode == #classDefinition ifTrue:\n\t\t[className == nil\n\t\t\tifTrue: [^ (Class template: category) asText]\n\t\t\tifFalse: [^ self selectedClass definition asText]].\n\ttextMode == #methodDefinition ifTrue:\n\t\t[selector == nil\n\t\t\tifTrue: [^ self selectedClass sourceCodeTemplate asText]\n\t\t\tifFalse: [^ (self selectedClass sourceCodeAt: selector) asText\n\t\t\t\t\t\tmakeSelectorBoldIn: self selectedClass]].\n\ttextMode == #category ifTrue:\n\t\t[^ 'category to add' asText].\n\ttextMode == #categories ifTrue:\n\t\t[^ organization printString asText].\n\ttextMode == #protocol ifTrue:\n\t\t[^ 'protocol to add' asText].\n\ttextMode == #protocols ifTrue:\n\t\t[^ self selectedClass organization printString asText].\n\ttextMode == #comment ifTrue:\n\t\t[text _ self selectedClass comment asText.\n\t\ttext isEmpty ifFalse: [^ text].\n\t\t^ 'This class has no comment' asText].\n\ttextMode == #hierarchy ifTrue:\n\t\t[^ self selectedClass printHierarchy asText].\n\t^ Text new\n",
          "prompt:initially:": "prompt: promptString initially: initialString\n\t| aString |\n\tFillInTheBlank\n\t\trequest: promptString , '\nthen accept or CR'\n\t\tdisplayAt: Sensor cursorPoint centered: false action: [:aString]\n\t\tinitialAnswer: initialString.\n\t^ aString\n",
          "textMode:": "textMode: aSymbol\n\ttextMode _ aSymbol.\n\tself changed: #text\n",
          "textMenu": "textMenu\n\t\"Browser flushMenus\"\n\tTextMenu == nil ifTrue:\n\t\t[TextMenu _ ActionMenu\n\t\t\tlabels: 'again\\undo\\copy\\cut\\paste\\do it\\print it\\accept\\cancel\\format\\spawn\\explain' withCRs\n\t\t\tlines: #(2 5 7 9)\n\t\t\tselectors: #(again undo copySelection cut paste doIt printIt accept cancel format spawnEdits:from: explain)].\n\t^ TextMenu\n"
        }
      }
    }
  },
  "Interface-Changes": {
    "ChangeListView": {
      "comment": "I am a list view of various system changes.\n",
      "class_name": "ChangeListView",
      "superclass": "ListView",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "open": "open\n\t\"Open a view for changes files.  Starts as an empty template.\"\n\n\tself openOn: ChangeList new\n\n\t\"ChangeListView open\"\n",
          "recover": "recover\n\t\"Open a view of the current changes file since the last snapshot.\"\n\n\tself openOn: (ChangeList new recoverFile: (SourceFiles at: 2))\n\n\t\"ChangeListView recover\"\n",
          "openOn:": "openOn: aChangeList\n\t\"schedule a change browser\"\n\t| topView aChangeListView aChangeView alignPoint |\n\n\ttopView _ StandardSystemView new model: aChangeList.\n\ttopView label: aChangeList listName.\n\ttopView minimumSize: 180@180.\n\n\taChangeListView _ self new.\n\taChangeListView model: aChangeList.\n\taChangeListView window: (0@0 extent: 180@120).\n\taChangeListView insideColor: Form white.\n\taChangeListView borderWidthLeft: 2 right: 2 top: 2 bottom: 0.\n\ttopView addSubView: aChangeListView.\n\n\talignPoint _ self\n\t\topenSwitches:\n\t\t\t#(\t('show file' showingField: (1) switchField:perform: (1 fileName) 90)\n\t\t\t\t('show category' showingField: (2) switchField:perform: (2 category) 90)\n\t\t\t)\n\t\ttopView: topView\n\t\tat: aChangeListView viewport bottomLeft\n\t\tmodel: aChangeList.\n\talignPoint _ self\n\t\topenSwitches:\n\t\t\t#(\t(file hasFilter: (1) switchFilter:perform: (1 file) 30)\n\t\t\t\t(type hasFilter: (2) switchFilter:perform: (2 class) 30)\n\t\t\t\t(class hasFilter: (3) switchFilter:perform: (3 className) 30)\n\t\t\t\t(category hasFilter: (4) switchFilter:perform: (4 category) 30)\n\t\t\t\t(selector hasFilter: (5) switchFilter:perform: (5 selector) 30)\n\t\t\t\t(same hasFilter: (6) switchFilter:perform: (6 values) 30)\n\t\t\t)\n\t\ttopView: topView\n\t\tat: alignPoint\n\t\tmodel: aChangeList.\n\n\taChangeView _ StringHolderView new.\n\taChangeView model: aChangeList.\n\taChangeView controller: ChangeController new.\n\taChangeView window: (0@0 extent: 180@240).\n\taChangeView insideColor: Form white.\n\taChangeView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.\n\ttopView\n\t\taddSubView: aChangeView\n\t\talign: aChangeView viewport topLeft\n\t\twith: alignPoint.\n\n\ttopView controller open.\n"
        },
        "private": {
          "openSwitches:topView:at:model:": "openSwitches: parameters topView: topView at: initialPoint model: aChangeList\n\t\"Define a related group of switches\"\n\t| aSwitchView alignPoint leftBorder |\n\n\talignPoint _ initialPoint.\n\tleftBorder _ 2.\n\n\tparameters do:\n\t\t[:args |\n\t\t\t[:label :viewSelector :viewArguments :controllerSelector :controllerArguments :width |\n\t\t\taSwitchView _ SwitchView new.\n\t\t\taSwitchView model: aChangeList.\n\t\t\taSwitchView controller: LockedSwitchController new.\n\t\t\taSwitchView borderWidthLeft: leftBorder right: 2 top: 2 bottom: 0.\n\t\t\taSwitchView selector: viewSelector.\n\t\t\taSwitchView arguments: viewArguments.\n\t\t\taSwitchView controller selector: controllerSelector.\n\t\t\taSwitchView controller arguments: controllerArguments.\n\t\t\taSwitchView window: (0 @ 0 extent: width @ 25).\n\t\t\taSwitchView label: label asParagraph.\n\t\t\ttopView addSubView: aSwitchView\n\t\t\t\talign: aSwitchView viewport topLeft\n\t\t\t\twith: alignPoint.\n\t\t\talignPoint _ aSwitchView viewport topRight.\n\t\t\tleftBorder _ 0.\n\t\t\t] valueWithArguments: args].\n\n\t^initialPoint x @ aSwitchView viewport bottom\n"
        },
        "examples": {
          "example": "example\n\t\"recover is an example, access other change files through the menu commands of a ChangeListView,\n\tor choose a recovery file to replace the following expression form\n\n\tChangeListView openOn: (ChangeList new recoverFile: (Disk file: 'filename'))\n\n\t\"\n"
        }
      },
      "instance_methods": {
        "selecting": {
          "deselect": "deselect\n\tsuper deselect.\n\tself reverseRemoved\n",
          "selectionBoxOffset:": "selectionBoxOffset: listIndex\n\t\"Answer an integer that determines the y position for the display box of a\n\tparticular selection.\"\n\t^(listIndex - 1 + self minimumSelection - 1) * list lineGrid\n",
          "reverseRemoved": "reverseRemoved\n\t| box line |\n\tself selectionInterval do:\n\t\t[:index |\n\t\t(model hasRemoved: index) ifTrue:\n\t\t\t[box _ self selectionBox: index.\n\t\t\tline _ Rectangle origin: box leftCenter - (0@1) extent: box width @ 2.\n\t\t\tDisplay reverse: (line intersect: self clippingBox)]]\n",
          "displaySelectionBox": "displaySelectionBox\n\tself reverseRemoved.\n\tsuper displaySelectionBox\n",
          "selectionInterval": "selectionInterval\n\t\"Answer the currently visible range of selection indices.\"\n\n\t^((self selectionIndex: self insetDisplayBox top) max: 1) to:\n\t ((self selectionIndex: self insetDisplayBox bottom) min: model listSize)\n",
          "selectionBox:": "selectionBox: listIndex\n\t\"Answer the rectangle in which a particular selection is displayed.\"\n\n\t^(self insetDisplayBox left @\n\t\t\t(list compositionRectangle top + (self selectionBoxOffset: listIndex))\n\t\textent: self insetDisplayBox width @ list lineGrid)\n\t\tinsetBy: (Rectangle left: 1 right: 1 top: 1 bottom: 0)\n",
          "selectionIndex:": "selectionIndex: yPosition\n\t\"Answer the selection index corresponding to a particular Y coordinate.\"\n\n\t^(yPosition - list compositionRectangle top) // list lineGrid - self minimumSelection + 2\n"
        },
        "model access": {
          "model:": "model: aChangeList\n\tsuper model: aChangeList.\n\tself list: model list.\n\tselection _ model listIndex.\n"
        },
        "initialize-release": {
          "release": "release\n\tmodel release.\n\tsuper release\n"
        },
        "controller access": {
          "defaultControllerClass": "defaultControllerClass\n\t^ChangeListController\n"
        }
      }
    },
    "ChangeController": {
      "comment": "I am the text view controller for a change browser.\n",
      "class_name": "ChangeController",
      "superclass": "StringHolderController",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "menu messages": {
          "accept": "accept\n\tmodel isUnlocked ifTrue: [^view flash].\n\tself controlTerminate.\n\t\"Submit the new contents to the model for validation before accepting.\"\n\t(model contents: paragraph string notifying: self) ifTrue: [super accept].\n\tself controlInitialize\n"
        }
      }
    },
    "ChangeList": {
      "comment": "I know how to scan a changes file and produce Change objects from it.  I also function as a model for a ListView.\n\nInstance variables:\n\tlistName <String> \"label for browser, the set of files that I have read\"\n\tchanges <OrderedCollection of: Change> \"my underlying collection of changes\"\n\tselectionIndex <Integer> \"currently selected change, or 0 if none\"\n\tcurrentChange <String> \"text of current selection\"\n\tlist <OrderedCollection of: Change> \"filtered collection of changes\"\n\tfilter <BlockContext> \"filter predicate\"\n\tremoved <Set> \"removed changes\"\n\tfilterList <Array of: Symbol> \"individual filters, or nil\"\n\tfilterKey <Change> \"the change supplying the key value(s) for the filter(s)\"\n\tchangeDict <Dictionary from: Symbol to: (OrderedCollection of: Change)> \"cross-index for conflict detection\"\n\tdoItDict <Dictionary from: String to: (OrderedCollection of: Change)> \"cross-index for conflict detection\"\n\tfieldList <Array of: Symbol> \"individual field options, or nil\"\n",
      "class_name": "ChangeList",
      "superclass": "StringHolder",
      "instanceVariables": "listName changes selectionIndex list filter removed filterList filterKey changeDict doItDict checkSystem fieldList",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "checking-Change": {
          "equalWithoutComments:and:": "equalWithoutComments: text1 and: text2\n\t| stream1 stream2 t |\n\tstream1 _ ReadStream on: text1.\n\tstream2 _ ReadStream on: text2.\n\t[(t _ self nextNonComment: stream1) = (self nextNonComment: stream2)]\n\t\twhileTrue:\n\t\t\t[t == nil ifTrue: [^true]].\n\t^false\n",
          "changesAt:": "changesAt: changeName\n\t^changeDict at: changeName ifAbsent: [#()]\n",
          "addDoIt:": "addDoIt: aChange\n\t| fileName |\n\tfileName _ aChange fileName.\n\t(doItDict at: fileName ifAbsent: [doItDict at: fileName put: OrderedCollection new])\n\t\tadd: aChange\n",
          "changesAt:add:": "changesAt: changeName add: aChange\n\t(changeDict at: changeName ifAbsent: [changeDict at: changeName put: OrderedCollection new])\n\t\tadd: aChange\n",
          "checkSystem": "checkSystem\n\t^checkSystem\n"
        },
        "selecting": {
          "toggleListIndex:": "toggleListIndex: anInteger\n\tselectionIndex = anInteger\n\t\tifTrue:\n\t\t\t[self deselect]\n\t\tifFalse:\n\t\t\t[selectionIndex _ anInteger.\n\t\t\tcontents _ self selection].\n\tself changed: #listIndex\n",
          "contents:": "contents: aString\n\t\"ignore\"\n",
          "deselect": "deselect\n\tselectionIndex _ 0.\n\tcontents _ ''\n",
          "selection": "selection\n\tselectionIndex > 0 ifTrue: [^(list at: selectionIndex) text]\n",
          "listIndex": "listIndex\n\t^selectionIndex\n"
        },
        "fileIn/Out": {
          "doThis": "doThis\n\tselectionIndex > 0 ifTrue: [(list at: selectionIndex) fileIn]\n",
          "fileOutOn:": "fileOutOn: aFile\n\t| previous current |\n\tlist do:\n\t\t[:next |\n\t\t(removed includes: next) ifFalse:\n\t\t\t[current == nil\n\t\t\t\tifFalse: [current fileOutOn: aFile previous: previous next: next].\n\t\t\tprevious _ current.\n\t\t\tcurrent _ next]].\n\tcurrent == nil ifFalse:\n\t\t[current fileOutOn: aFile previous: previous next: nil]\n",
          "doThis:": "doThis: listIndex\n\t(list at: listIndex) fileIn\n"
        },
        "lock access": {
          "lock": "lock\n\t\"ignore\"\n",
          "isUnlocked": "isUnlocked\n\t^true\n",
          "unlock": "unlock\n\t\"ignore\"\n"
        },
        "accessing": {
          "listSize": "listSize\n\t^list size\n",
          "contents:notifying:": "contents: newText notifying: requestor\n\t| oldChange newChange |\n\tselectionIndex = 0 ifTrue: [^false].\n\toldChange _ list at: selectionIndex.\n\tnewChange _ oldChange accept: newText notifying: requestor.\n\tnewChange isNil ifTrue: [^false].\n\tlist at: selectionIndex put: newChange.\n\tchanges at: (changes indexOf: oldChange) put: newChange.\n\tself contents: newText.\n\tself changed: #list\n",
          "filterCopy": "filterCopy\n\t^self class new listName: '(', self listName, ')' changes: list removed: (list select: [:c | removed includes: c])\n",
          "hasRemoved:": "hasRemoved: index\n\t^index > 0 and: [index <= list size and: [removed includes: (list at: index)]]\n",
          "listName": "listName\n\tlistName size = 0\n\t\tifTrue: [^'Changes']\n\t\tifFalse: [^listName]\n",
          "list": "list\n\t| name |\n\t^list collect:\n\t\t[:c |\n\t\tname _ nil.\n\t\tfieldList do:\n\t\t\t[:f |\n\t\t\tf == nil ifFalse:\n\t\t\t\t[f _ c perform: f.\n\t\t\t\tf == nil ifFalse:\n\t\t\t\t\t[name == nil ifTrue: [name _ WriteStream on: (String new: 50)].\n\t\t\t\t\tname nextPut: $(; nextPutAll: f; nextPutAll: ') ']]].\n\t\tname == nil ifTrue: [c name] ifFalse: [name nextPutAll: c name.  name contents]]\n"
        },
        "private": {
          "listName:changes:removed:": "listName: aString changes: aChangeCollection removed: aSet\n\tlistName _ aString.\n\tchanges addAll: aChangeCollection.\n\tlist addAll: aChangeCollection.\n\tremoved addAll: aSet\n",
          "updateSelection:": "updateSelection: newIndex\n\tself deselect.\n\tself changed: #list.\n\tnewIndex > 0 ifTrue:\n\t\t[self toggleListIndex: newIndex]\n",
          "addFilter:": "addFilter: aSymbol\n\t| value oldFilter |\n\tvalue _ filterKey perform: aSymbol.\n\tfilter isNil\n\t\tifTrue: [filter _ [:change | (change perform: aSymbol) = value]]\n\t\tifFalse:\n\t\t\t[oldFilter _ filter.\n\t\t\tfilter _ [:change | (oldFilter value: change) and: [(change perform: aSymbol) = value]]]\n",
          "updateList": "updateList\n\t| oldChange newIndex |\n\tselectionIndex > 0 ifTrue: [oldChange _ list at: selectionIndex].\n\tfilter _ nil.\n\tfilterList do: [:aSymbol | aSymbol notNil ifTrue: [self addFilter: aSymbol]].\n\tfilter isNil ifTrue: [filter _ [:change | true]].\n\tlist _ changes select: [:change | filter value: change].\n\tnewIndex _\n\t\toldChange == nil\n\t\t\tifTrue: [0]\n\t\t\tifFalse: [list indexOf: oldChange].\n\tself updateSelection: newIndex\n",
          "findLast:in:": "findLast: aString in: aStream\n\t\"Return the position in the stream of the end of the last occurrence of aString (presumably a snapshot message)\"\n\t| firstChar endPosition position count index lastEnd |\n\tfirstChar _ aString first.\n\taStream setToEnd.\n\tposition _ aStream position.\n\t[endPosition _ position.\n\tlastEnd == nil and: [(position _ endPosition - 5000 max: 0) < endPosition]]\n\t\twhileTrue:\n\t\t\t[aStream position: position.\n\t\t\tcount _ endPosition - position.\n\t\t\t[count > 0]\n\t\t\t\twhileTrue:\n\t\t\t\t\t[count _ count - 1.\n\t\t\t\t\taStream next = firstChar\n\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t[index _ 2.\n\t\t\t\t\t\t\t[index <= aString size and: [(aString at: index) = aStream next]]\n\t\t\t\t\t\t\t\twhileTrue: [index _ index + 1].\n\t\t\t\t\t\t\tindex > aString size\n\t\t\t\t\t\t\t\tifTrue: [lastEnd _ aStream position]\n\t\t\t\t\t\t\t\tifFalse: [aStream position: endPosition - count]]]].\n\t^lastEnd\n"
        },
        "initialize-release": {
          "addChanges:": "addChanges: changedMessages\n\tChangeScanner new scanChangedMessages: changedMessages do: [:change | changes add: change].\n\tself updateList\n",
          "scanFile:": "scanFile: aFileStream\n\tChangeScanner new scanFile: aFileStream do: [:change | changes add: change].\n\tlistName size = 0\n\t\tifTrue: [listName _ aFileStream name]\n\t\tifFalse: [listName _ listName, ' ..'].\n\tself updateList\n",
          "addChangeSet:": "addChangeSet: aChangeSet\n\tself addChanges: aChangeSet changedMessageList\n",
          "scheduleMessageBrowser": "scheduleMessageBrowser\n\t| change |\n\tselectionIndex > 0 ifTrue:\n\t\t[change _ list at: selectionIndex.\n\t\t(change isKindOf: MethodDefinitionChange) ifTrue:\n\t\t\t[^BrowserView openListBrowserOn: (Array with: change name) label: 'current definition']].\n\t^nil\n",
          "initialize": "initialize\n\tsuper initialize.\n\tlistName _ ''.\n\tchanges _ OrderedCollection new.\n\tlist _ OrderedCollection new.\n\tselectionIndex _ 0.\n\tfilter _ [:change | true].\n\tremoved _ Set new.\n\tfilterList _ #().\n\tfieldList _ #()\n",
          "recoverFile:": "recoverFile: aFileStream\n\t\"Recover all the changes from a .changes file since the last snapshot\"\n\t| position |\n\tposition _ self findLast: '\n\n''----SNAPSHOT----''!\n' in: aFileStream.\n\tposition isNil\n\t\tifTrue: [position _ 0].\n\taFileStream position: position.\n\tself scanFile: aFileStream\n",
          "release": "release\n\t\"break BlockContext cycles\"\n\tfilter _ nil.\n\tfilterList _ #()\n"
        },
        "checking-private": {
          "writeContendor:on:oldText:": "writeContendor: source on: aStream oldText: oldText\n\t\"write out the change\"\n\n\t| text method endComment code |\n\taStream cr; nextChunkPut: '\"File: ', source fileName, '\"'; cr.\n\ttext _ source text.\n\t(source isKindOf: MethodDefinitionChange) ifFalse:\n\t\t[self tabText: text on: aStream.\n\t\t^oldText].\n\tmethod _ ReadStream on: text.\n\tmethod skipSeparators; skipTo: Character cr; skipSeparators. \t\"skip header\"\n\t(method peekFor: $\")\n\t\tifTrue:\n\t\t\t[method skipTo: $\"; skipSeparators].\n\tendComment _ method position.\n\tcode _ method nextChunk.\n\t(self equalWithoutComments: code and: oldText)\n\t\tifTrue:\n\t\t\t[method reset.\n\t\t\taStream cr; nextPutAll: (method next: endComment);\n\t\t\t\t\tnextPutAll: '[SAME CODE AS ABOVE]'; cr]\n\t\tifFalse:\n\t\t\t[aStream cr; nextChunkPut: text; cr].\n\t^code\n",
          "tabText:on:": "tabText: text on: aStream\n\t\"report conflicts among the changes\"\n\t| cr previous terminator |\n\tcr _ Character cr.\n\tterminator _ $!.\n\tprevious _ cr.\n\ttext do:\n\t\t[:char |\n\t\tchar = cr ifFalse: [previous = cr ifTrue: [aStream tab]].\n\t\taStream nextPut: (previous _ char).\n\t\tchar = terminator ifTrue: [aStream nextPut: char]].\n\taStream nextPut: terminator; cr\n",
          "finishReportOn:": "finishReportOn: aStream\n\t\"report conflicts among the changes\"\n\t| cr previous terminator |\n\tcr _ Character cr.\n\tterminator _ $!.\n\tdoItDict associationsDo:\n\t\t[:aDoIt |\n\t\taStream cr; nextChunkPut: '\"*** DoIts in ', aDoIt key, ' ***\"'; cr; cr.\n\t\taDoIt value do:\n\t\t\t[:doit | self tabText: doit text on: aStream] ].\n\n\taStream isEmpty ifTrue:\n\t\t[Transcript show: '*** no conflicts ***'.\n\t\taStream nextChunkPut: '\"*** no conflicts ***\"'; cr].\n\t^aStream close\n",
          "nextNonComment:": "nextNonComment: sourceStream\n\t\"Return the next item from the sourceStream (assumed not atEnd),\n\tcarefully ignoring comments and separators.\"\n\n\t| char sepr |\n\tsepr _ false.\n\t[true]\n\t\twhileTrue:\n\t\t\t[sourceStream atEnd ifTrue: [^nil].\n\t\t\tchar _ sourceStream peek.\n\t\t\tchar = $$ ifTrue: [sourceStream next.  ^sourceStream next].\t\"catch chars/strings\"\n\t\t\tchar = $' ifTrue: [^String readFrom: sourceStream].\n\t\t\tchar = $\"\n\t\t\t\tifTrue: [sourceStream next; skipTo: $\".  sepr _ true]\n\t\t\t\tifFalse:\n\t\t\t\t\t[char isSeparator\n\t\t\t\t\t\tifTrue: [sourceStream skipSeparators.  sepr _ true]\n\t\t\t\t\t\tifFalse: [sepr ifTrue: [^Character space].\n\t\t\t\t\t\t\t\tsourceStream next.\n\t\t\t\t\t\t\t\t^char]]]\n",
          "reportChangesOn:extension:": "reportChangesOn: reportStream extension: extension\n\t\"report conflicts among the changes\"\n\t| aStream contendors oldText |\n\taStream _ reportStream.\n\tchangeDict keys asSortedCollection do: [:change |\n\t\tcontendors _ changeDict at: change.\n\t\tcontendors size > 1 ifTrue:\n\t\t\t[extension == nil ifFalse:\n\t\t\t\t[aStream _ Disk file: ((change copyUpTo: $ ) copyWithout: $ ), extension.\n\t\t\t\taStream setToEnd].\n\t\t\taStream cr; nextChunkPut: '\"*** conflict: ', change, ' ***\"'; cr.\n\t\t\toldText _ '...'.\n\t\t\tcontendors do: [:contendor | oldText _ self writeContendor: contendor on: aStream oldText: oldText].\n\t\t\textension == nil ifFalse: [aStream close]] ].\n"
        },
        "checking-reporting": {
          "reportConflictsByClassWithExtension:": "reportConflictsByClassWithExtension: extension\n\t\"report conflicts among the changes\"\n\tself reportChangesOn: nil extension: extension.\n\t^self finishReportOn: (Disk file: 'DoIts', extension)\n",
          "reportConflictsOn:": "reportConflictsOn: aStream\n\t\"report conflicts among the changes\"\n\tself reportChangesOn: aStream extension: nil.\n\t^self finishReportOn: aStream\n"
        },
        "filter": {
          "hasFilter:": "hasFilter: index\n\t^index <= filterList size and: [(filterList at: index) notNil]\n",
          "switchFilter:perform:": "switchFilter: index perform: aSymbol\n\tindex > filterList size\n\t\tifTrue:\n\t\t\t[filterList _ filterList , (Array new: index - filterList size)].\n\t(filterList at: index) isNil\n\t\tifTrue:\n\t\t\t[selectionIndex > 0 ifTrue:\n\t\t\t\t[filterKey _ list at: selectionIndex.\n\t\t\t\tfilterList at: index put: aSymbol]]\n\t\tifFalse:\n\t\t\t[filterList at: index put: nil].\n\tself updateList\n"
        },
        "checking": {
          "checkWithSystem:": "checkWithSystem: aBoolean\n\tchangeDict _ Dictionary new.\n\tdoItDict _ Dictionary new.\n\tcheckSystem _ aBoolean.\n\tlist do: [:change |\n\t\t(removed includes: change) ifFalse: [change checkWith: self]]\n",
          "checkWith:": "checkWith: aConflictChecker\n\tlist do:\n\t\t[:change |\n\t\t(removed includes: change) ifFalse:\n\t\t\t[change checkWith: aConflictChecker]]\n"
        },
        "removing": {
          "forget": "forget\n\tchanges _ changes select: [:c | (removed includes: c) not].\n\tremoved _ Set new.\n\tself updateList\n",
          "removeCurrent": "removeCurrent\n\tselectionIndex > 0 ifTrue:\n\t\t[removed add: (list at: selectionIndex)]\n",
          "restoreAll": "restoreAll\n\tlist do: [:change | removed remove: change ifAbsent: []]\n",
          "removeAll": "removeAll\n\tremoved addAll: list\n",
          "restoreCurrent": "restoreCurrent\n\tselectionIndex > 0 ifTrue:\n\t\t[removed remove: (list at: selectionIndex) ifAbsent: []]\n"
        },
        "showing": {
          "showingField:": "showingField: index\n\t^index <= fieldList size and: [(fieldList at: index) notNil]\n",
          "switchField:perform:": "switchField: index perform: aSymbol\n\tindex > fieldList size\n\t\tifTrue:\n\t\t\t[fieldList _ fieldList , (Array new: index - fieldList size)].\n\t(fieldList at: index) isNil\n\t\tifTrue:\n\t\t\t[fieldList at: index put: aSymbol]\n\t\tifFalse:\n\t\t\t[fieldList at: index put: nil].\n\tself updateSelection: selectionIndex\n"
        }
      }
    },
    "ChangeListController": {
      "comment": "I am the controller for ChangeListView, handling the list menu.\n",
      "class_name": "ChangeListController",
      "superclass": "LockedListController",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "ChangeListYellowButtonMenu ChangeListYellowButtonMessages",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"ChangeListController initialize\"\n\n\tChangeListYellowButtonMenu _\n\t\tPopUpMenu\n\t\t\tlabels:\n'file in\nfile out\nrecover last changes\ndisplay system changes\ndo all\nremove all\nrestore all\nspawn all\nforget\ndo it\nremove it\nrestore it\nspawn it\ncheck conflicts\ncheck with system'\n\t\t\tlines: #( 4 8 9 13 ).\n\tChangeListYellowButtonMessages _\n\t\t#(fileIn fileOut recover getChanges doAll removeAll restoreAll copyView forget doThis removeItem restoreItem browse check checkWithSystem)\n"
        }
      },
      "instance_methods": {
        "menu messages": {
          "doThis": "doThis\n\tself controlTerminate.\n\tmodel doThis.\n\tself controlInitialize\n",
          "fileOut": "fileOut\n\tself controlTerminate.\n\tself\n\t\tgetFile: #file:\n\t\twithPrompt: 'type name of file for writing'\n\t\tdo:\n\t\t\t[:aFile |\n\t\t\tmodel fileOutOn: aFile.\n\t\t\taFile shorten; close].\n\tself controlInitialize\n",
          "checkWithSystem": "checkWithSystem\n\tself controlTerminate.\n\tself checkWithSystem: true.\n\tself controlInitialize\n",
          "checkWithSystem:": "checkWithSystem: aBoolean\n\tself\n\t\tgetFile: #file:\n\t\twithPrompt: 'type name of file on which to write confilicts'\n\t\tdo:\n\t\t\t[:aFile |\n\t\t\tCursor execute showWhile: [model checkWithSystem: aBoolean].\n\t\t\tCursor write showWhile: [model reportConflictsOn: aFile].\n\t\t\taFile shorten; close]\n",
          "removeItem": "removeItem\n\tview deselect.\n\tmodel removeCurrent.\n\tview displaySelectionBox\n",
          "doFrom:": "doFrom: firstIndex\n\t\"Reset selection each time through the loop, so that if an error occurs, the selection is left at the item which caused it.\"\n\tfirstIndex to: model listSize do:\n\t\t[:index |\n\t\t(model hasRemoved: index)\n\t\t\tifFalse:\n\t\t\t\t[model toggleListIndex: index.\n\t\t\t\tmodel doThis: index]]\n",
          "fileIn": "fileIn\n\tself controlTerminate.\n\tself\n\t\tgetFile: #oldFile:\n\t\twithPrompt: 'type name of file for reading'\n\t\tdo:\n\t\t\t[:aFile |\n\t\t\taFile readOnly.\n\t\t\tmodel scanFile: aFile.\n\t\t\taFile close].\n\tself controlInitialize\n",
          "recover": "recover\n\tself controlTerminate.\n\tmodel recoverFile: (SourceFiles at: 2).\n\tself changeLabel.\n\tself controlInitialize\n",
          "forget": "forget\n\tself controlTerminate.\n\tCursor execute showWhile: [model forget].\n\tself controlInitialize\n",
          "getChanges": "getChanges\n\tself controlTerminate.\n\tmodel addChangeSet: Smalltalk changes.\n\tself controlInitialize\n",
          "doAll": "doAll\n\tself controlTerminate.\n\tself doFrom: 1.\n\tself controlInitialize\n",
          "browse": "browse\n\t\"Create and schedule a list browser containing only the displayed items.\"\n\tself controlTerminate.\n\tmodel scheduleMessageBrowser.\n\tself controlInitialize\n",
          "restoreItem": "restoreItem\n\tview deselect.\n\tmodel restoreCurrent.\n\tview displaySelectionBox\n",
          "restoreAll": "restoreAll\n\tview deselect.\n\tmodel restoreAll.\n\tview displaySelectionBox\n",
          "check": "check\n\tself controlTerminate.\n\tself checkWithSystem: false.\n\tself controlInitialize\n",
          "removeAll": "removeAll\n\tself controlTerminate.\n\tview deselect.\n\tmodel removeAll.\n\tview displaySelectionBox.\n\tself controlInitialize\n",
          "copyView": "copyView\n\t\"Create and schedule a list browser containing only the displayed items.  Accessed by choosing the menu command clone.\"\n\n\tself controlTerminate.\n\tChangeListView openOn: model filterCopy\n"
        },
        "private": {
          "getFile:withPrompt:do:": "getFile: aSymbol withPrompt: promptString do: actionBlock\n\t\"find out the file name\"\n\n\t| fixedBlock fileName directory end |\n\tfixedBlock _ actionBlock fixTemps.\n\tFillInTheBlank\n\t\trequest: promptString\n\t\tdisplayAt: Sensor cursorPoint\n\t\tcentered: true\n\t\taction: [:fileName | fileName]\n\t\tinitialAnswer: ''.\n\tfileName isEmpty\n\t\tifFalse:\n\t\t\t[directory _ Disk.\n\t\t\t(directory isLegalFileName: fileName)\n\t\t\t\tifTrue: [Cursor wait showWhile:\n\t\t\t\t\t\t\t[actionBlock value: (directory perform: aSymbol with: fileName)]]\n\t\t\t\tifFalse: [Transcript cr; show: 'You specified an illegal file name.']]\n",
          "changeModelSelection:": "changeModelSelection: anInteger\n\tmodel toggleListIndex: anInteger\n",
          "initializeYellowButtonMenu": "initializeYellowButtonMenu\n\tself\n\t\tyellowButtonMenu: ChangeListYellowButtonMenu\n\t\tyellowButtonMessages: ChangeListYellowButtonMessages.\n",
          "changeLabel": "changeLabel\n\t| superView |\n\t\"This method accesses the label with a terrible kludge.  It would be better if the label were a view of its own, but there would still be problems.\"\n\tsuperView _ view superView.\n\tDisplay gray: superView labelDisplayBox.\n\tsuperView label: model listName.\n\tsuperView displayView\n"
        },
        "initialize-release": {
          "initialize": "initialize\n\tsuper initialize.\n\tself initializeYellowButtonMenu\n"
        },
        "scrolling": {
          "scrollView:": "scrollView: anInteger\n\t| viewList maximumAmount minimumAmount amount |\n\tviewList _ view list.\n\tmaximumAmount _\n\t\tviewList clippingRectangle top -\n\t\tviewList compositionRectangle top max: 0.\n\tminimumAmount _\n\t\tviewList clippingRectangle bottom -\n\t\tviewList compositionRectangle bottom min: 0.\n\tamount _\n\t\t(anInteger min: maximumAmount) max:\n\t\tminimumAmount.\n\tamount ~= 0\n\t\tifTrue:\n\t\t\t[view deselect.\n\t\t\tviewList scrollBy: amount negated.\n\t\t\tview displaySelectionBox]\n"
        }
      }
    }
  },
  "Interface-Debugger": {
    "NotifierController": {
      "comment": "I am a kind of MouseMenuController that creates a yellow button menu for proceeding an interrupted process or for creating and scheduling a debugger on the interrupted machine state.  I give up control if a blue button is pressed or if the cursor is not inside the view.\n",
      "class_name": "NotifierController",
      "superclass": "StandardSystemController",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "NotifierYellowButtonMenu NotifierYellowButtonMessages",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\tNotifierYellowButtonMenu _\n\t\tPopUpMenu labels:\n'proceed\ndebug'.\n\tNotifierYellowButtonMessages _ #(proceed debug )\n\n\t\"NotifierController initialize.\"\n"
        }
      },
      "instance_methods": {
        "model access": {
          "model:": "model: aDebugger\n\t\"Intercept to possible enable spelling correction.\"\n\n\tsuper model: aDebugger.\n\tmodel interruptedContext selector == #doesNotUnderstand: ifTrue:\n\t\t[self yellowButtonMenu: (PopUpMenu labels:\n'proceed\ndebug\ncorrect' lines: #(2))\n\t\t\tyellowButtonMessages: #(proceed debug correct)]\n"
        },
        "menu messages": {
          "debug": "debug\n\t\"Open a Debugger on the receiver's model.\"\n\n\tself controlTerminate.\n\tview erase.\n\tDebugger openFullViewOn: model label: view label.\n\tself closeAndUnscheduleNoErase.\n\tProcessor terminateActive\n",
          "proceed": "proceed\n\t\"Proceed execution of the receiver's model.\"\n\tself controlTerminate.\n\tmodel proceed.\n\tself controlInitialize\n",
          "correct": "correct\n\t\"Attempt to correct the spelling of the not-understood message and resend.\"\n\n\tself controlTerminate.\n\tmodel correct: self.\n\tself controlInitialize\n"
        },
        "private": {
          "initializeYellowButtonMenu": "initializeYellowButtonMenu\n\tself yellowButtonMenu: NotifierYellowButtonMenu\n\t\tyellowButtonMessages: NotifierYellowButtonMessages\n"
        },
        "initialize-release": {
          "initialize": "initialize\n\tsuper initialize.\n\tself initializeYellowButtonMenu\n"
        }
      }
    },
    "NotifierView": {
      "comment": "I am a view of interrupted machine state.  The interruption occurred in order to notify the user that some action to be taken is dangerous, perhaps because it is not recoverable. I contain one subView in which the notification information is displayed.  My default controller is NotifierController.\n\nInstance Variables:\n\tcontents\t <String> the notification information\n",
      "class_name": "NotifierView",
      "superclass": "StandardSystemView",
      "instanceVariables": "contents",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "openInterrupt:onProcess:": "openInterrupt: aString onProcess: interruptedProcess\n\t\"Create and schedule an instance of me whose model is a Debugger on\n\tinterruptedProcess.  Sent to notify the user that the system is low in space or that\n\tthe user typed ctrl c.  The label of the scheduled view is aString.\"\n\n\t| debugger topView |\n\tdebugger _ Debugger interruptProcess: interruptedProcess.\n\ttopView _\n\t\tself openDebugger: debugger\n\t\t\tcontents: debugger interruptedContext shortStack\n\t\t\tlabel: aString\n\t\t\tdisplayAt: Display boundingBox center.\n\t^topView\n",
          "openContext:label:contents:": "openContext: haltContext label: aString contents: contentsString\n\t\"Create and schedule an instance of me viewing a Debugger on haltContext.\n\tThe view will be labeled with aString, and shows a short sender stack.\"\n\n\t| displayPoint |\n\tErrorRecursion\n\t\tifTrue:\n\t\t\t[ErrorRecursion _ false.\n\t\t\tself primitiveError: aString].\n\tErrorRecursion _ true.\n\tdisplayPoint _\n\t\tScheduledControllers activeController == nil\n\t\t\tifTrue: [Display boundingBox center]\n\t\t\tifFalse: [ScheduledControllers activeController view displayBox center].\n\tself openDebugger: (Debugger context: haltContext)\n\t\tcontents: contentsString\n\t\tlabel: aString\n\t\tdisplayAt: displayPoint.\n\tErrorRecursion _ false.\n\tProcessor activeProcess suspend\n"
        },
        "private": {
          "openDebugger:contents:label:displayAt:": "openDebugger: aDebugger contents: aString1 label: aString2 displayAt: aPoint\n\t| notifierView |\n\tCursor normal show.\n\tCursor cursorLink: true.\n\tnotifierView _ self new model: aDebugger.\n\tnotifierView contents: aString1.\n\tnotifierView label: aString2.\n\tnotifierView borderWidth: 2.\n\tnotifierView\n\t\tminimumSize: notifierView defaultWindow width\n\t\t\t\t\t\t@ notifierView defaultWindow height.\n\tnotifierView controller openNoTerminateDisplayAt: aPoint.\n\t^notifierView\n"
        }
      },
      "instance_methods": {
        "window access": {
          "defaultWindow": "defaultWindow\n\tcontents == nil\n\t\tifTrue: [^super defaultWindow]\n\t\tifFalse: [^contents boundingBox expandBy: 6]\n",
          "window:": "window: aWindow\n\tsuper window: aWindow.\n\tself centerContents\n"
        },
        "displaying": {
          "displayView": "displayView\n\tcontents\n\t\tdisplayOn: Display\n\t\ttransformation: self displayTransformation\n\t\tclippingBox: self insetDisplayBox\n\t\tfixedPoint: contents boundingBox center.\n\tsuper displayView\n"
        },
        "accessing": {
          "contents:": "contents: aString\n\t\"Set aString to be the information that is displayed in the receiver.\"\n\n\tcontents _ aString asParagraph.\n\tself centerContents\n",
          "contents": "contents\n\t\"Answer the information displayed in the receiver.\"\n\n\t^contents\n"
        },
        "private": {
          "centerContents": "centerContents\n\tcontents ~~ nil\n\t\tifTrue:\n\t\t\t[contents\n\t\t\t\talign: contents boundingBox center\n\t\t\t\twith: self getWindow center]\n"
        },
        "initialize-release": {
          "initialize": "initialize\n\tsuper initialize.\n\tself insideColor: Form white\n"
        },
        "controller access": {
          "defaultControllerClass": "defaultControllerClass\n\t^NotifierController\n"
        }
      }
    },
    "ProcessHandle": {
      "comment": "A ProcessHandle holds the state of an interrupted process.  It is capable of cutting back\nthe process's stack, terminating the process, or causing it to resume again.\n",
      "class_name": "ProcessHandle",
      "superclass": "Object",
      "instanceVariables": "process controller interrupted resumeContext proceedValue",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "on:at:interrupted:": "on: aProcess at: aContext interrupted: aBoolean\n\t^ self new\n\t\tprocess: aProcess\n\t\tcontroller: (ScheduledControllers activeControllerProcess == aProcess\n\t\t\t\t\tifTrue: [ScheduledControllers activeController]\n\t\t\t\t\tifFalse: [nil])\n\t\tinterrupted: aBoolean\n\t\tresumeContext: aContext\n"
        }
      },
      "instance_methods": {
        "access": {
          "proceedValue": "proceedValue\n\t^ proceedValue\n",
          "proceedValue:": "proceedValue: value\n\tproceedValue _ value\n",
          "interrupted": "interrupted\n\t^ interrupted\n",
          "interrupted:": "interrupted: aBoolean\n\t\"whoever uses this should be a method in this class\"\n\tinterrupted _ aBoolean\n",
          "topContext:": "topContext: aContext\n\tresumeContext _ aContext\n",
          "topContext": "topContext\n\t^ resumeContext\n"
        },
        "menu messages": {
          "proceed": "proceed\n\tinterrupted ifTrue: [resumeContext push: proceedValue].\n\tself resumeProcess\n"
        },
        "initialize-release": {
          "release": "release\n\tprocess _ nil.  \"break all cycles\"\n\tcontroller _ nil.\n\tresumeContext _ nil.\n\tproceedValue _ nil\n",
          "process:controller:interrupted:resumeContext:": "process: aProcess controller: aController interrupted: aBoolean resumeContext: aContext\n\tprocess _ aProcess.\n\tcontroller _ aController.\n\tinterrupted _ aBoolean.\n\tresumeContext _ aContext.\n\tproceedValue _ nil\n"
        },
        "control": {
          "terminate": "terminate\n\tprocess == nil ifFalse: [process terminate].\n\tself release\n",
          "resumeProcess": "resumeProcess\n\t| aScheduledController |\n\taScheduledController _ ScheduledControllers activeController.\n\taScheduledController view erase.\n\tprocess suspendedContext method == (Process compiledMethodAt: #terminate)\n\t\tifFalse:\n\t\t\t[resumeContext == process suspendedContext ifFalse:\n\t\t\t\t[process popTo: resumeContext].\n\t\t\tScheduledControllers\n\t\t\t\tactiveControllerNoTerminate: controller  \"NoTerminate\"\n\t\t\t\tandProcess: process].\n\t\"if old process was terminated, just terminate current one\"\n\tself release.  \"must precede close because it tries to terminate\"\n\taScheduledController closeAndUnscheduleNoErase.\n\tProcessor terminateActive\n"
        }
      }
    },
    "Debugger": {
      "comment": "The debugger allows browsing among the stack of contexts of a suspended process.  In addition to viewing the source code at each level, the debugger supports inspection (and change) of temporary and instance variables in each context.\n\nInstance Variables:\n\tcontext\t\t\t\t<ContextPart> the currently viewed context\n\treceiverInspector\t<Inspector> on instance variables in the current context\n\tcontextInspector\t\t<Inspector> on temporary variables in the current context\n\tshortStack\t\t\t<Boolean> true if only a short portion of the stack is being shown\n\tsourceMap\t\t\t<SortedCollection> of associations (pc -> range)\n\ttempNames\t\t\t<Array of: String>, cached names of the temporary variables\n\tprocessHandle\t\t<ProcessHandle> holding onto the observed process\n",
      "class_name": "Debugger",
      "superclass": "Browser",
      "instanceVariables": "context receiverInspector contextInspector shortStack sourceMap sourceCode processHandle",
      "classInstanceVariables": "",
      "classVariables": "ContextMenu HighlightPC",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "flushMenus": "flushMenus\n\t\"Debugger flushMenus.\"\n\tContextMenu _ nil\n",
          "initialize": "initialize\n\t\"Debugger initialize.\"\n\tHighlightPC _ true\n"
        },
        "instance creation": {
          "openFullViewOn:label:": "openFullViewOn: aDebugger label: aString\n\t\"Answer an instance of me on the model, aDebugger.\n\tThe label is aString.  Do not terminate the current active process.\"\n\n\t| topView |\n\taDebugger openInspectors.\n\ttopView _ BrowserView model: aDebugger label: aString minimumSize: 300@230.\n\ttopView addSubView:\n\t\t\t(SelectionInListView on: aDebugger printItems: true oneItem: false\n\t\t\t\taspect: #context change: #context: list: #contextList\n\t\t\t\tmenu: #contextMenu initialSelection: #context)\n\t\tin: (0@0 extent: 1@0.2) borderWidth: 1.\n\ttopView addSubView:\n\t\t\t(CodeView on: aDebugger aspect: #text change: #acceptText:from:\n\t\t\t\tmenu: #textMenu initialSelection: nil)\n\t\tin: (0@0.2 extent: 1@0.6) borderWidth: 1.\n\tInspectorView view: aDebugger receiverInspector\n\t\tin: (0@0.8 extent: 0.5@0.2) of: topView.\n\tInspectorView view: aDebugger contextInspector\n\t\tin: (0.5@0.8 extent: 0.5@0.2) of: topView.\n\ttopView controller openNoTerminate.\n\t^topView\n",
          "interruptProcess:": "interruptProcess: interruptedProcess\n\t\"Answer an instance of me that models the current state of the system.  The active\n\tprocess has decided to provide a debugger on an interrupted process.  This message\n\tis called if the user types the ctrl c interrupt, or a low space notification occurs.\"\n\n\t| debugger |\n\tdebugger _ self new.\n\tdebugger\n\t\tprocess: interruptedProcess\n\t\tcontext: interruptedProcess suspendedContext\n\t\tinterrupted: true.\n\t^debugger\n",
          "context:": "context: aContext\n\t\"Answer an instance of me that models the current state of the system.  The active\n\tprocess has determined that a debugger should be set up (often by the user issuing\n\tthe command debug).\"\n\n\t| aDebugger |\n\taDebugger _ self new.\n\taDebugger\n\t\tprocess: Processor activeProcess\n\t\tcontext: aContext\n\t\tinterrupted: false.\n\t^aDebugger\n"
        }
      },
      "instance_methods": {
        "pc selection": {
          "pcRange": "pcRange\n\t\"Answer the indices in the source code for the method corresponding\n\tto the selected context's program counter value.\"\n\n\t| i methodNode pc end |\n\t(HighlightPC and: [context ~~ nil])\n\t\tifFalse: [^1 to: 0].\n\t(sourceMap == nil or: [sourceMap size = 0])\n\t\t ifTrue: [^1 to: 0].\n\tpc_ context pc -\n\t\t((context == processHandle topContext and: [processHandle interrupted])\n\t\t\tifTrue: [1]\n\t\t\tifFalse: [2]).\n\ti _ sourceMap indexForInserting: (Association key: pc value: nil).\n\ti < 1 ifTrue: [^1 to: 0].\n\ti > sourceMap size\n\t\tifTrue:\n\t\t\t[end _ sourceMap inject: 0 into:\n\t\t\t\t[:prev :this | prev max: this value last].\n\t\t\t^ end+1 to: end].\n\t^(sourceMap at: i) value\n",
          "computeSourceMap": "computeSourceMap\n\t\"Compute the sourceMap for PC selection in the current code.\"\n\t| methodNode |\n\tmethodNode _ self selectedClass compilerClass new\n\t\t\tparse: sourceCode\n\t\t\tin: self selectedClass\n\t\t\tnotifying: nil.\n\tsourceMap _ methodNode sourceMap.\n\tcontext method cacheTempNames: methodNode tempNames\n"
        },
        "dependents access": {
          "removeDependent:": "removeDependent: aDependent\n\tsuper removeDependent: aDependent.\n\tself dependents isEmpty ifTrue: [self release]\n"
        },
        "menu messages": {
          "correct:": "correct: aNotifierController\n\t\"Attempt to correct the spelling of the not-understood message and resend.\"\n\t| oldSelector oldFirst oldArgs selectors guess score bestScore |\n\tprocessHandle topContext selector == #doesNotUnderstand:\n\t\tifFalse: [^ aNotifierController view flash].\n\toldSelector _ (processHandle topContext tempAt: 1) selector.\n\toldFirst _ oldSelector first.\n\toldArgs _ oldSelector numArgs.\n\tselectors _ processHandle topContext receiver class allSelectors select:\n\t\t\t[:sel | sel first = oldFirst and: [sel numArgs = oldArgs]].\n\tbestScore _ 0.\n\tselectors do:\n\t\t[:sel |\n\t\t(score _ sel spellAgainst: oldSelector) > bestScore ifTrue:\n\t\t\t[bestScore _ score. guess _ sel]].\n\t(self confirm: 'retry with selector:\n\t', guess) ifFalse: [^ aNotifierController view flash].\n\tprocessHandle topContext tempAt: 1 put:\n\t\t(Message selector: guess arguments: (processHandle topContext tempAt: 1) arguments).\n\t^ self proceed\n",
          "restart": "restart\n\t\"Proceed from the initial state of the currently selected context.\n\tThe argument is a controller on a view of the receiver.  That view\n\tis closed.\"\n\n\tself checkContextSelection.\n\tself revertBlock ifFalse: [^self].\n\tcontext restart.\n\tself resumeProcess\n",
          "spawnEdits:from:": "spawnEdits: aText from: aController\n\tcontext == nil  \"cant spawn changes when deselected\"\n\t\tifFalse: [super spawnEdits: aText from: aController]\n",
          "proceed": "proceed\n\t\"Proceed from the interrupted state of the currently selected context.\n\tThe argument is a controller on a view of the receiver.  That view\n\tis closed.\"\n\n\tself checkContextSelection.\n\t(context ~= processHandle topContext) | (processHandle interrupted not)\n\t\tifTrue: [context push: processHandle proceedValue].\n\tself resumeProcess\n",
          "fullStack": "fullStack\n\t\"Expand the stack to include all contexts, rather than the first few.\"\n\tshortStack _ false.\n\tself changed: #context\n",
          "spawn:": "spawn: aString\n\t\"Create and schedule a message browser on the message, aString.  Any edits already\n\tmade are retained.\"\n\n\tcontext == nil\n\t\tifFalse:\n\t\t\t[^BrowserView openMethodBrowserOn:\n\t\t\t\t(MethodListBrowser on:\n\t\t\t\t\t(Array with: self selectedClass name\n\t\t\t\t\t\t\twith: selector))\n\t\t\t\t\t\"editString: aString\"]\n"
        },
        "contextList": {
          "context": "context\n\t^ context\n",
          "contextMenu": "contextMenu\n\t\"Debugger flushMenus\"\n\tcontext == nil ifTrue:\n\t\t[^ ActionMenu labels: 'full stack\\proceed' withCRs selectors: #(fullStack proceed)].\n\tContextMenu == nil ifTrue:\n\t\t[ContextMenu _ ActionMenu\n\t\t\tlabels: 'full stack\\proceed\\restart\\senders\\implementors\\messages\\step\\send' withCRs\n\t\t\tlines: #(3 6)\n\t\t\tselectors: #(fullStack proceed restart browseSenders browseImplementors browseMessages step send)].\n\t^ ContextMenu\n",
          "context:": "context: aContext\n\t| oldContext class |\n\toldContext _ context.\n\tcontext _ aContext.\n\tcontext == nil\n\t\tifTrue:\n\t\t\t[contextInspector inspect: nil.\n\t\t\treceiverInspector inspect: nil.\n\t\t\tself changed: #text.\n\t\t\t^ self].\n\tclass _ context receiver class.\n\tmeta _ class isMeta.\n\tmeta\n\t\tifTrue: [className _ class soleInstance name]\n\t\tifFalse: [className _ class name].\n\tselector _ context selector.\n\t(oldContext == nil or: [oldContext method ~~ context method])\n\t\tifTrue:\n\t\t\t[sourceCode _ context sourceCode.\n\t\t\tself computeSourceMap. \"will compute tempNames\"\n\t\t\tself changed: #text].\n\treceiverInspector inspect: context receiver.\n\tcontextInspector inspect: context.\n\tself changed: #pc\n",
          "contextList": "contextList\n\tshortStack\n\t\tifTrue: [^ processHandle topContext stackOfSize: 9]\n\t\tifFalse: [^ processHandle topContext stack]\n"
        },
        "stack manipulation": {
          "step": "step\n\t\"Some context is selected (force top if none).  When this is so, either some message\n\tis about to be sent in that context, or that context is about to return.  Step will cause\n\tthe next message to be sent or the return to be executed.  In either case, the debugger\n\tregains control so that you can step your way down through a method, and out to the\n\tcaller when it returns.  Note that the execution invoked by step is actually simulated,\n\tso it will run much slower than normal\"\n\n\t| currentContext |\n\tself checkContextSelection.\n\tprocessHandle interrupted ifFalse: [processHandle topContext push: processHandle proceedValue].\n\tprocessHandle interrupted: true. \"simulation leaves same state as interrupting\"\n\tcontext == processHandle topContext\n\t\tifTrue:\n\t\t\t[currentContext _ context.\n\t\t\tcurrentContext stepToSendOrReturn.\n\t\t\tcurrentContext willReturn\n\t\t\t\tifTrue:\n\t\t\t\t\t[currentContext _ currentContext step.\n\t\t\t\t\tcurrentContext stepToSendOrReturn.\n\t\t\t\t\tself resetContext: currentContext]\n\t\t\t\tifFalse:\n\t\t\t\t\t[currentContext completeCallee: currentContext step.\n\t\t\t\t\tself changed: #pc.\n\t\t\t\t\tself updateInspectors]]\n\t\tifFalse:\n\t\t\t[\"Have to complete any stuff called from here\"\n\t\t\tcontext completeCallee: processHandle topContext.\n\t\t\tself resetContext: context]\n",
          "resumeProcess": "resumeProcess\n\tprocessHandle topContext: context.\n\tprocessHandle resumeProcess\n",
          "resetContext:": "resetContext: aContext\n\t\"Used when a new context becomes top-of-stack, for instance when the\n\tmethod of the selected context is re-compiled, or the simulator steps or\n\treturns to a new method.\"\n\tprocessHandle topContext: aContext.\n\tself changed: #context.\n\tcontext == aContext\n\t\tifFalse: \"old ctxt not in new stack\"\n\t\t[self context: aContext.\n\t\tself changed: #context]\n",
          "checkContextSelection": "checkContextSelection\n\tcontext == nil ifTrue: [context _ processHandle topContext]\n",
          "revertBlock": "revertBlock\n\t\"If the selected context is a block, then revert to its home.\"\n\t(context isKindOf: MethodContext) ifFalse:\n\t\t\t[(self confirm:\n'I will have to revert to the method from\nwhich this block originated.  Is that OK?')\n\t\t\t\tifTrue: [self context: context home. ^ true]\n\t\t\t\tifFalse: [^ false]].\n\t^ true\n",
          "send": "send\n\t\"The top context on the stack must be selected.  This being so, either some message\n\tis about to be sent in that context, or that context is about to return.  Send is only\n\teffective in the former case.  It will cause the next message to be sent.  The send is\n\tactually simulated, so that the debugger will regain control at the beginning of the\n\tmethod which is invokedi (unless it is a primitive).  In this way, you can step your\n\tway deeper into a computation\"\n\n\tself checkContextSelection.\n\tprocessHandle interrupted ifFalse: [processHandle topContext push: processHandle proceedValue].\n\tprocessHandle interrupted: true. \"simulation leaves same state as interrupting\"\n\tcontext stepToSendOrReturn.\n\t(context ~~ processHandle topContext) | context willReturn\n\t\tifFalse:\n\t\t\t[self resetContext: context step. context stepToSendOrReturn]\n"
        },
        "doIt/accept/explain": {
          "doItContext": "doItContext\n\t\"Answer the context in which a text selection can be evaluated.\"\n\t^ context\n",
          "doItValue:": "doItValue: anObject\n\t\"Set the value to be returned when the interrupted process proceeds.\"\n\tprocessHandle proceedValue: anObject\n",
          "doItReceiver": "doItReceiver\n\t\"Answer the receiver in which to evaluate code pane doIts.\"\n\tcontext == nil ifTrue: [^ nil].\n\t^ context receiver\n",
          "acceptText:from:": "acceptText: aText from: aController\n\t\"Recompile the method of the selected context.\"\n\t| newSelector classOfMethod newMethod |\n\tcontext == nil ifTrue: [^ false].\n\tself revertBlock ifFalse: [^ false].\n\tclassOfMethod _ context mclass.\n\tnewSelector _ classOfMethod parserClass new parseSelector: aText.\n\tnewSelector ~~ selector\n\t\tifTrue: [self notify: 'selector must not change'].\n\tCursor execute showWhile:\n\t\t[newSelector _ classOfMethod\n\t\t\t\tcompile: aText\n\t\t\t\tclassified: ClassOrganizer defaultProtocol\n\t\t\t\tnotifying: aController].\n\tnewSelector == nil ifTrue: [^ false].\n\tCursor execute showWhile:\n\t\t[\"**have to handle newMethod needing big stack!\"\n\t\tnewMethod _ classOfMethod compiledMethodAt: newSelector.\n\t\tsourceCode _ aText string.\n\t\tnewMethod isQuick\n\t\t\tifTrue:  \"If compiled quick, we need a non-quick version to put in the context.\"\n\t\t\t\t[newMethod _ (classOfMethod compilerClass new\n\t\t\t\t\t\t\tparse: sourceCode in: classOfMethod notifying: nil) generateNoQuick].\n\t\tnewMethod frameSize > context size\n\t\t\tifTrue:  \"This could be handled by allocating another bigger context,\n\t\t\t\t\tbut you would have to inform processHandle of change in stack.\"\n\t\t\t\t[self notify: 'The new method requires more frame space than the old.\nYou MUST not restart or proceed in this context.\nOther debugging, and restarting other methods is OK.\nYou may proceed from this notification'].\n\t\tcontext restartWith: newMethod.\n\t\tself computeSourceMap.  \"Should get cached in CompiledMethod-class like tempNames\"\n\t\tself resetContext: context].\n\t^ true\n"
        },
        "accessing": {
          "interruptedContext": "interruptedContext\n\t\"Answer the suspended context of the interrupted process.\"\n\t^processHandle topContext\n",
          "selectedClass": "selectedClass\n\t^ context mclass\n"
        },
        "initialize-release": {
          "process:context:interrupted:": "process: aProcess context: aContext interrupted: aBoolean\n\tsourceCode _ nil.\n\tshortStack _ true.\n\tprocessHandle _ ProcessHandle on: aProcess at: aContext interrupted: aBoolean\n",
          "release": "release\n\tprocessHandle terminate.\n\tcontext _ nil.\n\treceiverInspector _ nil.\n\tcontextInspector _ nil.\n\tSmalltalk resetSpaceLimits.\n\tsuper release\n"
        },
        "inspectors": {
          "openInspectors": "openInspectors\n\t\"Further initialization when opening notify view to debug view\"\n\n\treceiverInspector _ Inspector inspect: nil.\n\tcontextInspector _ ContextInspector inspect: nil.\n\tself changed: #contextList\n",
          "contextInspector": "contextInspector\n\t^contextInspector\n",
          "updateInspectors": "updateInspectors\n\treceiverInspector update.\n\tcontextInspector update\n",
          "receiverInspector": "receiverInspector\n\t^receiverInspector\n"
        },
        "text": {
          "text": "text\n\tcontext == nil ifTrue: [^ Text new].\n\t^ sourceCode asText makeSelectorBoldIn: self selectedClass\n"
        }
      }
    },
    "SyntaxError": {
      "comment": "I represent a report of a syntax error when reading class descriptions from a noninteractive source such as an external file.  As a StringHolder, the string to be viewed is the code or expression containing the error.\n",
      "class_name": "SyntaxError",
      "superclass": "Object",
      "instanceVariables": "class badText processHandle",
      "classInstanceVariables": "",
      "classVariables": "TextMenu",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "errorInClass:withCode:errorString:": "errorInClass: aClass withCode: aString errorString: errorString\n\t\"Answer a StandardSystemView whose model is an instance of me.\n\tThe syntax error occurred in trying to add code, aString, to class, aClass.\"\n\t| aSyntaxError topView aListView aCodeView |\n\tCursor normal show.\n\taSyntaxError _ self new\n\t\t\tsetClass: aClass\n\t\t\tcode: aString\n\t\t\tprocessHandle: (ProcessHandle on: Processor activeProcess at: thisContext interrupted: false).\n\ttopView _ StandardSystemView model: aSyntaxError label: 'Syntax Error' minimumSize: 300 @ 180.\n\ttopView addSubView:\n\t\t\t(CodeView on: aSyntaxError aspect: #text change: #acceptText:from:\n\t\t\t\tmenu: #textMenu initialSelection: errorString)\n\t\tin: (0@0 extent: 1@1) borderWidth: 1.\n\ttopView controller openNoTerminateDisplayAt: Display extent // 2.\n\tProcessor activeProcess suspend\n"
        },
        "initialization": {
          "flushMenus": "flushMenus\n\tTextMenu _ nil\n"
        }
      },
      "instance_methods": {
        "dependents access": {
          "removeDependent:": "removeDependent: aDependent\n\tsuper removeDependent: aDependent.\n\tself dependents isEmpty \"detect when closing\"\n\t\tifTrue: [processHandle release]\n"
        },
        "doIt/accept/explain": {
          "doItContext": "doItContext\n\t^ nil\n",
          "doItReceiver": "doItReceiver\n\t^ nil\n",
          "acceptText:from:": "acceptText: aString from: aController\n\t\"Compile the code in aString and notify aController of any errors.\n\tProceed if successful.\"\n\n\t(class\n\t\tcompile: aString\n\t\tclassified: ClassOrganizer defaultProtocol\n\t\tnotifying: aController)\n\t\t== nil\n\t\t\tifTrue: [^false]\n\t\t\tifFalse: [^true]\n"
        },
        "private": {
          "setClass:code:processHandle:": "setClass: aClass code: aString processHandle: aProcessHandle\n\tclass _ aClass.\n\tprocessHandle _ aProcessHandle.\n\tbadText _ aString asText\n"
        },
        "text": {
          "text": "text\n\t^ badText\n",
          "proceed": "proceed\n\t\"Continue the file in, ignoring this section of code, regardless of whether or not the\n\tsyntax error was corrected.\"\n\n\tself changeRequest ifTrue: [processHandle proceed]\n",
          "textMenu": "textMenu\n\t\"SyntaxError flushMenus\"\n\tTextMenu == nil ifTrue:\n\t\t[TextMenu _ ActionMenu\n\t\t\tlabels: 'again\\undo\\copy\\cut\\paste\\do it\\print it\\accept\\cancel\\proceed' withCRs\n\t\t\tlines: #(2 5 7 9)\n\t\t\tselectors: #(again undo copySelection cut paste doIt printIt accept cancel proceed)].\n\t^ TextMenu\n"
        }
      }
    }
  },
  "Interface-File Model": {
    "FileModel": {
      "comment": "I represent an interface between a File and an editable view of it.  As a StringHolder, the string is the contents of the File.\n\nInstance Variables:\n\tfileName\t<String> The name of the file I am viewing.\n",
      "class_name": "FileModel",
      "superclass": "Object",
      "instanceVariables": "fileName",
      "classInstanceVariables": "",
      "classVariables": "TextMenu",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "fileStream:": "fileStream: aFileStream\n\t\"Answer an instance of me on the argument, aFileStream.\"\n\t^self new setFileStream: aFileStream\n",
          "open:named:": "open: aFileModel named: aString\n\t\"Scheduled a view whose model is aFileModel and whose label is aString.\"\n\t| topView |\n\ttopView _ StandardSystemView model: aFileModel label: aString minimumSize: 180 @ 180.\n\ttopView addSubView:\n\t\t\t(CodeView on: aFileModel aspect: #text change: #acceptText:from:\n\t\t\t\tmenu: #textMenu initialSelection: nil)\n\t\tin: (0@0 extent: 1@1) borderWidth: 1.\n\ttopView controller open\n",
          "open:named:withController:": "open: aFileModel named: aString withController: aController\n\t\"Scheduled a FileModel view with changes made in another editor.\"\n\t| topView textView |\n\ttopView _ StandardSystemView model: aFileModel label: aString minimumSize: 180 @ 180.\n\ttextView _ CodeView on: aFileModel aspect: #text change: #acceptText:from:\n\t\t\t\tmenu: #textMenu initialSelection: nil.\n\ttextView controller: aController.\n\ttopView addSubView: textView in: (0@0 extent: 1@1) borderWidth: 1.\n\ttopView controller open\n"
        },
        "initialization": {
          "flushMenus": "flushMenus\n\tTextMenu _ nil\n"
        }
      },
      "instance_methods": {
        "user protocol": {
          "getNew:from:": "getNew: ignoreText from: aController\n\t\"Reinitialize the information the receiver models by re-reading the file stream.\"\n\n\tself changeRequest ifFalse: [^ aController view flash].\n\tself changed: #text\n",
          "fileItIn:from:": "fileItIn: fullText from: controller\n\t\"Make a Stream on the text selection and fileIn it.\"\n\t| selection |\n\tselection _ controller selection.\n\t(ReadWriteStream on: selection from: 1 to: selection size) fileIn\n",
          "fileInFile": "fileInFile\n\t\"Read the entire file as Smalltalk code.\"\n\n\t(FileStream oldFileNamed: fileName) fileIn.\n"
        },
        "doIt/accept/explain": {
          "doItContext": "doItContext\n\t^ nil\n",
          "doItReceiver": "doItReceiver\n\t^ nil\n",
          "acceptText:from:": "acceptText: aText from: aController\n\t\"Update the contents of the file stream with the receiver's contents.  If the file name does not include an explicit version number, create a new version.\"\n\n\tCursor write showWhile:\n\t\t[((fileName includes: $!)\n\t\t\tifTrue: [FileStream fileNamed: fileName]\n\t\t\tifFalse: [FileStream newFileNamed: fileName]) nextPutAll: aText string; close].\n\t^true\n"
        },
        "private": {
          "setFileStream:": "setFileStream: aStream\n\n\taStream release.\t\t\"close, since later a new file stream will be created\"\n\tfileName _ aStream file fullName\n",
          "setFileName:": "setFileName: fullFileName\n\tfileName _ fullFileName\n"
        },
        "text": {
          "text": "text\n\t| dir localName |\n\tfileName == nil ifTrue: [^nil].\n\tdir _ FileDirectory directoryFromName: fileName setFileName: [:localName].\n\t(dir includesKey: localName) ifFalse:\t\t\"don't create file\"\n\t\t[^'-new file-' asText emphasizeFrom: 2 to: 9 with: 3].\n\t^Cursor read showWhile:\n\t\t[(FileStream oldFileNamed: fileName) contentsOfEntireFile asText]\n",
          "textMenu": "textMenu\n\t\"FileModel flushMenus\"\n\tfileName == nil ifTrue: [^ nil].\n\tTextMenu == nil ifTrue:\n\t\t[TextMenu _ ActionMenu\n\t\t\tlabels: 'again\\undo\\copy\\cut\\paste\\do it\\print it\\file it in\\put\\get' withCRs\n\t\t\tlines: #(2 5 8 10)\n\t\t\tselectors: #(again undo copySelection cut paste doIt printIt fileItIn:from: accept getNew:from:)].\n\t^ TextMenu\n"
        }
      }
    },
    "FileList": {
      "comment": "I an a FileModel that can be viewed as a filtered ListMenu of file names as well as the text of a file.\n\n\tInstance Variables\n\tlist\t\t\t\t<OrderedCollection> of file names\n\tmyPatytern\t\t<String> represtenting the filter to select the list\n",
      "class_name": "FileList",
      "superclass": "FileModel",
      "instanceVariables": "list myPattern isReading",
      "classInstanceVariables": "",
      "classVariables": "FileMenu PatternMenu",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "flushMenus": "flushMenus\t\t\"FileList flushMenus.\"\n\tPatternMenu _ nil.\n\tFileMenu _ nil.\n\tsuper flushMenus\n"
        },
        "instance creation": {
          "open": "open\t\t\"FileList open\"\n\t\"Create and schedule a view of a new instance of me such that the instance references the files named in the argument, aFileNameList, that can be found in the directory, aFileDirectory.\"\n\t| topView aFileList patternView |\n\taFileList _ self new list: OrderedCollection new.\n\ttopView _ StandardSystemView model: aFileList label: 'File List' minimumSize: 200 @ 200.\n\tpatternView _\n\t\tCodeView on: aFileList aspect: #pattern change: #acceptPattern:from:\n\t\t\t\tmenu: #patternMenu initialSelection: nil.\n\ttopView addSubView: patternView in: (0@0 extent: 1@0.07) borderWidth: 1.\n\tpatternView controller: AlwaysAcceptCodeController new.\n\ttopView addSubView:\n\t\t\t(SelectionInListView on: aFileList aspect: #fileName change: #fileName:\n\t\t\t\tlist: #fileNameList menu: #fileListMenu initialSelection: nil)\n\t\tin: (0@0.07 extent: 1@0.23) borderWidth: 1.\n\ttopView addSubView:\n\t\t\t(OnlyWhenSelectedCodeView on: aFileList aspect: #text change: #acceptText:from:\n\t\t\t\tmenu: #textMenu initialSelection: nil selection: #isSelected)\n\t\tin: (0@0.3 extent: 1@0.7) borderWidth: 1.\n\ttopView controller open\n",
          "openOnFileNames:label:": "openOnFileNames: aFileNameList label: labelString\n\t\"Create and schedule a view of a new instance of me such that the\n\tinstance references the files named in the argument, aFileNameList.\"\n\t| topView aFileList |\n\taFileList _ self new list: aFileNameList.\n\ttopView _ StandardSystemView model: aFileList label: labelString minimumSize: 200 @ 200.\n\ttopView addSubView:\n\t\t\t(SelectionInListView on: aFileList aspect: #fileName change: #fileName:\n\t\t\t\tlist: #fileNameList menu: #fileListMenu initialSelection: nil)\n\t\tin: (0@0 extent: 1@0.2) borderWidth: 1.\n\ttopView addSubView:\n\t\t\t(CodeView on: aFileList aspect: #text change: #acceptText:from:\n\t\t\t\tmenu: #textMenu initialSelection: nil)\n\t\tin: (0@0.2 extent: 1@0.8) borderWidth: 1.\n\ttopView controller open\n"
        }
      },
      "instance_methods": {
        "file name list": {
          "fileName:": "fileName: selection\n\t\"If selection is not nil, it is the name of a file to be viewed\"\n\tself setFileName: selection.\n\tisReading _ false.\n\tself changed: #text\n",
          "fileName": "fileName\n\t^ fileName\n",
          "deleteFile": "deleteFile\n\t\"Remove the selected file from its directory.\"\n\n\t| dir localName |\n\tdir _ FileDirectory directoryFromName: fileName setFileName: [:localName].\n\t(dir includesKey: localName)\n\t\tifTrue: [(self confirm: 'really remove the selected file?') ifFalse: [^self].\n\tdir removeKey: localName].\n\tlist remove: fileName.\n\tself changed: #fileName.\n",
          "isSelected": "isSelected\n\t^isReading\n",
          "getFile": "getFile\n\tself changeRequest ifFalse: [^self].\n\tisReading _ true.\n\tself changed: #text\n",
          "copyName": "copyName\n\tParagraphEditor new copySelection: fileName asText\n",
          "renameFile": "renameFile\n\t| newList newName continue |\n\tfileName == nil ifTrue: [^nil].\n\tself changeRequest ifFalse: [^nil].\n\tcontinue _ true.\n\t[continue] whileTrue:\n\t\t[newName _ FillInTheBlank request: 'New name for file?' initialAnswer: fileName.\n\t\tnewName isEmpty ifTrue: [^nil].\n\t\tnewName last = $.\n\t\t\tifTrue: [newName _ newName copyFrom: 1 to: newName size-1].\n\t\t((self isLegalFileName: newName) and: [(Disk includesKey: newName) not])\n\t\t\tifTrue: [continue _ false]\n\t\t\tifFalse: [(BinaryChoice message: 'File exists or bad file name. Try again?')\n\t\t\t\t\t\tifFalse: [^nil]]].\n\tCursor execute showWhile:\n\t\t[newList _ list copyWithout: fileName.\n\t\t(Disk includesKey: fileName)\n\t\t\tifTrue:\n\t\t\t\t[Disk rename: (Disk file: fileName) file newName: newName].\n\t\tfileName _ newName.\n\t\tnewList add: fileName.\n\t\tlist _ newList.\n\t\tself changed: #fileName.\n\t\tself changed: #text]\n",
          "fileNameList": "fileNameList\n\t^ list\n",
          "fileListMenu": "fileListMenu\n\tfileName == nil ifTrue: [^nil].\n\tFileMenu == nil ifTrue:\n\t\t[FileMenu _\n\t\t\tActionMenu\n\t\t\t\tlabels: 'get contents\\file in\\copy name\\rename\\remove' withCRs\n\t\t\t\tlines: #(2 4)\n\t\t\t\tselectors: #(getFile fileInFile copyName renameFile deleteFile)].\n\t^ FileMenu\n\t\"Evaluate this when you change this method:\n\t\tFileList flushMenus\"\n"
        },
        "private": {
          "filesMatching:": "filesMatching: pattern\n\t\"Answer a list of file names matching the pattern string.  Do this by asking the appropriate directory.\"\n\n\t| dir nameBody matches |\n\tdir _ FileDirectory directoryFromName: pattern setFileName: [:nameBody].\n\tmatches _ dir filesMatching: nameBody.\n\t^matches\n",
          "isLegalFileName:": "isLegalFileName: pattern\n\t\"Answer whether pattern is a valid file name.  Do this by asking the appropriate directory.\"\n\n\t| dir nameBody |\n\tdir _ FileDirectory directoryFromName: pattern setFileName: [:nameBody].\n\t^dir isLegalFileName: pattern\n",
          "list:": "list: aList\n\tlist _ aList.\n\tisReading _ false\n"
        },
        "text": {
          "text": "text\n\tisReading\n\t\tifTrue: [^super text]\n\t\tifFalse: [^'' asText]\n"
        },
        "pattern": {
          "patternMenu": "patternMenu\n\t\"FileModel flushMenus\"\n\tPatternMenu == nil ifTrue:\n\t\t[PatternMenu _ ActionMenu\n\t\t\tlabels: 'again\\undo\\copy\\cut\\paste\\accept\\cancel' withCRs\n\t\t\tlines: #(2 5)\n\t\t\tselectors: #(again undo copySelection cut paste accept cancel)].\n\t^ PatternMenu\n",
          "acceptPattern:from:": "acceptPattern: aText from: aController\n\t\"The text consists of file names and file name patterns separated by carriage returns.\n\tPatterns can include the characters * (any chars) and # (any single char).\n\tMake my new list be those file names on my directory which match the patterns.\"\n\n\t| testPattern readStream newList |\n\tCursor execute showWhile:\n\t\t[myPattern _ aText string.\n\t\treadStream _ ReadStream on: myPattern.\n\t\tnewList _ SortedCollection new.\n\t\t[readStream atEnd] whileFalse:\n\t\t\t[testPattern _ readStream upTo: Character cr. \"get next name/pattern\"\n\t\t\ttestPattern last = $.\n\t\t\t\tifTrue: [testPattern _ testPattern copyFrom: 1 to: testPattern size-1].\n\t\t\t(testPattern includes: $*) | (testPattern includes: $#)\n\t\t\t\tifTrue: [newList addAll: (self filesMatching: testPattern)]\n\t\t\t\tifFalse: [(self isLegalFileName: testPattern)\n\t\t\t\t\t\t\tifTrue: [newList add: testPattern]]].\n\t\tlist _ newList.\n\t\tlist isEmpty\n\t\t\tifTrue: [aController deselect; replaceSelectionWith: 'No matching files' asText; select].\n\t\tself changed: #fileName].\n\t^true\n",
          "pattern": "pattern\n\t^ myPattern\n"
        }
      }
    }
  },
  "Interface-Framework": {
    "ControlManager": {
      "comment": "I represent the top level control over scheduling which controller of a view on the screen the user is actively using.  ScheduledControllers is the global reference to an instance of me, the one attached to the Project currently being used.\n\nInstance Variables:\n\tscheduledControllers\t<OrderedCollection> of Controllers, usually ScheduledControllers\n\tactiveController\t\t<Controller> usually a ScheduledController\n\tactiveControllerProcess\t<Process>\n\tscreenController \t<ScreenController> also appears in ScheduledControllers\n",
      "class_name": "ControlManager",
      "superclass": "Object",
      "instanceVariables": "scheduledControllers activeController activeControllerProcess screenController",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "exchange": {
          "newScheduler:": "newScheduler: controlManager\n\t\"When switching projects, the control scheduler has to be exchanged.  The\n\tactive one is the one associated with the current project.\"\n\n\tScheduledControllers deactivate.\n\tSmalltalk at: #ScheduledControllers put: controlManager.\n\tScheduledControllers restore.\n\tcontrolManager searchForActiveController\n"
        },
        "instance creation": {
          "new": "new\n\t^super new initialize\n"
        }
      },
      "instance_methods": {
        "scheduling": {
          "unschedule:": "unschedule: aController\n\t\"Remove the view, aController, from the collection of scheduled controllers.\"\n\n\tscheduledControllers remove: aController ifAbsent: []\n",
          "inActiveControllerProcess": "inActiveControllerProcess\n\t\"Answer whether the active scheduling process is the actual active process in the system.\"\n\n\t^activeControllerProcess == Processor activeProcess\n",
          "scheduleOnBottom:": "scheduleOnBottom: aController\n\t\"Make aController be scheduled as a scheduled controller, but not the active one.\n\tPut it at the end of the ordered collection of controllers.\"\n\n\tscheduledControllers addLast: aController\n",
          "searchForActiveController": "searchForActiveController\n\t\"Find a scheduled controller that wants control and give control to it.  If none\n\twants control, then see if the System Menu has been requested.\"\n\n\t| aController |\n\tactiveController _ nil.\n\tactiveControllerProcess _ Processor activeProcess.\n\t[Processor yield.\n\t aController _ scheduledControllers\n\t\tdetect:\n\t\t\t[:aController |\n\t\t\taController isControlWanted and:\n\t\t\t\t[aController ~~ screenController]]\n\t\tifNone:\n\t\t\t[screenController isControlWanted\n\t\t\t\tifTrue: [screenController]\n\t\t\t\tifFalse: [nil]].\n\taController isNil]\n\t\twhileTrue.\n\tself activeController: aController.\n\tProcessor terminateActive\n",
          "promote:": "promote: aController\n\t\"Make aController be the first scheduled controller in the ordered collection.\"\n\n\tscheduledControllers remove: aController.\n\tscheduledControllers addFirst: aController\n",
          "scheduleActive:": "scheduleActive: aController\n\t\"Make aController be scheduled as the active controller.  Presumably the active\n\tscheduling process asked to schedule this controller and that a new process associated\n\tthis controller takes control.  So this is the last act of the active scheduling process.\"\n\n\tCursor normal show.\n\tself scheduleActiveNoTerminate: aController.\n\tProcessor terminateActive\n",
          "schedulePassive:": "schedulePassive: aController\n\t\"Make aController be scheduled as a scheduled controller, but not the active one.\n\tPut it at the beginning of the ordered collection of controllers.\"\n\n\tscheduledControllers addFirst: aController\n",
          "scheduleActiveNoTerminate:": "scheduleActiveNoTerminate: aController\n\t\"Make aController be the active controller.  Presumably the process that requested\n\tthe new active controller wants to keep control to do more activites before the\n\tnew controller can take control.  Therefore, do not terminate the currently\n\tactive process.\"\n\n\tself schedulePassive: aController.\n\tself scheduled: aController\n\t\tfrom: Processor activeProcess\n",
          "pullBottomToTop": "pullBottomToTop\n\t\"Make the last scheduled view which wants control be the first one.  Used for implementing the message under to a scheduled controller.\"\n\n\tscheduledControllers reverseDo:\n\t\t[:controller |\n\t\t(controller isControlWanted and: [controller ~~ screenController]) ifTrue:\n\t\t\t[^scheduledControllers addFirst: (scheduledControllers remove: controller)]]\n",
          "interruptName:": "interruptName: title\n\t\"Create a Notifier on the active scheduling process whose label is title\n\tMake the Notifier the active controller.\"\n\n\t| newActiveController suspendingList |\n\tsuspendingList _ activeControllerProcess suspendingList.\n\tsuspendingList isNil\n\t\tifTrue: [activeControllerProcess==Processor activeProcess\n\t\t\t\t\t\tifTrue: [activeControllerProcess suspend]]\n\t\tifFalse: [suspendingList remove: activeControllerProcess.\n\t\t\t\t activeControllerProcess offList].\n\tnewActiveController _\n\t\t(NotifierView openInterrupt: title\n\t\t\t\t\t  onProcess: activeControllerProcess)\n\t\t\t\t\t\t\tcontroller.\n\tactiveController ~~ nil\n\t\t\tifTrue: [activeController controlTerminate].\n\tnewActiveController centerCursorInView.\n\tself activeController: newActiveController\n"
        },
        "displaying": {
          "restore": "restore\n\t\"Clear the screen to gray and then redisplay all the scheduled views.\"\n\n\tself unschedule: screenController.\n\tself scheduleOnBottom: screenController.\n\tscreenController view window: Display boundingBox.\n\tscheduledControllers reverseDo:\n\t\t[:aController | aController view display; deEmphasize].\n\tCursor normal show\n"
        },
        "accessing": {
          "activeController:andProcess:": "activeController: aController andProcess: aProcess\n\t\"Set aController to be the currently active controller and aProcess to be the\n\tthe process that is handles controller scheduling activities in the system.\"\n\n\n\tself inActiveControllerProcess\n\t\tifTrue:\n\t\t\t[aController~~nil\n\t\t\t\tifTrue: [(scheduledControllers includes: aController)\n\t\t\t\t\t\t\tifTrue: [self promote: aController]\n\t\t\t\t\t\t\tifFalse: [self error: 'Old controller not scheduled']].\n\t\t\tactiveController controlTerminate.\n\t\t\tactiveController _ aController.\n\t\t\tactiveController == nil\n\t\t\t\tifFalse: [activeController controlInitialize].\n\t\t\tactiveControllerProcess _ aProcess.\n\t\t\tactiveControllerProcess resume]\n\t\tifFalse:\n\t\t\t[self error: 'New active controller process must be set from old one']\n",
          "activeControllerProcess": "activeControllerProcess\n\t\"Answer the process that is currently handling controller scheduling activities\n\tin the system.\"\n\t^activeControllerProcess\n",
          "scheduledControllers": "scheduledControllers\n\t\"Answer a copy of the ordered collection of scheduled controllers.\"\n\t^scheduledControllers copy\n",
          "activeController": "activeController\n\t\"Answer the currently active controller.\"\n\n\t^activeController\n",
          "activeController:": "activeController: aController\n\t\"Set aController to be the currently active controller.  Give the user control in it.\"\n\n\tactiveController _ aController.\n\tself promote: activeController.\n\tactiveControllerProcess _\n\t\t\t[activeController startUp.\n\t\t\tself searchForActiveController] newProcess.\n\tactiveControllerProcess priority: Processor userSchedulingPriority.\n\tactiveControllerProcess resume\n",
          "activeControllerNoTerminate:andProcess:": "activeControllerNoTerminate: aController andProcess: aProcess\n\t\"Set aController to be the currently active controller and aProcess to be the\n\tthe process that handles controller scheduling activities in the system.\n\tThis message differs from activeController:andProcess: in that it does not send\n\tcontrolTerminate to the currently active controller.\"\n\n\n\tself inActiveControllerProcess\n\t\tifTrue:\n\t\t\t[aController~~nil\n\t\t\t\tifTrue: [(scheduledControllers includes: aController)\n\t\t\t\t\t\t\tifTrue: [self promote: aController]\n\t\t\t\t\t\t\tifFalse: [self error: 'Old controller not scheduled']].\n\t\t\tactiveController _ aController.\n\t\t\tactiveController == nil\n\t\t\t\tifFalse: [activeController controlInitialize].\n\t\t\tactiveControllerProcess _ aProcess.\n\t\t\tactiveControllerProcess resume]\n\t\tifFalse:\n\t\t\t[self error: 'New active controller process must be set from old one']\n"
        },
        "private": {
          "deactivate": "deactivate\n\tactiveController _ nil.\n\tactiveControllerProcess _ nil\n",
          "scheduled:from:": "scheduled: aController from: aProcess\n\tactiveControllerProcess==aProcess\n\t\tifTrue:\n\t\t\t[activeController ~~ nil\n\t\t\t\t\tifTrue: [activeController controlTerminate].\n\t\t\taController centerCursorInView.\n\t\t\tself activeController: aController]\n\t\tifFalse:\n\t\t\t[aController view display]\n"
        },
        "initialize-release": {
          "initialize": "initialize\n\t\"Initialize the receiver to refer to only the background controller.\"\n\t| screenView |\n\tscreenController _ ScreenController new.\n\tscreenView _ FormView new.\n\tscreenView model: (InfiniteForm with: Form gray) controller: screenController.\n\tscreenView window: Display boundingBox.\n\tscheduledControllers _ OrderedCollection with: screenController\n",
          "release": "release\n\tscheduledControllers == nil\n\t\tifFalse:\n\t\t\t[scheduledControllers\n\t\t\t\tdo: [:controller | (controller isKindOf: Controller)\n\t\t\t\t\t\t\t\tifTrue: [controller view release]\n\t\t\t\t\t\t\t\tifFalse: [controller release]].\n\t\t\tscheduledControllers _ nil]\n"
        }
      }
    },
    "Controller": {
      "comment": "A Controller coordinates a View, its model, and user actions\n",
      "class_name": "Controller",
      "superclass": "Object",
      "instanceVariables": "model view sensor",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t^super new initialize\n"
        }
      },
      "instance_methods": {
        "sensor access": {
          "sensor:": "sensor: aSensor\n\t\"Set the receiver's sensor to aSensor.\"\n\n\tsensor _ aSensor\n",
          "sensor": "sensor\n\t\"Answer the receiver's sensor.\n\tSubclasses may use other objects that are not instances of Sensor or its subclasses\n\tif more general kinds of input/output functions are required.\"\n\n\t^sensor\n"
        },
        "model access": {
          "model": "model\n\t\"Answer the receiver's model which is the same as the model of the\n\treceiver's view.\"\n\t^model\n",
          "model:": "model: aModel\n\t\"Controller|model: and Controller|view: are sent by View|controller: in order\n\tto coordinate the links between the model, view, and controller. In ordinary\n\tusage, the receiver is created and passed as the parameter to View|controller:\n\tso that the receiver's model and view links can be set up by the view.\"\n\n\tmodel _ aModel\n"
        },
        "cursor": {
          "centerCursorInView": "centerCursorInView\n\t\"Position sensor's mousePoint (which is assumed to be connected to the\n\tcursor) to the center of its view's inset display box (see Sensor|mousePoint: and\n\tView|insetDisplayBox).\"\n\n\t^sensor cursorPoint: view insetDisplayBox center\n",
          "viewHasCursor": "viewHasCursor\n\t| temp |\n\t\"Answer true if the cursor point of the receiver's sensor lies within the inset\n\tdisplay box of the receiver's view (see View|insetDisplayBox), and\n\tanswer false, otherwise. Controller|viewHasCursor is normally used in\n\tinternal methods.\"\n\n\t^view containsPoint: sensor cursorPoint\n"
        },
        "control defaults": {
          "controlToNextLevel": "controlToNextLevel\n\t\"Pass control to the next control level, that is, to the Controller of a subView of\n\tthe receiver's view if possible. The receiver finds the subView (if any) whose controller\n\twants control and sends that controller the message startUp.\"\n\n\t| aView |\n\taView _ view subViewWantingControl.\n\taView ~~ nil ifTrue: [aView controller startUp]\n",
          "isControlWanted": "isControlWanted\n\t\"Answer true if the cursor is inside the inset display box (see\n\tView|insetDisplayBox) of the receiver's view, and answer false,\n\totherwise. It is sent by Controller|controlNextLevel in order to determine\n\twhether or not control should be passed to this receiver from the Controller of\n\tthe superView of this receiver's view.\"\n\n\t^self viewHasCursor\n",
          "isControlActive": "isControlActive\n\t\"Answer whether the receiver wants control.  The default is to take control\n\tif the cursor is inside the view and the blue button is not pressed.  Pressing\n\tblue button a default to explicitly give up control without moving the cursor.\n\tIt is sent by Controller|controlLoop in order to determine when the receiver's control\n\tloop should terminate, and should be redefined in a subclass if some other\n\tcondition for terminating the main control loop is needed.\"\n\n\t^(view containsPoint: sensor cursorPoint) & sensor blueButtonPressed not\n",
          "controlActivity": "controlActivity\n\t\"Pass control to the next control level (that is, to the Controller of a subView of\n\tthe receiver's view) if possible. It is sent by Controller|controlLoop each time\n\tthrough the main control loop. It should be redefined in a subclass if some other\n\taction is needed.\"\n\n\tself controlToNextLevel\n"
        },
        "basic control sequence": {
          "startUp": "startUp\n\t\"Give control to the receiver. The default control sequence is to initialize\n\t(see Controller|controlInitialize), to loop (see Controller|controlLoop), and\n\tthen to terminate (see Controller|controlTerminate). After this sequence,\n\tcontrol is returned to the sender of Control|startUp. The receiver's control\n\tsequence is used to coordinate the interaction of its view and model. In general,\n\tthis consists of polling the sensor for user input, testing the input with respect\n\tto the current display of the view, and updating the model to reflect intended\n\tchanges.\"\n\n\tself controlInitialize.\n\tself controlLoop.\n\tself controlTerminate\n",
          "controlLoop": "controlLoop\n\t\"Sent by Controller|startUp as part of the standard control sequence.\n\tController|controlLoop sends the message Controller|isControlActive to test\n\tfor loop termination. As long as true is returned, the loop continues. When\n\tfalse is returned, the loop ends. Each time through the loop, the message\n\tController|controlActivity is sent.\"\n\n\t[self isControlActive] whileTrue: [Processor yield. self controlActivity]\n",
          "controlInitialize": "controlInitialize\n\t\"Sent by Controller|startUp as part of the standard control sequence. It provides\n\ta place in the standard control sequence for initializing the receiver\n\t(taking into account the current state of its model and view). It should be\n\tredefined in subclasses to perform some specific action.\"\n\t^self\n",
          "controlTerminate": "controlTerminate\n\t\"Provide a place in the standard control sequence for terminating the\n\treceiver (taking into account the current state of its model and view). It\n\tshould be redefined in subclasses to perform some specific action.\"\n\t^self\n"
        },
        "view access": {
          "view": "view\n\t\"Answer the receiver's view.\"\n\t^view\n",
          "view:": "view: aView\n\t\"Controller|view: and Controller|model: are sent by View|controller: in order\n\tto coordinate the links between the model, view, and controller. In ordinary\n\tusage, the receiver is created and passed as the parameter to View|controller:\n\tand the receiver's model and view links are set up automatically by the view.\"\n\n\tview _ aView\n"
        },
        "initialize-release": {
          "initialize": "initialize\n\t\"Initializes the state of the receiver.  Subclasses should include\n\t'super initialize' when redefining this message to insure proper initialization.\"\n\tsensor _ InputSensor default\n",
          "release": "release\n\t\"Breaks the cycle between the receiver and its view. It is usually not\n\tnecessary to send release provided the receiver's view has been properly\n\treleased independently.\"\n\n\tsuper release.\n\tview ~= nil\n\t\tifTrue:\n\t\t\t[view controller: nil.\n\t\t\tview _ nil]\n"
        }
      }
    },
    "NoController": {
      "comment": "I represent a controller that never wants control.  I am the controller for views that are non-interactive.\n",
      "class_name": "NoController",
      "superclass": "Controller",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "control defaults": {
          "isControlWanted": "isControlWanted\n\t^false\n",
          "isControlActive": "isControlActive\n\t^false\n"
        },
        "basic control sequence": {
          "startUp": "startUp\n\t\"I do nothing.\"\n\t^self\n"
        }
      }
    },
    "View": {
      "comment": "My instances are intended to be components in a  structured picture.  Each View in the structured picture can contain other Views as sub-components.  These sub-components are called subViews.  A View can be a subView of only one View.  This View is called its superView.  The set of Views in a structured picture forms a hierarchy.  The one View in the hierarchy that has no superView is called the topView of the structured picture.  A View in a structured picture with no subViews is called a bottom View.  A View and all of its subViews, and all of their subViews and so on, are treated as a unit in many operations on the View.  For example, if a View is displayed, all of its subViews are displayed as well.  There are several catagories of operations that can be performed on a View.  Among these are the following.\n\t1.\tAdding subViews to a View.\n\t2.\tPositioning subViews within a View.\n\t3.\tDeleting subViews from a View.\n\t4.\tTransforming a View.\n\t5.\tDisplaying a View.\n\nEach View has its own coordinate system.   In order to change from one coordinate system to another, each View has two transformations associated with it.  The local transformation is a WindowingTransformation that maps objects in the coordinate system of the View to objects in the coordinate system of the superView of the View.  The displayTransformation is a WindowingTransformation that maps objects in the coordinate system of the View to objects in the display screen coordinate system.\n\nThe part of the space that is to be made visible is represented by the window of the View.  The window of a View is a Rectangle expressed in the coordinate system of the View.  The area occupied by a View in the coordinate system of its superView is called its viewport.  The viewport of a View is its window transformed by its local transformation.  The region of the display screen occupied by a View is called its displayBox.  The display box of a View can include a border.  The width of the border expressed in display screen coordinates is called the border width of the View.  The color of the border is called the border color.  The region of the display box of a View excluding the border is called the inset display box.  The color of the inset display box is called the inside color of the View.\n\nmodel - any object\ncontroller - <Controller>, #NoControllerAllowed, or nil\nsuperView - <View>, or nil\nsubViews - <OrderedCollection> of Views\ntransformation - <WindowingTransformation>\nviewport - <Rectangle> (in superView coordinates), or nil.\nwindow - <Rectangle> (in View coordinates), or nil.\ndisplayTransformation - <WindowingTransformation>, or nil.\ninsetDisplayBox - <Rectangle> (in display screen coordinates), or nil.\nborderWidth - <Rectangle> (display screen unit) or 0 (meaning no border).\nborderColor - <Form>\ninsideColor - <Form>, or nil (meaning transparent)\nboundingBox - <Rectangle> (in View coordinates), or nil\n",
      "class_name": "View",
      "superclass": "Object",
      "instanceVariables": "model controller superView subViews transformation viewport window displayTransformation insetDisplayBox borderWidth borderColor insideColor boundingBox",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t\"Answer an initialized instance of me.  The transformation is an identity\n\ttransformation, the borderWidth is 0, the borderColor is black, and the\n\tinsideColor is transparent.\"\n\n\t^super new initialize\n",
          "identityTransformation": "identityTransformation\n\t\"Answer an instance of me with no translation and unity scaling. \"\n\n\t^WindowingTransformation identity\n"
        }
      },
      "instance_methods": {
        "deEmphasizing": {
          "deEmphasizeSubViews": "deEmphasizeSubViews\n\t\"Send the deEmphasize message to each of the receiver's subviews.\"\n\tsubViews do: [:aSubView | aSubView deEmphasize]\n",
          "deEmphasize": "deEmphasize\n\t\"Modify the emphasis (highlighting, special tabs) of the receiver.  This includes\n\tobjects such as labels, lines, and boxes.  Typically used so that the receiver is not\n\tpresented as active.  Do this for the receiver and then for each of the receiver's\n\tsubViews.\"\n\n\tself deEmphasizeView.\n\tself deEmphasizeSubViews\n",
          "deEmphasizeView": "deEmphasizeView\n\t\"Subclasses should redefine View|deEmphasizeView in order to modify\n\tthe emphasis (highlighting, special tabs) of particular objects associated\n\twith the View such as labels, lines, and boxes.\"\n\t^self\n",
          "emphasizeSubViews": "emphasizeSubViews\n\t\"Send the emphasize message to each of the receiver's subviews.\"\n\tsubViews do: [:aSubView | aSubView emphasize]\n",
          "emphasizeView": "emphasizeView\n\t\"Subclasses should redefine View|emphasizeView in order to modify\n\tthe emphasis (highlighting, special tabs) of particular objects associated\n\twith the View such as labels, lines, and boxes.\"\n\t^self\n",
          "emphasize": "emphasize\n\t\"Modify the emphasis (highlighting, special tabs) of the receiver.  This includes\n\tobjects such as labels, lines, and boxes.  Typically used so that the receiver is not\n\tpresented as active.  Do this for the receiver and then for each of the receiver's\n\tsubViews.\"\n\n\tself emphasizeView.\n\tself emphasizeSubViews\n"
        },
        "subView removing": {
          "removeSubViews": "removeSubViews\n\t\"Remove all the receiver's subViews.\"\n\n\tsubViews do:\n\t\t[:aView |\n\t\taView superView: nil.\n\t\taView unlock].\n\tself resetSubViews\n",
          "releaseSubView:": "releaseSubView: aView\n\t\"Delete aView from the receiver's list of subViews and send it the message\n\t'release' (so that it can break up cycles with subViews, etc.)\"\n\n\tself removeSubView: aView.\n\taView release\n",
          "releaseSubViews": "releaseSubViews\n\t\"Release (see View|releaseSubView: ) all subViews in the receiver's list of\n\tsubViews.\"\n\n\tsubViews do: [:aView | aView release].\n\tself resetSubViews\n",
          "removeFromSuperView": "removeFromSuperView\n\t\"Delete the receiver from its superView's collection of subViews.\"\n\n\tsuperView ~= nil ifTrue: [superView removeSubView: self]\n",
          "removeSubView:": "removeSubView: aView\n\t\"Remove aView from the receiver's list of subViews.\n\t If the list of subViews does not contain aView, an error window is created.\"\n\n\tsubViews remove: aView.\n\taView superView: nil.\n\taView unlock\n"
        },
        "bordering": {
          "borderColor:": "borderColor: aColor\n\t\"Set the receiver's border color to aColor.\"\n\tborderColor _ aColor\n",
          "borderColor": "borderColor\n\t\"Answer the receiver's border color.\"\n\t^borderColor\n",
          "borderWidthLeft:right:top:bottom:": "borderWidthLeft: anInteger1 right: anInteger2 top: anInteger3 bottom: anInteger4\n\t\"Set the border widths of the receiver to a Rectangle made up of the four\n\targuments.  These arguements represent the left, right, top, and bottom border\n\twidths.\"\n\n\tborderWidth _\n\t\t\tRectangle\n\t\t\t\tleft: anInteger1\n\t\t\t\tright: anInteger2\n\t\t\t\ttop: anInteger3\n\t\t\t\tbottom: anInteger4.\n\tself unlock\n",
          "insideColor": "insideColor\n\t\"Answer the inside color of the receiver. The inside color determines the color of\n\tthe inside of the receiver, which is the area inside the receiver's window excluding\n\tthe border. The inside color is initially nil (meaning transparent), which\n\tmeans that when the receiver is displayed, the inside region will not be affected.\"\n\n\t^insideColor\n",
          "borderWidth:": "borderWidth: borderValue\n\t\"Set the four border widths of the receiver to anInteger or rectangle.\"\n\n\t(borderValue isKindOf: Rectangle)\n\t\t\tifTrue:\t[borderWidth _ borderValue.\n\t\t\t\t\tself unlock]\n\t\t\tifFalse:\t[self\n\t\t\t\t\tborderWidthLeft: borderValue\n\t\t\t\t\tright: borderValue\n\t\t\t\t\ttop: borderValue\n\t\t\t\t\tbottom: borderValue].\n",
          "insideColor:": "insideColor: aColor\n\t\"Set the inside color of the receiver to be aColor.\"\n\n\tinsideColor _ aColor\n",
          "borderWidth": "borderWidth\n\t\"Answer either 0, indicating no border, or a Rectangle whose\n\tleft value is the width in display coordinates of the receiver's left border.\n\tRight, top, and bottom widths are analogous.\n\tThe border width is initially 0. A View with a border width of 0 will not have\n\tany border displayed.\"\n\n\t^borderWidth\n"
        },
        "model access": {
          "model": "model\n\t\"Answer the receiver's model.\"\n\t^model\n",
          "model:": "model: aModel\n\t\"Set the receiver's model to aModel.  The model of the receiver's controller is also\n\tset to aModel.\"\n\n\tself model: aModel controller: controller\n"
        },
        "basic control sequence": {
          "subViewWantingControl": "subViewWantingControl\n\t\"Answer the first subView that has a controller that now wants control.\"\n\n\tsubViews reverseDo:\n\t\t[:aSubView | aSubView controller isControlWanted ifTrue: [^aSubView]].\n\t^nil\n"
        },
        "lock access": {
          "lock": "lock\n\t\"'Lock' the receiver and all of its subViews (see View|isLocked). This has the effect\n\tof computing and storing the display transformation (see View|displayTransformation)\n\tand inset display box (see View|insetDisplayBox) of the receiver and all its subViews.\n\t The locking and unlocking of a View is handled automatically by the internal\n\tmethods of the View, but can also be done explicitly if desired.\"\n\n\tself isLocked ifTrue: [^self].\n\tdisplayTransformation _ self computeDisplayTransformation.\n\tinsetDisplayBox _ self computeInsetDisplayBox.\n\tsubViews do: [:aSubView | aSubView lock]\n",
          "isLocked": "isLocked\n\t\"Answer whether the receiver is locked.\n\tA View is 'locked' if its display transformation and inset display box are\n\tdefined. If these are undefined, the View is 'unlocked'. The display\n\ttransformation and inset display box become undefined when the\n\ttransformation of the View (or the transformation of a View in its superView\n\tchain) is changed, or when the superView of the View is changed, or any\n\tother change to the View that affects the display screen coordinates of the\n\tView. The locking and unlocking of a View is handled automatically by the\n\tinternal methods of the View, but can also be done explicitly if desired (see\n\tView|lock, and View|unlock).\"\n\n\tdisplayTransformation == nil | (insetDisplayBox == nil)\n\t\tifTrue: [^false]\n\t\tifFalse: [^true]\n",
          "isUnlocked": "isUnlocked\n\t\"Answer whether the receiver is unlocked.\n\tSee comment in View|isLocked.\"\n\n\t^displayTransformation == nil & (insetDisplayBox == nil)\n",
          "unlock": "unlock\n\t\"'Unlock the receiver and all of its subViews (see View|isUnlocked). This has the\n\teffect of forcing the display transformation (see View|displayTransformation) and\n\tinset display box (see View|insetDisplayBox) of the receiver and all its subViews to\n\tbe recomputed the next time they are referenced. The locking and unlocking of a\n\tView is handled automatically by the internal methods of the View, but can also be\n\tdone explicitly if desired.\"\n\n\tself isUnlocked ifTrue: [^self].\n\tdisplayTransformation _ nil.\n\tinsetDisplayBox _ nil.\n\tsubViews do: [:aSubView | aSubView unlock]\n"
        },
        "window access": {
          "defaultWindow": "defaultWindow\n\t\"Build the minimum Rectangle that encloses all the windows of the receiver's\n\tsubViews. The answer is a Rectangle obtained by expanding this\n\tminimal Rectangle by the borderWidth of the receiver. If the receiver has no\n\tsubViews, then a Rectangle enclosing the entire display screen is answered.\n\tIt is used internally by View methods if no window has been specified for the\n\tView.  Specialized subclasses of View should redefine\n\tView|defaultWindow to handle the default case for instances that have no\n\tsubViews. \"\n\n\t| aRectangle |\n\tsubViews isEmpty ifTrue: [^DisplayScreen boundingBox].\n\taRectangle _ self firstSubView viewport.\n\tsubViews do: [:aView | aRectangle _ aRectangle merge: aView viewport].\n\t^aRectangle expandBy: borderWidth\n",
          "window:": "window: aWindow\n\t\"Set the receiver's window to a copy of aWindow.\"\n\tself setWindow: aWindow copy\n",
          "window": "window\n\t\"Answer a copy of the receiver's window.\"\n\t^self getWindow copy\n",
          "insetWindow": "insetWindow\n\t\"Answer a Rectangle that is obtained by insetting the receiver's window\n\trectangle by the border width.\"\n\n\t^self getWindow insetBy: borderWidth\n"
        },
        "transforming": {
          "align:with:": "align: aPoint1 with: aPoint2\n\t\"Add a translation of (aPoint2 - aPoint1) to the receiver's local transformation.\n\tThe point in the receiver's coordinate system that previously was transformed\n\tto aPoint1 in the superView's coordinate system will now be transformed to\n\taPoint2 in the superView's coordinate system. Other points will be translated\n\tby the same amount. It is normally used when adding subViews to their\n\tsuperView in order to line up the Viewport of one subView with that of\n\tanother subView (see View|addSubView:align:with:). aPoint1 and aPoint2\n\tare usually points on the viewports that are to be aligned. For example,\n\t'subView2 align: subView2 viewport topLeft with: subView1 viewport\n\ttopRight' would be used to place the viewport of subView2 next to the\n\tviewport of subView1 with the topLeft and topRight corners, respectively,\n\tcoinciding. It is also possible to align the viewport of a subView with the\n\twindow of the superView, e.g. 'subView align: subView viewport center\n\twith: superView window center'. View|align:with: assumes that the view\n\thas been properly scaled, if necessary, to match its superView (see\n\tView|scaleBy:). Typically, the coordinate systems of the receiver and its\n\tsuperView will differ only by a translation offset so that no scaling is\n\tnecessary. \"\n\n\tself setTransformation: (transformation align: aPoint1 with: aPoint2)\n",
          "window:viewport:": "window: aWindow viewport: aViewport\n\t\"Set the receiver's window to aWindow, set its viewport to aViewport, and\n\tcreate a new local transformation for the receiver based on aWindow and\n\taViewport. The receiver is scaled and translated so that aWindow, when\n\ttransformed, coincides with aViewport.\n\tIt is used to position a subView's window within some specific region of its\n\tsuperView's area. For example, 'subView window: aRectangle1 viewport:\n\taRectangle2' sets subView's window to aRectangle1, its viewport to\n\taRectangle2, and its local transformation to one that transforms aRectangle1\n\tto aRectange2.\"\n\n\tself window: aWindow.\n\tself setTransformation:\n\t\t(WindowingTransformation window: aWindow viewport: aViewport).\n\tself getViewport\n",
          "transform:": "transform: anObject\n\t\"Apply the local transformation of the receiver to anObject and answer the\n\tresulting transformation.  It is used to get the superView coordinates of an object.\n\tFor example, the viewport is equal to the window transformed.\"\n\n\t^transformation applyTo: anObject\n",
          "transformation:": "transformation: aTransformation\n\t\"Set the receiver's local transformation to a copy of aTransformation, unlock the\n\treceiver (see View|unlock) and set the viewport to undefined (this forces it to be\n\trecomputed when needed).\"\n\n\tself setTransformation: aTransformation copy\n",
          "transformation": "transformation\n\t\"Answer a copy of the receiver's local transformation.\"\n\t^transformation copy\n",
          "scaleBy:": "scaleBy: aScale\n\t\"The x component of aScale (a Point) specifies the scale in the x direction;\n\tthe y component specifies the scale in the y direction. aScale can, optionally,\n\tbe an instance of Integer or Float in order to specify uniform scaling in both\n\tdirections. Scales the View by aScale. The scale is concatenated with the current\n\ttransformation of the receiver and is applied when View|transform is sent. This\n\thappens automatically in the process of displaying the receiver, for example.\"\n\n\tself setTransformation: (transformation scaleBy: aScale)\n",
          "scale:translation:": "scale: aScale translation: aTranslation\n\t\"The x component of aScale (a Point) specifies the scale (translation) in the\n\tx direction; the y component specifies the scale (translation) in the y direction.\n\taScale can optionally be an instance of Integer or Float in order to specify uniform\n\tscaling in both directions.\n\n\tCreate a new local transformation for the receiver with a scale factor of aScale and\n\ta translation offset of aTranslation. When the transformation is applied (see\n\tView|transform:), the scale is applied first, followed by the translation. It is\n\ttypically used when building a superView from its subViews in order to line\n\tup the viewports of the subViews in the desired way. If no scaling is required\n\tbetween subView and superView, then View|align:with: is often more\n\tconvenient to use.\"\n\n\tself setTransformation:\n\t\t(WindowingTransformation scale: aScale translation: aTranslation)\n",
          "translateBy:": "translateBy: aPoint\n\t\"Translate the receiver by aPoint. The translation is concatenated with the\n\tcurrent transformation of the receiver and is applied when View|transform is\n\tsent. This happens automatically in the process of displaying the receiver.\"\n\n\tself setTransformation: (transformation translateBy: aPoint)\n"
        },
        "subView inserting": {
          "addSubView:in:borderWidth:": "addSubView: aView in: aRelativeRectangle borderWidth: width\n\n\t\"I make 'aView' into a subview. I use 'aRelativeRectangle' and the super view's window to compute (1) a viewport within the superview for 'aView' and (2) the window extent for 'aView'.\nNote: defining the windowing transformation and deriving the viewport is logically equivalent but does not seem to be easily done\"\n\n\t| subViewPort subWindow |\n\tself addSubView: aView ifCyclic: [self error: 'cycle in subView structure.'].\n\taView borderWidth: width.\n\tsubViewPort _ self window extent * aRelativeRectangle origin\n\t\t\tcorner: self window extent * aRelativeRectangle corner.\n\tsubWindow _ 0 @ 0 extent: (self window extent * aRelativeRectangle extent).\n\taView window: subWindow viewport: subViewPort\n",
          "addSubView:ifCyclic:": "addSubView: aView ifCyclic: exceptionBlock\n\t\"Remove aView from the tree of Views it is in (if any) and add it to the rear of the\n\tlist of subViews of the receiver.  Set the superView of aView to be the receiver.\n\tIt is typically used to build up a hierarchy of Views (a structured picture). An\n\terror is generated if aView is the same as the receiver or its superView, etc.\"\n\n\t(self isCyclic: aView)\n\t\tifTrue: [exceptionBlock value]\n\t\tifFalse:\n\t\t\t[aView removeFromSuperView.\n\t\t\tsubViews addLast: aView.\n\t\t\taView superView: self]\n",
          "addSubView:below:": "addSubView: aSubView below: lowerView\n\t\"Adds aView (see View|addSubView:) so that it lies below lowerView\"\n\tself addSubView: aSubView\n\t\talign: aSubView viewport topLeft\n\t\twith: lowerView viewport bottomLeft\n",
          "addSubView:window:viewport:": "addSubView: aView window: aWindow viewport: aViewport\n\t\"Add aView to the receiver's list of subViews (see View|addSubView:) and\n\tapplies to aView a scale and translation computed from aWindow and\n\taViewport (such that aWindow fills aViewport).\"\n\n\tself addSubView: aView.\n\taView window: aWindow viewport: aViewport\n",
          "addSubView:toLeftOf:": "addSubView: aSubView toLeftOf: rightView\n\t\"Adds aView (see addSubView:) so that it lies to the left of rightView.\"\n\tself addSubView: aSubView\n\t\talign: aSubView viewport topRight\n\t\twith:  rightView viewport topLeft\n",
          "insertSubView:before:ifCyclic:": "insertSubView: aView before: anotherView ifCyclic: exceptionBlock\n\t\"Remove aView from the tree of Views it is in (if any) and add it to the rear of the list of subViews of the receiver.  Set the superView of aView to be the receiver.   It is typically used to build up a hierarchy of Views (a structured picture). An  error is generated if aView is the same as the receiver or its superView, etc.\"\n\n\t(self isCyclic: aView)\n\t\tifTrue: [exceptionBlock value]\n\t\tifFalse:\n\t\t\t[aView removeFromSuperView.\n\t\t\tsubViews add: aView before: anotherView.\n\t\t\taView superView: self]\n",
          "addSubView:above:": "addSubView: aSubView above: lowerView\n\t\"Adds aView (see View|addSubView:) so that it lies above lowerView\"\n\tself addSubView: aSubView\n\t\talign: aSubView viewport bottomLeft\n\t\twith: lowerView viewport topLeft\n",
          "addSubView:toRightOf:": "addSubView: aSubView toRightOf: leftView\n\t\"Adds aView (see addSubView:) so that it lies to the right of leftView\"\n\tself addSubView: aSubView\n\t\talign: aSubView viewport topLeft\n\t\twith: leftView viewport topRight\n",
          "addSubView:viewport:": "addSubView: aView viewport: aViewport\n\t\"Add aView to the receiver's list of subViews (see View|addSubView:) and\n\tapplies to aView a scale and translation computed from its window and\n\taViewport (such that its window fills aViewport).\"\n\n\tself addSubView: aView.\n\taView window: aView window viewport: aViewport\n",
          "insertSubView:above:": "insertSubView: aSubView above: lowerView\n\t\"Adds aView (see View|addSubView:) so that it lies above lowerView\"\n\tself insertSubView: aSubView before: lowerView ifCyclic: [self error: 'cycle in subView structure.'].\n\taSubView\n\t\talign: aSubView viewport bottomLeft\n\t\t\twith: lowerView viewport topLeft.\n",
          "addSubView:align:with:": "addSubView: aSubView align: aPoint1 with: aPoint2\n\t\"Add aView to the receiver's list of subViews (see View|addSubView:) and\n\ttranslate aView so that aPoint1 coincides with aPoint2. It is typically used to\n\tbuild up a hierarchy of Views (a structured picture). Normally, aPoint1 is a\n\tpoint on aView's viewport (e.g. aView viewport topLeft, etc.), and aPoint2 is\n\teither an arbitrary point in the receiver's coordinate system or a point on the\n\treceiver's window (e.g. self window topRight, etc).\"\n\n\tself addSubView: aSubView.\n\taSubView align: aPoint1 with: aPoint2\n",
          "addSubView:": "addSubView: aView\n\t\"Remove aView from the tree of Views it is in (if any) and adds it to the rear\n\tof the list of subViews of the receiver.  Set the superView of aView to be the\n\treceiver. It is typically used to build up a hierarchy of Views (a structured\n\tpicture). An error is generated if aView is the same as the receiver or its\n\tsuperView, etc.\"\n\n\tself addSubView: aView ifCyclic: [self error: 'cycle in subView structure.']\n"
        },
        "updating": {
          "update:": "update: aParameter\n\t\"Normally sent by the receiver's model (via 'View|update') in order to notify the\n\treceiver that the state of the model has changed.\n\tView|update: should be redefined in a subclass if some specific action is to take\n\tplace when the model changes. A typical action that might be required is to\n\tredisplay the receiver.\"\n\n\t^self\n",
          "update": "update\n\t\"Normally sent by the receiver's model in order to notify the receiver of a change in\n\tthe model's state.  Subclasses implement this message to do particular update actions.\"\n\n\tself update: self\n"
        },
        "displaying": {
          "inspect": "inspect\n\t\"Build an inspector of my model, me, and my controller.\"\n\n\t| topView titleView className |\n\ttopView _ StandardSystemView model: nil label: 'MVC inspector'\n\t\tminimumSize: 250 @ 250.\n\n\ttitleView _ StringHolderView new.\n\tclassName _ model class name.\n\ttitleView model: (StringHolder new contents: '\tModel: ',\n\t\t\t((className at: 1) isVowel ifTrue: ['an '] ifFalse: ['a ']), className).\n\ttitleView controller: Controller new.\n\ttopView addSubView: titleView\n\t\tin: (0@0 extent: 1@0.06) borderWidth: 1.\n\tInspectorView view: (Inspector inspect: model)\n\t\tin: (0@0.06 extent: 1@0.34) of: topView.\n\n\ttitleView _ StringHolderView new.\n\tclassName _ self class name.\n\ttitleView model: (StringHolder new contents: '\tView: ',\n\t\t\t((className at: 1) isVowel ifTrue: ['an '] ifFalse: ['a ']), className).\n\ttitleView controller: Controller new.\n\ttopView addSubView: titleView\n\t\tin: (0@0.4 extent: 1@0.06) borderWidth: 1.\n\tInspectorView view: (Inspector inspect: self)\n\t\tin: (0@0.46 extent: 1@0.24) of: topView.\n\n\ttitleView _ StringHolderView new.\n\tclassName _ controller class name.\n\ttitleView model: (StringHolder new contents: '\tController: ',\n\t\t\t((className at: 1) isVowel ifTrue: ['an '] ifFalse: ['a ']), className).\n\ttitleView controller: Controller new.\n\ttopView addSubView: titleView\n\t\tin: (0@0.7 extent: 1@0.06) borderWidth: 1.\n\tInspectorView view: (Inspector inspect: controller)\n\t\tin: (0@0.76 extent: 1@0.24) of: topView.\n\n\ttopView controller open\n",
          "displayView": "displayView\n\t\"Subclasses should redefine View|displayView in order to display particular\n\tobjects associated with the View such as labels, lines, boxes, etc.\"\n\t^self\n",
          "displaySubViews": "displaySubViews\n\t\"Display all the subViews of the receiver.\"\n\n\tsubViews do: [:aSubView | aSubView display]\n",
          "displayBorder": "displayBorder\n\t\"Display the receiver's border (using the receiver's borderColor).\"\n\n\tborderWidth = 0\n\t\tifTrue:\n\t\t\t[insideColor == nil\n\t\t\t\tifFalse:\n\t\t\t\t\t[Display fill: self displayBox mask: insideColor]]\n\t\tifFalse:\n\t\t\t[insideColor == nil\n\t\t\t\tifTrue:\n\t\t\t\t\t[superView isNil\n\t\t\t\t\t\tifTrue:\t[Display\n\t\t\t\t\t\t\t\tborder: self displayBox\n\t\t\t\t\t\t\t\twidthRectangle: borderWidth\n\t\t\t\t\t\t\t\tmask: borderColor]\n\t\t\t\t\t\tifFalse:\t[Display\n\t\t\t\t\t\t\t\tborder: self displayBox\n\t\t\t\t\t\t\t\twidthRectangle: borderWidth\n\t\t\t\t\t\t\t\tmask: borderColor\n\t\t\t\t\t\t\t\tclippingBox: superView insetDisplayBox]]\n\t\t\t\tifFalse:\n\t\t\t\t\t[Display fill: self displayBox mask: borderColor.\n\t\t\t\t\tDisplay fill: self insetDisplayBox mask: insideColor]]\n",
          "display": "display\n\t\"Display the receiver's border, display the receiver, then display\n\tthe subViews of the receiver.\n\tCan be sent to the top View of a structured picture in order to display the entire\n\tstructure, or to any particular View in the structure in order to display that\n\tView and its subViews. It is typically sent in response to an update request to\n\ta View.\"\n\n\tself displayBorder.\n\tself displayView.\n\tself displaySubViews\n"
        },
        "indicating": {
          "flash": "flash\n\t\"Cause the inset display box (the display box excluding the border, see\n\tView|insetDisplayBox) of the receiver to complement twice in succession.\"\n\n\tDisplay flash: self insetDisplayBox\n",
          "highlight": "highlight\n\t\"Cause the inset display box (the display box excluding the border, see\n\tView|insetDisplayBox) of the receiver to complement.\"\n\n\tDisplay reverse: self insetDisplayBox\n"
        },
        "testing": {
          "containsPoint:": "containsPoint: aPoint\n\t\"Answer true if aPoint is within the receiver's display box,\n\tand answer false, otherwise. It is sent to a View's\n\tsubViews by View|subViewAt: in order to determine which subView\n\tcontains the cursor point (so that, for example, control can be pass down to\n\tthat subView's controller).\"\n\n\t^self displayBox containsPoint: aPoint\n"
        },
        "display transformation": {
          "displayTransformation": "displayTransformation\n\t\"Answer a WindowingTransformation that is the result of composing all local\n\ttransformations in the receiver's superView chain with the receiver's own local\n\ttransformation. The resulting transformation transforms objects in the\n\treceiver's coordinate system into objects in the display screen coordinate\n\tsystem. \"\n\n\tdisplayTransformation == nil\n\t\tifTrue: [displayTransformation _ self computeDisplayTransformation].\n\t^displayTransformation\n",
          "displayTransform:": "displayTransform: anObject\n\t\"Apply the display transformation of the receiver to anObject (see\n\tView|displayTransformation) and answer the resulting scaled, translated\n\tobject. It is normally applied to Rectangles, Points, and other objects with\n\tcoordinates defined in the View's local coordinate system in order to get a\n\tcorresponding object in display coordinates.\"\n\n\t^(self displayTransformation applyTo: anObject) rounded\n",
          "inverseDisplayTransform:": "inverseDisplayTransform: aPoint\n\t\"Answer a point that is obtained from aPoint by applying to it the inverse of the\n\treceiver's display transformation.  It is typically used by the Controller of the\n\treceiver in order to convert a point in display coordinates, such as the cursor point,\n\tto the local coordinate system of the receiver.\"\n\n\t^self displayTransformation applyInverseTo: aPoint\n"
        },
        "private": {
          "getController": "getController\n\t\"Returns the View's controller if one exists. nil indicates that the\n\tdefault controller is to be used.\"\n\n\t^controller\n",
          "setTransformation:": "setTransformation: aTransformation\n\t\"Sets the View's local transformation to aTransformation, unlocks the View\n\t(see View|unlock) and sets the viewport to undefined (this forces it to be\n\trecomputed when needed).  Should be used instead of setting the\n\ttransformation directly.\"\n\n\ttransformation _ aTransformation.\n\tself unlock.\n\tviewport _ nil\n",
          "computeInsetDisplayBox": "computeInsetDisplayBox\n\t\"Compute the View's inset display box by intersecting the superView's inset\n\tdisplay box with the View's window transformed to display coordinates and\n\tthen inseting the result by the border width. It is sent by\n\tView|insetDisplayBox if the inset display box is nil.\"\n\n\tself isTopView\n\t\tifTrue:\n\t\t\t[^(self displayTransform: self getWindow) insetBy: borderWidth]\n\t\tifFalse:\n\t\t\t[^(superView insetDisplayBox\n\t\t\t\tintersect: (self displayTransform: self getWindow))\n\t\t\t\t\t\tinsetBy: borderWidth]\n",
          "superView:": "superView: aView\n\t\"Sets the View's superView to aView and unlocks the View (see View|unlock).\n\tIt is sent by View|addSubView:  in order to properly set all the links.\"\n\n\tsuperView _ aView.\n\tself unlock\n",
          "setWindow:": "setWindow: aWindow\n\t\"Sets the View's window to aWindow and unlocks the View (see View|unlock).\n\tView|setWindow should be used by methods of View and subclasses to set the\n\tView window (rather than directly setting the instance variable) to insure\n\tthat the View is unlocked.\"\n\n\twindow _ aWindow.\n\tviewport _ nil.\n\tself unlock\n",
          "isCyclic:": "isCyclic: aView\n\t\"Answers true if aView is the same as this View or its superView, false\n\totherwise. \"\n\n\tself == aView ifTrue: [^true].\n\tself isTopView ifTrue: [^false].\n\t^superView isCyclic: aView\n",
          "getViewport": "getViewport\n\t\"Returns the Rectangle representing the View's viewport (in the coordinate\n\tsystem of the superclass). If no viewport has been specified, the View's\n\twindow transformed into the superView's coordinate system is saved and\n\treturned. It should be used by methods of View and subclasses (instead of\n\tdirectly referring to the viewport) unless it is known that a viewport actually\n\texists. It should not be used outside of View or subclasses because the\n\tviewport is not sharable.\"\n\n\tviewport == nil ifTrue: [viewport _ self transform: self getWindow].\n\t^viewport\n",
          "computeDisplayTransformation": "computeDisplayTransformation\n\t\"Returns a WindowingTransformation that transforms the coordinate\n\tsystem of the View into that of the display screen. The transformation is\n\tcomputed by composing the View's transformation with all transformations\n\talong its superView chain.\n\tIt is sent by View|displayTransformation when the View is unlocked (see\n\tView|unlock).\"\n\n\tself isTopView\n\t\tifTrue: [^transformation]\n\t\tifFalse: [^superView displayTransformation compose: transformation]\n",
          "getWindow": "getWindow\n\t\"Returns the Rectangle that represents the window of this View. If no window\n\thas been specified, a default window (see View|defaultWindow) is created,\n\tsaved, and returned.\n\tShould be used by methods of View and subclasses to access the View window\n\tinstead of directly accessing the field unless it is known that a window\n\tactually exists. It is not to be used outside of View (or subclasses) because the\n\twindow is not sharable. View|window should be used for outside access to the\n\twindow.\"\n\n\twindow == nil ifTrue: [self setWindow: self defaultWindow].\n\t^window\n"
        },
        "initialize-release": {
          "initialize": "initialize\n\t\"Initialize the state of the receiver. Subclasses should include 'super initialize'\n\twhen redefining this message to insure proper initialization.\"\n\n\tself resetSubViews.\n\ttransformation _ WindowingTransformation identity.\n\tself borderWidth: 0.\n\tself borderColor: Form black\n",
          "release": "release\n\t\"Remove the receiver from its model's list of dependents (if the model exists), and\n\trelease all of its subViews.  It is used to break possible cycles in the receiver and\n\tshould be sent when the receiver is no longer needed.  Subclasses should include\n\t'super release.' when redefining release.\"\n\n\tsuper release.\n\tmodel removeDependent: self.\n\tmodel _ nil.\n\tcontroller release.\n\tcontroller _ nil.\n\tsubViews ~~ nil ifTrue: [subViews do: [:aView | aView release]].\n\tsubViews _ nil.\n\tsuperView _ nil.\n"
        },
        "superView access": {
          "isTopView": "isTopView\n\t\"Answer true if the receiver is a top view, that is, if it has no superView.\"\n\n\t^superView == nil\n",
          "superView": "superView\n\t\"Answer the superView of the receiver.\"\n\t^superView\n",
          "topView": "topView\n\t\"Answer the root of the tree of Views in which the receiver is a node.\n\tThe root of the tree is found by going up the superView path until reaching\n\ta View whose superView is nil.\"\n\n\tsuperView == nil\n\t\tifTrue: [^self]\n\t\tifFalse: [^superView topView]\n",
          "resetSubViews": "resetSubViews\n\t\"Set the list of subviews to an empty collection.\"\n\n\tsubViews _ OrderedCollection new\n"
        },
        "viewport access": {
          "viewport": "viewport\n\t\"Answer a copy of the receiver's viewport.\"\n\t^self getViewport copy\n"
        },
        "display box access": {
          "boundingBox": "boundingBox\n\t\"Answer the bounding box which for the default case is the rectangular\n\tarea surrounding the bounding boxes of all the subViews.\"\n\n\tboundingBox ~~ nil\n\t\tifTrue: [^boundingBox]\n\t\tifFalse: [^self computeBoundingBox]\n",
          "displayBox": "displayBox\n\t\"Answer the receiver's inset display box (see View|insetDisplayBox) expanded by the\n\tborderWidth.  The display box represents the region of the display screen in\n\twhich the receiver (including the border) is displayed.  If the receiver is totally\n\tclipped by the display screen and its superView, the resulting Rectangle will\n\tbe invalid.\"\n\n\t^self insetDisplayBox expandBy: borderWidth\n",
          "insetDisplayBox": "insetDisplayBox\n\t\"Answer the receiver's inset display box. The inset display box is the intersection\n\tof the receiver's window, tranformed to display coordinates, and the inset\n\tdisplay box of the superView, inset by the border width. The inset display box\n\trepresents the region of the display screen in which the inside of the receiver (all\n\texcept the border) is displayed. If the receiver is totally clipped by the display\n\tscreen and its superView, the resulting Rectangle will be invalid.\"\n\n\t[insetDisplayBox == nil] whileTrue: [insetDisplayBox _ self computeInsetDisplayBox].\n\t^insetDisplayBox\n",
          "computeBoundingBox": "computeBoundingBox\n\t\"Answer the minimum Rectangle that encloses the bounding boxes of the\n\treceiver's subViews. If the receiver has no subViews, then the bounding box is the\n\treceiver's window. Subclasses should redefine View|boundingBox if a more\n\tsuitable default for the case of no subViews is available.\"\n\n\t| aRectangle |\n\tsubViews isEmpty ifTrue: [^self getWindow].\n\taRectangle _ self firstSubView transform: self firstSubView boundingBox.\n\tsubViews do:\n\t\t[:aView |\n\t\taRectangle _ aRectangle merge: (aView transform: aView boundingBox).].\n\t^aRectangle expandBy: borderWidth\n"
        },
        "scrolling": {
          "scrollBy:": "scrollBy: aPoint\n\t\"The x component of aPoint specifies the amount of scrolling in the x direction;\n\tthe y component specifies the amount of scrolling in the y direction. The amounts\n\tare specified in the receiver's local coordinate system.\n\tScroll the receiver up or down, left or right. The window of the receiver is kept\n\tstationary and the subViews and other objects in the receiver are translated\n\trelative to it. Scrolling doesn't change the insetDisplayBox or the viewport\n\tsince the change in the transformation is canceled by the change in the\n\twindow. In other words, all display objects in the view, except the window,\n\tare translated by the scrolling operation.\"\n\n\t| aRectangle |\n\taRectangle _ insetDisplayBox.\n\ttransformation _ transformation scrollBy: aPoint.\n\twindow _ self getWindow translateBy: aPoint x negated @ aPoint y negated.\n\tself unlock.\n\tinsetDisplayBox _ aRectangle\n"
        },
        "controller access": {
          "controller:": "controller: aController\n\t\"Set the receiver's controller to aController.  An instance of NoController can be\n\tspecified to indicate that the receiver will not have a controller.  The model of\n\taController is set to the receiver's model.\"\n\n\tself model: model controller: aController\n",
          "defaultControllerClass": "defaultControllerClass\n\t\"Answer the class of the default controller for the receiver.\n\tSubclasses should redefine View|defaultControllerClass if the class of the\n\tdefault controller is not Controller.\"\n\n\t^Controller\n",
          "defaultController": "defaultController\n\t\"Answer an initialized instance of the receiver's default controller.\n\tSubclasses should redefine this message only if the default controller\n\tinstances need to be initialized in a nonstandard way.\"\n\n\t^self defaultControllerClass new\n",
          "controller": "controller\n\t\"If the receiver's controller is nil (the default case), an initialized instance of the\n\treceiver's default controller is returned.\"\n\n\tcontroller == nil ifTrue: [self controller: self defaultController].\n\t^controller\n",
          "model:controller:": "model: aModel controller: aController\n\t\"Set the receiver's model to aModel, add the receiver to aModel's list of dependents,\n\tand set the receiver's controller to aController. Subsequent changes to aModel\n\t(see Model|change) will result in View|update: messages being sent to the\n\treceiver. nil for the value of aController indicates that the default\n\tcontroller is to be used when needed. If aController is not nil, its view is set to the\n\treceiver and its model is set to aModel.\"\n\n\tmodel ~~ nil & (model ~~ aModel)\n\t\tifTrue: [model removeDependent: self].\n\taModel ~~ nil & (aModel ~~ model)\n\t\tifTrue: [aModel addDependent: self].\n\tmodel _ aModel.\n\taController ~~ nil\n\t\tifTrue:\n\t\t\t[aController view: self.\n\t\t\taController model: aModel].\n\tcontroller _ aController\n"
        },
        "clearing": {
          "clear:": "clear: aColor\n\t\"Use aColor to paint the display box (including the border, see\n\tView|displayBox) of the receiver.\"\n\n\taColor ~= nil ifTrue: [Display fill: self displayBox mask: aColor]\n",
          "clearInside:": "clearInside: aColor\n\t\"Use aColor to paint the inset display box (excluding the border, see\n\tView|insetDisplayBox) of the receiver.\"\n\n\taColor ~= nil ifTrue: [Display fill: self insetDisplayBox mask: aColor]\n",
          "clearInside": "clearInside\n\t\"Use the inside color to paint the inset display box (excluding the border,\n\tsee View|insetDisplayBox) of the receiver.\"\n\n\tinsideColor ~= nil ifTrue: [self clearInside: insideColor]\n",
          "clear": "clear\n\t\"Use the border color to paint the display box (including the border, see\n\tView|displayBox) of the receiver.\"\n\n\tborderColor ~= nil ifTrue: [self clear: borderColor]\n"
        },
        "subView access": {
          "firstSubView": "firstSubView\n\t\"Answer the first subView in the receiver's list of subViews if it is not empty,\n\telse nil.\"\n\n\tsubViews isEmpty\n\t\tifTrue: [^nil]\n\t\tifFalse: [^subViews first]\n",
          "lastSubView": "lastSubView\n\t\"Answer the last subView in the receiver's list of subViews if it is not empty,\n\telse nil.\"\n\n\tsubViews isEmpty\n\t\tifTrue: [^nil]\n\t\tifFalse: [^subViews last]\n",
          "subViewContaining:": "subViewContaining: aPoint\n\t\"Answer the first subView that contains aPoint within its window and answer\n\tnil, otherwise. It is typically sent from a Controller in order to determine\n\twhere to pass control (usually to the Controller of the View returned by\n\tView|subViewContaining:). \"\n\n\tsubViews reverseDo:\n\t\t[:aSubView |\n\t\t(aSubView displayBox containsPoint: aPoint) ifTrue: [^aSubView]].\n\t^nil\n",
          "subViews": "subViews\n\t\"Answer the receiver's collection of subViews.\"\n\n\t^subViews\n"
        }
      }
    },
    "WindowingTransformation": {
      "comment": "WindowingTransformation is used to transform objects from a source coordinate system to a destination coordinate system.  WindowingTransformation contains a scale and a translation which can be applied to objects that respond to scaleBy: and translateBy:.  An instance of WindowingTransformation can be created with a default identity scale and translation, or with a specified scale and translation, or with a scale and translation computed from a window (a Rectangle in the source coordinate system) and a viewport (a Rectangle in the destination coordinate system).  In applying a WindowingTransformation to an object, the object is first scaled (around the origin of the source coordinate system) and then translated.  WindowingTransformations can be composed to form a single compound transformation.\n",
      "class_name": "WindowingTransformation",
      "superclass": "Object",
      "instanceVariables": "scale translation",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "window:viewport:": "window: aWindow viewport: aViewport\n\t\"Answer an instance of me with a scale and translation based on aWindow and\n\taViewport. The scale and translation are computed such that aWindow, when\n\ttransformed, coincides with aViewport. \"\n\n\t| scale translation |\n\taViewport width = aWindow width & (aViewport height = aWindow height)\n\t\tifTrue:\n\t\t\t[scale _ nil]\n\t\tifFalse:\n\t\t\t[scale _ aViewport width asFloat / aWindow width asFloat\n\t\t\t\t\t\t@ (aViewport height asFloat / aWindow height asFloat)].\n\tscale == nil\n\t\tifTrue: [translation _ aViewport left - aWindow left\n\t\t\t\t\t\t\t\t@ (aViewport top - aWindow top)]\n\t\tifFalse: [translation _ aViewport left - (scale x * aWindow left)\n\t\t\t\t\t\t\t\t@ (aViewport top - (scale y * aWindow top))].\n\t^self new setScale: scale translation: translation\n",
          "identity": "identity\n\t\"Answer an instance of me with no scaling (nil) and no translation (0@0).\"\n\n\t^self new setScale: nil translation: 0 @ 0\n",
          "scale:translation:": "scale: aScale translation: aTranslation\n\t\"Answer an instance of me with a scale factor of\n\taScale and a translation offset of aTranslation. When the transformation is\n\tapplied (see WindowingTransformation|apply:), the scale is applied first,\n\tfollowed by the translation.\"\n\n\t^self new setScale: aScale translation: aTranslation\n"
        }
      },
      "instance_methods": {
        "applying transform": {
          "compose:": "compose: aTransformation\n\t\"Answer a new WindowingTransformation that is the composition of the\n\treceiver and aTransformation.  The effect of applying\n\tthe resulting WindowingTransformation to an object is the same as that of\n\tfirst applying aTransformation to the object and then applying the\n\treceiver to its result.\"\n\n\t| aTransformationScale newScale newTranslation |\n\taTransformationScale _ aTransformation scale.\n\tscale == nil\n\t\tifTrue:\n\t\t\t[aTransformation noScale\n\t\t\t\tifTrue: [newScale _ nil]\n\t\t\t\tifFalse: [newScale _ aTransformationScale].\n\t\t\tnewTranslation _ translation + aTransformation translation]\n\t\tifFalse:\n\t\t\t[aTransformation noScale\n\t\t\t\tifTrue: [newScale _ scale]\n\t\t\t\tifFalse: [newScale _ scale * aTransformationScale].\n\t\t\tnewTranslation _ translation + (scale * aTransformation translation)].\n\t^WindowingTransformation scale: newScale translation: newTranslation\n",
          "applyInverseTo:": "applyInverseTo: anObject\n\t\"Apply the inverse of the receiver to anObject and answer the result.\n\tUsed to map some object in destination coordinates to one in source coordinates.\"\n\n\t| transformedObject |\n\ttransformedObject _ anObject translateBy: translation x negated @ translation y negated.\n\tscale == nil\n\t\tifFalse: [transformedObject _ transformedObject scaleBy: 1.0 / scale x @ (1.0 / scale y)].\n\t^transformedObject\n",
          "applyTo:": "applyTo: anObject\n\t\"Apply the receiver to anObject and answer the result.\n\tUsed to map some object in source coordinates to one in destination\n\tcoordinates.\"\n\n\t| transformedObject |\n\tscale == nil\n\t\tifTrue: [transformedObject _ anObject]\n\t\tifFalse: [transformedObject _ anObject scaleBy: scale].\n\ttransformedObject _ transformedObject translateBy: translation.\n\t^transformedObject\n"
        },
        "transforming": {
          "align:with:": "align: point1 with: point2\n\t\"Answer a new WindowingTransformation with the same scale as the\n\treceiver and with a translation of (aPoint2 - aPoint1).\n\tIt is normally used when the source and destination coordinate systems are\n\tscaled the same (that is, there is no scaling between them), and is then a\n\tconvenient way of specifying a translation, given two points that are\n\tintended to coincide.\"\n\n\t^self translateBy: point2 - point1\n",
          "translation": "translation\n\t\"Answer a copy of the receiver's translation.\"\n\n\t^translation copy\n",
          "noScale": "noScale\n\t\"Answer true if the identity scale is in effect;  answer false, otherwise.\"\n\n\t^scale == nil\n",
          "scaleOfOne": "scaleOfOne\n\tscale _ 1.0 @ 1.0.\n",
          "scale": "scale\n\t\"Answer a copy of the point that represents the current scale of the receiver.\"\n\n\tscale == nil\n\t\tifTrue: [^1.0 @ 1.0]\n\t\tifFalse: [^scale copy]\n",
          "scaleBy:": "scaleBy: aScale\n\t\"Answer a new WindowingTransformation with the scale and translation of\n\tthe receiver both scaled by aScale.\"\n\n\t| checkedScale newScale newTranslation |\n\taScale == nil\n\t\tifTrue:\n\t\t\t[newScale _ scale.\n\t\t\tnewTranslation _ translation]\n\t\tifFalse:\n\t\t\t[checkedScale _ self checkScale: aScale.\n\t\t\tscale == nil\n\t\t\t\tifTrue: [newScale _ checkedScale]\n\t\t\t\tifFalse: [newScale _ scale * checkedScale].\n\t\t\tnewTranslation _ checkedScale * translation].\n\t^WindowingTransformation scale: newScale translation: newTranslation\n",
          "translateBy:": "translateBy: aPoint\n\t\"Answer a new WindowingTransformation with the same scale as the\n\treceiver and with a translation of the current translation plus aPoint. It is used\n\twhen the translation is known in scaled source coordinates, rather than source\n\tcoordinates (see WindowingTransformation|scrollBy:). If no scaling is in effect\n\t(scale = nil), then WindowingTransformation|translateBy: and\n\tWindowingTransformation|scrollBy: are equivalent.\"\n\n\t^WindowingTransformation scale: scale translation: translation + aPoint\n"
        },
        "printing": {
          "printOn:": "printOn: aStream\n\taStream nextPutAll: self class name, ' scale: ';\n\t\tprint: scale; nextPutAll: ' translation: ';\n\t\tprint: translation\n",
          "storeOn:": "storeOn: aStream\n\taStream nextPut: $(; nextPutAll: self species name;\n\tnextPutAll: ' scale: ';\n\tstore: scale; cr;\n\tnextPutAll: ' translation: ';\n\tstore: translation;\n\tnextPut: $).\n"
        },
        "private": {
          "setScale:translation:": "setScale: aScale translation: aTranslation\n\t\"Sets the scale to aScale and the translation to aTranslation.\"\n\n\tscale _ aScale.\n\ttranslation _ aTranslation\n",
          "checkScale:": "checkScale: aScale\n\t\"Converts aScale to the internal format of a floating-point Point.\"\n \t| checkedScale |\n\tcheckedScale _ aScale asPoint.\n\t^checkedScale x asFloat @ checkedScale y asFloat\n"
        },
        "scrolling": {
          "scrollBy:": "scrollBy: aPoint\n\t\"Answer a new WindowingTransformation with the same scale as the\n\treceiver and with a translation of the current translation plus aPoint scaled by\n\tthe current scale. It is used when the translation is known in source coordinates,\n\trather than scaled source coordinates (see WindowingTransformation|translateBy:).\n\tAn example is that of scrolling objects with respect to a stationary window in the\n\tsource coordinate system. If no scaling is in effect (scale = nil), then\n\tWindowingTransformation|translateBy: and\n\tWindowingTransformation|scrollBy: are equivalent.\"\n\n\t| newTranslation |\n\tscale == nil\n\t\tifTrue: [newTranslation _ aPoint]\n\t\tifFalse: [newTranslation _ scale * aPoint].\n\t^self translateBy: newTranslation\n"
        }
      }
    }
  },
  "Interface-Inspector": {
    "DictionaryInspector": {
      "comment": "Note that the \"field\" instance variable of DictionaryInspectors contains the actual current dictionary key object, not a field name string.\n",
      "class_name": "DictionaryInspector",
      "superclass": "Inspector",
      "instanceVariables": "ok",
      "classInstanceVariables": "",
      "classVariables": "DictListMenu",
      "poolDictionaries": "",
      "class_methods": {
        "initialization": {
          "flushMenus": "flushMenus\n\tDictListMenu _ nil\n"
        },
        "examples": {
          "example": "example\n\t\"Create and schedule an Inspector in which the user can examine the\n\treceiver's variables.\"\n\tInspectorView open: (DictionaryInspector inspect: Smalltalk)\n\n\t\"DictionaryInspector example.\"\n"
        }
      },
      "instance_methods": {
        "compiler interface": {
          "insertAndSelect:at:": "insertAndSelect: aString at: ignoredIndex\n\tok _ false\n"
        },
        "menu commands": {
          "removeField": "removeField\n\n\t(self confirm: 'Confirm removal of ', field printString) ifFalse: [^self].\n\tobject removeKey: field.\n\tfield _ nil.\n\tself changed: #field\n",
          "addField": "addField\n\t| aString key |\n\taString _ Browser new prompt: 'Enter key as a Smalltalk constant' initially: ''.\n\taString isEmpty ifTrue: [^ self].\n\tok _ true.\n\tkey _ Compiler evaluate: aString for: nil notifying: self logged: false.\n\tok ifFalse: [^nil].\n\tobject add: (Association key: key value: nil).\n\tfield _ key.\n\tself changed: #field\n",
          "browseReferences": "browseReferences\n\tSmalltalk browseAllCallsOn: (object associationAt: field)\n"
        },
        "field list": {
          "printItems": "printItems\n\t\"Answer whether the elements of the fieldList need to be converted to strings\"\n\n\t^true\n",
          "fieldValue": "fieldValue\n\n\t^object at: field\n",
          "fieldMenu": "fieldMenu\n\t\"DictionaryInspector flushMenus\"\n\n\tfield == nil ifTrue:\n\t\t[^ActionMenu labels: 'add field' withCRs\n\t\t\tselectors: #(addField)].\n\tDictListMenu == nil ifTrue:\n\t\t[DictListMenu _ ActionMenu\n\t\t\tlabels: 'inspect\\references\\add field\\remove' withCRs\n\t\t\tlines: #(2)\n\t\t\tselectors: #(inspectField browseReferences\n\t\t\t\t\t\taddField removeField)].\n\t^DictListMenu\n",
          "acceptText:from:": "acceptText: aText from: aController\n\t| val |\n\tfield == nil ifTrue: [^ false].\n\tval _ self evaluateText: aText string from: aController ifFail: [^ false].\n\tobject at: field put: val.\n\tself changed: #text.\n\t^ true\n",
          "fieldList": "fieldList\n\t\"Answer a collection of the keys of the inspected dictionary.\"\n\n\t| keys |\n\tkeys _ object keys.\n\tkeys detect: [:key | (key class == Symbol) not]\n\t\tifNone: [^keys asSortedCollection]. \"sort dictionaries with Symbol keys\"\n\t ^keys asOrderedCollection\n"
        }
      }
    },
    "Inspector": {
      "comment": "I represent a query path into the internal representation of an object.  The value of fields\ncan be inspected by selecting the field name, and can be changed using 'accept'.\n\nInstance Variables:\n\tobject\t\tany object to be queried\n\tfield\t\t<String> name of field being viewed\n",
      "class_name": "Inspector",
      "superclass": "Object",
      "instanceVariables": "object field",
      "classInstanceVariables": "",
      "classVariables": "ListMenu TextMenu",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "inspect:": "inspect: anObject\n\t\"Answer an instance of me to provide an inspector for anObject.\"\n\t^self new inspect: anObject\n"
        },
        "initialization": {
          "flushMenus": "flushMenus\n\tListMenu _ TextMenu _ nil\n"
        }
      },
      "instance_methods": {
        "initialization": {
          "inspect:": "inspect: anObject\n\tanObject == object ifTrue: [^ self update].\n\tobject _ anObject.\n\tself changed: #field\n",
          "object": "object\n\t\"Answer the object being inspected by the receiver.\"\n\t^object\n"
        },
        "updating": {
          "update": "update\n\t\"Reshow contents, assuming selected value may have changed\"\n\tfield ~~ nil ifTrue: [self changed: #text]\n"
        },
        "doIt/accept/explain": {
          "doItContext": "doItContext\n\t^ nil\n",
          "doItReceiver": "doItReceiver\n\t\"Answer the object that should be informed of the result of evaluating a\n\ttext selection.\"\n\t^object\n",
          "evaluateText:from:ifFail:": "evaluateText: aText from: aController ifFail: failBlock\n\t^ Compiler new evaluate: aText\n\t\tin: self doItContext to: self doItReceiver\n\t\tnotifying: aController ifFail: failBlock\n",
          "acceptText:from:": "acceptText: aText from: aController\n\t| val |\n\tobject class == CompiledMethod\n\t\tifTrue: [^false].\n\tfield == nil ifTrue: [^false].\n\tval _ self evaluateText: aText string from: aController ifFail: [^ false].\n\tfield first isLetter\n\t\tifTrue: [object instVarAt: self fieldIndex put: val]\n\t\tifFalse: [object basicAt: self fieldIndex put: val].\n\tself changed: #text.\n\t^ true\n"
        },
        "menu commands": {
          "inspectField": "inspectField\n\tself fieldValue inspect\n"
        },
        "text": {
          "text": "text\n\tfield == nil ifTrue: [^ Text new].\n\t^ self fieldValue printString asText\n",
          "textMenu": "textMenu\n\t\"Inspector flushMenus\"\n\tTextMenu == nil ifTrue:\n\t\t[TextMenu _ ActionMenu\n\t\t\tlabels: 'again\\undo\\copy\\cut\\paste\\do it\\print it\\accept\\cancel' withCRs\n\t\t\tlines: #(2 5 7)\n\t\t\tselectors: #(again undo copySelection cut paste doIt printIt accept cancel)].\n\t^ TextMenu\n"
        },
        "field list": {
          "printItems": "printItems\n\t\"Answer whether the elements of the fieldList need to be converted to strings\"\n\n\t^false\n",
          "fieldValue": "fieldValue\n\n\tfield = 'self' ifTrue: [^object].\n\tfield first isDigit\n\t\tifTrue: [^object basicAt: self fieldIndex]\n\t\tifFalse: [^object instVarAt: self fieldIndex]\n",
          "fieldMenu": "fieldMenu\n\t\"Inspector flushMenus\"\n\tfield == nil ifTrue: [^ nil].\n\tListMenu == nil ifTrue:\n\t\t[ListMenu _ ActionMenu\n\t\t\tlabels: 'inspect'\n\t\t\tselectors: #(inspectField)].\n\t^ ListMenu\n",
          "field:": "field: selection\n\tfield _ selection.\n\tself changed: #text\n",
          "field": "field\n\t^ field\n",
          "fieldIndex": "fieldIndex\n\t\"Answer the offset corresponding to the currently selected field.\"\n\n\tfield first isDigit\n\t\tifTrue: [^ Integer readFromString: field]\n\t\tifFalse: [^ object class allInstVarNames indexOf: field]\n",
          "fieldList": "fieldList\n\t\"Answer an Array consisting of 'self' and the instance variable names of the inspected object.  Up to 40 indices are given for variable length objects.\"\n\n\t| max |\n\tmax _ object basicSize.\n\t^(Array with: 'self'), object class allInstVarNames,\n\t\t((max <= 40\n\t\t\tifTrue: [1 to: max]\n\t\t\tifFalse: [(1 to: 30) , (max-10 to: max)])\n\t\tcollect: [:i | i printString])\n"
        }
      }
    },
    "ContextInspector": {
      "comment": "I represent a query path into the internal representation of a ContextPart.  Typically this is a context at a point in the query path of a Debugger.  As a StringHolder, the string I represent is the value of the currently selected variable of the observed temporary variable of the context.\n\nInstance Variables:\n\tcontextCode\t<String> the method whose activation is being inspected\n\ttempNames\t<Array> of Strings, each the name of a temporary variable.\n",
      "class_name": "ContextInspector",
      "superclass": "Inspector",
      "instanceVariables": "tempNames",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "initialization": {
          "inspect:": "inspect: anObject\n\tobject _ anObject.\n\tself changed: #field\n"
        },
        "doIt/accept": {
          "doItContext": "doItContext\n\t^object\n",
          "doItReceiver": "doItReceiver\n\t^object receiver\n",
          "acceptText:from:": "acceptText: aText from: aController\n\t| val |\n\t(field == nil) | (field = 'self') ifTrue: [^ false].\n\tval _ self evaluateText: aText string from: aController ifFail: [^ false].\n\tobject tempAt: self fieldIndex put: val.\n\tself changed: #text.\n\t^ true\n"
        },
        "field list": {
          "fieldValue": "fieldValue\n\tfield = 'self' ifTrue: [^ object receiver].\n\t^ object tempAt: self fieldIndex\n",
          "fieldMenu": "fieldMenu\n\tfield == nil ifTrue: [^ nil].\n\t^ActionMenu\n\t\tlabels: 'inspect'\n\t\tselectors: #(inspectField)\n",
          "fieldIndex": "fieldIndex\n\t^ tempNames indexOf: field\n",
          "fieldList": "fieldList\n\tobject == nil ifTrue: [^nil].\n\t^(tempNames _ object tempNames)\n"
        }
      }
    },
    "InspectorView": {
      "comment": "I am a StandardSystemView that provides initialization methods (messages to myself) to create and schedule the interface to an object Inspector.  I have two subViews, an InspectListView and an InspectCodeView.\n",
      "class_name": "InspectorView",
      "superclass": "StandardSystemView",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "inspector:": "inspector: anInspector\n\t\"Answer an instance of me on the model, anInspector.\n\tLabel and minimum size are not set.\"\n\n\t| anInspectorView |\n\tanInspectorView _ InspectorView new.\n\tanInspectorView model: anInspector.\n\tself view: anInspector in: (0@0 extent: 1@1) of: anInspectorView.\n\t^anInspectorView\n",
          "open:": "open: anInspector\n\t\"Create and schedule an instance of me on the model, anInspector.\"\n\t(self buildScheduledView: anInspector) controller open\n",
          "view:in:of:": "view: anInspector in: area of: superView\n\t\"Create proportioned List and Code views on anInspector in area of superView\"\n\n\t| mid |\n\tmid _ area left + (area width * 0.3).\n\tsuperView addSubView:\n\t\t(SelectionInListView\n\t\t\ton: anInspector printItems: anInspector printItems\n\t\t\toneItem: false aspect: #field change: #field: list: #fieldList\n\t\t\tmenu: #fieldMenu initialSelection: #field)\n\t\tin: (area copy right: mid) borderWidth: 1.\n\tsuperView addSubView: (CodeView on: anInspector aspect: #text\n\t\t\tchange: #acceptText:from:\n\t\t\tmenu: #textMenu initialSelection: nil)\n\t\tin: (area copy left: mid) borderWidth: 1\n"
        },
        "private": {
          "buildScheduledView:": "buildScheduledView: anInspector\n\t| topView |\n\ttopView _ self model: anInspector label: anInspector object class name minimumSize: 180 @ 180.\n\tself view: anInspector in: (0@0 extent: 1@1) of: topView.\n\t^ topView\n"
        }
      }
    }
  },
  "Interface-Lists": {
    "TextList": {
      "comment": "TextList is a subclass of Paragraph which is a more efficient representation of lists.\nSince it displays a list of items, it does not try to produce a single string with CRs,\nbut instead simply makes up TextLineIntervals on the fly as needed by the view.\nThe major savings come from not needing to make up a new string for the whole list\nand not having to measure the lines, since it is assumed that if they are too long,\nthey will simply be clipped rather than wrapping to the next line.\n",
      "class_name": "TextList",
      "superclass": "Paragraph",
      "instanceVariables": "list",
      "classInstanceVariables": "",
      "classVariables": "ListStyle",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize  \"TextList initialize.\"\n\tListStyle _ DefaultTextStyle copy.\n\tListStyle gridForFont: 1 withLead: 0\n"
        },
        "instance creation": {
          "onList:": "onList: aList\n\t^self basicNew\n\t\tcompositionRectangle: DefaultCompositionRectangle\n\t\tlist:\taList\n\t\tstyle: ListStyle\n\t\toffset: 0@0\n\t\toutputMedium: #Display\n"
        }
      },
      "instance_methods": {
        "initialization": {
          "compositionRectangle:list:style:offset:outputMedium:": "compositionRectangle: compositionRect list: aList style: aTextStyle offset: aPoint outputMedium: aSymbol\n\tcompositionRectangle _ compositionRect copy.\n\tlist _ aList.\n\ttext _ Text new.\n\ttextStyle _ aTextStyle.\n\tfirstIndent _ textStyle firstIndent.\n\trestIndent _ textStyle restIndent.\n\trightIndent _ textStyle rightIndent.\n\tmarginTabsLevel _ 0.\n\toutputMedium _ aSymbol.\n\trule _ DefaultRule.\n\tmask _ DefaultMask.\n\tdestinationForm _ Display.\n\tclippingRectangle _ destinationForm boundingBox.\n\toffset _ aPoint.\n\tlastLine _ list size.\n\tcompositionRectangle height: textStyle lineGrid * lastLine\n"
        },
        "line access": {
          "textAt:": "textAt: lineIndex\n\t^ (list at: lineIndex) asText\n",
          "lineAt:": "lineAt: lineIndex\n\t^ TextLineInterval\n\t\tstart: 1\n\t\tstop: (list at: lineIndex) size\n\t\tinternalSpaces: 1\n\t\tpaddingWidth: 0\n"
        }
      }
    },
    "SelectionInListController": {
      "comment": "This controllers is designed to support the pluggable SelectionInListViews (q.v.).\nAs its operation is parameterized in the view, it must ask its view for current\nselection and for menu options.  The tighter controller/view relationship appropriate to\npluggable viewing has not yet fully matured.  Note that control is not accepted\nif the view is empty.\n",
      "class_name": "SelectionInListController",
      "superclass": "ListController",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "control defaults": {
          "isControlWanted": "isControlWanted\n\tview isEmpty ifTrue: [^ false].\n\t^super isControlWanted\n"
        },
        "menu messages": {
          "yellowButtonActivity": "yellowButtonActivity\n\t| index menu |\n\tmenu _ view yellowButtonMenu.\n\tmenu == nil\n\t\tifTrue:\n\t\t\t[view flash.\n\t\t\tsuper controlActivity]\n\t\tifFalse:\n\t\t\t[index _ menu startUpYellowButton.\n\t\t\tindex ~= 0\n\t\t\t\tifTrue:\n\t\t\t\t\t[self controlTerminate.\n\t\t\t\t\tmodel perform: (menu selectorAt: index).\n\t\t\t\t\tself controlInitialize]]\n",
          "redButtonActivity": "redButtonActivity\n\t| selectionMovement oldSelection trialSelection nextSelection |\n\tselectionMovement _ false.\n\toldSelection _ view selection.\n\t[sensor redButtonPressed]\n\t\twhileTrue:\n\t\t\t[trialSelection _ view findSelection: sensor cursorPoint.\n\t\t\ttrialSelection ~~ nil\n\t\t\t\tifTrue:\n\t\t\t\t\t[nextSelection _ trialSelection.\n\t\t\t\t\tview moveSelectionBox: nextSelection.\n\t\t\t\t\tnextSelection ~= oldSelection ifTrue: [selectionMovement _ true]]].\n\tnextSelection == nil ifTrue: [^self].\n\tnextSelection = oldSelection ifTrue:\n\t\t[selectionMovement ifTrue: [^self].\n\t\tnextSelection _ 0.\n\t\tview moveSelectionBox: nextSelection].\n\tmodel changeRequest ifFalse:\n\t\t\t[view moveSelectionBox: oldSelection.\n\t\t\t^ view flash].\n\tview changeModelSelection: nextSelection\n"
        }
      }
    },
    "LockedListController": {
      "comment": "I am a kind of ListController that blocks new selections if the model is locked--i.e., has been changed in some way that still requires completion.\n",
      "class_name": "LockedListController",
      "superclass": "ListController",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "model access": {
          "feedbackResponseTest": "feedbackResponseTest\n\t\"Answer whether the receiver should respond to any user button requests.\"\n\t^sensor anyButtonPressed | self scrollBarContainsCursor\n",
          "normalResponseTest": "normalResponseTest\n\t\"Answer whether the receiver can proceed with selections--depends\n\ton whether the model is locked.\"\n\t^model isUnlocked\n"
        },
        "control defaults": {
          "controlActivity": "controlActivity\n\tself normalResponseTest ifTrue: [^super controlActivity].\n\tself feedbackResponseTest ifTrue: [^view flash]\n"
        }
      }
    },
    "ListView": {
      "comment": "I am an abstract View of a list of items.  I provide support for storing a selection of one item, as well as formatting the list for presentation on the screen.  My default controller is ListController.\n\nInstance Variables:\n\tlist\t\t\t\t<Array> of Strings, each one an item\n\tselection\t\t<Integer> index into the array, list\n\ttopDelimiter\t\t<String>, usually  ------------, indicating the top of the list\n\tbottomDelimiter\t<String>, usually  ------------, indicating the bottom of the list\n\tlineSpacing\t\t<Integer> the amount of extra space between line items\n\tisEmpty\t\t\t<Boolean> true if the list is empty\n",
      "class_name": "ListView",
      "superclass": "View",
      "instanceVariables": "list selection topDelimiter bottomDelimiter lineSpacing isEmpty",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "list access": {
          "resetAndDisplayView": "resetAndDisplayView\n\t\"Set the list of items displayed to be empty and redisplay the receiver.\"\n\n\tisEmpty\n\t\tifFalse:\n\t\t\t[self reset.\n\t\t\tself displayView]\n",
          "list:": "list: itemCollection\n\t\"Create the textList corresponding to the items in itemCollection.\"\n\n\tisEmpty _ itemCollection isNil.\n\tlist _ TextList onList:\n\t\t(topDelimiter == nil\n\t\t\tifTrue: [itemCollection]\n\t\t\tifFalse: [(Array with: topDelimiter) ,\n\t\t\t\t\titemCollection ,\n\t\t\t\t\t(Array with: bottomDelimiter)]).\n\tselection _ 0.\n\tself positionList\n",
          "list": "list\n\t\"Answer the list of items the receiver displays.\"\n\t^list\n",
          "reset": "reset\n\t\"Set the list of items displayed to be empty.\"\n\n\tisEmpty _ true.\n\tself list: Array new\n"
        },
        "deEmphasizing": {
          "deEmphasizeView": "deEmphasizeView\n\t| aRectangle newForm |\n\tself deselect.\n\tselection ~= 0\n\t\tifTrue: [aRectangle _ (self selectionBox intersect: self clippingBox).\n\t\t\t\taRectangle _ aRectangle insetOriginBy: 0@-1 cornerBy: 0@0.\n\t\t\t\tnewForm _ Form fromDisplay: aRectangle.\n\t\t\t\tnewForm\n\t\t\t\t\tdisplayOn: Display\n\t\t\t\t\tat: (aRectangle topLeft + (1@0))\n\t\t\t\t\tclippingBox: aRectangle\n\t\t\t\t\trule: Form under\n\t\t\t\t\tmask: Form black.\n\t\t\t\tDisplay fill: aRectangle rule: Form under mask: Form lightGray]\n"
        },
        "selecting": {
          "deselect": "deselect\n\t\"If the receiver has a selection, then it is highlighted.  Remove the highlighting.\"\n\tselection ~= 0 ifTrue: [Display reverse: (self selectionBox intersect: self clippingBox)]\n",
          "displaySelectionBox": "displaySelectionBox\n\t\"If the receiver has a selection and that selection is visible on the display\n\tscreen, then highlight it.\"\n\n\t(selection ~= 0 and: [self selectionBox intersects: self clippingBox])\n\t\tifTrue: [Display reverse: (self selectionBox intersect: self clippingBox)]\n",
          "maximumSelection": "maximumSelection\n\t\"Answer which selection is the last possible one.\"\n\ttopDelimiter == nil\n\t\tifTrue: [^list numberOfLines]\n\t\tifFalse: [^list numberOfLines - 1]\n",
          "selectionBox": "selectionBox\n\t\"Answer the rectangle in which the current selection is displayed.\"\n\n\t^(self insetDisplayBox left @ (list compositionRectangle top + self selectionBoxOffset)\n\t\textent: self insetDisplayBox width @ list lineGrid)\n\t\tinsetBy: (Rectangle left: 1 right: 1 top: 1 bottom: 0)\n",
          "minimumSelection": "minimumSelection\n\t\"Answer which selection is the first possible one.\"\n\ttopDelimiter == nil\n\t\tifTrue: [^1]\n\t\tifFalse: [^2]\n",
          "selection": "selection\n\t\"Answer the receiver's current selection.\"\n\t^selection\n",
          "isSelectionBoxClipped": "isSelectionBoxClipped\n\t\"Answer whether there is a selection and whether the selection is visible\n\ton the screen.\"\n\n\t^selection ~= 0 & (self selectionBox intersects: self clippingBox) not\n",
          "findSelection:": "findSelection: aPoint\n\t\"Determine which selection is displayed in an area containing the point,\n\taPoint.  Answer the selection if one contains the point, answer nil otherwise.\"\n\n\t| trialSelection |\n\t(self clippingBox containsPoint: aPoint) ifFalse: [^nil].\n\ttrialSelection _ aPoint y - list compositionRectangle top // list lineGrid + 1.\n\ttrialSelection < self minimumSelection | (trialSelection > self maximumSelection)\n\t\tifTrue: [^nil]\n\t\tifFalse: [^trialSelection - self minimumSelection + 1]\n",
          "moveSelectionBox:": "moveSelectionBox: anInteger\n\t\"Presumably the selection has changed to be anInteger.  Deselect the\n\tprevious selection and display the new one, highlighted.\"\n\n\tselection ~= anInteger\n\t\tifTrue:\n\t\t\t[self deselect.\n\t\t\tselection _ anInteger.\n\t\t\tself displaySelectionBox]\n",
          "selectionBoxOffset": "selectionBoxOffset\n\t\"Answer an integer that determines the y position for the display box of the\n\tcurrent selection.\"\n\t^selection - 1 + self minimumSelection - 1 * list lineGrid\n"
        },
        "delimiters": {
          "bottomDelimiter:": "bottomDelimiter: aString\n\t\"Set the string used to indicate the bottom of the list.\"\n\tbottomDelimiter _ aString\n",
          "noBottomDelimiter": "noBottomDelimiter\n\t\"Set the string used to indicate the bottom of the list to be nothing.\"\n\tbottomDelimiter _ nil\n",
          "bottomDelimiter": "bottomDelimiter\n\t\"Answer the string used to indicate the bottom of the list.\"\n\t^bottomDelimiter\n",
          "noTopDelimiter": "noTopDelimiter\n\t\"Set the string used to indicate the top of the list to be nothing.\"\n\ttopDelimiter _ nil\n",
          "topDelimiter:": "topDelimiter: aString\n\t\"Set the string used to indicate the top of the list.\"\n\ttopDelimiter _ aString\n",
          "topDelimiter": "topDelimiter\n\t\"Answer the string used to indicate the top of the list.\"\n\t^topDelimiter\n"
        },
        "clipping box access": {
          "clippingBox": "clippingBox\n\t\"Answer the rectangle in which the model can be displayed--this\n\tis the insetDisplayBox inset by the height of a line for an item.\"\n\n\t^self insetDisplayBox insetBy:\n\t\t(Rectangle\n\t\t\tleft: 0\n\t\t\tright: 0\n\t\t\ttop: 0\n\t\t\tbottom: self insetDisplayBox height \\\\ list lineGrid)\n"
        },
        "updating": {
          "update:": "update: aSymbol\n\taSymbol == #list\n\t\tifTrue:\n\t\t\t[self list: model list.\n\t\t\tself displayView.\n\t\t\t^self].\n\taSymbol == #listIndex\n\t\tifTrue:\n\t\t\t[self moveSelectionBox: model listIndex.\n\t\t\t^self]\n"
        },
        "displaying": {
          "displayView": "displayView\n\tself clearInside.\n\tlist displayOn: Display.\n\tself displaySelectionBox\n",
          "display": "display\n\tlist == nil ifTrue: [self list: Array new].\n\tself isUnlocked ifTrue: [self positionList].\n\tsuper display\n"
        },
        "private": {
          "positionList": "positionList\n\tlist repositionAt: (self wrappingBox topLeft) clippingBox: self clippingBox\n",
          "wrappingBox": "wrappingBox\n\t| aRectangle |\n\taRectangle _ self insetDisplayBox.\n\tselection = 0\n\t\tifTrue: [^aRectangle topLeft + (4 @ 0) extent: list compositionRectangle extent]\n\t\tifFalse: [^aRectangle left + 4 @\n\t\t\t\t\t(aRectangle top -\n\t\t\t\t\t\t(self selectionBoxOffset\n\t\t\t\t\t\t\tmin: ((list height - aRectangle height\n\t\t\t\t\t\t\t\t\t+ list lineGrid truncateTo: list lineGrid)\n\t\t\t\t\t\t\tmax: 0)))\n\t\t\t\t\textent: list compositionRectangle extent]\n"
        },
        "initialize-release": {
          "initialize": "initialize\n\tsuper initialize.\n\tinsideColor _ Form white.\n\ttopDelimiter _ '------------'.\n\tbottomDelimiter _ '------------'.\n\tlineSpacing _ 0.\n\tisEmpty _ true\n"
        },
        "display box access": {
          "boundingBox": "boundingBox\n\t^list boundingBox\n"
        },
        "controller access": {
          "defaultControllerClass": "defaultControllerClass\n\t^ListController\n"
        }
      }
    },
    "SelectionInListView": {
      "comment": "SelectionInListView is a \"pluggable\" ListView.  The notion of pluggable views is an\nexperiment in user interface design.  The idea is to provide a view which can be plugged\nonto any object, rather than having to define a new subclass specific to every kind of\nobject which needs to be viewed.\n\nThe chief mechanism is a set of selectors, which can be thought of as an adaptor to\nconvert the generic listView operations (such as changeSelection) into model-specific\noperations (such as fileName:).\n\nAn added feature of this listView is that it tries to preserve its selection through\nchanges in the choice list.  This effect, and also the choice of an intial selection are\ntransmitted to the model just as a user-requested selection would be.\n\nSee the protocol 'adaptor' for use of the pluggable selectors.\nSee the creation messages in my class for an explication of the various parameters.\nBrowse senders of the creation messages in my class for examples in the system.\n",
      "class_name": "SelectionInListView",
      "superclass": "ListView",
      "instanceVariables": "itemList printItems oneItem partMsg initialSelectionMsg changeMsg listMsg menuMsg",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "on:aspect:change:list:menu:initialSelection:": "on: anObject\n\taspect: aspectMsg change: changeMsg list: listMsg menu: menuMsg initialSelection: sel\n\t\"Create a 'pluggable' (see class comment) listView viewing anObject.\n\taspectMsg is sent to read the value of the current selection.\n\t\tIt is also used as the changed: parameter for this view.\n\tchangeMsg is sent to inform anObject of a new selection.\n\tlistMsg is sent to read the current list which should be displayed.\n\tmenuMsg is sent to read the yellowButton menu for this view.\n\tinitialSelection is sent to read a selection to be selected initailly as a default.\"\n\n\t^ self new on: anObject printItems: false oneItem: false\n\t\taspect: aspectMsg change: changeMsg list: listMsg menu: menuMsg initialSelection: sel\n",
          "on:printItems:oneItem:aspect:change:list:menu:initialSelection:": "on: anObject printItems: flag1 oneItem: flag2\n\taspect: aspectMsg change: changeMsg list: listMsg menu: menuMsg initialSelection: sel\n\t\"Create a listView with these parameters - see comment in on:aspect:change: . . .\n\tMoreover, if printItems is true, then the view will show the printStrings of the\n\t\titems in the list, rather than assuming they are already text-like objects.\n\tAnd if oneItem is true the list works as a read-only list of one item.  this is mainly\n\t\tused for the root list of various sub-browsers spawned from the browser.\"\n\n\t^ self new on: anObject printItems: flag1 oneItem: flag2\n\t\taspect: aspectMsg change: changeMsg list: listMsg menu: menuMsg initialSelection: sel\n"
        }
      },
      "instance_methods": {
        "list access": {
          "list:": "list: anArray\n\t| item |\n\titemList _ anArray.\n\tanArray == nil ifTrue:\n\t\t[isEmpty _ true.\n\t\tselection _ 0.\n\t\t^self changeModelSelection: 0].\n\tprintItems\n\t\tifTrue: [super list: (anArray collect:\n\t\t\t\t\t[:each | each printString copyUpTo: Character cr])]\n\t\tifFalse: [super list: anArray].\n\titem _ self initialSelection.\n\tselection _ item == nil\n\t\t\tifTrue: [0]\n\t\t\tifFalse: [itemList findFirst: [:x | x = item]].\n\tselection > 0 ifTrue: [self positionList].\n\tself changeModelSelection: selection\n"
        },
        "initialization": {
          "on:printItems:oneItem:aspect:change:list:menu:initialSelection:": "on: anObject printItems: flag1 oneItem: flag2\n\t\taspect: m1 change: m3 list: m4 menu: m5 initialSelection: m6\n\tself model: anObject.\n\tprintItems _ flag1.\n\toneItem _ flag2.\n\tpartMsg _ m1.\n\tchangeMsg _ m3.\n\tlistMsg _ m4.\n\tmenuMsg _ m5.\n\tinitialSelectionMsg _ m6.\n\toneItem ifTrue:\n\t\t[self noTopDelimiter noBottomDelimiter.\n\t\tinitialSelectionMsg == nil\n\t\t\tifTrue: [self error: 'initialSelection must be specified for oneItem mode']].\n\tself list: self getList\n"
        },
        "updating": {
          "update:": "update: aSymbol\n\taSymbol == partMsg\n\t\tifTrue: [self list: self getList; displayView]\n"
        },
        "adaptor": {
          "getList": "getList\n\t| item |\n\toneItem ifTrue:\n\t\t[item _ self initialSelection.\n\t\titem == nil ifTrue: [^ nil].\n\t\t^ Array with: item].\n\tlistMsg == nil ifTrue: [^nil].\n\t^ model perform: listMsg\n",
          "changeModelSelection:": "changeModelSelection: anInteger\n\n\tchangeMsg ~~ nil ifTrue:\n\t\t[model perform: changeMsg with:\n\t\t\t(anInteger = 0 ifTrue: [nil] ifFalse: [itemList at: anInteger])]\n",
          "initialSelection": "initialSelection\n\tinitialSelectionMsg == nil ifTrue: [^ nil].\n\t^ model perform: initialSelectionMsg\n",
          "yellowButtonMenu": "yellowButtonMenu\n\tmenuMsg == nil ifTrue: [^ nil].\n\t^ model perform: menuMsg\n"
        },
        "displaying": {
          "displayView": "displayView\n\tisEmpty\n\t\tifTrue: [self clearInside]\n\t\tifFalse: [super displayView]\n"
        },
        "testing": {
          "isEmpty": "isEmpty\n\t^ isEmpty\n"
        },
        "controller access": {
          "defaultControllerClass": "defaultControllerClass\n\t^ SelectionInListController\n"
        }
      }
    },
    "ListController": {
      "comment": "I am a kind of ScrollController that assumes that the view is a kind of ListView.  Therefore, scrolling means moving the items in a textual list (menu) up or down. In addition, I provide the red button activity of determining when the red button is selecting an item in the list.\n",
      "class_name": "ListController",
      "superclass": "ScrollController",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "control defaults": {
          "isControlActive": "isControlActive\n\t^super isControlActive & sensor blueButtonPressed not\n"
        },
        "menu messages": {
          "redButtonActivity": "redButtonActivity\n\t| noSelectionMovement oldSelection trialSelection nextSelection |\n\tnoSelectionMovement _ true.\n\toldSelection _ view selection.\n\t[sensor redButtonPressed]\n\t\twhileTrue:\n\t\t\t[trialSelection _ view findSelection: sensor cursorPoint.\n\t\t\ttrialSelection ~~ nil\n\t\t\t\tifTrue:\n\t\t\t\t\t[nextSelection _ trialSelection.\n\t\t\t\t\tview moveSelectionBox: nextSelection.\n\t\t\t\t\tnextSelection ~= oldSelection ifTrue: [noSelectionMovement _ false]]].\n\tnextSelection ~~ nil & (nextSelection = oldSelection\n\t\t\tifTrue: [noSelectionMovement]\n\t\t\tifFalse: [true]) ifTrue: [self changeModelSelection: nextSelection]\n"
        },
        "marker adjustment": {
          "markerDelta": "markerDelta\n\t| viewList |\n\tviewList _ view list.\n\t^(marker top - scrollBar inside top) -\n\t\t((viewList clippingRectangle top -\n\t\t\t\tviewList compositionRectangle top) asFloat /\n\t\t\tviewList compositionRectangle height asFloat *\n\t\t\tscrollBar inside height asFloat) rounded\n",
          "computeMarkerRegion": "computeMarkerRegion\n\t| viewList |\n\tviewList _ view list.\n\t^ 0@0 extent: 10@\n\t\t\t((viewList clippingRectangle height asFloat /\n\t\t\t\t\t\tviewList compositionRectangle height *\n\t\t\t\t\t\t\tscrollBar inside height)\n\t\t\t\t\trounded min: scrollBar inside height)\n"
        },
        "private": {
          "changeModelSelection:": "changeModelSelection: anInteger\n\tmodel toggleListIndex: anInteger\n"
        },
        "scrolling": {
          "scrollAmount": "scrollAmount\n\t^sensor cursorPoint y - scrollBar inside top\n",
          "viewDelta": "viewDelta\n\t| viewList |\n\tviewList _ view list.\n\t^(viewList clippingRectangle top -\n\t\t\tviewList compositionRectangle top -\n\t\t\t((marker top - scrollBar inside top) asFloat /\n\t\t\t\tscrollBar inside height asFloat *\n\t\t\t\tviewList compositionRectangle height asFloat))\n\t\troundTo: viewList lineGrid\n",
          "scrollViewDown": "scrollViewDown\n\tself scrollView: self scrollAmount.\n",
          "scrollView:": "scrollView: anInteger\n\t| viewList maximumAmount minimumAmount amount |\n\tviewList _ view list.\n\tmaximumAmount _\n\t\tviewList clippingRectangle top -\n\t\tviewList compositionRectangle top max: 0.\n\tminimumAmount _\n\t\tviewList clippingRectangle bottom -\n\t\tviewList compositionRectangle bottom min: 0.\n\tamount _\n\t\t(anInteger min: maximumAmount) max:\n\t\tminimumAmount.\n\tamount ~= 0\n\t\tifTrue:\n\t\t\t[view deselect.\n\t\t\tviewList scrollBy: amount negated.\n\t\t\tview isSelectionBoxClipped\n\t\t\t\t\"ifTrue: [ self changeModelSelection: 0]  compile this code to deselect\n\t\t\t\t\twhen the selection is scrolled outside of the visible region\"\n\t\t\t\tifFalse: [ view displaySelectionBox ]]\n",
          "canScroll": "canScroll\n\t| viewList |\n\tviewList _ view list.\n\t^viewList compositionRectangle height - viewList clippingRectangle height\n\t\t> (viewList lineGrid // 2)\n",
          "scrollViewUp": "scrollViewUp\n\tself scrollView: (self scrollAmount) negated.\n"
        }
      }
    }
  },
  "Interface-Menus": {
    "OneOnSwitch": {
      "comment": "I am a kind of Switch that can be connected to some related object, typically to a collection of my instances.  When my instance is created, its connection is set to a particular object.  When the object changes because an instance is turned on, an update message is broadcasted.  All the connected OneOnSwitches, except the changed one, turn off.  This allows OneOnSwitches to maintain the constraint that at most one of them will be on at any time.  OneOnSwitches can thus be made to act like \"car radio\" switches.\n\nInstance Variables:\n\tconnection\tany object\n",
      "class_name": "OneOnSwitch",
      "superclass": "Switch",
      "instanceVariables": "connection",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "connection": {
          "connection:": "connection: anObject\n\t\"Set anObject to be the connection among two or more Switches.\"\n\tconnection _ anObject.\n\tconnection addDependent: self\n",
          "connection": "connection\n\t\"Answer the object that connects the receiver to other Switches.\"\n\t^connection\n",
          "notifyConnection": "notifyConnection\n\t\"Send the receiver's connection (if it exists) the message 'changed: self' in order for\n\tthe \tconnection to broadcast the change to other objects connected by the\n\tconnection. \"\n\n\tself isConnectionSet ifTrue: [self connection changed: self]\n",
          "isConnectionSet": "isConnectionSet\n\t\"Answer whether the receiver is connected to an object that coordinates\n\tupdates among switches.\"\n\tconnection == nil\n\t\tifTrue: [^false]\n\t\tifFalse: [^true]\n"
        },
        "state": {
          "turnOn": "turnOn\n\t\"Does nothing if it is already on.  If it is not, it is set to 'on', its dependents\n\tare \tnotified of the change, its connection is notified, and its action is\n\texecuted.\"\n\n\tself isOff\n\t\tifTrue:\n\t\t\t[on _ true.\n\t\t\tself changed.\n\t\t\tself notifyConnection.\n\t\t\tself doAction: onAction]\n"
        },
        "updating": {
          "update:": "update: aOneOnSwitch\n\t\"Does nothing if aOneOnSwitch is identical to this object.  If it is not, this\n\tobject is turned off.  Is sent by the connection (an Object) when some related\n\tOneOnSwitch (possibly this one) has changed.  This allows a group of related\n\tOneOnSwitches to maintain the constraint that at most one will be on at any\n\ttime. \"\n\n\tself ~~ aOneOnSwitch ifTrue: [self turnOff]\n"
        },
        "initialize-release": {
          "release": "release\n\tsuper release.\n\tself isConnectionSet ifTrue: [connection removeDependent: self]\n"
        }
      }
    },
    "BinaryChoiceView": {
      "comment": "I am a view of a BinaryChoice.  I display a question and two switches, yes and no, indicating choices the user can make.\n",
      "class_name": "BinaryChoiceView",
      "superclass": "View",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "ThumbsDown ThumbsUp",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\tThumbsUp _\n\t\tCursor\n\t\t\textent: 16@16\n\t\t\tfromArray:\n\t\t\t\t#(16 104 72 120 136 136 3980 4227 8192 16128 8192 16128 8192 7943 2056 4080 )\n\t\t\toffset: -15@0.\n\tThumbsDown _\n\t\tCursor\n\t\t\textent: 16@16\n\t\t\tfromArray:\n\t\t\t\t#(4080 2056 7943 8192 16128 8192 16128 8192 4227 3980 136 136 120 72 104 16 )\n\t\t\toffset: 0@0\n\t\"BinaryChoiceView initialize\"\n"
        },
        "instance creation": {
          "openOn:message:displayAt:centered:": "openOn: aBinaryChoice message: messageString displayAt: originPoint centered: centered\n\t\"Answer an instance of me that displays aBinaryChoice asking the question\n\tmessageString.  If the argument centered, a Boolean, is false, display the instance\n\twith top left corner at originPoint;  otherwise, display it with its center at\n\toriginPoint.  If necessary, translate so the view is completely on the screen.\n\tDo not schedule, rather take control immediately and insist that the user respond.\"\n\n\t| topView messageView switchView savedArea |\n\tmessageView _ DisplayTextView new model: messageString asDisplayText.\n\tmessageView insideColor: Form white.\n\tmessageView controller: NoController new.\n\tmessageView centered.\n\tswitchView _\n\t\tself buildSwitchesFor: aBinaryChoice width: messageView window width.\n\ttopView _ self new model: aBinaryChoice.\n\ttopView addSubView: messageView.\n\ttopView addSubView: switchView below: messageView.\n\ttopView\n\t\talign: (centered\n\t\t\t\tifTrue: [switchView viewport center]\n\t\t\t\tifFalse: [topView viewport topLeft])\n\t\twith: originPoint.\n\ttopView borderWidth: 2.\n\ttopView translateBy:\n\t\t(topView displayBox amountToTranslateWithin: Display boundingBox).\n\ttopView insideColor: Form white.\n\tsavedArea _ Form fromDisplay: topView displayBox.\n\ttopView display.\n\ttopView controller startUp.\n\ttopView release.\n\tsavedArea displayOn: Display at: topView viewport topLeft\n"
        },
        "private": {
          "buildSwitchesFor:width:": "buildSwitchesFor: aBinaryChoice\twidth: anInteger\n\t|switchView yesSwitchView noSwitchView|\n\tswitchView _ View new model: aBinaryChoice.\n\tswitchView controller: BinaryChoiceController new.\n\tyesSwitchView _ SwitchView new model: aBinaryChoice.\n\tyesSwitchView borderWidthLeft: 0 right: 2 top: 0 bottom: 0.\n\tyesSwitchView selector: #active.\n\tyesSwitchView controller selector: #selectTrue.\n\tyesSwitchView controller cursor: ThumbsUp.\n\tyesSwitchView label: 'yes' asParagraph.\n\tyesSwitchView window: (0@0 extent: anInteger//2 @ yesSwitchView window height).\n\tnoSwitchView _ SwitchView new model: aBinaryChoice.\n\tnoSwitchView selector: #active.\n\tnoSwitchView controller selector: #selectFalse.\n\tnoSwitchView controller cursor: ThumbsDown.\n\tnoSwitchView label: 'no' asParagraph.\n\tnoSwitchView window: (0@0 extent: anInteger//2 @ noSwitchView window height).\n\tswitchView addSubView: yesSwitchView.\n\tswitchView addSubView: noSwitchView toRightOf: yesSwitchView.\n\tswitchView borderWidthLeft: 0 right: 0 top: 2 bottom: 0.\n\t^switchView\n"
        }
      },
      "instance_methods": {
        "controller access": {
          "defaultControllerClass": "defaultControllerClass\n\t^BinaryChoiceController\n"
        }
      }
    },
    "SwitchView": {
      "comment": "I am a view of a Switch.  My instances have labels and display modes (set to \"normal\" or \"complemented\").  When one of my instances is displayed in complemented mode, its inside color is reversed.  The value of the display mode corresponds to the value of the model so that, for example, when a Switch is off, its SwitchView is displayed with black text (for the label) on a white background, and when the Switch is off, its SwitchView is displayed with white text on a black background.  My instances have a key character that can be used for switching on or off.  Highlighting can be done specially using a stored form, rather than simply changing all black bits to white and vice versa.  My default controller is SwitchController.\n\nInstance Variables:\n\t\tcomplemented\t\t<Boolean> true if the model is on\n\t\tlabel\t\t\t\t<DisplayObject>, for example, a DisplayText or a Form\n\t\tselector\t\t\t\t<Symbol>\n\t\tkeyCharacter\t\t<Character>\n\t\thighlightForm\t\t<Form>\n\t\targuments\t\t\t<Array>\n",
      "class_name": "SwitchView",
      "superclass": "View",
      "instanceVariables": "complemented label selector keyCharacter highlightForm arguments",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "deEmphasizing": {
          "deEmphasizeView": "deEmphasizeView\n\t| newForm |\n\tcomplemented\n\t\tifTrue: [self highlight.\n\t\t\t\tnewForm _ Form fromDisplay: self insetDisplayBox.\n\t\t\t\tnewForm\n\t\t\t\t\tdisplayOn: Display\n\t\t\t\t\tat: (self insetDisplayBox topLeft + (1@0))\n\t\t\t\t\tclippingBox: self insetDisplayBox\n\t\t\t\t\trule: Form under\n\t\t\t\t\tmask: Form black.\n\t\t\t\tDisplay fill: self insetDisplayBox rule: Form under mask: Form lightGray]\n"
        },
        "selector": {
          "selector:": "selector: aSymbol\n\t\"Set aSymbol to be the selector the receiver sends in a message to its model.\"\n\tselector _ aSymbol\n",
          "selector": "selector\n\t\"Answer the selector the receiver sends in a message to its receiver.\"\n\t^selector\n",
          "interrogateModel": "interrogateModel\n\t\"Answer the result of sending the receiver's model the message\n\tcreated from the receiver's selector and arguments.\"\n\targuments size = 0\n\t\tifTrue: [^model perform: selector]\n\t\tifFalse: [^model perform: selector withArguments: arguments]\n"
        },
        "label access": {
          "label": "label\n\t\"Answer the label, a display object, that is the receiver's screen image.\"\n\t^label\n",
          "centerLabel": "centerLabel\n\t\"Align the center of the frame of the label with the center of the receiver's window.\"\n\n\tlabel == nil\n\t\tifFalse:\n\t\t\t[label\n\t\t\t\talign: label boundingBox center\n\t\t\t\twith: self getWindow center]\n",
          "label:": "label: aDisplayObject\n\t\"Set aDisplayObject to be the label that is the receiver's screen image.\"\n\n\tlabel release.\n\tlabel _ aDisplayObject.\n\tself centerLabel\n"
        },
        "window access": {
          "defaultWindow": "defaultWindow\n\t\"Returns the frame of the SwitchView's label's frame (slightly enlarged)\n\tif the label exists, and returns the standard View default window (see\n\tView|defaultWindow), otherwise.\"\n\n\tlabel == nil\n\t\tifTrue: [^super defaultWindow]\n\t\tifFalse: [^label boundingBox expandBy: 6]\n",
          "window:": "window: aWindow\n\tsuper window: aWindow.\n\tself centerLabel\n"
        },
        "updating": {
          "update:": "update: aParameter\n\thighlightForm == nil\n\t\tifTrue: [self interrogateModel\n\t\t\t\t\tifTrue: [self displayComplemented]\n\t\t\t\t\tifFalse: [self displayNormal]]\n\t\tifFalse: [self display]\n"
        },
        "displaying": {
          "displayComplemented": "displayComplemented\n\t\"Complement the receiver if its mode is 'normal'.\"\n\tcomplemented\n\t\tifFalse:\n\t\t\t[complemented _ true.\n\t\t\tself highlight]\n",
          "displayNormal": "displayNormal\n\t\"Complement the receiver if its mode is 'complemented'.\"\n\tcomplemented\n\t\tifTrue:\n\t\t\t[complemented _ false.\n\t\t\tself highlight]\n",
          "displayView": "displayView\n\t\"Does the standard View actions and, in addition, displays the receiver's\n\tlabel based on the current display transformation and inset display box.\"\n\n\tself clearInside.\n\tlabel == nil\n\t\tifFalse:\n\t\t\t[label\n\t\t\t\tdisplayOn: Display\n\t\t\t\ttransformation: self displayTransformation\n\t\t\t\tclippingBox: self insetDisplayBox\n\t\t\t\tfixedPoint: label boundingBox center]\n",
          "displaySpecial": "displaySpecial\n\tcomplemented\n\t\tifTrue: [self displaySpecialComplemented].\n\tlabel == nil\n\t\tifFalse: [label\n\t\t\t\t\tdisplayOn: Display\n\t\t\t\t\ttransformation: self displayTransformation\n\t\t\t\t\tclippingBox: self insetDisplayBox\n\t\t\t\t\talign: label boundingBox center\n\t\t\t\t\twith: label boundingBox center\n\t\t\t\t\trule: Form under\n\t\t\t\t\tmask: Form black]\n",
          "display": "display\n\t\"Sets the SwitchView mode to 'normal', displays the border, displays the\n\tinside and, if its model is 'on', complements the inside.\"\n\n\tself displayBorder.\n\tcomplemented _ self interrogateModel.\n\thighlightForm == nil\n\t\tifTrue: [self displayView.\n\t\t\t\tcomplemented ifTrue: [self highlight]]\n\t\tifFalse: [self displaySpecial]\n",
          "displaySpecialComplemented": "displaySpecialComplemented\n\thighlightForm\n\t\tdisplayOn: Display\n\t\ttransformation: self displayTransformation\n\t\tclippingBox: self insetDisplayBox\n\t\tfixedPoint: label boundingBox center\n"
        },
        "indicating": {
          "indicatorOnDuring:": "indicatorOnDuring: aBlockContext\n\t\"Indicate the receiver during the execution of aBlockContext by\n\tcomplementing the label (or a portion of the display box if no label is\n\tdefined). \"\n\n\tself indicatorReverse.\n\tself highlight.\n\taBlockContext value.\n\tself highlight.\n\tself indicatorReverse\n",
          "indicatorReverse": "indicatorReverse\n\t\"Complement the label (or a portion of the displayBox if no label is defined).\"\n\n\tDisplay reverse: self insetDisplayBox mask: Form gray.\n\tDisplay reverse: (self insetDisplayBox insetBy: 2) mask: Form gray\n"
        },
        "testing": {
          "containsKey:": "containsKey: aCharacter\n\t\"Answer whether the receiver can be selected by the argument, aCharacter.\"\n\t^keyCharacter = aCharacter\n"
        },
        "accessing": {
          "key:": "key: aCharacter\n\t\"Set the receiver to be selected by the argument, aCharacter.\"\n\tkeyCharacter _ aCharacter\n",
          "highlightForm:": "highlightForm: aForm\n\t\"The argument is the form to be used to highlight the receiver.\"\n\thighlightForm _ aForm\n",
          "arguments": "arguments\n\t\"Answer the arguments the receiver sends in a message to its receiver.\"\n\t^arguments\n",
          "arguments:": "arguments: anArray\n\t\"The argument, anArray, consists of the arguments of the message\n\tthe receiver sends to its model.\"\n\targuments _ anArray\n"
        },
        "initialize-release": {
          "initialize": "initialize\n\tsuper initialize.\n\tinsideColor _ Form white.\n\tcomplemented _ false.\n\tlabel _ nil.\n\tselector _ #isOn.\n\targuments _ #()\n",
          "release": "release\n\tsuper release.\n\tlabel release\n"
        },
        "controller access": {
          "defaultControllerClass": "defaultControllerClass\n\t^SwitchController\n"
        }
      }
    },
    "SwitchController": {
      "comment": "I coordinate the interaction of a Switch, a SwitchView, and input events (user actions, see class Sensor).  My instances own a message in the form of a selector and an array of arguments.  Whenever the Switch is selected, this message is sent to the Switch.\n\nInstance Variables:\n\n\tselector\t<Symbol>\n\targuments\t<Array>\n",
      "class_name": "SwitchController",
      "superclass": "Controller",
      "instanceVariables": "selector arguments cursor",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "control defaults": {
          "isControlWanted": "isControlWanted\n\tself viewHasCursor ifTrue: [cursor == nil ifFalse: [cursor show]].\n\t^self viewHasCursor & sensor redButtonPressed\n",
          "isControlActive": "isControlActive\n\t^sensor anyButtonPressed & self viewHasCursor\n",
          "controlActivity": "controlActivity\n\t^ self\n"
        },
        "basic control sequence": {
          "sendMessage": "sendMessage\n\t\"The receiver consists of a selector and possibly of arguments that should be\n\tused to create a message to send to the receiver's model.\"\n\targuments size = 0\n\t\tifTrue: [model perform: selector]\n\t\tifFalse: [model perform: selector withArguments: arguments]\n",
          "controlInitialize": "controlInitialize\n\tview indicatorReverse\n",
          "controlTerminate": "controlTerminate\n\tview indicatorReverse.\n\tself viewHasCursor ifTrue: [self sendMessage]\n"
        },
        "accessing": {
          "cursor:": "cursor: aCursor\n\tcursor _ aCursor\n",
          "addArgument:": "addArgument: aValue\n\t\"Add the argument, aValue, as one of the arguments of the message\n\tthe receiver sends to its model.\"\n\targuments _ arguments copyWith: aValue\n",
          "selector:": "selector: aSymbol\n\t\"Set aSymbol to be the selector the receiver sends in a message to its model.\"\n\tselector _ aSymbol\n",
          "selector": "selector\n\t\"Answer the selector the receiver sends in a message to its receiver.\"\n\t^selector\n",
          "arguments": "arguments\n\t\"Answer the arguments the receiver sends in a message to its receiver.\"\n\t^arguments\n",
          "arguments:": "arguments: anArray\n\t\"The argument, anArray, consists of the arguments of the message\n\tthe receiver sends to its model.\"\n\targuments _ anArray\n"
        },
        "initialize-release": {
          "initialize": "initialize\n\tsuper initialize.\n\tselector _ #switch.\n\targuments _ Array new: 0\n"
        }
      }
    },
    "PopUpMenu": {
      "comment": "I represent a list of items.  My instances are presented on the display screen in a rectangular area.  The user points to an item, pressing a mouse button;  the item is highlighted.  When the button is released, the highlighted item indicates the selection.\n\nInstance Variables:\n\nlabelString\t<String> of menu items\nfont\t\t<StrikeFont> for displaying the characters\nlineArray\t<Array> of integers indicating where lines should be drawn in the menu\nframe\t<Quadrangle>\nform\t<Form> containing the composed paragraph\nmarker\t<Rectangle> used to highlight selection\nselection\t<Integer> index into menu items;  if 0, no selection\n",
      "class_name": "PopUpMenu",
      "superclass": "Object",
      "instanceVariables": "labelString font lineArray frame form marker selection",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "labels:lines:": "labels: aString lines: anArray\n\t\"Answer an instance of me whose items are in aString, with lines drawn\n\tafter each item indexed by anArray.\"\n\t^ self new labels: aString font: (TextStyle default fontAt: 1) lines: anArray\n",
          "labels:": "labels: aString\n\t\"Answer an instance of me whose items are in aString.\"\n\t^self labels: aString lines: nil\n"
        }
      },
      "instance_methods": {
        "controlling": {
          "startUpAndWaitForSelectionAt:": "startUpAndWaitForSelectionAt: aPoint\n\t\"Display and make a selection from the receiver as long as the button denoted\n\tby the symbol, aSymbol, is pressed.  Answer the current selection.\"\n\n\t  | upperLeft |\n\n\tself displayAt: aPoint\n\t\tduring: [[(Sensor anyButtonPressed and: [frame inside containsPoint: Sensor cursorPoint])]\n\t\t\t\t\twhileFalse: [].\n\t\t\t\t[self buttonPressed: #anyButton]\n\t\t\t\t\twhileTrue: [self manageMarker]].\n\t^selection\n",
          "startUpBlueButton": "startUpBlueButton\n\t\"Display and make a selection from the receiver as long as the blue button\n\tis pressed.\"\n\t^self startUp: #blueButton\n",
          "startUp:withHeading:": "startUp: aSymbol withHeading: aText\n\t\"Display and make a selection from the receiver as long as the button\n\tdenoted by the symbol, aSymbol, is pressed.  Answer the current selection.\"\n\n\tself displayAt: Sensor cursorPoint withHeading: aText\n\t\tduring: [Sensor cursorPoint: marker center.\n\t\t\t\t[self buttonPressed: aSymbol]\n\t\t\t\t\twhileFalse: [(frame containsPoint: Sensor cursorPoint) ifFalse: [Display flash: frame]].\n\t\t\t\t[self buttonPressed: aSymbol]\n\t\t\t\t\twhileTrue: [self manageMarker]].\n\t^selection\n",
          "startUpRedButton": "startUpRedButton\n\t\"Display and make a selection from the receiver as long as the red button\n\tis pressed.\"\n\t^self startUp: #redButton\n",
          "startUpYellowButton": "startUpYellowButton\n\t\"Display and make a selection from the receiver as long as the yellow button\n\tis pressed.\"\n\t^self startUp: #yellowButton\n",
          "startUp:": "startUp: aSymbol\n\t\"Display and make a selection from the receiver as long as the button\n\tdenoted by the symbol, aSymbol, is pressed.  Answer the current selection.\"\n\n\tself displayAt: Sensor cursorPoint\n\t\tduring: [Sensor cursorPoint: marker center.\n\t\t\t\t[self buttonPressed: aSymbol] whileFalse: [].\n\t\t\t\t[self buttonPressed: aSymbol] whileTrue: [self manageMarker]].\n\t^selection\n",
          "buttonPressed:": "buttonPressed: aSymbol\n\t\"The argument indicates which button should be tested.  Answer whether\n\tit is pressed.\"\n\n\taSymbol = #redButton ifTrue: [^Sensor redButtonPressed].\n\taSymbol = #yellowButton ifTrue: [^Sensor yellowButtonPressed].\n\taSymbol = #blueButton ifTrue: [^Sensor blueButtonPressed].\n\t^Sensor anyButtonPressed\n"
        },
        "bordering": {
          "borderWidth": "borderWidth\n\t\"Answer the borderWidth of the receiver's rectangular area.\"\n\t^frame borderWidth\n"
        },
        "selecting": {
          "selection": "selection\n\t\"Answer the current selection.\"\n\t^selection\n"
        },
        "basic control sequence": {
          "startUp": "startUp\n\t\"Show the receiver and give control to the user to make a selection.\"\n\t^self startUp: #anyButton\n"
        },
        "marker adjustment": {
          "markerOff": "markerOff\n\t\"No item is selected.  Reverse the highlight if any item has been marked as selected.\"\n\tselection ~= 0\n\t\tifTrue:\n\t\t\t[Display reverse: marker.\n\t\t\tselection _ 0]\n",
          "markerOn:": "markerOn: aPoint\n\t\"The item whose bounding area contains aPoint should be marked as selected.\n\tHighlight its area and set the selection to its index.\"\n\n\tselection = 0 | (marker containsPoint: aPoint) not\n\t\tifTrue: [selection = 0 & (marker containsPoint: aPoint)\n\t\t\t\t\tifTrue: [Display reverse: marker]\n\t\t\t\t\tifFalse:\n\t\t\t\t\t\t[selection ~= 0 ifTrue: [Display reverse: marker].\n\t\t\t\t\t\tmarker _\n\t\t\t\t\t\t\tmarker\n\t\t\t\t\t\t\t\talign: marker topLeft\n\t\t\t\t\t\t\t\twith: marker left @ (self markerTop: aPoint).\n\t\t\t\t\t\tDisplay reverse: marker]].\n\tselection _ marker top - frame top // marker height + 1\n",
          "manageMarker": "manageMarker\n\t\"If the cursor is inside the receiver's frame, then highlight the marked item.\n\tOtherwise no item is to be marked.\"\n\n\t| aPoint |\n\taPoint _ Sensor cursorPoint.\n\t(frame inside containsPoint: aPoint)\n\t\tifTrue: [self markerOn: aPoint]\n\t\tifFalse: [self markerOff]\n",
          "markerTop:": "markerTop: aPoint\n\t\"Answer aPoint, gridded to lines in the receiver.\"\n\n\t^(aPoint y - frame inside top truncateTo: font height) + frame inside top\n"
        },
        "displaying": {
          "displayAt:during:": "displayAt: aPoint during: aBlock\n\t\"Display the receiver centered at aPoint while aBlock is evaluated.\n\tIf necessary, translate so the view is completely on the screen.\"\n\n\t| delta savedArea |\n\tframe _ frame align: marker center with: aPoint.\n\tdelta _ frame amountToTranslateWithin: Display boundingBox.\n\tframe moveBy: delta.\n\tmarker _ marker align: marker center with: aPoint + delta.\n\tsavedArea _ Form fromDisplay: frame.\n\tDisplay black: (frame origin + (1@1) corner: frame corner).\n\tDisplay black: (frame origin corner: frame corner - (1@1)).\n\tform displayOn: Display at: frame inside topLeft clippingBox: frame inside.\n\tselection ~= 0 ifTrue: [Display reverse: marker].\n\taBlock value.\n\tsavedArea displayOn: Display at: frame topLeft\n",
          "displayAt:withHeading:during:": "displayAt: aPoint withHeading: aText during: aBlock\n\t\"Display the receiver centered at aPoint while aBlock is evaluated.\n\tIf necessary, translate so the view is completely on the screen.\"\n\n\t| delta savedArea heading headingBox headingSavedArea |\n\tframe _ frame align: marker center with: aPoint.\n\theading _ aText asDisplayText.\n\theadingBox _ heading boundingBox expandBy: 2.\n\theadingBox _ headingBox\n\t\t\talign: headingBox bottomCenter\n\t\t\twith: frame topCenter + (0@2).\n\tdelta _ (frame merge: headingBox) amountToTranslateWithin: Display boundingBox.\n\tframe moveBy: delta.\n\theadingBox moveBy: delta.\n\tmarker _ marker align: marker center with: aPoint + delta.\n\tsavedArea _ Form fromDisplay: frame.\n\theadingSavedArea _ Form fromDisplay: headingBox.\n\tDisplay border: (headingBox) width: 2 mask: Form black.\n\theading displayAt: headingBox origin + (2@2).\n\tDisplay black: (frame origin + (1@1) corner: frame corner).\n\tDisplay black: (frame origin corner: frame corner - (1@1)).\n\tform displayOn: Display at: frame inside topLeft clippingBox: frame inside.\n\tselection ~= 0 ifTrue: [Display reverse: marker].\n\taBlock value.\n\tsavedArea displayOn: Display at: frame topLeft.\n\theadingSavedArea displayOn: Display at: headingBox topLeft\n"
        },
        "accessing": {
          "width": "width\n\t\"Answer the width of the receiver's rectangular area.\"\n\t^frame width\n",
          "topLeft": "topLeft\n\t\"Answer the point at the topLeft of the receiver's rectangular area.\"\n\t^frame topLeft\n",
          "height": "height\n\t\"Answer the width of the receiver's rectangular area.\"\n\t^frame height\n",
          "center": "center\n\t\"Answer the point at the center of the receiver's rectangular area.\"\n\t^frame center\n",
          "reset": "reset\n\tmarker _  marker align: marker topLeft with: frame topLeft + frame borderWidth.\n\tselection _ 0.\n"
        },
        "private": {
          "labels:font:lines:": "labels: aString font: aFont lines: anArray\n\t| style labelPara |\n\tlabelString _ aString.\n\tfont _ aFont.\n\tstyle _ TextStyle fontArray: (Array with: font).\n\tstyle alignment: 2.  \"centered\"\n\tstyle gridForFont: 1 withLead: 0.\n\tlabelPara _ Paragraph withText: aString asText style: style.\n\tlineArray _ anArray.\n\tform _ labelPara asForm.\n\tframe _ Quadrangle new.\n\tframe region: (labelPara compositionRectangle expandBy: 2).\n\tframe borderWidth: (1@1 corner: 3@3).\n\tlineArray == nil\n\t  ifFalse:\n\t\t[lineArray do:\n\t\t\t[:line |\n\t\t\tform fill: (0 @ (line * font height) extent: (frame width @ 1))\n\t\t\t\tmask: Form black]].\n\tmarker _ frame inside topLeft extent: frame inside width @ labelPara lineGrid.\n\tselection _ 0\n",
          "rescan": "rescan\n\t\"cause me to be recreated for system changes like fonts\"\n\n\tlabelString == nil\n\t\tifFalse: [self labels: labelString font: font lines: lineArray]\n\n\t\"PopUpMenu allInstancesDo: [:x | x rescan].\"\n"
        }
      }
    },
    "Button": {
      "comment": "I am a Switch that turns off automatically after being turned on, that is, I act like a push-button switch.\n",
      "class_name": "Button",
      "superclass": "Switch",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "newOn": "newOn\n\tself error: 'Buttons cannot be created in the on state'.\n\t^nil\n"
        }
      },
      "instance_methods": {
        "state": {
          "turnOn": "turnOn\n\t\"The receiver remains in the 'off' state'.\"\n\n\tself doAction: onAction.\n\tself doAction: offAction\n",
          "turnOff": "turnOff\n\t\"Sets the state of the receiver to 'off'.  The off action of the receiver is not\n\texecuted.\"\n\n\ton _ false\n"
        }
      }
    },
    "IndicatorOnSwitchController": {
      "comment": "I am a SwitchController that has its View (a SwitchView) highlighted while the model (a Switch) handles the messages it is sent.\n",
      "class_name": "IndicatorOnSwitchController",
      "superclass": "SwitchController",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "basic control sequence": {
          "sendMessage": "sendMessage\n\targuments size = 0\n\t\tifTrue: [view indicatorOnDuring: [model perform: selector]]\n\t\tifFalse: [view indicatorOnDuring:\n\t\t\t\t\t[model perform: selector withArguments: arguments]]\n"
        }
      }
    },
    "Switch": {
      "comment": "I represent a selection setting and actions to take depending on a change in the setting.  An instance of me has three attributes:  state, which is either on or off;  on action;  and off action.  The on and off actions are blocks of code that execute whenever the instance changes state.  I am typically used as a menu item in conjunction with a SwitchView and a SwitchController.\n\nInstance Variables:\n\t\ton\t\t\t\t<Boolean> true if the Switch is on\n\t\tonAction\t\t<BlockContext> or nil\n\t\toffAction\t\t<BlockContext> or nil\n",
      "class_name": "Switch",
      "superclass": "Object",
      "instanceVariables": "on onAction offAction",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t\"Answer an instance of me such that the on and off actions are set to nil\n\t('no action'), and the state is set to 'off'.\"\n\n\t^self newOff\n",
          "newOn": "newOn\n\t\"Answer an instance of me such that the on and off actions are set to nil\n\t('no action'), and the state is set to 'on'.\"\n\n\t^super new initializeOn\n",
          "newOff": "newOff\n\t\"Answer an instance of me such that the on and off actions are set to nil\n\t('no action'), and the state is set to 'off'.\"\n\n\t^super new initializeOff\n"
        }
      },
      "instance_methods": {
        "dependents access": {
          "removeDependent:": "removeDependent: aDependent\n\t\"If aDependent is the only dependent in the list, the receiver sends\n\tSwitch|release to try to break up possible pointer cycles.\"\n\n\tsuper removeDependent: aDependent.\n\tself dependents isEmpty ifTrue: [self release]\n"
        },
        "state": {
          "isOff": "isOff\n\t\"Answer whether the receiver is set off or not.\"\n\t^on not\n",
          "isOn": "isOn\n\t\"Answer whether the receiver is set on or not.\"\n\t^on\n",
          "set": "set\n\t\"Set the state of the receiver to 'on'.  If the state of the receiver was previously\n\t'off', then 'self change' is sent.  The receiver's on action is NOT executed.\"\n\n\tself isOff\n\t\tifTrue:\n\t\t\t[on _ true.\n\t\t\tself changed]\n",
          "turnOn": "turnOn\n\t\"Set the state of the receiver to 'on'.  If the state of the receiver was previously\n\t'off', then 'self change' is sent and the receiver's on action is executed.\"\n\n\tself isOff\n\t\tifTrue:\n\t\t\t[on _ true.\n\t\t\tself changed.\n\t\t\tself doAction: onAction]\n",
          "turnOff": "turnOff\n\t\"Set the state of the receiver to 'off'.  If the state of the receiver was previously\n\t'on', then 'self change' is sent and the receiver's off action is executed.\"\n\n\tself isOn\n\t\tifTrue:\n\t\t\t[on _ false.\n\t\t\tself changed.\n\t\t\tself doAction: offAction]\n",
          "switch": "switch\n\t\"Change the state of the receiver from 'on' to 'off' or from 'off' to 'on' (see\n\tSwitch|turnOn, Switch|turnOff).\"\n\n\tself isOn\n\t\tifTrue: [self turnOff]\n\t\tifFalse: [self turnOn]\n"
        },
        "action": {
          "offAction:": "offAction: anAction\n\t\"Set the off action of the receiver to anAction.\"\n\n\toffAction _ anAction fixTemps\n",
          "doAction:": "doAction: anAction\n\t\"Execute anAction if it is non-nil.\"\n\n\tanAction == nil ifFalse: [anAction value]\n",
          "onAction:": "onAction: anAction\n\t\"Set the on action of the receiver to anAction.\"\n\n\tonAction _ anAction fixTemps\n"
        },
        "private": {
          "initializeOff": "initializeOff\n\ton _ false.\n\tonAction _ nil.\n\toffAction _ nil\n",
          "initializeOn": "initializeOn\n\ton _ true.\n\tonAction _ nil.\n\toffAction _ nil\n"
        },
        "initialize-release": {
          "release": "release\n\t\"Set the on and off actions of the receiver to nil ('no action') in order to break\n\tpossible pointer cycles.  It is sent by Switch|deleteDependent: when the\n\tlast dependent has been deleted from the Switch's list of dependents.\"\n\n\tsuper release.\n\tonAction _ nil.\n\toffAction _ nil\n"
        },
        "clearing": {
          "clear": "clear\n\t\"Set the state of the receiver to 'off'.  If the state of the receiver was previously\n\t'on', then 'self change' is sent.  The receiver's off action is NOT executed.\"\n\n\tself isOn\n\t\tifTrue:\n\t\t\t[on _ false.\n\t\t\tself changed]\n"
        }
      }
    },
    "ActionMenu": {
      "comment": "ActionMenus carry an array of selectors which correspond to the listed menu items.  This allows a menu to stand alone in parameterizing a controller, since the controller just sends the selector to its model.\n\nActionMenus allow the pluggable views experiment (TextView, SelectionInListView) to\nhandle menus much easier than having pairs of variables for the menu and its associated\nselectors.  Obviously these menus eagerly await a proper objectification of protocol.\n",
      "class_name": "ActionMenu",
      "superclass": "PopUpMenu",
      "instanceVariables": "selectors",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "labels:lines:selectors:": "labels: aString lines: anArray selectors: selArray\n\t| aMenu |\n\taMenu _ self labels: aString lines: anArray.\n\taMenu setSelectors: selArray.\n\t^ aMenu\n",
          "labels:selectors:": "labels: aString selectors: selArray\n\t^ self labels: aString lines: nil selectors: selArray\n"
        },
        "confirmation": {
          "confirm": "confirm  \"ActionMenu confirm\"\n\t^ (ActionMenu labels: 'confirm\\abort' withCRs selectors: nil) startUp = 1\n"
        }
      },
      "instance_methods": {
        "action symbols": {
          "selectorAt:": "selectorAt: index\n\t^ selectors at: index\n",
          "setSelectors:": "setSelectors: selArray\n\tselectors _ selArray\n"
        }
      }
    },
    "LockedSwitchController": {
      "comment": "I am a SwitchController that will not take control if the model (a Switch) is locked.  As an indication, the view (a SwitchView) flashes.\n",
      "class_name": "LockedSwitchController",
      "superclass": "SwitchController",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "control defaults": {
          "isControlWanted": "isControlWanted\n\tmodel isLocked\n\t\tifTrue:\n\t\t\t[view flash.\n\t\t\t^false].\n\t^super isControlWanted\n"
        }
      }
    },
    "BooleanView": {
      "comment": "BooleanView is a \"pluggable\" view of a boolean value.  The notion of pluggable views is an\nexperiment in user interface design.  The idea is to provide a view which can be plugged\nonto any object, rather than having to define a new subclass specific to every kind of\nobject which needs to be viewed.\n\nThe chief mechanism is a set of selectors, which can be thought of as an adaptor to\nconvert the generic textView operations (such as interrogateModel) into model-specific\noperations (such as metaclassSelected).\n\nSee the creation messages in my class for an explication of the various parameters.\nBrowse senders of the creation messages in my class for examples in the system.\n",
      "class_name": "BooleanView",
      "superclass": "SwitchView",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "on:aspect:label:change:value:": "on: model aspect: aspect label: label change: changeSel value: onValue\n\t\"Create a 'pluggable' (see class comment) switchView viewing anObject.\n\taspect is sent to read the current boolean value in the model.\n\t\tIt is also used as the changed: parameter for this view.\n\tchangeSel is sent to inform anObject of new boolean value for the model.\"\n\t| view args |\n\tview _ self new.\n\tview model: model.\n\tview selector: aspect; arguments: (args _ Array with: onValue).\n\tview controller selector: changeSel; arguments: args.\n\tview label: label asParagraph.\n\t^view\n"
        }
      },
      "instance_methods": {
        "updating": {
          "update:": "update: aspect\n\taspect == selector ifTrue: [super update: aspect]\n",
          "interrogateModel": "interrogateModel\n\t^ (model perform: selector) = arguments first\n"
        }
      }
    }
  },
  "Interface-Projects": {
    "ProjectController": {
      "comment": "I am a kind of StringHolderController (a ParagraphEditor that adds the doIt, printIt, accept, and cancel commands).  The commands doIt and printIt are omitted.  I provide one additional menu command\n\tenter -- replace the current project by the model, thereby \"entering\" the door\n\t\t\tto a new office or work area\n",
      "class_name": "ProjectController",
      "superclass": "StringHolderController",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "ProjectYellowButtonMenu ProjectYellowButtonMessages",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"Initialize the menu for the yellow mouse button.\"\n\n\tProjectYellowButtonMenu _\n\t\tPopUpMenu\n\t\t\tlabels: 'again\nundo\ncopy\ncut\npaste\naccept\ncancel\nenter'\n\t\t\tlines: #(2 5 7 ).\n\tProjectYellowButtonMessages _\n\t\t\t#(again undo copySelection cut paste accept cancel enter )\n\t\"ProjectViewController initialize\"\n"
        }
      },
      "instance_methods": {
        "menu messages": {
          "enter": "enter\n\t\"Exchange projects so that the receiver's model is the context in which the user works.\"\n\tview topView deEmphasize.\n\tmodel enter\n"
        },
        "private": {
          "initializeYellowButtonMenu": "initializeYellowButtonMenu\n\tself yellowButtonMenu: ProjectYellowButtonMenu\n\t\tyellowButtonMessages: ProjectYellowButtonMessages.\n"
        }
      }
    },
    "ProjectView": {
      "comment": "I am a StringHolderView of the description of a Project.  ProjectController is my default controller.\n",
      "class_name": "ProjectView",
      "superclass": "StringHolderView",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "open": "open\n\t\"Answer an instance of me for a new Project.  It is created on the display screen.\"\n\n\t^self open: Project new\n\t\"ProjectView open\"\n",
          "open:": "open: aProject\n\t\"Answer an instance of me for the argument, aProject.  It is created on the\n\tdisplay screen.\"\n\t| aProjectView topView |\n\taProjectView _ super new.\n\taProjectView model: aProject.\n\taProjectView borderWidth: 1.\n\ttopView _ StandardSystemView new.\n\ttopView model: aProject.\n\ttopView borderWidth: 1.\n\ttopView addSubView: aProjectView.\n\ttopView label: 'Project'.\n\ttopView minimumSize: 100 @ 50.\n\ttopView controller open\n"
        }
      },
      "instance_methods": {
        "initialize-release": {
          "release": "release\n\tmodel release.\n\tsuper release\n"
        },
        "controller access": {
          "defaultControllerClass": "defaultControllerClass\n\t^ProjectController\n"
        }
      }
    },
    "Project": {
      "comment": "Each screen is a manifestation of a project.  Each project manages the windows (views) in it.  While the user is working in the project, the changes made to classes are collected.  Thus a system-wide set of changes is the collection of all project changes.\n",
      "class_name": "Project",
      "superclass": "StringHolder",
      "instanceVariables": "projectWindows projectChangeSet projectTranscript projectHolder",
      "classInstanceVariables": "",
      "classVariables": "CurrentProject",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"This is the Top Project.\"\n\n\tCurrentProject _ super new initialProject\n\t\"Project initialize.\"\n"
        },
        "constants": {
          "current": "current\n\t\"Answer the project that is currently being used.\"\n\t^CurrentProject\n"
        },
        "instance creation": {
          "new": "new\n\t^super new setProjectHolder: CurrentProject\n"
        }
      },
      "instance_methods": {
        "change management": {
          "noChanges": "noChanges\n\t\"Reset the receiver's ChangeSet so that it is empty.\"\n\tprojectChangeSet _ ChangeSet new.\n\tSmalltalk newChanges: projectChangeSet\n"
        },
        "controlling": {
          "enter": "enter\n\t\"The user has chosen to change the context of the workspace to be that of\n\tthe receiver.  Change the ChangeSet, Transcript, and collection of scheduled\n\tviews accordingly.\"\n\n\tSmalltalk newChanges: projectChangeSet.\n\tCurrentProject _ self.\n\tTextCollector newTranscript: projectTranscript.\n\tControlManager newScheduler: projectWindows\n",
          "exit": "exit\n\t\"Leave the current project and enter the project in which the receiver's view\n\tis scheduled.\"\n\tprojectHolder enter\n"
        },
        "dependents access": {
          "removeDependent:": "removeDependent: aDependent\n\tsuper removeDependent: aDependent.\n\tself dependents isEmpty ifTrue: [self release]\n"
        },
        "lock access": {
          "isLocked": "isLocked\n\t^super isLocked\n\t| projectChangeSet isEmpty not\n\t| (projectWindows scheduledControllers size > 1)\n",
          "isUnlocked": "isUnlocked\n\t^ self isLocked not\n"
        },
        "private": {
          "initialProject": "initialProject\n\tprojectWindows _ ScheduledControllers.\n\tprojectChangeSet _ Smalltalk changes.\n\tprojectHolder _ self\n",
          "setProjectHolder:": "setProjectHolder: aProject\n\tprojectWindows _ ControlManager new.\n\tprojectChangeSet _ ChangeSet new.\n\tprojectTranscript _ TextCollector new.\n\tprojectHolder _ aProject\n"
        },
        "initialize-release": {
          "release": "release\n\tprojectWindows isNil ifFalse: [projectWindows release].\n\t^super release\n"
        }
      }
    }
  },
  "Interface-Prompt/Confirm": {
    "FillInTheBlankView": {
      "comment": "I am a view of a FillInTheBlank--I display a query and an area in which the user can type some information.\n",
      "class_name": "FillInTheBlankView",
      "superclass": "StringHolderView",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "on:message:displayAt:centered:": "on: aFillInTheBlank message: messageString displayAt: originPoint centered: centered\n\t\"Answer an instance of me on the model aFillInTheBlank asking the question messageString. If the argument centered, a Boolean, is false, display the instance with top left corner at originPoint; otherwise, display it with its center at originPoint.  If necessary, translate so the view is completely on the screen.\"\n\n\t^self on: aFillInTheBlank message: messageString displayAt: originPoint centered: centered useCRController: true\n",
          "openOn:message:displayAt:centered:": "openOn: aFillInTheBlank message: messageString displayAt: originPoint centered: centered\n\t\"Create and schedule an instance of me that displays aFillInTheBlank asking the\n\tquestion messageString.  If the argument centered, a Boolean, is false, display the\n\tinstance with top left corner at originPoint;  otherwise, display it with its center at\n\toriginPoint.  Do not schedule, rather take control immediately and insist that\n\tthe user respond.\"\n\n\t| topView messageView answerView |\n\tmessageView _ self buildMessageView: messageString.\n\tanswerView _\n\t\tself buildAnswerView: aFillInTheBlank\n\t\t\tframeWidth: messageView window width.\n\ttopView _ StandardSystemView new model: aFillInTheBlank.\n\ttopView addSubView: messageView.\n\ttopView addSubView: answerView below: messageView.\n\ttopView\n\t\talign: (centered\n\t\t\t\tifTrue: [topView viewport center]\n\t\t\t\tifFalse: [topView viewport topLeft])\n\t\twith: originPoint.\n\ttopView label: 'Type a response'.\n\ttopView window:\n\t\t(0@0 extent: messageView window width @ (messageView window height + 40)).\n\ttopView controller openDisplayAt: originPoint\n",
          "on:message:displayAt:centered:useCRController:": "on: aFillInTheBlank message: messageString displayAt: originPoint centered: centered useCRController: useCRController\n\n\t| topView messageView answerView |\n\tmessageView _ self buildMessageView: messageString.\n\tanswerView _\n\t\tself buildAnswerView: aFillInTheBlank\n\t\t\tframeWidth: messageView window width.\n\tuseCRController ifTrue: [answerView controller: CRFillInTheBlankController new].\n\ttopView _ View new model: aFillInTheBlank.\n\ttopView controller: BinaryChoiceController new.\n\ttopView addSubView: messageView.\n\ttopView addSubView: answerView below: messageView.\n\ttopView align: (centered\n\t\t\tifTrue: [topView viewport center]\n\t\t\tifFalse: [topView viewport topLeft])\n\t\twith: originPoint.\n\ttopView window:\n\t\t(0 @ 0 extent:\n\t\t\tmessageView window width @\n\t\t\t(messageView window height + answerView window height)).\n\ttopView translateBy:\n\t\t(topView displayBox amountToTranslateWithin: Display boundingBox).\n\t^topView\n"
        },
        "private": {
          "buildAnswerView:frameWidth:": "buildAnswerView: aFillInTheBlank frameWidth: widthInteger\n\t| answerView |\n\tanswerView _ self new model: aFillInTheBlank.\n\tanswerView window: (0@0 extent: widthInteger @ 40).\n\tanswerView borderWidth: 2.\n\t^answerView\n",
          "buildMessageView:": "buildMessageView: messageString\n\t|  messageView  |\n\tmessageView _ DisplayTextView new model: messageString asDisplayText.\n\tmessageView borderWidthLeft: 2 right: 2 top: 2 bottom: 0.\n\tmessageView insideColor: Form white.\n\tmessageView controller: NoController new.\n\tmessageView window: (0@0 extent: (messageView window extent max: 200@30)).\n\tmessageView centered.\n\t^messageView\n"
        }
      },
      "instance_methods": {
        "controller access": {
          "defaultControllerClass": "defaultControllerClass\n\t^FillInTheBlankController\n"
        }
      }
    },
    "FillInTheBlankController": {
      "comment": "I am a StringHolderController for a FillInTheBlankView.  The string is information that the user can type in and edit.  Upon issuing the accept command, this information is used by my model in the evaluation of an action block.\n",
      "class_name": "FillInTheBlankController",
      "superclass": "StringHolderController",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "control defaults": {
          "isControlWanted": "isControlWanted\n\tmodel actionTaken ifTrue: [^false].\n\t^super isControlActive\n",
          "isControlActive": "isControlActive\n\tmodel actionTaken ifTrue: [^false].\n\t^super isControlActive\n"
        },
        "basic control sequence": {
          "controlTerminate": "controlTerminate\n\t| topController |\n\tsuper controlTerminate.\n\tmodel actionTaken ifFalse: [^self].\n\ttopController _ view topView controller.\n\t(topController notNil & (topController isKindOf: StandardSystemController))\n\t\tifTrue: [topController close].\n\tmodel selectAction\n"
        },
        "menu messages": {
          "accept": "accept\n\tsuper accept.\n\tmodel setAction: true\n"
        },
        "initialize-release": {
          "resetState": "resetState\n\t\"intercept to force selection of entire text\"\n\n\tsuper resetState.\n\tstopBlock _ paragraph characterBlockForIndex: paragraph text size+1.\n"
        }
      }
    },
    "FillInTheBlank": {
      "comment": "I represent a request for information that will be applied as the argument of a block of actions.\n\nInstance Variables\n\tactionBlock\t<BlockContext>\n\tactionTaken <Boolean> whether the actonBlock has been evaluated at least once\n",
      "class_name": "FillInTheBlank",
      "superclass": "StringHolder",
      "instanceVariables": "actionBlock actionTaken",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "request:initialAnswer:": "request: messageString initialAnswer: aString\n\t\"Create an instance of me whose question is messageString.\n\tDisplay it centered around the cursor.\n\tSupply aString as an initial answer.\n\tSimply return whatever the user accepts.\"\n\n\tself\n\t\trequest: messageString\n\t\tdisplayAt: Sensor cursorPoint\n\t\tcentered: true\n\t\taction: [:response | response]\n\t\tinitialAnswer: aString.\n\t^response\n",
          "action:initialAnswer:": "action: aBlock initialAnswer: aString\n\t\"Answer an instance of me whose action is aBlock and initial action argument is\n\taString.\"\n\t| newBlank |\n\tnewBlank _ self new initialize.\n\tnewBlank action: aBlock.\n\tnewBlank contents: aString.\n\t^newBlank\n",
          "request:": "request: messageString\n\t\"Create an instance of me whose question is messageString.\n\tDisplay it centered around the cursor.\n\tSimply return whatever the user accepts.\"\n\n\t^self request: messageString initialAnswer: ''\n",
          "request:displayAt:centered:action:initialAnswer:useCRController:": "request: messageString displayAt: aPoint centered: centered action: aBlock initialAnswer: aString useCRController: useCRController\n\t\"Answer an instance of me whose question is messageString.  Once the user provides an answer, then evaluate aBlock. If centered, a Boolean, is false, display the view of the instance at aPoint; otherwise display it with its center at aPoint. \"\n\n\t| newBlank fillInView savedArea |\n\tnewBlank _ self new initialize.\n\tnewBlank action: aBlock.\n\tnewBlank contents: aString.\n\tfillInView _\n\t\tFillInTheBlankView\n\t\t\ton: newBlank\n\t\t\tmessage: messageString\n\t\t\tdisplayAt: aPoint\n\t\t\tcentered: centered\n\t\t\tuseCRController: useCRController.\n\tsavedArea _ Form fromDisplay: fillInView displayBox.\n\tfillInView display.\n\tfillInView controller centerCursorInView.\n\tfillInView controller startUp.\n\tfillInView release.\n\tsavedArea displayOn: Display at: fillInView viewport topLeft\n",
          "request:displayAt:centered:action:initialAnswer:": "request: messageString displayAt: aPoint centered: centered action: aBlock initialAnswer: aString\n\n\t^self request: messageString displayAt: aPoint centered: centered action: aBlock initialAnswer: aString useCRController: true\n",
          "message:displayAt:centered:action:initialAnswer:": "message: messageString displayAt: aPoint centered: centered action: aBlock initialAnswer: aString\n\t\"Answer an instance of me whose question is messageString.  Once the\n\tuser provides an answer, then evaluate aBlock. If centered, a Boolean, is\n\tfalse, display the view of the instance at aPoint; otherwise display it with its center\n\tat aPoint. \"\n\n\t| newBlank |\n\tnewBlank _ self new initialize.\n\tnewBlank action: aBlock.\n\tnewBlank contents: aString.\n\tFillInTheBlankView\n\t\topenOn: newBlank\n\t\tmessage: messageString\n\t\tdisplayAt: aPoint\n\t\tcentered: centered\n"
        },
        "examples": {
          "example3": "example3\n\t\"Try this example by choosing menu command print it\"\n\n\t^Text fromUser\n\n\t\"FillInTheBlank example3.\"\n",
          "example2": "example2\n\t\"Example waits for you to click red button somewhere on the screen. The\n\tview will show where you point.  Terminate by choosing menu command accept or\n\ttyping carriage return.\"\n\n\tFillInTheBlank\n\t\trequest: 'What is your name?'\n\t\tdisplayAt: Sensor waitButton\n\t\tcentered: true\n\t\taction: [:answer | Transcript cr; show: answer]\n\t\tinitialAnswer: ''\n\n\t\"FillInTheBlank example2.\"\n",
          "example1": "example1\n\t\"Example waits for you to click red button somewhere on the screen. The\n\tview will show where you point.  Terminate by choosing menu command accept.\"\n\n\tFillInTheBlank\n\t\tmessage: 'What is your name?'\n\t\tdisplayAt: Sensor waitButton\n\t\tcentered: true\n\t\taction: [:answer | Transcript cr; show: answer]\n\t\tinitialAnswer: ''\n\n\t\"FillInTheBlank example1.\"\n"
        }
      },
      "instance_methods": {
        "menu messages": {
          "selectAction": "selectAction\n\t\"Evaluate the receiver's assigned action block, if any, with the answer as the\n\tblock argument.\"\n\tactionBlock notNil ifTrue: [actionBlock value: contents]\n"
        },
        "accessing": {
          "action:": "action: aBlock\n\t\"The argument, aBlock, will be evaluated when the receiver is sent the\n\tmessage selectAction.\"\n\tactionBlock _ aBlock\n",
          "actionTaken": "actionTaken\n\t^actionTaken\n",
          "setAction:": "setAction: aBoolean\n\tactionTaken _ aBoolean\n"
        },
        "initialize-release": {
          "initialize": "initialize\n\tsuper initialize.\n\tactionTaken _ false\n"
        }
      }
    },
    "CRFillInTheBlankController": {
      "comment": "I am a FillInTheBlankController that causes termination on a carriage return.\n",
      "class_name": "CRFillInTheBlankController",
      "superclass": "FillInTheBlankController",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "sensor access": {
          "readKeyboard": "readKeyboard\n\t\"Copied from ParagraphEditor to gain access to carriage return termination--read a key that the user strikes on the keyboard.\"\n\n\t| typeAhead currentCharacter |\n\tself deselect.\n\ttypeAhead _ WriteStream on: (String new: 128).\n\tbeginTypeInBlock == nil\n\t\tifTrue:\n\t\t\t[UndoSelection _ self selection.\n\t\t\tbeginTypeInBlock _ startBlock copy].\n\t[sensor keyboardPressed]\n\t\twhileTrue:\n\t\t\t[currentCharacter _ sensor keyboardPeek.\n\t\t\tcurrentCharacter = Character cr ifTrue: [^self cr: typeAhead].\n\t\t\t(self perform: (Keyboard at: currentCharacter asciiValue + 1)\n\t\t\t\t with: typeAhead)\n\t\t\t\tifTrue: [^self]].\n\tself replaceSelectionWith:\n\t\t(Text string: typeAhead contents emphasis: emphasisHere).\n\tstartBlock _ stopBlock copy.\n\tself selectAndScroll\n"
        },
        "basic control sequence": {
          "controlInitialize": "controlInitialize\n\tstartBlock _ paragraph characterBlockForIndex: startBlock stringIndex.\n\tstopBlock _ paragraph characterBlockForIndex: stopBlock stringIndex.\n\tself initializeSelection.\n\tbeginTypeInBlock _ nil\n",
          "controlTerminate": "controlTerminate\n\t\"self closeTypeIn ifTrue: [startBlock _ stopBlock copy].\"\n\t\"so leaving and entering window won't select last type-in\"\n\tsuper controlTerminate\n"
        },
        "stop conditions": {
          "cr:": "cr: characterStream\n\t\"The carriage return was typed by the user.  This designates that the receiver should give up control.\"\n\n\tsensor keyboard. \t\"gobble cr\"\n\tcharacterStream isEmpty ifFalse:\n\t\t[self replaceSelectionWith:\n\t\t\t(Text string: characterStream contents emphasis: emphasisHere)].\n\tself accept\n"
        }
      }
    },
    "BinaryChoice": {
      "comment": "I represent a true/false (yes/no) choice.  My instances have two possible actions they can take, depending on which choice is made.\n\nInstance variables\n\ttrueAction\t<BlockContext>\tsequence of expression to do if positive choice is made\n\tfalseAction\t<BlockContext>\tsequence of expression to do if negative choice is made\n\tactionTaken\t<Boolean> was the action, true or false, already taken\n",
      "class_name": "BinaryChoice",
      "superclass": "Object",
      "instanceVariables": "trueAction falseAction actionTaken",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "message:displayAt:centered:ifTrue:ifFalse:": "message: messageString displayAt: aPoint centered: centered ifTrue: trueAlternative ifFalse: falseAlternative\n\t\"Answer an instance of me whose question is messageString.  If the user\n\tanswer is yes, then evaluate trueAlternative.  If the user answer is no,\n\tevaluate falseAlternative. If centered, a Boolean, is false, display the view of the\n\tinstance at aPoint; otherwise display it with its center at aPoint.\"\n\n\t| newChoice |\n\tnewChoice _ self new initialize.\n\tnewChoice trueAction: trueAlternative.\n\tnewChoice falseAction: falseAlternative.\n\tBinaryChoiceView openOn: newChoice message: messageString displayAt: aPoint centered: centered\n",
          "message:displayAt:ifTrue:ifFalse:": "message: messageString displayAt: originPoint ifTrue: trueAlternative ifFalse: falseAlternative\n\t\"Answer an instance of me whose question is messageString.  If the user\n\tanswer is yes, then evaluate trueAlternative.  If the user answer is no,\n\tevaluate falseAlternative.  Display the view of the instance at originPoint.\"\n\n\t^self\n\t\tmessage: messageString\n\t\tdisplayAt: originPoint\n\t\tcentered: false\n\t\tifTrue: trueAlternative\n\t\tifFalse: falseAlternative\n",
          "message:displayAt:ifTrue:": "message: messageString displayAt: originPoint ifTrue: trueAlternative\n\t\"Answer an instance of me whose question is messageString.  If the user\n\tanswer is yes, then evaluate trueAlternative.  If the user answer is no,\n\tdo nothing.  Display the view of the instance at originPoint.\"\n\n\t^self\n\t\tmessage: messageString\n\t\tdisplayAt: originPoint\n\t\tcentered: false\n\t\tifTrue: trueAlternative\n\t\tifFalse: nil\n",
          "message:displayAt:ifFalse:": "message: messageString displayAt: originPoint ifFalse: falseAlternative\n\t\"Answer an instance of me whose question is messageString.  If the user\n\tanswer is yes, then do nothing.  If the user answer is no, evaluate falseAlternative.\n\tDisplay the view of the instance at originPoint.\"\n\n\t^self\n\t\tmessage: messageString\n\t\tdisplayAt: originPoint\n\t\tcentered: false\n\t\tifTrue: nil\n\t\tifFalse: falseAlternative\n",
          "message:": "message: messageString\n\t\"Answer an instance of me whose question is messageString.  If the user\n\tanswer is yes, then return true.  If the user answer is no, return false.\n\tDisplay the view of the instance at the cursor location.\"\n\t| answer |\n\tself\n\t\tmessage: messageString\n\t\tdisplayAt: Sensor cursorPoint\n\t\tcentered: true\n\t\tifTrue: [answer _ true]\n\t\tifFalse: [answer _ false].\n\t^answer\n"
        },
        "examples": {
          "example": "example\n\tBinaryChoice\n\t\tmessage: 'Are you happy?'\n\t\tdisplayAt: Sensor waitButton\n\t\tcentered: true\n\t\tifTrue: [Transcript cr; show: 'happy']\n\t\tifFalse: [Transcript cr; show: 'not happy']\n\n\t\"BinaryChoice example.\"\n"
        }
      },
      "instance_methods": {
        "menu messages": {
          "selectFalse": "selectFalse\n\t\"Take the action, if one, associated with selecting no or false.\"\n\tactionTaken _ true.\n\tfalseAction notNil ifTrue: [falseAction value]\n",
          "selectTrue": "selectTrue\n\t\"Take the action, if one, associated with selecting yes or true.\"\n\tactionTaken _ true.\n\ttrueAction notNil ifTrue: [trueAction value]\n"
        },
        "accessing": {
          "active": "active\n\t\"Answer whether the receiver is an active system view.\"\n\t^false\n",
          "actionTaken": "actionTaken\n\t\"Answer whether the receiver has carried out its actions yet.\"\n\t^actionTaken\n"
        },
        "initialize-release": {
          "trueAction:": "trueAction: aBlock\n\t\"The argument, aBlock, will be evaluated if the receiver is sent the\n\tmessage selectTrue.\"\n\ttrueAction _ aBlock\n",
          "initialize": "initialize\n\t\"Initialize the receiver so that it indicates no action has yet been taken.\"\n\tactionTaken _ false\n",
          "falseAction:": "falseAction: aBlock\n\t\"The argument, aBlock, will be evaluated if the receiver is sent the\n\tmessage selectFalse.\"\n\tfalseAction _ aBlock\n"
        }
      }
    },
    "BinaryChoiceController": {
      "comment": "My instances assume that their model can carry out some action only once--that is, make a selection only once.  Control is given up if the model responds true to the message actionTaken.\n",
      "class_name": "BinaryChoiceController",
      "superclass": "Controller",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "cursor": {
          "centerCursorInView": "centerCursorInView\n\t\"Position sensor's mousePoint (which is assumed to be connected to the\n\tcursor) to the center of its view's inset display box (see Sensor|mousePoint: and\n\tView|insetDisplayBox).\"\n\n\t| lowestSubView subViews |\n\tsubViews_ view subViews.\n\tsubViews isEmpty\n\t\tifFalse:\t[lowestSubView _ subViews at: 1.\n\t\t\t\tsubViews do:\n\t\t\t\t\t[:subView |\n\t\t\t\t\t\t(subView insetDisplayBox top >\n\t\t\t\t\t\t\tlowestSubView insetDisplayBox top)\n\t\t\t\t\t\tifTrue:\t[lowestSubView _ subView]].\n\t\t\t\t^lowestSubView controller centerCursorInView].\n\n\t^super centerCursorInView\n"
        },
        "control defaults": {
          "isControlActive": "isControlActive\n\tmodel actionTaken ifTrue: [^false].\n\t[super isControlActive] whileFalse: [view flash].\n\t^true\n"
        },
        "basic control sequence": {
          "startUp": "startUp\n\n\tCursor normal showWhile: [super startUp]\n"
        }
      }
    }
  },
  "Interface-Support": {
    "ScrollController": {
      "comment": "I represent control for scrolling using a scrollBar.  I am a MouseMenuController that creates a scrollBar, rather than menus.  My subclasses add the button menus.  I keep control as long as the cursor is inside the view or the scrollBar area.\n\nA scrollBar is a rectangular area representing the length of the information being viewed.  It contains an inner rectangle whose top y-coordinate represents the relative position of the information visible on the screen with respect to all of the information, and whose size represents the relative amount of that information visible on the screen.  The user controls which part of the information is visible by pressing the red button.  If the cursor is to the right of the inner rectangle, the window onto the visible information moves upward, if the cursor is to the left, the window moves downward, and if the cursor is inside, the inner rectangle is grabbed and moved to a desired position.\n\nInstance Variables:\n\tscrollBar\t<Quadrangle> inside white, the outer rectangle\n\tmarker\t\t<Quadrangle> inside gray, the inner rectangle\n\tsavedArea\t<Form> the area the scrollBar overlaps, restored whenever\n\t\t\t\tthe scrollBar is hidden\n",
      "class_name": "ScrollController",
      "superclass": "MouseMenuController",
      "instanceVariables": "scrollBar marker savedArea",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "cursor": {
          "markerContainsCursor": "markerContainsCursor\n\t\"Answer whether the gray area inside the scroll bar area contains the cursor.\"\n\t^marker inside containsPoint: sensor cursorPoint\n",
          "changeCursor:": "changeCursor: aCursor\n\t\"The current cursor should be set to be aCursor.\"\n\tsensor currentCursor ~~ aCursor ifTrue: [aCursor show]\n",
          "scrollBarContainsCursor": "scrollBarContainsCursor\n\t\"Answer whether the cursor is anywhere within the scroll bar area.\"\n\t^scrollBar containsPoint: sensor cursorPoint\n"
        },
        "control defaults": {
          "isControlWanted": "isControlWanted\n\t^self viewHasCursor\n",
          "isControlActive": "isControlActive\n\t^self viewHasCursor | self scrollBarContainsCursor\n",
          "controlActivity": "controlActivity\n\tself scrollBarContainsCursor\n\t\tifTrue: [self scroll]\n\t\tifFalse: [super controlActivity]\n"
        },
        "basic control sequence": {
          "controlInitialize": "controlInitialize\n\t\"The scrollbar has a two-pixel border, and for alignment it assumes that this sub-view\n\thas a one-pixel border and shares another one-pixel border from its neighbor/super view\"\n\tsuper controlInitialize.\n\tscrollBar region: (0 @ 0 extent: 32 @ (view displayBox height + 2)).\n\tmarker region: self computeMarkerRegion.\n\tscrollBar _ scrollBar align: scrollBar topRight with: view displayBox topLeft - (0@1).\n\tmarker _ marker align: marker topCenter with: scrollBar inside topCenter.\n\tsavedArea _ Form fromDisplay: scrollBar.\n\tscrollBar displayOn: Display.\n\tself moveMarker\n",
          "controlTerminate": "controlTerminate\n\tsuper controlTerminate.\n\tsavedArea notNil\n\t\tifTrue:\n\t\t\t[savedArea displayOn: Display at: scrollBar topLeft.\n\t\t\tsavedArea_ nil]\n"
        },
        "marker adjustment": {
          "markerDelta": "markerDelta\n\t^marker top\n\t\t- scrollBar inside top\n\t\t- ((view window top - view boundingBox top) asFloat\n\t\t\t/ view boundingBox height asFloat *\n\t\t\t\tscrollBar inside height asFloat) rounded\n",
          "moveMarker:": "moveMarker: anInteger\n\t\"Update the marker so that is is translated by an amount corresponding to\n\ta distance of anInteger, constrained within the boundaries of the scroll bar.\"\n\n\tDisplay fill: marker mask: scrollBar insideColor.\n\tmarker _ marker translateBy: 0 @\n\t\t\t\t((anInteger min: scrollBar inside bottom - marker bottom) max:\n\t\t\t\t\tscrollBar inside top - marker top).\n\tmarker displayOn: Display\n",
          "computeMarkerRegion": "computeMarkerRegion\n\t\"Answer the rectangular area in which the gray area of the scroll bar\n\tshould be displayed.\"\n\n\t^0@0 extent: 10 @\n\t\t\t((view window height asFloat /\n\t\t\t\t\t\tview boundingBox height *\n\t\t\t\t\t\t\tscrollBar inside height)\n\t\t\t\t rounded min: scrollBar inside height)\n",
          "moveMarker": "moveMarker\n\t\"The view window has changed.  Update the marker.\"\n\n\tself moveMarker: self markerDelta negated\n",
          "markerRegion:": "markerRegion: aRectangle\n\t\"Set the area defined by aRectangle as the marker.  Fill it with gray tone.\"\n\n\tDisplay fill: marker mask: scrollBar insideColor.\n\tmarker region: aRectangle.\n\tmarker _ marker align: marker topCenter with: scrollBar inside topCenter\n"
        },
        "private": {
          "scrollUp": "scrollUp\n\tself changeCursor: Cursor up.\n\tsensor anyButtonPressed\n\t\tifTrue: [self canScroll\n\t\t\t\t\tifTrue:\n\t\t\t\t\t\t[self scrollViewUp.\n\t\t\t\t\t\tself moveMarker]].\n\tsensor waitNoButton\n",
          "scrollAbsolute": "scrollAbsolute\n\t| oldMarker |\n\tself changeCursor: Cursor marker.\n\tself canScroll & sensor anyButtonPressed ifTrue:\n\t\t[[sensor anyButtonPressed] whileTrue:\n\t\t\t[oldMarker _ marker.\n\t\t\tmarker _ marker translateBy:\n\t\t\t\t0@((sensor cursorPoint y - marker center y min:\n\t\t\t\t\tscrollBar inside bottom - marker bottom) max: scrollBar inside top - marker top).\n\t\t\t(oldMarker areasOutside: marker), (marker areasOutside: oldMarker) do:\n\t\t\t\t[:region | Display fill: region rule: Form reverse mask: Form gray]].\n\t\t\tself scrollView.\n\t\t\tscrollBar display.\n\t\t\tself moveMarker]\n",
          "scrollDown": "scrollDown\n\tself changeCursor: Cursor down.\n\tsensor anyButtonPressed\n\t\tifTrue: [self canScroll\n\t\t\t\t\tifTrue:\n\t\t\t\t\t\t[self scrollViewDown.\n\t\t\t\t\t\tself moveMarker]].\n\tsensor waitNoButton\n"
        },
        "initialize-release": {
          "initialize": "initialize\n\tsuper initialize.\n\tscrollBar _ Quadrangle new.\n\tscrollBar borderWidthLeft: 2 right: 0 top: 2 bottom: 2.\n\tmarker _ Quadrangle new.\n\tmarker insideColor: Form gray\n"
        },
        "scrolling": {
          "scrollView": "scrollView\n\t\"The scroll bar jump method was used so that the view should be updated to\n\tcorrespond to the location of the scroll bar gray area.\"\n\tself scrollView: self viewDelta\n",
          "scrollAmount": "scrollAmount\n\t\"Answer the number of bits of y-coordinate should be scrolled.  This is a\n\tdefault determination based on the view's preset display transformation.\"\n\n\t^((view inverseDisplayTransform: sensor cursorPoint)\n\t\t- (view inverseDisplayTransform: scrollBar inside topCenter)) y\n",
          "viewDelta": "viewDelta\n\t\"Answer an integer that indicates how much the view should be scrolled.\n\tThe scroll bar has been moved and now the view must be so the amount to\n\tscroll is computed as a ratio of the current scroll bar position.\"\n\n\t^view window top - view boundingBox top -\n\t\t((marker top - scrollBar inside top) asFloat /\n\t\t\tscrollBar inside height asFloat *\n\t\t\t\tview boundingBox height asFloat) rounded\n",
          "scrollViewDown": "scrollViewDown\n\t\"Scroll the receiver's view down the default amount.\"\n\tself scrollView: self scrollAmount\n",
          "scrollView:": "scrollView: anInteger\n\t\"If anInteger is not zero, tell the reciever's view to scroll by anInteger amount.\"\n\n\tanInteger ~= 0\n\t\tifTrue:\n\t\t\t[view scrollBy: 0 @\n\t\t\t\t((anInteger min: view window top - view boundingBox top)\n\t\t\t\t\t\tmax: view window top - view boundingBox bottom).\n\t\t\tview clearInside.\n\t\t\tview display]\n",
          "canScroll": "canScroll\n\t\"Answer whether there is information that is not visible and can be seen\n\tby scrolling.\"\n\t^marker region height < scrollBar inside height\n",
          "scroll": "scroll\n\t\"Check to see whether the user wishes to jump, scroll up, or scroll down.\"\n\n\t| savedCursor regionPercent |\n\tsavedCursor _ sensor currentCursor.\n\t[self scrollBarContainsCursor]\n\t\twhileTrue:\n\t\t\t[Processor yield.\n\t\t\tregionPercent _ 100 * (sensor cursorPoint x - scrollBar left) // scrollBar width.\n\t\t\tregionPercent <= 40\n\t\t\t\tifTrue: [self scrollDown]\n\t\t\t\tifFalse: [regionPercent >= 60\n\t\t\t\t\t\t\tifTrue: [self scrollUp]\n\t\t\t\t\t\t\tifFalse: [self scrollAbsolute]]].\n\tsavedCursor show\n",
          "scrollViewUp": "scrollViewUp\n\t\"Scroll the receiver's view up the default amount.\"\n\tself scrollView: self scrollAmount negated\n"
        }
      }
    },
    "MouseMenuController": {
      "comment": "I am a Controller that modifies the scheduling of user activities so that the three mouse buttons can be used to make selections or display menus.  The menu items are unary messages to the value of sending my instance the message menuMessageReceiver.\n\nInstance Variables:\n\tredButtonMenu\t\t\t<PopUpMenu>\n\tredButtonMessages\t\t<Array> of Symbols, unary messages\n\tyellowButtonMenu\t\t<PopUpMenu>\n\tyellowButtonMessages\t<Array> of Symbols, unary messages\n\tblueButtonMenu\t\t<PopUpMenu>\n\tblueButtonMessages\t\t<Array> of Symbols, unary messages\n",
      "class_name": "MouseMenuController",
      "superclass": "Controller",
      "instanceVariables": "redButtonMenu redButtonMessages yellowButtonMenu yellowButtonMessages blueButtonMenu blueButtonMessages",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "control defaults": {
          "isControlActive": "isControlActive\n\t^view containsPoint: sensor cursorPoint\n",
          "controlActivity": "controlActivity\n\tsensor redButtonPressed & self viewHasCursor\n\t\tifTrue: [^self redButtonActivity].\n\tsensor yellowButtonPressed & self viewHasCursor\n\t\tifTrue: [^self yellowButtonActivity].\n\tsensor blueButtonPressed & self viewHasCursor\n\t\tifTrue: [^self blueButtonActivity].\n\tsuper controlActivity\n"
        },
        "menu messages": {
          "menuMessageReceiver": "menuMessageReceiver\n\t\"Answer the object that should be sent a message when a menu item is selected.\"\n\t^ self\n",
          "yellowButtonActivity": "yellowButtonActivity\n\t\"Determine which item in the yellow button pop-up menu is selected.\n\tIf one is selected, then send the corresponding message to the object\n\tdesignated as the menu message receiver.\"\n\n\t| index |\n\tyellowButtonMenu ~~ nil\n\t\tifTrue:\n\t\t\t[index _ yellowButtonMenu startUpYellowButton.\n\t\t\tindex ~= 0\n\t\t\t\tifTrue: [self menuMessageReceiver perform:\n\t\t\t\t\t\t\t(yellowButtonMessages at: index)]]\n\t\tifFalse: [super controlActivity]\n",
          "redButtonActivity": "redButtonActivity\n\t\"Determine which item in the red button pop-up menu is selected.\n\tIf one is selected, then send the corresponding message to the object\n\tdesignated as the menu message receiver.\"\n\n\t| index |\n\tredButtonMenu ~~ nil\n\t\tifTrue:\n\t\t\t[index _ redButtonMenu startUpRedButton.\n\t\t\tindex ~= 0\n\t\t\t\tifTrue: [self menuMessageReceiver perform:\n\t\t\t\t\t\t\t(redButtonMessages at: index)]]\n\t\tifFalse: [super controlActivity]\n",
          "blueButtonActivity": "blueButtonActivity\n\t\"Determine which item in the blue button pop-up menu is selected.\n\tIf one is selected, then send the corresponding message to the object\n\tdesignated as the menu message receiver.\"\n\n\t| index |\n\tblueButtonMenu ~~ nil\n\t\tifTrue:\n\t\t\t[index _ blueButtonMenu startUpBlueButton.\n\t\t\tindex ~= 0\n\t\t\t\tifTrue: [self menuMessageReceiver perform:\n\t\t\t\t\t\t\t(blueButtonMessages at: index)]]\n\t\tifFalse: [super controlActivity]\n"
        },
        "initialize-release": {
          "release": "release\n\tsuper release.\n\tredButtonMenu release.\n\tyellowButtonMenu release.\n\tblueButtonMenu release\n",
          "reset": "reset\n\t\"Eliminate references to all mouse button menus.\"\n\n\tredButtonMenu _ nil.\n\tredButtonMessages _ nil.\n\tyellowButtonMenu _ nil.\n\tyellowButtonMessages _ nil.\n\tblueButtonMenu _ nil.\n\tblueButtonMessages _ nil\n"
        },
        "menu setup": {
          "redButtonMenu:redButtonMessages:": "redButtonMenu: aSystemMenu redButtonMessages: anArray\n\t\"Initialize the pop-up menu that should appear when the user presses\n\tthe red mouse button to be aSystemMenu.  The corresponding messages\n\tthat should be sent are listed in the array, anArray.\"\n\n\tredButtonMenu release.\n\tredButtonMenu _ aSystemMenu.\n\tredButtonMessages _ anArray\n",
          "yellowButtonMenu:yellowButtonMessages:": "yellowButtonMenu: aSystemMenu yellowButtonMessages: anArray\n\t\"Initialize the pop-up menu that should appear when the user presses\n\tthe yellow mouse button to be aSystemMenu.  The corresponding messages\n\tthat should be sent are listed in the array, anArray.\"\n\n\tyellowButtonMenu release.\n\tyellowButtonMenu _ aSystemMenu.\n\tyellowButtonMessages _ anArray\n",
          "blueButtonMenu:blueButtonMessages:": "blueButtonMenu: aSystemMenu blueButtonMessages: anArray\n\t\"Initialize the pop-up menu that should appear when the user presses\n\tthe blue mouse button to be aSystemMenu.  The corresponding messages\n\tthat should be sent are listed in the array, anArray.\"\n\n\tblueButtonMenu release.\n\tblueButtonMenu _ aSystemMenu.\n\tblueButtonMessages _ anArray\n"
        }
      }
    },
    "StandardSystemView": {
      "comment": "I represent a view that has a label above its top left corner.  The text in the label identifies the kind of view.  In addition to a label, I add control over the maximum and minimum size of the display box of my instance.  My default controller is StandardSystemController.  The elements of ScheduledControllers, the sole instance of ControlManager, usually contain controllers for instances of me.\n\nInstance Variables:\n\tlabelFrame\t\t\t\t<Quadrangle>\n\tlabelText\t\t\t\t<Paragraph>\n\tisLabelComplemented\t<Boolean> true if the label is complemented\n\tsavedSubViews\t\t\t<Array> of Views\n\tminimumSize\t\t\t<Point> representing minimum width and height\n\tmaximumSize\t\t\t<Point> representing maximum width and height\n",
      "class_name": "StandardSystemView",
      "superclass": "View",
      "instanceVariables": "labelFrame labelText isLabelComplemented savedSubViews minimumSize maximumSize",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "model:label:minimumSize:": "model: aModel label: labelText minimumSize: minimumSize\n\t| view |\n\tview _ self new.\n\tview model: aModel.\n\tview label: labelText.\n\tview minimumSize: minimumSize.\n\tview borderWidth: 1.\n\t^view\n"
        }
      },
      "instance_methods": {
        "deEmphasizing": {
          "deEmphasizeView": "deEmphasizeView\n\tself deEmphasizeLabel\n"
        },
        "label access": {
          "deEmphasizeLabel": "deEmphasizeLabel\n\t\"If the label is highlighted, reverse it.\"\n\n\tisLabelComplemented\n\t\tifTrue:\n\t\t\t[self reverseLabel.\n\t\t\tisLabelComplemented _ false]\n",
          "labelFrame:": "labelFrame: aQuadrangle\n\t\"Set the bounding box for the label to be aQuadrangle.\"\n\tlabelFrame _ aQuadrangle\n",
          "label": "label\n\t\"Answer the string that appears in the receiver's label.\"\n\t^labelText isNil\n\t\tifTrue: [^'']\n\t\tifFalse: [labelText asString]\n",
          "label:": "label: aString\n\t\"Set aString to be the receiver's label.\"\n\taString == nil\n\t\tifTrue:\n\t\t\t[labelText _ nil.\n\t\t\tlabelFrame region: (0 @ 0 extent: 0 @ 0)]\n\t\tifFalse:\n\t\t\t[labelText _ aString asParagraph.\n\t\t\tlabelFrame region: (0 @ 0 extent: labelText boundingBox width + 8 @ 20)]\n",
          "emphasizeLabel": "emphasizeLabel\n\t\"Highlight the label.\"\n\n\tisLabelComplemented\n\t\tifFalse:\n\t\t\t[self reverseLabel.\n\t\t\tisLabelComplemented _ true]\n",
          "labelDisplayBox": "labelDisplayBox\n\t\"Answer the rectangle that borders the visible parts of the receiver's label on the\n\tdisplay screen.\"\n\n\t^labelFrame\n\t\talign: (self isCollapsed\n\t\t\t\tifTrue: [labelFrame topLeft]\n\t\t\t\tifFalse: [labelFrame bottomLeft])\n\t\twith: self displayBox topLeft\n",
          "labelFrame": "labelFrame\n\t\"Answer the bounding box for the label.\"\n\t^labelFrame\n"
        },
        "clipping box access": {
          "clippingBox": "clippingBox\n\t\"Answer the rectangular area in which the receiver can show its label.\"\n\n\t^self isTopView\n\t\tifTrue: [self labelDisplayBox]\n\t\tifFalse: [super insetDisplayBox]\n"
        },
        "displaying": {
          "displayEmphasized": "displayEmphasized\n\t\"Display the receiver with the label highlighted to indicate\n\tthat it is active.\"\n\tself display.\n\tself emphasize.\n\tself emphasizeLabel\n",
          "displayView": "displayView\n\t| clippingBox labelDisplayBox |\n\tclippingBox _ self clippingBox.\n\tlabelDisplayBox _ self labelDisplayBox.\n\t(labelDisplayBox intersect: clippingBox) displayOn: Display.\n\tlabelText isNil\n\t\tifFalse:\n\t\t\t[labelText\n\t\t\t\tdisplayOn: Display\n\t\t\t\tat: (labelDisplayBox center -\n\t\t\t\t\t\t(labelText boundingBox center -\n\t\t\t\t\t\t\tlabelText boundingBox topLeft))\n\t\t\t\tclippingBox: clippingBox]\n"
        },
        "testing": {
          "isCollapsed": "isCollapsed\n\t\"Answer whether the scheduled view is collapsed (true) or expanded (false).\"\n\t^savedSubViews ~~ nil\n",
          "containsPoint:": "containsPoint: aPoint\n\t^(super containsPoint: aPoint)\n\t\t| (self labelDisplayBox containsPoint: aPoint)\n"
        },
        "private": {
          "reverseLabel": "reverseLabel\n\tlabelText isNil ifFalse: [Display reverse: self labelDisplayBox inside]\n"
        },
        "initialize-release": {
          "initialize": "initialize\n\tsuper initialize.\n\tself insideColor: Form lightGray.\n\tlabelFrame _ Quadrangle new.\n\tlabelFrame region: (Rectangle origin: 0 @ 0 extent: 50 @ 20).\n\tlabelFrame insideColor: Form white.\n\tlabelFrame\n\t\tborderWidthLeft: 2\n\t\tright: 2\n\t\ttop: 2\n\t\tbottom: 0.\n\tself label: nil.\n\tisLabelComplemented _ false.\n\tminimumSize _ 50 @ 50.\n\tmaximumSize _ Display extent\n",
          "release": "release\n\tself expand.\n\tsuper release\n"
        },
        "controller access": {
          "defaultControllerClass": "defaultControllerClass\n\t^StandardSystemController\n"
        },
        "size": {
          "maximumSize:": "maximumSize: aPoint\n\t\"Set the argument, aPoint, to be the maximum width and height of the receiver.\"\n\tmaximumSize _ aPoint\n",
          "minimumSize": "minimumSize\n\t\"Answer a point representing the minimum width and height of the receiver.\"\n\t^minimumSize\n",
          "minimumSize:": "minimumSize: aPoint\n\t\"Set the argument, aPoint, to be the minimum width and height of the receiver.\"\n\tminimumSize _ aPoint\n",
          "maximumSize": "maximumSize\n\t\"Answer a point representing the maximum width and height of the receiver.\"\n\t^maximumSize\n"
        },
        "framing": {
          "resize": "resize\n\t\"Determine the rectangular area for the receiver, adjusted to the minimum\n\tand maximum sizes.\"\n\n\t| aRectangle |\n\taRectangle _ self getFrame.\n\taRectangle _ aRectangle origin extent:\n\t\t\t\t\t((aRectangle extent max: minimumSize) min: maximumSize).\n\tself window: self window viewport: aRectangle.\n",
          "erase": "erase\n\t\"Clear the display box of the receiver to be gray, as in the screen background.\"\n\n\tself clear: Form gray.\n\tDisplay fill: self labelDisplayBox region mask: Form gray.\n\tisLabelComplemented _ false\n",
          "getFrame": "getFrame\n\t\"Ask the user to designate a rectangular area in which the receiver should\n\tbe displayed.\"\n\n\t| origin minimumCorner maximumCorner frame corner |\n\tSensor waitNoButton.\n\tCursor origin\n\t\tshowWhile:\n\t\t\t[origin _ Sensor cursorPoint.\n\t\t\t[Sensor redButtonPressed]\n\t\t\t\twhileFalse: [Processor yield.\n\t\t\t\t\t\t\t origin _ Sensor cursorPoint]].\n\tminimumCorner _ origin + self minimumSize.\n\tmaximumCorner _ origin + self maximumSize.\n\tframe _ origin corner: minimumCorner.\n\tDisplay fill: frame rule: Form reverse mask: Form gray.\n\tDisplay fill: frame rule: Form reverse mask: Form gray.\n\tminimumCorner = maximumCorner\n\t\tifFalse:\n\t\t\t[Sensor cursorPoint: minimumCorner.\n\t\t\tCursor corner\n\t\t\t\tshowWhile:\n\t\t\t\t\t[corner _ Sensor cursorPoint.\n\t\t\t\t\t[Sensor redButtonPressed]\n\t\t\t\t\t\twhileTrue:\n\t\t\t\t\t\t\t[Processor yield.\n\t\t\t\t\t\t\tframe _ origin corner:\n\t\t\t\t\t\t\t\t\t\t((corner max: minimumCorner)\n\t\t\t\t\t\t\t\t\t\t\tmin: maximumCorner).\n\tDisplay fill: frame rule: Form reverse mask: Form gray.\n\tDisplay fill: frame rule: Form reverse mask: Form gray.\n\t\t\t\t\t\t\tcorner _ Sensor cursorPoint]]].\n\t^frame\n",
          "expand": "expand\n\t\"If the receiver is collapsed, change its view to be that of all of its subviews,\n\tnot its label alone.\"\n\n\tself isCollapsed\n\t\tifTrue:\n\t\t\t[subViews _ savedSubViews.\n\t\t\tself window: self defaultWindow.\n\t\t\tlabelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 0.\n\t\t\tsavedSubViews _ nil]\n",
          "resizeMinimumCenteredAt:": "resizeMinimumCenteredAt: aPoint\n\t\"Determine the rectangular area for the receiver, adjusted so that it is centered\n\ta position, aPoint.\"\n\n\t| aRectangle |\n\taRectangle _ 0 @ 0 extent: self minimumSize.\n\taRectangle _ aRectangle align: aRectangle center with: aPoint.\n\tself window: self window viewport: aRectangle\n",
          "collapse": "collapse\n\t\"If the receiver is not already collapsed, change its view to be that of\n\tits label only.\"\n\n\tself isCollapsed\n\t\tifFalse:\n\t\t\t[savedSubViews _ subViews.\n\t\t\tself resetSubViews.\n\t\t\tlabelText isNil ifTrue: [self label: 'No Label'].\n\t\t\tself window: (self inverseDisplayTransform: self labelDisplayBox region).\n\t\t\tlabelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2]\n"
        }
      }
    },
    "ScreenController": {
      "comment": "I am the controller for the parts of the display screen that have no window on them.  I only provide a standard yellow button menu.  I view (a FormView of) an infinite gray form.\n",
      "class_name": "ScreenController",
      "superclass": "MouseMenuController",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "ScreenYellowButtonMenu ScreenYellowButtonMessages",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"Initialize the System Menu.\"\n\n\tScreenYellowButtonMenu _\n\t\tPopUpMenu\n\t\t\tlabels:\n'restore display\nexit project\nproject\nfile list\nbrowser\nworkspace\nsystem transcript\nsystem workspace\nsave\nquit'\n\t\t\tlines: #(2 8 ).\n\tScreenYellowButtonMessages _\n\t\t\t#(restoreDisplay exitProject openProject\n\t\t\topenFileList openBrowser openWorkspace openTranscript openSystemWorkspace\n\t\t\tsave quit).\n\n\t\"ScreenController initialize.\n\tScreenController allInstancesDo: [:c | c initializeYellowButtonMenu]\"\n"
        }
      },
      "instance_methods": {
        "cursor": {
          "centerCursorInView": "centerCursorInView\n\t\"Override so this doesn't happen when taking control\"\n"
        },
        "control defaults": {
          "openFileList": "openFileList\n\t\"Create and schedule a FileList view for specifying files to access.\"\n\tFileList open\n",
          "isControlWanted": "isControlWanted\n\t^super isControlWanted and: [sensor yellowButtonPressed]\n",
          "isControlActive": "isControlActive\n\t^super isControlActive and: [sensor yellowButtonPressed]\n"
        },
        "menu messages": {
          "openProject": "openProject\n\tProjectView open\n",
          "openTranscript": "openTranscript\n\tTextCollectorView open: Transcript label: 'System Transcript'\n",
          "openSystemWorkspace": "openSystemWorkspace\n\tStringHolderView openSystemWorkspace.\n",
          "openWorkspace": "openWorkspace\n\tStringHolderView open\n",
          "openBrowser": "openBrowser\n\tBrowserView openOn: SystemOrganization\n",
          "save": "save\n\t| prefix |\n\tprefix _ Smalltalk getImagePrefix.\n\tprefix isEmpty ifTrue: [^self].\n\tSmalltalk saveAs: prefix thenQuit: false\n",
          "restoreDisplay": "restoreDisplay\n\tScheduledControllers restore\n",
          "quit": "quit\n\t| menu index imagePrefix |\n\tmenu _ PopUpMenu labels:\n' Save, then quit\n Quit, without saving\n Continue '\n\t\tlines: #(1 2).\n\tindex _ menu startUp.\n\tindex = 1\n\t\tifTrue:\n\t\t\t[imagePrefix _ Smalltalk getImagePrefix.\n\t\t\timagePrefix isEmpty ifTrue: [^self].\n\t\t\tSmalltalk saveAs: imagePrefix thenQuit: true].\n\tindex = 2 ifTrue: [Smalltalk quit]\n",
          "exitProject": "exitProject\n\tProject current exit\n"
        },
        "private": {
          "initializeYellowButtonMenu": "initializeYellowButtonMenu\n\tself yellowButtonMenu: ScreenYellowButtonMenu\n\t\tyellowButtonMessages: ScreenYellowButtonMessages\n"
        },
        "initialize-release": {
          "initialize": "initialize\n\tsuper initialize.\n\tself initializeYellowButtonMenu\n"
        }
      }
    },
    "StandardSystemController": {
      "comment": "I am a controller for StandardSystemViews, that is, those views that are at the top level of a project in the system user interface.  I am a kind of MouseMenuController that creates a blue button menu for moving, framing, collapsing, and closing StandardSystemViews, and for selecting views under the view of my instance.\n\nInstance Variables:\n\tstatus\t<Symbol> condition, either\n\t\t\t#active--keep control as long as the cursor is inside the view if a\n\t\t\t\t\tbutton is pressed\n\t\t\t#inactive -- no longer in control, deEmphasize any highlighting\n\t\t\t#open -- visible on the screen\n\t\t\t#closed -- unschedule the instance from the project\n",
      "class_name": "StandardSystemController",
      "superclass": "MouseMenuController",
      "instanceVariables": "status",
      "classInstanceVariables": "",
      "classVariables": "ScheduledBlueButtonMenu ScheduledBlueButtonMessages",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"StandardSystemController initialize.\"\n\tScheduledBlueButtonMenu _ PopUpMenu labels:\n'under\nmove\nframe\ncollapse\nclose' lines: #(4 ).\n\tScheduledBlueButtonMessages _ #(under move expand collapse close )\n"
        }
      },
      "instance_methods": {
        "scheduling": {
          "closeAndUnschedule": "closeAndUnschedule\n\t\"Erase the receiver's view and remove it from the collection of scheduled controllers.\"\n\n\tstatus _ #closed.\n\tview erase.\n\tview release.\n\tScheduledControllers unschedule: self\n",
          "open": "open\n\t\"Create an area on the screen in which the receiver's scheduled controller can\n\tbe displayed.  Make it the active controller.\"\n\n\tview resize.\n\tstatus _ #open.\n\tScheduledControllers scheduleActive: self\n",
          "openNoTerminateDisplayAt:": "openNoTerminateDisplayAt: aPoint\n\t\"Create an area with origin aPoint in which the receiver's scheduled view can\n\tbe displayed.  Make it the active view.  Do not terminate the currently active\n\tprocess.\"\n\n\tview resizeMinimumCenteredAt: aPoint.\n\tstatus _ #open.\n\tScheduledControllers scheduleActiveNoTerminate: self\n",
          "openDisplayAt:": "openDisplayAt: aPoint\n\t\"Create an area with origin aPoint in which the receiver's scheduled\n\tview can be displayed.  If necessary, translate so the view is completely\n\ton the screen.  Make it the active view.\"\n\n\tview align: view viewport center with: aPoint.\n\tview translateBy:\n\t\t(view displayBox amountToTranslateWithin: Display boundingBox).\n\tstatus _ #open.\n\tScheduledControllers scheduleActive: self\n",
          "openNoTerminate": "openNoTerminate\n\t\"Create an area in which the receiver's scheduled view can\n\tbe displayed.  Make it the active view.  Do not terminate the currently active\n\tprocess.\"\n\n\tview resize.\n\tstatus _ #open.\n\tScheduledControllers scheduleActiveNoTerminate: self\n",
          "closeAndUnscheduleNoErase": "closeAndUnscheduleNoErase\n\t\"Remove the scheduled view from the collection of scheduled controllers.\n\tSet its status to closed but do not erase.\"\n\n\tstatus _ #closed.\n\tview release.\n\tScheduledControllers unschedule: self\n"
        },
        "control defaults": {
          "isControlActive": "isControlActive\n\t^status == #active\n\t\tand: [sensor anyButtonPressed\n\t\t\t\tifTrue: [view containsPoint: sensor cursorPoint]\n\t\t\t\tifFalse: [true]]\n"
        },
        "basic control sequence": {
          "controlInitialize": "controlInitialize\n\tview displayEmphasized.\n\tstatus _ #active\n",
          "controlTerminate": "controlTerminate\n\tstatus == #closed\n\t\tifTrue:\n\t\t\t[view ~~ nil ifTrue: [view release].\n\t\t\tScheduledControllers unschedule: self.\n\t\t\t^self].\n\tstatus == #inactive\n\t\tifTrue:\n\t\t\t[view deEmphasize.\n\t\t\tScheduledControllers pullBottomToTop.\n\t\t\t^self].\n\tview deEmphasize\n"
        },
        "menu messages": {
          "menuMessageReceiver": "menuMessageReceiver\n\t\"Answer the object that should receive the message corresponding to\n\ta menu selection.\"\n\t^ self\n",
          "move": "move\n\t\"Ask the user to designate a new origan position for the recevier's view.\"\n\t| form |\n\tSensor cursorPoint: view labelDisplayBox origin.\n\tview deEmphasize.\n\tform _ Form fromDisplay: (view labelDisplayBox).\n\tview erase.\n\tCursor origin showWhile:\n\t\t[form follow: [Sensor cursorPoint] while: [Sensor noButtonPressed]].\n\n\tview align: view labelDisplayBox origin\n\t\twith: sensor cursorPoint.\n\tview displayEmphasized.\n",
          "expand": "expand\n\t\"The receiver's view was collapsed;  open it again and ask the user to\n\tdesignate its rectangular area.\"\n\n\tview erase.\n\tview expand.\n\tview resize.\n\tview displayEmphasized\n",
          "under": "under\n\t\"Deactive the receiver's scheduled view and pass control to any view that\n\tmight be positioned directly underneath it and the cursor.\"\n\n\tstatus _ #inactive\n",
          "close": "close\n\t\"The receiver's view should be removed from the screen and from the\n\tcollection of scheduled views.\"\n\n\tmodel changeRequest  \"check for changes in progress\"\n\t\tifFalse: [^self].\n\tstatus _ #closed.\n\tview erase\n",
          "collapse": "collapse\n\t\"Get the receiver's view to change to a collapsed view on the screen.\"\n\n\tview erase; collapse; display.\n\tself move.\n"
        },
        "initialize-release": {
          "initializeBlueButtonMenu": "initializeBlueButtonMenu\n\t\"Initialize the blue button pop-up menu and corresponding array of messages\n\tfor the receiver.\"\n\n\tself blueButtonMenu: ScheduledBlueButtonMenu\n\t\tblueButtonMessages: ScheduledBlueButtonMessages\n",
          "initialize": "initialize\n\tsuper initialize.\n\tstatus _ #inactive.\n\tself initializeBlueButtonMenu\n"
        }
      }
    },
    "Explainer": {
      "comment": "I try to determine what a piece of text represents, usually in the context of a method.\n",
      "class_name": "Explainer",
      "superclass": "Object",
      "instanceVariables": "class selector instance context methodText",
      "classInstanceVariables": "",
      "classVariables": "NewLine",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"Explainer initialize\"\n\tNewLine _ String with: Character cr\n"
        }
      },
      "instance_methods": {
        "explaining": {
          "explainScan:": "explainScan: string\n\t\"remove beginning and trailing space, tab, cr\"\n\n\t| c beg end |\n\tbeg _ 1.\n\tend _ string size.\n\n\t[beg = end ifTrue: [^string copyFrom: 1 to: 1].\n\t\"if all blank, tell about the first\"\n\tc _ string at: beg.\n\tc = Character space or: [c = Character tab or: [c = Character cr]]]\n\t\twhileTrue: [beg _ beg + 1].\n\n\t[c _ string at: end.\n\tc = Character space or: [c = Character tab or: [c = Character cr]]]\n\t\twhileTrue: [end _ end - 1].\n\t^string copyFrom: beg to: end\t\"Return purely visible characters\"\n",
          "explainInst:": "explainInst: string\n\t\"Is string an instance variable of this class?\"\n\n\t| name each classes |\n\tclass == nil ifTrue: [^nil].\t  \"no class is selected\"\n\tclasses _ class withAllSuperclasses.\n\tclasses _ classes detect: [:each | (each instVarNames\n\t\t\tdetect: [:name | name = string] ifNone: [])\n\t\t\t~~ nil] ifNone: [^nil].\n\tclasses _ classes printString.\n\t^ '\"is an instance variable of the receiver; defined in class ' , classes , '\"',\n\t\tNewLine , classes , ' browseAllAccessesTo: ''' , string , '''.'\n",
          "explainTemp:": "explainTemp: string\n\t\"Is string the name of a temporary variable (or block argument variable)?\"\n\n\t| tempNames i reply methodNode method |\n\tselector == nil ifTrue: [^nil].\t\"no message is selected\"\n\ttempNames _ class parserClass new parseArgsAndTemps: methodText notifying: nil.\n\tmethod _ class compiledMethodAt: selector.\n\t(i _ tempNames findFirst: [:each | each = string]) = 0 ifTrue: [\n\t\t(method numTemps > tempNames size and: [Smalltalk frills])\n\t\t\tifTrue:\n\t\t\t\t[\"It must be an undeclared block argument temporary\"\n\t\t\t\tmethodNode _ class compilerClass new\n\t\t\t\t\t\t\tparse: methodText\n\t\t\t\t\t\t\tin: class\n\t\t\t\t\t\t\tnotifying: nil.\n\t\t\t\ttempNames _ methodNode tempNames]\n\t\t\tifFalse: [^nil]].\n\t(i _ tempNames findFirst: [:each | each = string]) > 0 ifTrue: [i > method numArgs\n\t\t\tifTrue: [reply _ '\"is a temporary variable in this method\"']\n\t\t\tifFalse: [reply _ '\"is an argument to this method\"']].\n\t^reply\n",
          "explainChar:": "explainChar: string\n\t\"Does string start with a special character?\"\n\n\t| char |\n\tchar _ string at: 1.\n\tchar = $. ifTrue: [^'\"Period marks the end of a Smalltalk statement.  A period in the middle of a number means a decimal point.  (The number is an instance of Float).  A period in the middle of a selector means a compound selector.  (To the left is the superclass, to the right is the selector).\"'].\n\tchar = $' ifTrue: [^'\"The characters between two single quotes are made into an instance of class String\"'].\n\tchar = $\" ifTrue: [^'\"Double quotes enclose a comment.  Smalltalk ignores everything between double quotes.\"'].\n\tchar = $# ifTrue: [^'\"The characters following a hash mark are made into an instance of class Symbol.  If parenthesis follow a hash mark, an instance of class Array is made.\"'].\n\t(char = $( or: [char = $)]) ifTrue: [^'\"Expressions enclosed in parenthesis are evaluated first\"'].\n\t(char = $[ or: [char = $]]) ifTrue: [^'\"The code inside square brackets is an unevaluated block of code.  It becomes an instance of BlockContext and is usually passed as an argument.\"'].\n\t(char = $< or: [char = $>]) ifTrue: [^'\"<primitive: xx> means that this method is usually preformed directly by the virtual machine.  If this method is primitive, its Smalltalk code is executed only when the primitive fails.\"'].\n\tchar = $^ ifTrue: [^'\"Uparrow means return from this method.  The value returned is the expression following the ^\"'].\n\tchar = $| ifTrue: [^'\"Vertical bars enclose the names of the temporary variables used in this method.  In a block, the vertical bar separates the argument names from the rest of the code.\"'].\n\tchar = $_ ifTrue: [^'\"Left arrow means assignment.  The value of the expression after the left arrow is stored into the variable before it.\"'].\n\tchar = $; ifTrue: [^'\"Semicolon means cascading.  The message after the semicolon is sent to the same object which received the message before the semicolon.\"'].\n\tchar = $: ifTrue: [^'\"A colon at the end of a keyword means that an argument is expected to follow.  Methods which take more than one argument have selectors with more than one keyword.  (One keyword, ending with a colon, appears before each argument).', NewLine, NewLine, 'A colon before a variable name just inside a block means that the block takes an agrument.  (When the block is evaluated, the argument will be assigned to the variable whose name appears after the colon).\"'].\n\tchar = $$ ifTrue: [^'\"The single character following a dollar sign is made into an instance of class Character\"'].\n\tchar = $- ifTrue: [^'\"A minus sign in front of a number means a negative number.\"'].\n\tchar = $e ifTrue: [^'\"An e in the middle of a number means that the exponent follows.\"'].\n\tchar = $r ifTrue: [^'\"An r in the middle of a bunch of digits is an instance of Integer expressed in a certain radix.  The digits before the r denote the base and the digits after it express a number in that base.\"'].\n\tchar = Character space ifTrue: [^'\"the space Character\"'].\n\tchar = Character tab ifTrue: [^'\"the tab Character\"'].\n\tchar = Character cr ifTrue: [^'\"the carriage return Character\"'].\n\t^nil\n",
          "explainClass:": "explainClass: symbol\n\t\"Is symbol a class variable or a pool variable?\"\n\n\t|  name pool reply classes |\n\tclass == nil ifTrue: [^nil].\t  \"no class is selected\"\n\tclasses _\n\t\t((class isKindOf: Metaclass) ifTrue: [class soleInstance] ifFalse: [class])\n\t\t\twithAllSuperclasses.\n\n\t\"class variables\"\n\treply _ classes detect: [:each | (each classVarNames\n\t\t\tdetect: [:name | symbol = name] ifNone: [])\n\t\t\t~~ nil] ifNone: [].\n\treply == nil ifFalse: [^'\"is a class variable; defined in class ' , reply printString, '\"', NewLine,\n\t\t'Smalltalk browseAllCallsOn: (', reply printString, ' classPool associationAt: #', symbol, ').'].\n\n\t\"pool variables\"\n\tclasses do: [:each | (each sharedPools\n\t\t\tdetect: [:pool | (pool includesKey: symbol) and: [reply _ pool. true]]\n\t\t\tifNone: []) ~~ nil].\n\treply == nil ifTrue: [(Undeclared includesKey: symbol) ifTrue: [reply _ Undeclared]].\n\treply == nil\n\t\tifFalse:\n\t\t\t[classes _ WriteStream on: Array new.\n\t\t\tSmalltalk allBehaviorsDo: [:each |\n\t\t\t\t\t(each sharedPools detect: [:pool | pool == reply] ifNone: [])\n\t\t\t\t\t~~ nil ifTrue: [classes nextPut: each]].\n\t\t\t\"Perhaps not print whole list of classes if too long. (unlikely)\"\n\t\t\t^'\"is a pool variable from the pool ' , (Smalltalk keyAtValue: reply),\n\t\t\t', which is used by the following classes ' , classes contents printString , '\"', NewLine,\n\t\t\t'Smalltalk browseAllCallsOn: (', (Smalltalk keyAtValue: reply) printString,\n\t\t\t' associationAt: #', symbol, ').'].\n\t^nil\n",
          "explainPartSel:": "explainPartSel: string\n\t\"Is this a fragment of a multiple-argument selector sent in this method?\"\n\n\t| lits frag whole reply classes s |\n\tselector == nil ifTrue: [^nil].  \"not in a message\"\n\tstring last == $: ifFalse: [^nil].\n\t\"Name of this method\"\n\tlits _ Array with: selector.\n\t(whole _ lits detect: [:each | (each keywords detect: [:frag | frag = string]\n\t\t\t\t\tifNone: []) ~~ nil]\n\t\t\t\tifNone: []) ~~ nil\n\t\tifTrue: [reply _ ', which is the selector of this very method!'.\n\t\t\ts _ '.  To see the other definitions, go to the message list pane and use yellowbug to select ''implementors''.\"']\n\t\tifFalse:\n\t\t\t[\"Selectors called from this method\"\n\t\t\tlits _ (class compiledMethodAt: selector) messages.\n\t\t\t(whole _ lits detect: [:each | (each keywords detect: [:frag | frag = string]\n\t\t\t\t\t\t\tifNone: []) ~~ nil]\n\t\t\t\t\t\tifNone: []) ~~ nil\n\t\t\t\tifFalse: [string = 'primitive:'\n\t\t\t\t\tifTrue: [^self explainChar: '<']\n\t\t\t\t\tifFalse: [^nil]].\n\t\t\treply _ '.'.\n\t\t\ts _ '.  To see the definitions, go to the message list pane and use yellowbug to select ''messages''.\"'].\n\tclasses _ Smalltalk allClassesImplementing: whole.\n\tclasses size > 12\n\t\tifTrue: [classes _ 'many classes']\n\t\tifFalse: [classes _ 'these classes ' , classes printString].\n\t^ '\"' , string , ' is one part of the message selector ' , whole, reply , '  It is defined in ' , classes , s\n",
          "explainCtxt:": "explainCtxt: symbol\n\t\"Is symbol a context variable?\"\n\n\t| reply classes text |\n\tsymbol = #nil ifTrue: [reply _ '\"is a constant.  It is the only instance of class UndefinedObject.  nil is the initial value of all variables.\"'].\n\tsymbol = #true ifTrue: [reply _ '\"is a constant.  It is the only instance of class True and is the receiver of many control messages.\"'].\n\tsymbol = #false ifTrue: [reply _ '\"is a constant.  It is the only instance of class False and is the receiver of many control messages.\"'].\n\tclass == nil ifTrue: [^nil].\t  \"no message selected\"\n\tsymbol = #self\n\t\tifTrue:\n\t\t\t[classes _ class withAllSubclasses.\n\t\t\tclasses size > 12\n\t\t\t\tifTrue: [text _ class printString , ' or a subclass']\n\t\t\t\tifFalse:\n\t\t\t\t\t[classes _ classes printString.\n\t\t\t\t\ttext _ 'one of these classes' , (classes copyFrom: 4 to: classes size)].\n\t\t\treply _ '\"is the receiver of this message; an instance of ' , text , '\"'].\n\tsymbol = #super ifTrue: [reply _ '\"is just like self.  Messages to super are looked up in the superclass (' , class superclass printString , ')\"'].\n\tsymbol = #thisContext ifTrue: [reply _ '\"is a context variable.  It''s value is always the MethodContext which is executing this method.\"'].\n\t^reply\n",
          "explainAnySel:": "explainAnySel: symbol\n\t\"Is this any message selector?\"\n\n\t| list reply |\n\tlist _ Smalltalk allClassesImplementing: symbol.\n\tlist size = 0 ifTrue: [^nil].\n\tlist size < 12\n\t\tifTrue: [reply _ ' is a message selector which is defined in these classes ' , list printString]\n\t\tifFalse: [reply _ ' is a message selector which is defined in many classes'].\n\t^'\"' , symbol , reply , '.\"', NewLine, 'Smalltalk browseAllImplementorsOf: #' , symbol\n",
          "class:selector:instance:context:methodText:": "class: aClass selector: aSymbol instance: anInstance context: aContext methodText: aText\n\tclass _ aClass.\n\tselector _ aSymbol.\n\tinstance _ anInstance.\n\tcontext _ aContext.\n\tmethodText _ aText\n",
          "explainDelimitor:": "explainDelimitor: string\n\t\"Is string enclosed in delimitors?\"\n\n\t| str |\n\t(string at: 1) isLetter ifTrue: [^nil].  \"only special chars\"\n\t(string first = string last) ifTrue:\n\t\t\t[^ self explainChar: (String with: string first)]\n\t\tifFalse:\n\t\t\t[(string first = $( and: [string last = $)]) ifTrue:\n\t\t\t\t[^ self explainChar: (String with: string first)].\n\t\t\t(string first = $[ and: [string last = $]]) ifTrue:\n\t\t\t\t[^ self explainChar: (String with: string first)].\n\t\t\t(string first = $< and: [string last = $>]) ifTrue:\n\t\t\t\t[^ self explainChar: (String with: string first)].\n\t\t\t(string first = $# and: [string last = $)]) ifTrue:\n\t\t\t\t[^'\"An instance of class Array.  The Numbers, Characters, or Symbols between the parenthesis are the elements of the Array.\"'].\n\t\t\tstring first = $# ifTrue:\n\t\t\t\t[^'\"An instance of class Symbol.\"'].\n\t\t\t(string first = $$ and: [string size = 2]) ifTrue:\n\t\t\t\t[^'\"An instance of class Character.  This one is the character ', (String with: string last), '.\"'].\n\t\t\t(string first = $:) ifTrue:\n\t\t\t\t[str _ (string copyFrom: 2 to: string size).\n\t\t\t\t(self explainTemp: str) ~~ nil ifTrue:\n\t\t\t\t\t[^'\"An argument to this block will be bound to the temporary variable ',\n\t\t\t\t\t\tstr, '.\"']]].\n\t^ nil\n",
          "explain:for:": "explain: selection for: model\n\t\"Try to shed some light on what kind of entity the current selection is.\n\tThe selection must be a single token or construct.  Insert the answer\n\tafter the selection.  Call private routines whose names begin with\n\t'explain'.  They return a String if they recognise the selection, else nil.\"\n\n\t| string tiVars cgVars selectors delimitors numbers symbol reply |\n\tCursor execute\n\t\tshowWhile:\n\t\t\t[selection isEmpty\n\t\t\t\tifTrue: [reply _ '']\n\t\t\t\tifFalse:\n\t\t\t\t\t[string _ self explainScan: selection.\n\t\t\t\t\t\"Remove space, tab, cr\"\n\t\t\t\t\t\"Temps and Instance vars need only test strings that are all letters\"\n\t\t\t\t\t(string detect: [:char | (char isLetter or: [char isDigit]) not]\n\t\t\t\t\t\tifNone: [])\n\t\t\t\t\t\t~~ nil\n\t\t\t\t\t\tifFalse:\n\t\t\t\t\t\t\t[tiVars _ self explainTemp: string.\n\t\t\t\t\t\t\ttiVars == nil ifTrue: [tiVars _ self explainInst: string]].\n\t\t\t\t\t(tiVars == nil)\n\t\t\t\t\t\tifTrue: [tiVars _ model explainSpecial: string].\n\t\t\t\t\ttiVars == nil\n\t\t\t\t\t\tifTrue: [tiVars _ '']\n\t\t\t\t\t\tifFalse: [tiVars _ tiVars , NewLine].\n\t\t\t\t\t\"Context, Class, Pool, and Global vars, and Selectors need\n\t\t\t\t\tonly test symbols\"\n\t\t\t\t\t(Symbol hasInterned: string ifTrue: [:symbol | symbol])\n\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t[cgVars _ self explainCtxt: symbol.\n\t\t\t\t\t\t\tcgVars == nil\n\t\t\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t\t\t[cgVars _ self explainClass: symbol.\n\t\t\t\t\t\t\t\t\tcgVars == nil ifTrue: [cgVars _ self explainGlobal: symbol]].\n\t\t\t\t\t\t\t\"See if it is a Selector (sent here or not)\"\n\t\t\t\t\t\t\tselectors _ self explainMySel: symbol.\n\t\t\t\t\t\t\tselectors == nil\n\t\t\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t\t\t[selectors _ self explainPartSel: string.\n\t\t\t\t\t\t\t\t\tselectors == nil ifTrue: [selectors _ self explainAnySel: symbol]]]\n\t\t\t\t\t\tifFalse: [selectors _ self explainPartSel: string].\n\t\t\t\t\tcgVars == nil\n\t\t\t\t\t\tifTrue: [cgVars _ '']\n\t\t\t\t\t\tifFalse: [cgVars _ cgVars , NewLine].\n\t\t\t\t\tselectors == nil\n\t\t\t\t\t\tifTrue: [selectors _ '']\n\t\t\t\t\t\tifFalse: [selectors _ selectors , NewLine].\n\t\t\t\t\tstring size = 1\n\t\t\t\t\t\tifTrue: [\"single special characters\"\n\t\t\t\t\t\t\tdelimitors _ self explainChar: string]\n\t\t\t\t\t\tifFalse: [\"matched delimitors\"\n\t\t\t\t\t\t\tdelimitors _ self explainDelimitor: string].\n\t\t\t\t\tnumbers _ self explainNumber: string.\n\t\t\t\t\tnumbers == nil ifTrue: [numbers _ ''].\n\t\t\t\t\tdelimitors == nil ifTrue: [delimitors _ ''].\n\t\t\t\t\treply _ tiVars , cgVars , selectors , delimitors , numbers]].\n\treply size = 0 ifTrue:\n\t\t[^ '\"Sorry, I can''t explain that.  Please select a single token, construct, or special character.\"'].\n\t^ reply\n",
          "explainNumber:": "explainNumber: string\n\t\"Is string a Number?\"\n\n\t| strm c |\n\t(c _ string at: 1) isDigit ifFalse: [(c = $- and: [string size > 1])\n\t\t\tifFalse: [^nil]].\n\tstrm _ ReadStream on: string.\n\tc _ Number readFrom: strm.\n\tstrm atEnd ifFalse: [^nil].\n\tc printString = string\n\t\tifTrue: [^'\"' , string , ' is a ' , c class name , '\"']\n\t\tifFalse: [^'\"' , string , ' (= ' , c printString , ') is a ' , c class name , '\"']\n",
          "explainMySel:": "explainMySel: symbol\n\t\"Is symbol the selector of this method?  Is it sent by this method?  If\n\tnot, then expalin will call (explainPartSel:) to see if it is a fragment of a\n\tselector sent here.  If not, explain will call (explainAnySel:) to catch any\n\tselector. \"\n\n\t| lits classes |\n\tselector == nil ifTrue: [^nil].\t\"not in a message\"\n\tclasses _ Smalltalk allClassesImplementing: symbol.\n\tclasses size > 12\n\t\tifTrue: [classes _ 'many classes']\n\t\tifFalse: [classes _ 'these classes ' , classes printString].\n\tselector = symbol\n\t\tifTrue: [^ '\"' , symbol , ' is the selector of this very method!  It is defined in ',\n\t\t\tclasses , '.  To see the other definitions, go to the message list pane and use yellowbug to select ''implementors''.\"']\n\t\tifFalse:\n\t\t\t[lits _ (class compiledMethodAt: selector) messages.\n\t\t\t(lits detect: [:each | each == symbol]\n\t\t\t\tifNone: [])\n\t\t\t\t== nil ifTrue: [^nil].\n\t\t\t^ '\"' , symbol , ' is a message selector which is defined in ', classes , '.  To see the definitions, go to the message list pane and use yellowbug to select ''messages''.\"'].\n",
          "explainGlobal:": "explainGlobal: symbol\n\t\"Is symbol a global variable?\"\n\n\t| each pool reply classes |\n\treply _ Smalltalk at: symbol ifAbsent: [^nil].\n\t(reply isKindOf: Behavior)\n\t\tifTrue: [^'\"is a global variable.  ' , symbol , ' is a class in category ', reply category,\n\t\t\t'.\"', NewLine, 'Browser newOnClass: ' , symbol , '.'].\n\tsymbol == #Smalltalk ifTrue: [^'\"is a global.  Smalltalk is the only instance of SystemDictionary and holds all global variables.\"'].\n\treply class == Dictionary\n\t\tifTrue:\n\t\t\t[classes _ Set new.\n\t\t\tSmalltalk allBehaviorsDo: [:each | (each sharedPools detect: [:pool | pool == reply]\n\t\t\t\t\tifNone: [])\n\t\t\t\t\t~~ nil ifTrue: [classes add: each]].\n\t\t\tclasses _ classes printString.\n\t\t\t^'\"is a global variable.  ' , symbol , ' is a Dictionary.  It is a pool which is used by the following classes' , (classes copyFrom: 4 to: classes size) , '\"'].\n\t^'\"is a global variable.  ' , symbol , ' is ' , reply printString , '\"'\n"
        }
      }
    }
  },
  "Interface-Text": {
    "StringHolderController": {
      "comment": "I represent a ParagraphEditor for a single paragraph of text, omitting alignment commands.  I provide items in the yellow button menu so that the text selection can be evaluated and so that the contents of the model can be stored or restored.\n\tdoIt -- evaluate the text selection as an expression\n\tprintIt -- same as doIt but insert a description of the result after the selection\n\taccept -- store the contents of the StringHolder into the model\n\tcancel -- store the contents of the model into the StringHolder\n\nInstance Variables:\n\tisLockingOn\t<Boolean> true if the view has been editted so that it should not\n\t\t\t\t\tbe closed without warning the user.\n",
      "class_name": "StringHolderController",
      "superclass": "ParagraphEditor",
      "instanceVariables": "isLockingOn",
      "classInstanceVariables": "",
      "classVariables": "CodeYellowButtonMenu CodeYellowButtonMessages",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"Initialize the yellow button pop-up menu and corresponding messages.\"\n\n\tCodeYellowButtonMenu _\n\t\tPopUpMenu\n\t\t\tlabels:\n'again\nundo\ncopy\ncut\npaste\ndo it\nprint it\naccept\ncancel'\n\t\tlines: #(2 5 7).\n\tCodeYellowButtonMessages _\n\t\t#(again undo copySelection cut paste doIt printIt accept cancel)\n\t\"StringHolderController initialize\"\n"
        }
      },
      "instance_methods": {
        "model access": {
          "model:": "model: aModel\n\tsuper model: aModel.\n\tview displayContents == nil\n\t\tifFalse: [self changeParagraph: view displayContents]\n"
        },
        "lock access": {
          "isLockingOff": "isLockingOff\n\t\"Answer whether no unsaved modifications have been carried out using\n\tthe receiver.\"\n\t^isLockingOn not\n",
          "turnLockingOff": "turnLockingOff\n\t\"Turn off the receiver's indication that it is locked.\"\n\tisLockingOn _ false\n",
          "unlockModel": "unlockModel\n\t\"If the receiver is locked, then the model probably is, but should not be, so\n\tunlock the model.\"\n\tisLockingOn ifTrue: [model unlock]\n",
          "turnLockingOn": "turnLockingOn\n\t\"Turn on the receiver's indication that it is locked.\"\n\tisLockingOn _ true\n",
          "isLockingOn": "isLockingOn\n\t\"Answer whether unsaved modifications have been carried out using the receiver.\"\n\t^isLockingOn\n",
          "lockModel": "lockModel\n\t\"If the receiver is lock, do so to the receiver's model.\"\n\tisLockingOn ifTrue: [model lock]\n"
        },
        "menu messages": {
          "accept": "accept\n\tsuper accept.\n\tmodel contents: paragraph string.\n\tself unlockModel\n",
          "printIt": "printIt\n\t\"Treat the current text selection as an expression;  evaluate it.  Insert\n\tthe description of the result of evaluation after the selection and then make this\n\tdescription the new text selection.\"\n\n\t| result |\n\tresult _ self doIt.\n\tresult ~~ #failedDoit\n\t\tifTrue: [self afterSelectionInsertAndSelect: result printString]\n",
          "cancel": "cancel\n\tsuper cancel.\n\tself unlockModel\n",
          "doIt": "doIt\n\t\"Treat the current text selection as an expression; evaluate it\"\n\n\t| result |\n\tself controlTerminate.\n\tresult _\n\t\tmodel doItReceiver class evaluatorClass new\n\t\t\t\tevaluate: self selectionAsStream\n\t\t\t\tin: model doItContext\n\t\t\t\tto: model doItReceiver\n\t\t\t\tnotifying: self\n\t\t\t\tifFail:\n\t\t\t\t\t[self controlInitialize.\n\t\t\t\t\t^#failedDoit].\n\tSmalltalk logChange: self selection string.\n\tself controlInitialize.\n\t^result\n"
        },
        "editing": {
          "insertAndSelect:at:": "insertAndSelect: aString at: anInteger\n\tself selectAt: anInteger.\n\tself deselect.\n\tself replaceSelectionWith: (' ' , aString) asText.\n\tself selectAndScroll\n"
        },
        "private": {
          "afterSelectionInsertAndSelect:": "afterSelectionInsertAndSelect: aString\n\tself insertAndSelect: aString at: stopBlock stringIndex\n",
          "replaceSelectionWith:": "replaceSelectionWith: aText\n\tsuper replaceSelectionWith: aText.\n\tself lockModel\n",
          "initializeYellowButtonMenu": "initializeYellowButtonMenu\n\tself yellowButtonMenu: CodeYellowButtonMenu\n\t\tyellowButtonMessages: CodeYellowButtonMessages\n"
        },
        "initialize-release": {
          "initialize": "initialize\n\tsuper initialize.\n\tisLockingOn _ true\n"
        }
      }
    },
    "TextView": {
      "comment": "TextView is a \"pluggable\" view of text.  The notion of pluggable views is an\nexperiment in user interface design.  The idea is to provide a view which can be plugged\nonto any object, rather than having to define a new subclass specific to every kind of\nobject which needs to be viewed.\n\nThe chief mechanism is a set of selectors, which can be thought of as an adaptor to\nconvert the generic textView operations (such as yellowButtonMenu) into model-specific\noperations (such as textMenu).\n\nSee the protocol 'adaptor' for use of the pluggable selectors.\nSee the creation messages in my class for an explication of the various parameters.\nBrowse senders of the creation messages in my class for examples in the system.\n",
      "class_name": "TextView",
      "superclass": "View",
      "instanceVariables": "partMsg acceptMsg menuMsg",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "on:aspect:change:menu:": "on: anObject aspect: aspectMsg change: changeMsg menu: menuMsg\n\t\"Create a 'pluggable' (see class comment) textView viewing anObject.\n\taspectMsg is sent to read the current text value in the model.\n\t\tIt is also used as the changed: parameter for this view.\n\tchangeMsg is sent to inform anObject of new text for the model.\n\tmenuMsg is sent to read the yellowButton menu for this view.\"\n\n\t^ self new on: anObject aspect: aspectMsg change: changeMsg menu: menuMsg\n"
        }
      },
      "instance_methods": {
        "deEmphasizing": {
          "deEmphasizeView": "deEmphasizeView\n\tself controller deselect\n"
        },
        "updating": {
          "update:": "update: aSymbol\n\t| text |\n\taSymbol == partMsg\n\t\tifTrue:\n\t\t\t[text _ self getText.\n\t\t\tself controller text ~= text\n\t\t\t\tifTrue:\n\t\t\t\t\t[self newText: text.\n\t\t\t\t\tself displayView]]\n",
          "updateRequest": "updateRequest\n\t| cancel |\n\tself controller textHasChanged ifFalse: [^true].\n\tself superView isCollapsed\n\t\tifFalse:\n\t\t\t[Display reverse: insetDisplayBox mask: Form gray.\n\tDisplay reverse: (insetDisplayBox insetBy: 4) mask: Form gray].\n\tcancel _ self confirm: 'The text showing has been altered.\nDo you wish to discard those changes?'.\n\tself superView isCollapsed\n\t\tifFalse:\n\t\t\t[Display reverse: insetDisplayBox mask: Form gray.\n\tDisplay reverse: (insetDisplayBox insetBy: 4) mask: Form gray].\n\t^ cancel\n"
        },
        "adaptor": {
          "accept:from:": "accept: aText from: aController\n\tacceptMsg == nil ifTrue: [self flash. ^ false].\n\t^ acceptMsg numArgs = 1\n\t\tifTrue:  \"one arg selectors get text only\"\n\t\t\t[model perform: acceptMsg with: aText]\n\t\tifFalse:  \"two arg selectors get text and controller as well\"\n\t\t\t[model perform: acceptMsg with: aText with: aController]\n",
          "getText": "getText\n\t| text |\n\tpartMsg == nil ifTrue: [^ Text new].\n\ttext _ model perform: partMsg.\n\ttext == nil ifTrue: [^ Text new].\n\t^ text\n",
          "yellowButtonMenu": "yellowButtonMenu\n\tmenuMsg == nil ifTrue: [^ nil].\n\t^ model perform: menuMsg\n"
        },
        "displaying": {
          "displayView": "displayView\n\tself clearInside.\n\tself controller display\n",
          "display": "display\n\tself isUnlocked\n\t\tifTrue:\n\t\t\t[self controller\n\t\t\t\twrappingBox: (self insetDisplayBox insetBy: 6 @ 0)\n\t\t\t\tclippingBox: self insetDisplayBox.\n\t\t\t\"ugly initialization hack: \"\n\t\t\t(controller text isEmpty and: [controller textHasChanged not])\n\t\t\t\tifTrue: [self newText: self getText]].\n\tsuper display\n"
        },
        "emphasizing": {
          "emphasizeView": "emphasizeView\n\tself controller select\n"
        },
        "private": {
          "on:aspect:change:menu:": "on: anObject aspect: m1 change: m3 menu: m4\n\tself model: anObject.\n\tpartMsg _ m1.\n\tacceptMsg _ m3.\n\tmenuMsg _ m4.\n\tself initialize\n"
        },
        "initialize-release": {
          "newText:": "newText: aText\n\taText == nil ifTrue: [^ self newText: Text new].\n\tself controller paragraph text: aText.\n\tself controller scrollToTop; resetState\n",
          "initialize": "initialize\n\tsuper initialize.\n\tself insideColor: Form white\n"
        },
        "controller access": {
          "defaultControllerClass": "defaultControllerClass\n\t^ TextController\n"
        }
      }
    },
    "AlwaysAcceptCodeController": {
      "comment": "I am a code controller that will do an accept even if the text is the same.\n",
      "class_name": "AlwaysAcceptCodeController",
      "superclass": "CodeController",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "menu messages": {
          "accept": "accept\n\t(model changeRequestFrom: view)\n\t\tifFalse: [^view flash].\n\tself controlTerminate.\n\t(view accept: self text from: self)\n\t\tifTrue: [initialText _ paragraph text copy]\n\t\tifFalse: [view flash].\n\tself controlInitialize\n"
        }
      }
    },
    "OnlyWhenSelectedCodeView": {
      "comment": "I am a code view for an OnlyWhenSelectedCodeController.\n",
      "class_name": "OnlyWhenSelectedCodeView",
      "superclass": "CodeView",
      "instanceVariables": "selectionMsg",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "on:aspect:change:menu:initialSelection:selection:": "on: anObject aspect: m1 change: m3 menu: m4 initialSelection: sel selection: selMsg\n\t\"Create an instance viewing anObject.  See super method in TextView for full\n\texplanation.  initialSelection (if not nil) is a string which will be searched for,\n\tand then highlighted if found, whenever the viewed text changes.\"\n\t^(super on: anObject aspect: m1 change: m3 menu: m4) selectionMsg: selMsg\n"
        }
      },
      "instance_methods": {
        "initialization": {
          "selectionMsg:": "selectionMsg: selMsg\n\tselectionMsg _ selMsg\n"
        },
        "controller access": {
          "defaultControllerClass": "defaultControllerClass\n\t^OnlyWhenSelectedCodeController\n"
        },
        "control": {
          "isSelected": "isSelected\n\t^model perform: selectionMsg\n"
        }
      }
    },
    "TextController": {
      "comment": "This subclass of the paragraphEditor uses actionMenus for model control protocol.\nIt also makes a stab (localMenuItem:) at the problem of distinguishing user control\ndirected at the model from that directed at the view/controller.\n\nThis controller is more tightly connected to its view (for example it asks it for its\nyellowButtonMenu), because the view is the current site for \"pluggable\" parameterization.\n",
      "class_name": "TextController",
      "superclass": "ParagraphEditor",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "menu messages": {
          "accept": "accept\n\t(self textHasChanged and: [model changeRequestFrom: view])\n\t\tifFalse: [^view flash].\n\tself controlTerminate.\n\t(view accept: self text from: self)\n\t\tifTrue: [super accept]\n\t\tifFalse: [view flash].\n\tself controlInitialize\n",
          "localMenuItem:": "localMenuItem: selector\n\t^ #(cut paste copySelection again undo cancel accept) includes: selector\n"
        },
        "composition": {
          "wrappingBox:clippingBox:": "wrappingBox: wrapRectangle clippingBox: clipRectangle\n\tparagraph recomposeIn: wrapRectangle clippingBox: clipRectangle.\n\tself selectFrom: startBlock stringIndex to: stopBlock stringIndex-1\n"
        },
        "control activity": {
          "yellowButtonActivity": "yellowButtonActivity\n\t| index menu selector |\n\tmenu _ view yellowButtonMenu.\n\tmenu == nil\n\t\tifTrue:\n\t\t\t[view flash.\n\t\t\tsuper controlActivity]\n\t\tifFalse:\n\t\t\t[index _ menu startUpYellowButton.\n\t\t\tindex ~= 0\n\t\t\t\tifTrue:\n\t\t\t\t\t[selector _ menu selectorAt: index.  \"editing to self, rest to model\"\n\t\t\t\t\t(self localMenuItem: selector)\n\t\t\t\t\t\tifTrue: [self perform: selector]\n\t\t\t\t\t\tifFalse: [self controlTerminate.\n\t\t\t\t\t\t\t\tselector numArgs = 2\n\t\t\t\t\t\t\t\t\tifTrue: [model perform: selector with: self text with: self]\n\t\t\t\t\t\t\t\t\tifFalse: [model perform: selector].\n\t\t\t\t\t\t\t\tself controlInitialize]]]\n"
        },
        "editing": {
          "insertAndSelect:at:": "insertAndSelect: aString at: anInteger\n\tself selectAt: anInteger.\n\tself deselect.\n\tself replaceSelectionWith: (' ' , aString) asText.\n\tself selectAndScroll\n"
        },
        "accessing": {
          "paragraph": "paragraph\n\t^ paragraph\n",
          "textHasChanged": "textHasChanged\n\t^ self text ~= initialText\n"
        }
      }
    },
    "CodeController": {
      "comment": "This controller adds some capability appropriate only to viewing Smalltalk code,\nsuch as 'explain' and 'format'.\n",
      "class_name": "CodeController",
      "superclass": "TextController",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "menu messages": {
          "printIt": "printIt\n\t\"Evaluate the current selection as an expression.  If successful, insert and\n\tselect the printString of the result of evaluation after the current selection.\"\n\t| result |\n\tresult _ self doIt.\n\tresult ~~ #failedDoit\n\t\tifTrue: [self insertAndSelect: result printString at: stopBlock stringIndex]\n",
          "explain": "explain\n\t\"Try to shed some light on what kind of entity the current selection is.\n\tThe selection must be a single token or construct.  Insert the answer\n\tafter the selection.  Call private routines whose names begin with\n\t'explain'.  They return a String if they recognise the selection, else nil.\"\n\t| reply |\n\treply _ (Explainer new\n\t\tclass: model selectedClass\n\t\tselector: model selector\n\t\tinstance: model doItReceiver\n\t\tcontext: model doItContext\n\t\tmethodText: model text) explain: self selection string for: model.\n\treply size = 0 ifTrue:\n\t\t[reply _ '\"Sorry, I can''t explain that.  Please select a single token, construct, or special character.' ,\n\t\t\t(model isUnlocked ifTrue: ['\"'] ifFalse: ['  Also, please cancel or accept.\"']).\n].\n\tself insertAndSelect: reply at: stopBlock stringIndex\n",
          "miniFormat": "miniFormat\n\t\"Replace selection with selection un-wrapped.\"\n\n\t| inStream outStream char |\n\tinStream _ ReadStream on: (self selection copyWithout: Character tab).\n\toutStream _ WriteStream on: (String new: self selection size).\n\t[inStream atEnd]\n\t\twhileFalse:\n\t\t\t[char _ inStream next.\n\t\t\tchar isSeparator\n\t\t\t\tifTrue:\n\t\t\t\t\t[outStream space.\n\t\t\t\t\t[inStream atEnd not and: [inStream peek isSeparator]]\n\t\t\t\t\t\twhileTrue: [inStream next]]\n\t\t\t\tifFalse: [outStream nextPut: char]].\n\tself deselect.\n\tself replaceSelectionWith: outStream contents asText.\n\tself select\n",
          "localMenuItem:": "localMenuItem: selector\n\t^ (#(doIt printIt format explain) includes: selector) or:\n\t\t[super localMenuItem: selector]\n",
          "doIt": "doIt\n\t\"Evaluate the current text selection as an expression\"\n\t| result selectionStart oldTextSize selection |\n\tself controlTerminate.\n\tselectionStart _ startBlock stringIndex.\n\toldTextSize _ self text size.\n\tselection _ self selection.\n\tresult _\n\t\tmodel doItReceiver class evaluatorClass new\n\t\t\t\tevaluate: self selectionAsStream\n\t\t\t\tin: model doItContext\n\t\t\t\tto: model doItReceiver\n\t\t\t\tnotifying: self\n\t\t\t\tifFail:\n\t\t\t\t\t[self controlInitialize.\n\t\t\t\t\t^#failedDoit].\n\tself selection asString = selection asString ifFalse:\n\t\t[self selectFrom: selectionStart  \"Reselect doIt range after compiler interaction\"\n\t\t\tto: selectionStart + selection size - 1 + (self text size - oldTextSize)].\n\tSmalltalk logChange: self selection string.\n\tmodel doItValue: result.\n\tself controlInitialize.\n\t^result\n",
          "format": "format\n\t\"Reformat the contents of the receiver's view, formatted, if the view is unlocked.\"\n\t| selectedClass aCompiler newText |\n\tSensor leftShiftDown ifTrue: [^self miniFormat].\n\tself textHasChanged\n\t\tifTrue: [view flash. ^self].\n\tselectedClass _ model selectedClass.\n\tself controlTerminate.\n\tCursor execute showWhile:\n\t\t[aCompiler _ selectedClass compilerClass new.\n\t\tself selectFrom: 1 to: paragraph text size.\n\t\tself deselect.\n\t\tnewText _\n\t\t\taCompiler\n\t\t\t\tformat: model text\n\t\t\t\tin: selectedClass\n\t\t\t\tnotifying: self.\n\t\tnewText == nil ifFalse:\n\t\t\t[self replaceSelectionWith: (newText asText makeSelectorBoldIn: selectedClass).\n\t\t\tself selectAt: 1]].\n\tself controlInitialize\n"
        }
      }
    },
    "StringHolder": {
      "comment": "A model for providing a layer of structure in order to view an aspect of structured information that is a string.\n\nInstance variables\n\tcontents\t\t<String>\n\tisLocked\t<Boolean> whether or not the contents has been changed but not stored\n",
      "class_name": "StringHolder",
      "superclass": "Object",
      "instanceVariables": "contents isLocked",
      "classInstanceVariables": "",
      "classVariables": "Workspace",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"The class variables were initialized once, and\n\tsubsequently filled with information.  Re-executing this method is\n\ttherefore dangerous.\n\n\tworkSpace  _ StringHolder new.\n\n\n\tStringHolder initialize\"\n"
        },
        "instance creation": {
          "new": "new\n\t^super new initialize\n"
        },
        "workspace constants": {
          "workspace": "workspace\n\t\"Answer the model for the system workspace.\"\n\t^Workspace\n"
        }
      },
      "instance_methods": {
        "lock access": {
          "lock": "lock\n\t\"Note that the receiver has been modified.\"\n\tisLocked _ true\n",
          "isLocked": "isLocked\n\t\"Answer whether the receiver is locked, that is, has the contents of the\n\treceiver been modified since the last time it was unlocked.\"\n\n\t^isLocked\n",
          "isUnlocked": "isUnlocked\n\t\"Answer whether the receiver is unlocked.\"\n\t^isLocked not\n",
          "unlock": "unlock\n\t\"Unlock the receiver.  Any modification has presumably been saved.\"\n\tisLocked _ false\n"
        },
        "doIt/accept/explain": {
          "doItContext": "doItContext\n\t\"Answer the context in which a text selection can be evaluated.\"\n\t^nil\n",
          "doItReceiver": "doItReceiver\n\t\"Answer the object that should be informed of the result of evaluating a\n\ttext selection.\"\n\t^nil\n"
        },
        "accessing": {
          "contents:": "contents: aString\n\t\"Set aString to be the contents of the receiver.\"\n\tcontents _ aString\n",
          "contents": "contents\n\t\"Answer the contents that the receiver is holding--presumably a string.\"\n\t^contents\n"
        },
        "private": {
          "defaultContents": "defaultContents\n\t^ ''\n"
        },
        "initialize-release": {
          "initialize": "initialize\n\t\"Initialize the state of the receiver to be unlocked with default contents.\"\n\tisLocked _ false.\n\tcontents _ self defaultContents\n"
        }
      }
    },
    "ParagraphEditor": {
      "comment": "I contain the main handling of text editing.  I ought to be used only on smallish paragraphs.\n\nInstance Variables\n\n\tparagraph\n<Paragraph>  A pointer to the textForm being edited.  The Paragraph is optimized for managing replacements in it*s stylizedString and for scrolling.\n\n\tstartBlock\n\tstopBlock\n<CharacterBlock>  These variables contain the string indices, characters, and bounding boxes of the starting and stopping characters in the stylizedString which will be operated upon by the next command.\n\n\tbeginTypeInBlock\n<CharacterBlock>  Used to manage typing and to distinguish selection arising from the last characters typed in from selection with the mouse or which is the result of some special keystroke.\n\n\tinitialText\n<Text>  A copy of the string held by the Paragraph at the time the text editor was instantiated.  It is currently used to manage the editing of Smalltalk code, and is reinstalled in the Paragraph when a *cancel* is executed and is overwritten when an *accept* is executed.\"\n\n\tselectionState\n<Integer>  1 = on, 0 = off.  Since selection involves raw modification of the bits in the destinationForm of the Paragraph, it must be monitored closely and with care.\"\n",
      "class_name": "ParagraphEditor",
      "superclass": "ScrollController",
      "instanceVariables": "paragraph startBlock stopBlock beginTypeInBlock emphasisHere initialText selectionShowing",
      "classInstanceVariables": "",
      "classVariables": "CurrentSelection Keyboard TextEditorYellowButtonMenu TextEditorYellowButtonMessages UndoSelection",
      "poolDictionaries": "TextConstants",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"Initialize the yellow button menu information, the keyboard map for special\n\tcontrol characters, and the shared buffers for copying text across views and\n\tmanaging undo.\"\n\n\tCurrentSelection _ UndoSelection _ Text new.\n\tTextEditorYellowButtonMenu _ PopUpMenu labels: 'again\nundo\ncopy\ncut\npaste\naccept\ncancel\nalign\nfit'\n\tlines: #(2 5 7).\n\tTextEditorYellowButtonMessages _\n\t\t#(again undo copySelection cut paste accept cancel align fit ).\n\tKeyboard _ Array new: 256.\n\tKeyboard atAllPut: #normalCharacter:.\n\tKeyboard at: Cut asciiValue + 1 put: #cut:.\n\tKeyboard at: Paste asciiValue + 1 put: #paste:.\n\tKeyboard at: ESC asciiValue + 1 put: #selectCurrentTypeIn:.\n\tKeyboard at: BS asciiValue + 1 put: #backspace:.\n\tKeyboard at: Ctrlw asciiValue + 1 put: #backWord:.\n\tKeyboard at: Ctrlt asciiValue + 1 put: #displayIfTrue:.\n\tKeyboard at: Ctrlf asciiValue + 1 put: #displayIfFalse:.\n\tKeyboard at: 132 + 1 put: #displayDate:.\t\"ctrl-d\"\n\n\t#(159 144 143 128 127 129 131 180 149 135 223 208\t\t\"fonts\"\n\t\t137 201\t\t\t\t\t\t\t\t\t\t\t\"underline, unUnderline\"\n\t\t166 230\t\t\t\t\t\t\t\t\t\t\t\"bold, unbold\"\n\t\t150 214\t\t\t\t\t\t\t\t\t\t\t\"italic, unitalic\"\n\t\t151\t\t\t\t\t\t\t\t\t\t\t\t\"clear emphasis\")\n\tdo:\n\t\t[\"CTL-1 thru 9, and 0, CTLSHIFT 1-2\n\t\t\tCTL-, CTLSHIFT-\"\n\t\t:i |\tKeyboard at: i + 1 put: #changeEmphasis:].\n\n\t#(213 7 218 249 219 15) do:\n\t\t[:i | \"ctl open brackets\"\n\t\tKeyboard at: i + 1 put: #enclose:].\n\tKeyboard at: BS2 asciiValue + 1 put: #leaveBrackets:.\n\n\t\"ParagraphEditor initialize.\"\n"
        },
        "instance creation": {
          "new": "new\n\t\"Answer a new instance of me with a null Paragraph to be edited.\"\n\t^ self newParagraph: '' asParagraph\n",
          "newParagraph:": "newParagraph: aParagraph\n\t\"Answer an instance of me with aParagraph as the text to be edited. \"\n\n\t| aParagraphEditor |\n\taParagraphEditor _ super new.\n\taParagraphEditor changeParagraph: aParagraph.\n\t^aParagraphEditor\n"
        }
      },
      "instance_methods": {
        "sensor access": {
          "processRedButton": "processRedButton\n\t\"The user pressed a red mouse button, meaning create a new text selection.\n\tHighlighting the selection is carried out by the paragraph itself.  Double\n\tclicking causes a selection of the area between the nearest enclosing delimitors;\n\textension is based on both ends if different.\"\n\n\t| paragraphOrigin selectionBlocks |\n\tself deselect.\n\tself closeTypeIn.\n\tparagraphOrigin _ paragraph compositionRectangle origin.\n\tselectionBlocks _ paragraph mouseSelect: startBlock to: stopBlock.\n\tselectionShowing _ true.\n\tstartBlock _ selectionBlocks at: 1.\n\tstopBlock _ selectionBlocks at: 2.\n\tself updateMarker.\n\tself setEmphasisHere\n",
          "processKeyboard": "processKeyboard\n\t\"Determine whether the user pressed the keyboard.  If so, read the keys.\"\n\tsensor keyboardPressed\n\t\tifTrue: [self readKeyboard]\n",
          "processBlueButton": "processBlueButton\n\t\"The user pressed the blue button on the mouse.  Determine what action to take.\"\n\t^self\n",
          "processYellowButton": "processYellowButton\n\t\"User pressed the yellow button on the mouse.  Determine what\n\tactions to take.\"\n\tself yellowButtonActivity\n",
          "processMouseButtons": "processMouseButtons\n\t\"Determine whether the user pressed any mouse button.  For each possible\n\tbutton, determine what actions to take.\"\n\n\tsensor redButtonPressed ifTrue: [self processRedButton].\n\tsensor yellowButtonPressed ifTrue: [self processYellowButton].\n\tsensor blueButtonPressed ifTrue: [self processBlueButton]\n"
        },
        "selecting": {
          "selectAndScrollFrom:to:": "selectAndScrollFrom: start to: stop\n\tself deselect.\n\tstartBlock _ paragraph characterBlockForIndex: start.\n\tstopBlock _ paragraph characterBlockForIndex: stop + 1.\n\tself selectAndScroll\n",
          "deselect": "deselect\n\t\"If the text selection is visible on the screen, reverse its highlight.\"\n\tselectionShowing ifTrue: [self reverseSelection]\n",
          "findAndSelect:": "findAndSelect: aString\n\t| index |\n\tindex _ paragraph text findString: aString startingAt: stopBlock stringIndex.\n\tindex = 0 ifTrue: [^false].\n\tself selectAndScrollFrom: index to: index + aString size-1.\n\t^true\n",
          "selectionAsStream": "selectionAsStream\n\t\"Answer a ReadStream on the text in the paragraph that is currently selected.\"\n\t^ReadStream\n\t\ton: paragraph text asString\n\t\tfrom: startBlock stringIndex\n\t\tto: stopBlock stringIndex - 1\n",
          "selectAndScroll": "selectAndScroll\n\t\"Scroll until the selection is in the view and then highlight it.\"\n\n\t| lineHeight deltaY clippingRectangle |\n\tlineHeight _ paragraph textStyle lineGrid.\n\tclippingRectangle _ paragraph clippingRectangle.\n\tdeltaY _ stopBlock top - clippingRectangle top.\n\tdeltaY >= 0\n\t\tifTrue: [deltaY _ stopBlock bottom - clippingRectangle bottom max: 0].\n\t\t\t\t\t\t\"check if stopIndex below bottom of clippingRectangle\"\n\tdeltaY ~= 0\n\t\tifTrue: [self scrollBy: (deltaY abs + lineHeight - 1 truncateTo: lineHeight)\n\t\t\t\t\t\t\t\t\t* deltaY sign].\n\tself select\n",
          "select": "select\n\t\"If the text selection is visible on the screen, highlight it.\"\n\tselectionShowing ifFalse: [self reverseSelection]\n",
          "selection": "selection\n\t\"Answer the text in the paragraph that is currently selected.\"\n\t^paragraph text copyFrom: startBlock stringIndex to: stopBlock stringIndex - 1\n",
          "initializeSelection": "initializeSelection\n\t\"Do the initial activity when starting up the receiver.  For example, in the\n\tParagraphEditor highlight the current selection.\"\n\tself select\n",
          "selectFrom:to:": "selectFrom: start to: stop\n\t\"The text selection starts at the character at position start and ends at the\n\tcharacter at position stop.\"\n\n\tself deselect.\n\tstartBlock _ paragraph characterBlockForIndex: start.\n\tstopBlock _ paragraph characterBlockForIndex: stop+1.\n\tself selectAndScroll\n",
          "recomputeSelection": "recomputeSelection\n\t\"eg after changing the composition rectangle of the paragraph\"\n\tself deselect.\n\tstartBlock _ paragraph characterBlockForIndex: startBlock stringIndex.\n\tstopBlock _ paragraph characterBlockForIndex: stopBlock stringIndex.\n\tselectionShowing_ false\n",
          "selectAt:": "selectAt: characterIndex\n\t\"Place the character before the character at position characterIndex.  Make\n\tcertain the selection is in the view.\"\n\n\tself deselect.\n\tstartBlock _ paragraph characterBlockForIndex: characterIndex.\n\tstopBlock _ startBlock copy.\n\tself selectAndScroll\n",
          "reverseSelection": "reverseSelection\n\t\"Reverse the valence of the current selection highlighting.\"\n\n\tselectionShowing _ selectionShowing not.\n\tstartBlock = stopBlock\n\t\tifTrue: [paragraph displayCaretAt:\n\t\t\t\t\tstartBlock topLeft + (0 @ paragraph textStyle baseline)]\n\t\tifFalse: [paragraph reverseFrom: startBlock to: stopBlock]\n"
        },
        "control defaults": {
          "processKeyset": "processKeyset\n\t\"clever trick to remove this method after it is called for the last time\"\n\tParagraphEditor removeSelector: #processKeyset\n",
          "isControlActive": "isControlActive\n\t^super isControlActive & sensor blueButtonPressed not\n",
          "controlActivity": "controlActivity\n\tself scrollBarContainsCursor\n\t\tifTrue:\n\t\t\t[self scroll]\n\t\tifFalse:\n\t\t\t[self processKeyboard.\n\t\t\tself processMouseButtons].\n"
        },
        "basic control sequence": {
          "controlInitialize": "controlInitialize\n\tsuper controlInitialize.\n\tstartBlock _ paragraph characterBlockForIndex: startBlock stringIndex.\n\tstopBlock _ paragraph characterBlockForIndex: stopBlock stringIndex.\n\tself initializeSelection.\n\tbeginTypeInBlock _ nil.\n",
          "controlTerminate": "controlTerminate\n\tsuper controlTerminate.\n\tself closeTypeIn ifTrue: [startBlock _ stopBlock copy].\n\t\"so leaving and entering window won't select last type-in\"\n"
        },
        "menu messages": {
          "accept": "accept\n\t\"Save the current text of the text being edited as the current acceptable\n\tversion for purposes of canceling.\"\n\tinitialText _ paragraph text copy\n",
          "undo": "undo\n\t\"Reset the state of the paragraph prior to the previous cut or paste edit.\"\n\n\tself deselect.\n\tself closeTypeIn.\n\tself replaceSelectionWith: UndoSelection.\n\tself selectAndScroll.\n\tself updateMarker\n",
          "paste": "paste\n\t\"Paste the text from the shared buffer over the current selection and redisplay\n\tif necessary.\"\n\n\tself deselect.\n\tself closeTypeIn.\n\tself replaceSelectionWith: CurrentSelection.\n\tself selectAndScroll.\n\tself updateMarker\n",
          "again": "again\n\t\"Text subsititution.  If the left shift key is down, the substitution is made\n\tthroughout the entire Paragraph.  Otherwise, only the next possible\n\tsubsitution is made.\"\n\n\t| many |\n\tmany _ sensor leftShiftDown.\n\tself deselect.\n\tself closeTypeIn.\n\tself select.\n\tmany\n\t\tifTrue: [[self againOnce] whileTrue]\n\t\tifFalse: [self againOnce ifFalse: [self flash]].\n\tself moveMarker\n",
          "cancel": "cancel\n\t\"Restore the text of the paragraph to be the text saved since initialization or\n\tthe last accept.\"\n\n\tself controlTerminate.\n\tUndoSelection _ paragraph text.\n\tview clearInside.\n\tself changeParagraph: (paragraph text: initialText).\n\tparagraph displayOn: Display.\n\tself scrollToTop.\n\tself controlInitialize\n",
          "align": "align\n\t\"Align text according to the next greater alignment value--cycling among\n\tleft flush, right flush, center, justified.\"\n\n\tself deselect.\n\tparagraph toggleAlignment.\n\tparagraph displayOn: Display.\n\tstartBlock _ paragraph characterBlockForIndex: startBlock stringIndex.\n\tstopBlock _ paragraph characterBlockForIndex: stopBlock stringIndex.\n\tself select\n",
          "fit": "fit\n\t\"Make the bounding rectangle of the paragraph contain all the text while not\n\tchanging the width of the view of the paragraph.\"\n\n\tself deselect.\n\tparagraph clearVisibleRectangle.\n\tparagraph fit.\n\tparagraph displayOn: Display.\n\tparagraph outline.\n\tself select.\n\tself updateMarker\n",
          "copySelection": "copySelection\n\t\"Copy the current selection and store it in the shared buffer.\"\n\tCurrentSelection _ UndoSelection _ self selection\n",
          "cut": "cut\n\t\"Cut out the current selection and redisplay the paragraph if necessary.\"\n\n\tself deselect.\n\tself closeTypeIn.\n\tself replaceSelectionWith: Text new.\n\tself selectAndScroll.\n\tself updateMarker.\n\tCurrentSelection _ UndoSelection copy\n"
        },
        "marker adjustment": {
          "markerDelta": "markerDelta\n\t^marker top - scrollBar top - ((paragraph clippingRectangle top -\n\t\tparagraph compositionRectangle top) asFloat /\n\t\t\t(self scrollRectangleHeight max: 1) asFloat *\n\t\t\t\tscrollBar height asFloat) rounded\n",
          "updateMarker": "updateMarker\n\t\"A variation of moveMarker--only redisplay the marker in the scrollbar\n\tif an actual change has occurred in the positioning of the paragraph.\"\n\n\t| newMarkerRegion |\n\tnewMarkerRegion _ self computeMarkerRegion.\n\tnewMarkerRegion extent ~= marker region extent\n\t\tifTrue:\n\t\t\t[self markerRegion: newMarkerRegion.\n\t\t\tself moveMarker]\n",
          "computeMarkerRegion": "computeMarkerRegion\n\tparagraph compositionRectangle height = 0\n\t\tifTrue:\t[^0@0 extent: 10 @ scrollBar inside height]\n\t\tifFalse:\t[^0@0 extent:\n\t\t\t\t\t10 @ ((paragraph clippingRectangle height asFloat /\n\t\t\t\t\t\t\tself scrollRectangleHeight * scrollBar inside height) rounded\n\t\t\t\t\t\t\tmin: scrollBar inside height)]\n"
        },
        "displaying": {
          "displayAt:clippingBox:rule:mask:": "displayAt: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger mask: aForm\n\t\"Redisplay the paragraph starting at aDisplayPoint, clipped by the rectangle,\n\tclipRectangle.  The characters are displayed with respect to the rule, ruleInteger, and\n\tthe mask, aForm.\"\n\tself deselect.\n\tparagraph\n\t\tdisplayOn: Display\n\t\tat: aDisplayPoint\n\t\tclippingBox: clipRectangle\n\t\trule: ruleInteger\n\t\tmask: aForm.\n\tself select\n",
          "display": "display\n\t\"Redisplay the paragraph.\"\n\t| selectionState |\n\tselectionState _ selectionShowing.\n\tself deselect.\n\tparagraph displayOn: Display.\n\tselectionState ifTrue: [self select]\n"
        },
        "indicating": {
          "flash": "flash\n\t\"Causes the view of he paragraph to complement twice in succession.\"\n\tparagraph flash\n"
        },
        "copying": {
          "copy": "copy\n\t| p c |\n\t\"Return a copy of me, which goes one level deeper into my paragraph\"\n\tp _ paragraph.\n\tparagraph _ paragraph copy.\n\tc _ super copy.\n\tparagraph _ p.\n\t^ c\n"
        },
        "editing": {
          "backWord:": "backWord: characterStream\n\t\"Backspace over the last word--i.e., cut the last word.  Initiated by ctrl w\"\n\n\t| startIndex |\n\tsensor keyboard.\t\t\" flush the ctrl-w\"\n\tcharacterStream isEmpty\n\t\tifFalse:\n\t\t\t[self replaceSelectionWith:\n\t\t\t\t(Text string: characterStream contents emphasis: emphasisHere).\n\t\t\tstartBlock _ stopBlock copy.\n\t\t\tcharacterStream reset].\n\tstartIndex _ 1 max: startBlock stringIndex - 1.\n\t[startIndex > 1 and: [(paragraph text at: startIndex - 1) asCharacter tokenish]]\n\t\twhileTrue: [startIndex _ startIndex - 1].\n\tstartBlock _ paragraph characterBlockForIndex: startIndex.\n\tbeginTypeInBlock _\n\t\tparagraph characterBlockForIndex:\n\t\t\t\t(beginTypeInBlock stringIndex min: startIndex).\n\t^false\n",
          "selectCurrentTypeIn:": "selectCurrentTypeIn: characterStream\n\t\"The user just finished typing in some text and then typed the esc key.  The\n\ttyped text becomes the current text selection.\"\n\n\tsensor keyboard.\t\t\"flush character\"\n\tcharacterStream isEmpty\n\t\tifTrue:\n\t\t\t[self deselect]\n\t\tifFalse:\n\t\t\t[self replaceSelectionWith:\n\t\t\t\t(Text string: characterStream contents emphasis: emphasisHere).\n\t\t\tstartBlock _ stopBlock copy].\n\tself closeTypeIn.\n\tstartBlock = stopBlock\n\t\tifFalse: [startBlock _\n\t\t\t\t\tparagraph characterBlockForIndex:\n\t\t\t\t\t\tstopBlock stringIndex - CurrentSelection size].\n\tself select.\n\t^true\n",
          "changeEmphasis:": "changeEmphasis: characterStream\n\t\"Change the emphasis of the current selection or prepare to accept characters with the change in emphasis.  Emphasis change amounts to a font change.\"\n\n\t| oldCode newCode keyboard |\n\n\toldCode _ paragraph text emphasisAt: startBlock stringIndex.\n\t((newCode _ #(159 144 143 128 127 129 131 180 149 135 223 208)\n\t\t\"CTL 1-9, 0, CTLSHIFT 1-2\t\t-- fonts\"\n\t\tindexOf:  ((keyboard _ sensor keyboard) asciiValue)) = 0)\n\t\tifTrue:\t[newCode _ self emphasisDefault: oldCode keyedTo: keyboard].\n\t(((paragraph textStyle isFontUnderlined: oldCode)\n\t\tand: [keyboard ~= CtrlShiftMinus\t\t\"--unUnderline\"])\n\t\t\tand: [keyboard ~= Ctrlx\t\t\t\t\"clear emphasis\"])\n\t\tifTrue:\t[\"If font being replaced was underlined, use underlined version\n\t\t\t\t\tof new font, unless unUnderline has just been struck\"\n\t\t\t\tnewCode _ paragraph textStyle underlinedFontFor: newCode].\n\n\tstartBlock stringIndex = stopBlock stringIndex\n\t  ifTrue:  \"only change emphasisHere while typing\"\n\t\t[emphasisHere _ newCode.\n\t\tself select.\n\t\t^true].\n\tself replaceSelectionWith:\n\t\t(Text string: self selection asString emphasis: (newCode max: 1)).\n\tself closeTypeIn.\n\tself select.\n\t^true\n",
          "leaveBrackets:": "leaveBrackets: characterStream\n\t\"Jump typing cursor over a close-bracket character\"\n\t| stopIndex nextChar |\n\tSensor keyboard.\n\t\tstopBlock character notNil\n\t\tifTrue:\t[stopIndex _ stopBlock stringIndex.\n\t\t\t\tnextChar _ paragraph text at: stopIndex.\n\t\t\t\t(')]>}\"''' includes: nextChar) ifFalse: [^false].\n\t\t\t\tself deselect.\n\t\t\t\tstartBlock _ stopBlock _ paragraph characterBlockForIndex: stopIndex+1.\n\t\t\t\tself select]\n\t\tifFalse:\t[self select].\n\t^ true\n",
          "displayIfFalse:": "displayIfFalse: characterStream\n\t\"Replace the current text selection with the text 'ifFalse:'--initiated by ctrl f.\"\n\n\tsensor keyboard.\t\t\"flush character\"\n\tcharacterStream nextPutAll: 'ifFalse:'.\n\t^false\n",
          "displayIfTrue:": "displayIfTrue: characterStream\n\t\"Replace the current text selection with the text 'ifTrue:'--initiated by ctrl t.\"\n\n\tsensor keyboard.\t\t\"flush character\"\n\tcharacterStream nextPutAll: 'ifTrue:'.\n\t^false\n",
          "backspace:": "backspace: characterStream\n\t\"Backspace over the last character--i.e., cut the previous character.\"\n\n\t| startIndex |\n\tsensor keyboard.\t\t\t\"flush character\"\n\tcharacterStream isEmpty\n\t\tifTrue:\n\t\t\t[startIndex _ 1 max: startBlock stringIndex - 1.\n\t\t\tstartBlock _ paragraph characterBlockForIndex: startIndex.\n\t\t\tbeginTypeInBlock _\n\t\t\t\tparagraph characterBlockForIndex:\n\t\t\t\t\t\t\t(beginTypeInBlock stringIndex min: startIndex)]\n\t\tifFalse: [characterStream skip: -1].\n\t^false\n",
          "cut:": "cut: characterStream\n\t\"Cut out the current text selection.\"\n\n\tsensor keyboard.\t\"flush character\"\n\tself cut.\n\t^true\n",
          "normalCharacter:": "normalCharacter: characterStream\n\t\"A nonspecial character is to be added to the stream of characters.\"\n\n\tcharacterStream nextPut: sensor keyboard.\n\t^false\n",
          "displayDate:": "displayDate: characterStream\n\t\"Replace the current text selection with today's date--initiated by ctrl d.\"\n\n\tsensor keyboard.\t\t\"flush character\"\n\tcharacterStream nextPutAll: Date today printString.\n\t^false\n",
          "paste:": "paste: characterStream\n\t\"Replace the current text selection by the text in the shared buffer.\"\n\n\tsensor keyboard.\t\t\"flush character\"\n\tself paste.\n\t^true\n",
          "readKeyboard": "readKeyboard\n\t\"Key struck on the keyboard.  Find out which one and, if special,\n\tcarry out the associated special action.  Otherwise, add the character to\n\tthe stream of characters.\n\tThis also includes fast-echo: while the user is typing, it tries to keep up, even if not\n\texactly correctly.  When the user pauses, it fixes things up.\"\n\n\t| typeAhead nextCharacter line font x w delay expired charType firstWasCR |\n\tbeginTypeInBlock == nil\n\t\tifTrue:\n\t\t\t[UndoSelection _ self selection.\n\t\t\tbeginTypeInBlock _ startBlock copy].\n\tself deselect.\n\n\t\"Prepare for fast-echo loop\"\n\ttypeAhead _ WriteStream on: (String new: 128).\n\tline _ (startBlock expandBy: 9999@0) intersect: paragraph visibleRectangle.\n\tstartBlock = stopBlock\n\t\tifTrue:\t\t\"Only do fast type-in if null selection\"\n\t\t\t[x _ startBlock left.\n\t\t\tfont _ paragraph textStyle fontAt: emphasisHere.\n\t\t\tfirstWasCR _ sensor keyboardPeek = Character cr.\n\n\t\t\t\"Fast echo loop, accumulates chars in typeAhead stream\"\n\t\t\t[delay _ 100.  \"wait for small typing pauses:\"\n\t\t\t[sensor keyboardPressed | (delay=0)]\n\t\t\t\twhileFalse: [delay _ delay - 1].\n\t\t\tsensor keyboardPressed and:\n\t\t\t\t[((nextCharacter _ sensor keyboardPeek) = Character cr) == firstWasCR]]\n\n\t\t\t\twhileTrue:\n\t\t\t\t\t[charType _ Keyboard at: nextCharacter asciiValue + 1.\n\t\t\t\t\t(self perform: charType with: typeAhead)\n\t\t\t\t\t\tifTrue: [^self].\n\t\t\t\t\tw _ font widthOf: nextCharacter.\n\t\t\t\t\t(charType = #normalCharacter:) & (x+w <= line right)\n\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t[Display\n\t\t\t\t\t\t\t\tcopy: ((x+w) @ line top corner: line corner)\n\t\t\t\t\t\t\t\tfrom: x @ line top\n\t\t\t\t\t\t\t\tin: Display rule: Form over.\n\t\t\t\t\t\t\t(font characterForm: nextCharacter)\n\t\t\t\t\t\t\t\tdisplayAt:\n\t\t\t\t\t\t\t\t\tx @ (line top + paragraph textStyle baseline - font ascent).\n\t\t\t\t\t\t\tx _ x+w]].\t\"end fast echo loop\"\n\t\t\t\t]\n\t\t\tifFalse:\t\t\"Do normal behavior if non-null selection\"\n\t\t\t\t[nextCharacter _ sensor keyboardPeek.\n\t\t\t\tcharType _ Keyboard at: nextCharacter asciiValue + 1.\n\t\t\t\t(self perform: charType with: typeAhead)\n\t\t\t\t\t\tifTrue: [^self]].\n\t\"Now properly paste and display accumulated characters\"\n\tself replaceSelectionWith:\n\t\t(Text string: typeAhead contents emphasis: emphasisHere).\n\tstartBlock _ stopBlock copy.\n\tself selectAndScroll\n",
          "enclose:": "enclose: characterStream\n\t\"Insert or remove bracket characters around the current selection.\n\t\tIf null selection, then make a pair of brackets with cursor inside\"\n\t| char left right startIndex stopIndex which text oldSelection |\n\tchar _ Sensor keyboard asciiValue.\n\tcharacterStream reset.\n\tself deselect.\n\tstartIndex _ startBlock stringIndex.\n\tstopIndex _ stopBlock stringIndex.\n\twhich _ #(213 7 218 249 219 15) indexOf: char.\n\tleft _ '([<{\"''' at: which.\n\tright _ ')]>}\"''' at: which.\n\ttext _ paragraph text.\n\t((startIndex > 1 and: [stopIndex <= text size])\n\t\tand:\n\t\t[(text at: startIndex-1) = left and: [(text at: stopIndex) = right]])\n\t\tifTrue:\n\t\t\t[\"already enclosed; strip off brackets\"\n\t\t\toldSelection _ self selection.\n\t\t\tself selectFrom: startIndex-1 to: stopIndex; deselect.\n\t\t\tself replaceSelectionWith: oldSelection.\n\t\t\tself select]\n\t\tifFalse:\n\t\t\t[\"not enclosed; enclose by matching brackets\"\n\t\t\tself selectAt: startIndex; deselect.\n\t\t\tself setEmphasisHere.\n\t\t\tself replaceSelectionWith: (Text string: (String with: left)\n\t\t\t\t\t\temphasis: emphasisHere).\n\t\t\tself selectAt: stopIndex+1; deselect.\n\t\t\tself setEmphasisHere.\n\t\t\tself replaceSelectionWith: (Text string: (String with: right)\n\t\t\t\t\t\temphasis: emphasisHere).\n\t\t\tself selectFrom: stopIndex+1 to: stopIndex].\n\t^ true\n"
        },
        "accessing": {
          "text": "text\n\t\"Answer the text of the paragraph being edited.\"\n\t^paragraph text\n",
          "copySelection:": "copySelection: aText\n\tCurrentSelection _ UndoSelection _ aText\n"
        },
        "private": {
          "emphasisDefault:keyedTo:": "emphasisDefault: oldEmphasisCode keyedTo: keyboardCharacter\n\t\"Some default ways to get common forms of emphasis -- returns a new emphasis code.  Subroutine for changeEmphasis.  If anyone else uses, please note here.\"\n\n\tkeyboardCharacter = CtrlMinus\t\t\t\t\t\"underline\"\n\t\tifTrue:\t[^ paragraph textStyle underlinedFontFor: oldEmphasisCode].\n\tkeyboardCharacter = CtrlShiftMinus\t\t\t\t\"unUnderline\"\n\t\tifTrue:\t[^ paragraph textStyle unUnderlinedFontFor: oldEmphasisCode].\n\tkeyboardCharacter = Ctrlb\t\t\t\t\t\t\"Bold\"\n\t\tifTrue:\t[^ paragraph textStyle boldFontFor: oldEmphasisCode].\n\tkeyboardCharacter = CtrlB\t\t\t\t\t\t\"unBold\"\n\t\tifTrue:\t[^ paragraph textStyle basalFontFor: oldEmphasisCode].\n\tkeyboardCharacter = Ctrli\t\t\t\t\t\t\"Italic\"\n\t\tifTrue:\t[^ paragraph textStyle italicFontFor: oldEmphasisCode].\n\tkeyboardCharacter = CtrlI\t\t\t\t\t\t\"unItalic\"\n\t\tifTrue:\t[^ paragraph textStyle basalFontFor: oldEmphasisCode].\n\tkeyboardCharacter = Ctrlx\t\t\t\t\t\t\"clear emphasis, go to basal font\"\n\t\tifTrue:\t[^ paragraph textStyle basalFontFor: oldEmphasisCode].\n",
          "closeTypeIn": "closeTypeIn\n\tbeginTypeInBlock ~~ nil\n\t\tifTrue:\n\t\t\t[beginTypeInBlock < startBlock\n\t\t\t\tifTrue:\n\t\t\t\t\t[CurrentSelection _\n\t\t\t\t\t\tparagraph text\n\t\t\t\t\t\t\tcopyFrom: beginTypeInBlock stringIndex\n\t\t\t\t\t\t\tto: startBlock stringIndex - 1.\n\t\t\t\t\tstartBlock _ beginTypeInBlock copy].\n\t\t\tbeginTypeInBlock _ nil.\n\t\t\t^true]\n\t\tifFalse: [^false]\n",
          "scrollRectangleHeight": "scrollRectangleHeight\n\t^paragraph compositionRectangle height\n\t\t+ paragraph clippingRectangle height\n\t\t- paragraph lineGrid\n",
          "replaceSelectionWith:": "replaceSelectionWith: aText\n\tbeginTypeInBlock == nil ifTrue: [UndoSelection _ self selection].\n\tparagraph\n\t\treplaceFrom: startBlock stringIndex\n\t\tto: stopBlock stringIndex - 1\n\t\twith: aText\n\t\tdisplaying: true.\n\tstartBlock _ paragraph characterBlockForIndex: startBlock stringIndex.\n\tstopBlock _\n\t\tparagraph characterBlockForIndex: startBlock stringIndex + aText size\n",
          "initializeYellowButtonMenu": "initializeYellowButtonMenu\n\tself yellowButtonMenu: TextEditorYellowButtonMenu\n\t\tyellowButtonMessages: TextEditorYellowButtonMessages\n",
          "againOnce": "againOnce\n\t| nextStartIndex |\n\tnextStartIndex _\n\t\tparagraph text findString: UndoSelection startingAt: stopBlock stringIndex.\n\tnextStartIndex = 0 ifTrue: [^false].\n\tself deselect.\n\tstartBlock _ paragraph characterBlockForIndex: nextStartIndex.\n\tstopBlock _ paragraph characterBlockForIndex: nextStartIndex + UndoSelection size.\n\tCurrentSelection = UndoSelection\n\t\tifFalse: [self replaceSelectionWith: CurrentSelection].\n\tself selectAndScroll.\n\t^true\n",
          "setEmphasisHere": "setEmphasisHere\n\temphasisHere _ paragraph text emphasisAt: startBlock stringIndex\n"
        },
        "initialize-release": {
          "changeParagraph:": "changeParagraph: aParagraph\n\t\"Install aParagraph as the one to be edited by the receiver.\"\n\n\tparagraph _ aParagraph.\n\tself resetState\n",
          "initialize": "initialize\n\tsuper initialize.\n\tself initializeYellowButtonMenu\n",
          "resetState": "resetState\n\t\"Establish the initial conditions for editing the paragraph:  place caret\n\tbefore first character, set the emphasis to that of the first character,\n\tand save the paragraph for purposes of canceling.\"\n\n\t| insetDisplayBox |\n\tinsetDisplayBox _ paragraph compositionRectangle.\n\tstartBlock _\n\t\tCharacterBlock\n\t\t\tstringIndex: 1\n\t\t\tcharacter: nil\n\t\t\tboundingRectangle: (insetDisplayBox topLeft extent: 0 @ 0).\n\tstopBlock _ startBlock copy.\n\tbeginTypeInBlock _ startBlock copy.\n\tself setEmphasisHere.\n\tselectionShowing _ false.\n\tinitialText _ paragraph text copy\n"
        },
        "scrolling": {
          "scrollAmount": "scrollAmount\n\t^sensor cursorPoint y - scrollBar top\n",
          "viewDelta": "viewDelta\n\t^paragraph clippingRectangle top\n\t\t- paragraph compositionRectangle top\n\t\t- ((marker top - scrollBar inside top) asFloat\n\t\t\t\t/ scrollBar inside height asFloat * self scrollRectangleHeight asFloat)\n\t\t\troundTo: paragraph lineGrid\n",
          "scrollView:": "scrollView: anInteger\n\t| maximumAmount minimumAmount amount |\n\tself deselect.\n\tmaximumAmount _\n\t\tparagraph clippingRectangle top - paragraph compositionRectangle top max: 0.\n\tminimumAmount _\n\t\tparagraph clippingRectangle top\n\t\t\t+ paragraph lineGrid - paragraph compositionRectangle bottom min: 0.\n\tamount _ (anInteger min: maximumAmount) max: minimumAmount.\n\tamount ~= 0 ifTrue: [self scrollBy: amount negated].\n\tself select\n",
          "canScroll": "canScroll\n\t^true\n",
          "scrollToTop": "scrollToTop\n\t\"Scroll so that the paragraph is at the top of the view.\"\n\tself scrollView: (paragraph clippingRectangle top\n\t\t- paragraph compositionRectangle top)\n",
          "scrollBy:": "scrollBy: heightToMove\n\t\"Move the paragraph by the amount, heightToMove, and reset the text selection.\"\n\tself deselect.\n\tparagraph scrollBy: heightToMove.\n\tstartBlock _ paragraph characterBlockForIndex: startBlock stringIndex.\n\tstopBlock _ paragraph characterBlockForIndex: stopBlock stringIndex.\n\tself select\n",
          "scroll": "scroll\n\tself updateMarker.\n\tsuper scroll\n"
        }
      }
    },
    "OnlyWhenSelectedCodeController": {
      "comment": "I am a code controller that will not take control unless my model has some selection.\n",
      "class_name": "OnlyWhenSelectedCodeController",
      "superclass": "CodeController",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "control defaults": {
          "isControlWanted": "isControlWanted\n\tview isSelected\n\t\tifFalse:\n\t\t\t[sensor yellowButtonPressed ifTrue: [view flash].\n\t\t\tself deselect.\n\t\t\t^false].\n\t^self viewHasCursor\n"
        }
      }
    },
    "StringHolderView": {
      "comment": "I am a View of a String that is an aspect of a more structured object.  This String should not be changed by any editing unless the user issues the accept command.  Thus my instances provide a working copy of the String.  This copy is edited.  When the user issues the accept command, the String is copied from the working version;  or if the user issues the cancel command, the working version is restored from the String.  StringHolderController is my default controller.  It is initialized specially by passing the string viewed which is then converted to a Paragraph for editing.\n\nInstance Variables:\n\tdisplayContents\t<String> the working copy\n",
      "class_name": "StringHolderView",
      "superclass": "View",
      "instanceVariables": "displayContents",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "container:": "container: aContainer\n\t\"Answer an instance of me whose model is aContainer.  Give it a 2-dot border.\"\n\n\t| aCodeView |\n\taCodeView _ self new model: aContainer.\n\taCodeView borderWidth: 1.\n\t^aCodeView\n",
          "container": "container\n\t\"Answer an instance of me with a new instance of StringHolder as the model.\"\n\t^self container: StringHolder new\n",
          "open": "open\n\t\"Create a scheduled view of a workspace on the screen.\"\n\n\tself open: StringHolder new label: 'Workspace'\n",
          "open:label:": "open: aStringHolder label: aString\n\t\"Create a StandardSystemView of the model, aStringHolder, as viewed by an instance of me.\n\tThe label of the view is aString.\"\n\t| aStringHolderView topView |\n\taStringHolderView _ self container: aStringHolder.\n\ttopView _ StandardSystemView new.\n\ttopView borderWidth: 1.\n\ttopView model: aStringHolderView model.\n\ttopView addSubView: aStringHolderView.\n\ttopView label: aString.\n\ttopView minimumSize: 200 @ 150.\n\ttopView controller open\n",
          "open:": "open: aStringHolder\n\t\"Create a scheduled view of the argument, aStringHolder, as viewed by an\n\tinstance of me.  The view has label 'StringHolder'.\"\n\n\tself open: aStringHolder label: 'StringHolder'\n"
        },
        "workspace constants": {
          "openSystemWorkspace": "openSystemWorkspace\t\"StringHolderView openSystemWorkspace.\"\n\t\"Schedule a view of the system workspace.\"\n\tself open: StringHolder workspace label: 'System Workspace'\n"
        }
      },
      "instance_methods": {
        "deEmphasizing": {
          "deEmphasizeView": "deEmphasizeView\n\t(self controller isKindOf: ParagraphEditor)\n\t \tifTrue: [controller deselect]\n"
        },
        "model access": {
          "editString:": "editString: aString\n\t\"The paragraph to be displayed is created from the characters in aString.\"\n\n\tdisplayContents _ Paragraph\n\t\t\t\twithText: aString asText\n\t\t\t\tstyle: TextStyle default copy\n\t\t\t\tcompositionRectangle: (self insetDisplayBox insetBy: self paragraphInset)\n\t\t\t\tclippingRectangle: self insetDisplayBox.\n\t(self controller isKindOf: ParagraphEditor)\n\t\tifTrue: [controller changeParagraph: displayContents]\n",
          "model:": "model: aLockedModel\n\tsuper model: aLockedModel.\n\tself editString: self getContents\n"
        },
        "updating": {
          "update:": "update: aSymbol\n\tself updateDisplayContents\n",
          "updateRequest": "updateRequest\n\t^ model isUnlocked or:\n\t\t\t[(self confirm: 'Contents have not been saved.  Are you\ncertain that you want to close?')\n\t\t\t\tifTrue: [model unlock. ^true]\n\t\t\t\tifFalse: [^false]]\n",
          "updateDisplayContents": "updateDisplayContents\n\t\"Make the text that is displayed be the contents of the receiver's model.\"\n\n\t| contents |\n\tcontents _ self getContents.\n\tdisplayContents string ~= contents\n\t\tifTrue:\n\t\t\t[self editString: contents.\n\t\t\tself displayView]\n"
        },
        "displaying": {
          "displayView": "displayView\n\tself clearInside.\n\t(self controller isKindOf: ParagraphEditor)\n\t\tifTrue: [controller display]\n\t\tifFalse: [displayContents display]\n",
          "positionDisplayContents": "positionDisplayContents\n\t\"Presumably the text being displayed changed so that the wrapping box and clipping box should be reset.\"\n\n\tdisplayContents\n\t\trecomposeIn: (self insetDisplayBox insetBy: self paragraphInset)\n\t\tclippingBox: self insetDisplayBox\n",
          "display": "display\n\tself isUnlocked\n\t\tifTrue:\n\t\t\t[self positionDisplayContents.\n\t\t\t(self controller isKindOf: ParagraphEditor)\n\t\t\t\tifTrue: [controller recomputeSelection]].\n\tsuper display\n"
        },
        "private": {
          "getContents": "getContents\n\t^model contents\n",
          "paragraphInset": "paragraphInset\n\t\"Answer the amount to inset the paragraph from the border\"\n\t^6@0\n"
        },
        "initialize-release": {
          "initialize": "initialize\n\tsuper initialize.\n\tdisplayContents _ '' asParagraph.\n\tself insideColor: Form white\n"
        },
        "controller access": {
          "defaultControllerClass": "defaultControllerClass\n\t^StringHolderController\n",
          "defaultController": "defaultController\n\t^self defaultControllerClass newParagraph: displayContents\n",
          "displayContents": "displayContents\n\t^displayContents\n"
        }
      }
    },
    "CodeView": {
      "comment": "I am a TextView that assumes the text is code.  I include support for initial selection of a part of the text.\n",
      "class_name": "CodeView",
      "superclass": "TextView",
      "instanceVariables": "initialSelection",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "on:aspect:change:menu:initialSelection:": "on: anObject aspect: m1 change: m3 menu: m4 initialSelection: sel\n\t\"Create an instance viewing anObject.  See super method in TextView for full\n\texplanation.  initialSelection (if not nil) is a string which will be searched for,\n\tand then highlighted if found, whenever the viewed text changes.\"\n\n\t^ (super on: anObject aspect: m1 change: m3 menu: m4) initialSelection: sel\n"
        }
      },
      "instance_methods": {
        "updating": {
          "update:": "update: aSymbol\n\t| range |\n\taSymbol == #pc ifTrue:\n\t\t[range _ model pcRange.\n\t\tself controller selectAndScrollFrom: range first to: range last].\n\tsuper update: aSymbol\n"
        },
        "initialize-release": {
          "newText:": "newText: aText\n\tsuper newText: aText.\n\tinitialSelection==nil ifFalse: [self controller findAndSelect: initialSelection]\n",
          "initialSelection:": "initialSelection: sel\n\tinitialSelection _ sel\n"
        },
        "controller access": {
          "defaultControllerClass": "defaultControllerClass\n\t^ CodeController\n"
        }
      }
    }
  },
  "Interface-Transcript": {
    "TextCollector": {
      "comment": "I represent a StringHolder into which text can also be gathered by sending messages using Stream protocol.\n\nInstance Variables\n\tentryStream\t<WriteStream>\n",
      "class_name": "TextCollector",
      "superclass": "StringHolder",
      "instanceVariables": "entryStream",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "system": {
          "newTranscript:": "newTranscript: aTextCollector\n\t\"Store aTextCollector as the value of the system global Transcript.\"\n\tSmalltalk at: #Transcript put: aTextCollector.\n\t^aTextCollector\n"
        },
        "examples": {
          "example": "example\n\t\"TextCollectors support WriteStream protocol for appending characters to the\n\tSystem Transcript.\"\n\n\tTranscript show: (3+4) printString; cr.\n\tTranscript nextPutAll: '3+4 ='; space; print: 3+4; cr; endEntry\n\n\t\"TextCollector example\"\n"
        }
      },
      "instance_methods": {
        "entry control": {
          "endEntry": "endEntry\n\t\"If the receiver's WriteStream is not empty, then reinitialize it.  Send all\n\tdepends a message that the streaming has changed.\"\n\tentryStream isEmpty\n\t\tifFalse:\n\t\t\t[self changed: #appendEntry.\n\t\t\tself beginEntry]\n",
          "appendEntry": "appendEntry\n\t\"Append the text contents of the receiver's WriteStream to its text.\"\n\tcontents _ contents , self nextEntry asText.\n\tcontents size > self characterLimit\n\t\tifTrue: [contents _\n\t\t\t\t\tcontents\n\t\t\t\t\t\tcopyFrom: contents size - (self characterLimit // 2)\n\t\t\t\t\t\tto: contents size].\n\tself beginEntry\n",
          "beginEntry": "beginEntry\n\t\"To speed up appending information to the receiver, a WriteStream is\n\tmaintained.  Initialize it.\"\n\tentryStream _ WriteStream on: (String new: 200)\n",
          "nextEntry": "nextEntry\n\t\"Answer the text contents of the receiver's WriteStream.\"\n\t^entryStream contents\n"
        },
        "character writing": {
          "cr": "cr\n\t\"Append a carriage return to the text.\"\n\t^entryStream cr\n",
          "tab": "tab\n\t\"Append a tab to the text.\"\n\t^entryStream tab\n",
          "space": "space\n\t\"Append a space to the text.\"\n\t^entryStream space\n",
          "crtab": "crtab\n\t\"Append a carriage return and a tab to the text.\"\n\t^entryStream crtab\n",
          "crtab:": "crtab: anInteger\n\t\"Append a carriage return and anInteger number of tabs to the text.\"\n\t^entryStream crtab: anInteger\n"
        },
        "printing": {
          "store:": "store: anObject\n\t\"Have anObject print on me for rereading.\"\n\n\tanObject storeOn: self\n",
          "print:": "print: anObject\n\t\"Append a description of the object, anObject, to the text.\"\n\t^entryStream print: anObject\n"
        },
        "accessing": {
          "nextPut:": "nextPut: aCharacter\n\t\"Append aCharacter to the text.\"\n\t^entryStream nextPut: aCharacter\n",
          "next:put:": "next: anInteger put: aCharacter\n\t\"Insert the character, aCharacter, at position anInteger in the text.\"\n\t^entryStream next: anInteger put: aCharacter\n",
          "show:": "show: aString\n\t\"Append all the characters in aCollection to the text and display the text.\"\n\tself nextPutAll: aString.\n\tself endEntry\n",
          "nextPutAll:": "nextPutAll: aCollection\n\t\"Append all the characters in aCollection to the text.\"\n\t^entryStream nextPutAll: aCollection\n"
        },
        "private": {
          "characterLimit": "characterLimit\n\t^2000\n"
        },
        "initialize-release": {
          "initialize": "initialize\n\tsuper initialize.\n\tself beginEntry\n"
        },
        "clearing": {
          "refresh": "refresh\n\t\"Bring window to front on screen\"\n\n\tself changed: #refresh\n\t\"Transcript refresh\"\n",
          "clear": "clear\n\t\"Re-initialize the text to contain no characters.\"\n\n\tcontents _ Text new.\n\tself beginEntry.\n\tself changed: #update\n\t\"Transcript clear\"\n"
        }
      }
    },
    "TextCollectorController": {
      "comment": "I am a kind of StringHolderController (a ParagraphEditor) that adds the doIt, printIt, accept, and cancel commands.  I do not change the yellow button menu.  I do add methods for accepting text that was generated from Stream-like messages to the model, a TextCollector\n",
      "class_name": "TextCollectorController",
      "superclass": "StringHolderController",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "entry control": {
          "appendEntry": "appendEntry\n\t\"Append the text in the model's writeStream to the editable text.\"\n\t\"revised 9/14/82 SBP\"\n\n\tview topView isCollapsed\n\t\tifTrue:\n\t\t\t[paragraph text replaceFrom: 1 to: paragraph text size with: model contents]\n\t\tifFalse:\n\t\t\t[self deselect.\n\t\t\tparagraph text size > model characterLimit ifTrue:\n\t\t\t\t[paragraph removeFirstChars: paragraph text size - (model characterLimit//2)].\n\t\t\tself selectWithoutComp: paragraph text size + 1.\n\t\t\tself replaceSelectionWith: model nextEntry asText.\n\t\t\tself selectWithoutComp: paragraph text size + 1.\n\t\t\tself selectAndScroll.\n\t\t\tself deselect.\n\t\t\tmodel contents: paragraph text]\n",
          "changeText:": "changeText: aText\n\t\"The paragraph to be edited is changed to aText.\"\n\n\tparagraph text: aText.\n\tself resetState.\n\tself selectWithoutComp: paragraph text size + 1.\n\tself selectAndScroll.\n\tparagraph displayOn: Display.\n\tself deselect\n",
          "viewToTop": "viewToTop\n\t\"Bring the view to top in z of screen.\"\n\n\tview topView isCollapsed ifFalse: [view display].\n"
        },
        "private": {
          "selectWithoutComp:": "selectWithoutComp: characterIndex\n\tstartBlock _ paragraph characterBlockForIndex: characterIndex.\n\tstopBlock _ startBlock copy\n"
        }
      }
    },
    "TextCollectorView": {
      "comment": "I am a StringHolderView of the description of the contents of a TextCollector or Transcript.  TextCollectorController is my default controller.\n",
      "class_name": "TextCollectorView",
      "superclass": "StringHolderView",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "open": "open\n\t\"Answer an instance of me on a new TextCollector.  Schedule it.\"\n\t^self open: TextCollector new label: 'TextCollector'\n",
          "open:label:": "open: aTextCollector label: aString\n\t\"Answer an instance of me on the argument, aTextCollector.  The\n\tlabel of the StandardSystemView should be aString.\"\n\n\t| topView aView |\n\ttopView _ StandardSystemView new.\n\ttopView model: aTextCollector.\n\ttopView label: aString.\n\ttopView minimumSize: 160 @ 120.\n\taView _ self new model: aTextCollector.\n\taView insideColor: Form white.\n\taView borderWidth: 1.\n\ttopView borderWidth: 1.\n\ttopView addSubView: aView.\n\ttopView controller open\n"
        }
      },
      "instance_methods": {
        "updating": {
          "update:": "update: aParameter\n\tself topView isCollapsed ifTrue: [model appendEntry].\n\t(self controller isKindOf: TextCollectorController)\n\t\tifTrue:\n\t\t\t[aParameter == #appendEntry\n\t\t\t\tifTrue: [^controller appendEntry].\n\t\t\taParameter == #update\n\t\t\t\tifTrue: [^controller changeText: model contents asText].\n\t\t\taParameter == #refresh\n\t\t\t\tifTrue:\t[^controller viewToTop]]\n"
        },
        "controller access": {
          "defaultControllerClass": "defaultControllerClass\n\t| t |\n\tt _ 0.\n\t^TextCollectorController\n"
        }
      }
    }
  },
  "Kernel-Classes": {
    "Behavior": {
      "comment": "Instance Variables:\n\tsuperclass\t<Behavior> links the chain of inheritance\n\tmethodDict\t<IdentityDictionary> associates message names with methods\n\tformat\t\t<Integer> encodes storage layout of instances\n\tsubclasses\t<Set> back-pointers to the class' subclasses\n\nBehavior provides the minimum state necessary for compiling methods, and creating and running instances.  Most objects are created as instances of the more fully supported subclass, Class, but Behavior is a good starting point for providing instance-specific behavior (as in Metaclass).\n",
      "class_name": "Behavior",
      "superclass": "Object",
      "instanceVariables": "superclass methodDict format subclasses",
      "classInstanceVariables": "",
      "classVariables": "SelectorsOfConflictMethods SelectorsOfCopiedMethods SelectorsOfDirectedMethods",
      "poolDictionaries": "",
      "class_methods": {
        "initialization": {
          "init": "init  \"Behavior init.\"\n\tSelectorsOfConflictMethods _ IdentityDictionary new.\n\t\t\"selector -> Array of classes\"\n\tSelectorsOfCopiedMethods _ IdentityDictionary new.\n\t\t\"selector -> Array of classes\"\n\tSelectorsOfDirectedMethods _ IdentityDictionary new\n\t\t\"selector -> Array of classes\"\n"
        }
      },
      "instance_methods": {
        "compiling": {
          "compileAllFrom:": "compileAllFrom: oldClass\n\t\"Compile all the methods in oldClass's method dictionary.\n\tSee recompile:from: regarding oldClass, which is normally just self.\"\n\n\tself selectors do: [:sel | self recompile: sel from: oldClass]\n",
          "sourceCodeTemplate": "sourceCodeTemplate\n\t\"Answer an expression to be edited and evaluated in order to\n\tdefine methods in this class.\"\n\n\t^'message selector and argument names\n\t\"comment stating purpose of message\"\n\n\t| temporary variable names |\n\tstatements'\n",
          "compileAll": "compileAll\n\t^ self compileAllFrom: self\n",
          "subclassDefinerClass": "subclassDefinerClass\n\t\"Return an evaluator class appropriate for evaluating definitions of new\n\tsubclasses of this class.\"\n\n\t^Compiler\n",
          "compile:notifying:trailer:": "compile: code notifying: requestor trailer: bytes\n\t\"Compile  the argument, code, as source code in the context of the\n\treceiver.  Use the default fail code [^nil].  Does not save source code.\n\tThe second argument, requestor, is to be notified if an error occurs. The\n\targument code is either a string or an object that converts to a string or a\n\tPositionableStream on an object that converts to a string. The third argument,\n\tbytes, is a trailer, that is, an array of three bytes that should be added to the end\n\tof the compiled method. These point to the location of the source code (on a file).\"\n\n\t^self compile: code notifying: requestor trailer: bytes ifFail: [^nil]\n",
          "compilerClass": "compilerClass\n\t\"Return a compiler class appropriate for source methods of this class.\"\n\n\t^Compiler\n",
          "compileUnchecked:": "compileUnchecked: code\n\t\"Compile the argument, code, and install the result in the receiver's method dictionary.\n\tDo not check for possible effect on inheritance, since that's what this is doing.\"\n\t| selector methodNode |\n\tmethodNode _ self compilerClass new\n\t\t\t\tcompile: code\n\t\t\t\tin: self\n\t\t\t\tnotifying: nil\n\t\t\t\tifFail: [^nil].\n\tselector _ methodNode selector.\n\tself addSelectorUnchecked: selector withMethod: (methodNode generate: #(0 0 0)).\n\t^selector\n",
          "evaluatorClass": "evaluatorClass\n\t\"Return an evaluator class appropriate for evaluating expressions in the\n\tcontext of instances of this class.\"\n\n\t^Compiler\n",
          "compileBroadcastCodeFor:": "compileBroadcastCodeFor: selector\n\t\"compile code that invokes ALL methods for 'selector' in my inheritance hierarchy\"\n\t| implementors strm keywords argNames |\n\timplementors _ self withAllSuperclasses select:\n\t\t[:each | each includesSelector: selector].\n\targNames _ Array new: selector numArgs.\n\t1 to: argNames size do: [:i | argNames at: i put: 'arg' , i printString].\n\tstrm _ WriteStream on: (String new: 500).\n\tstrm nextPutAll: 'all.'.\n\targNames size=0\n\t\tifTrue: [strm nextPutAll: selector]\n\t\tifFalse: [keywords _ selector keywords.\n\t\t\t\t1 to: argNames size do:\n\t\t\t\t\t[:i | strm nextPutAll: (keywords at: i); space;\n\t\t\t\t\t\tnextPutAll: (argNames at: i); space]].\n\timplementors do:\n\t\t[:each | strm cr; tab; nextPutAll: 'self '; nextPutAll: each name; nextPut: $. .\n\t\t\targNames size=0\n\t\t\t\tifTrue: [strm nextPutAll: selector]\n\t\t\t\tifFalse: [keywords _ selector keywords.\n\t\t\t\t\t\t1 to: argNames size do:\n\t\t\t\t\t\t\t[:i | strm nextPutAll: (keywords at: i); space;\n\t\t\t\t\t\t\t\tnextPutAll: (argNames at: i); space]].\n\t\t\tstrm nextPut: $.].\n\tself compileUnchecked: strm contents\n",
          "decompilerClass": "decompilerClass\n\t\"Return a decompiler class appropriate for compiled methods of this class.\"\n\n\t^Decompiler\n",
          "compileAllSubclasses": "compileAllSubclasses\n\t\"Compile all the methods in the receiver's subclasses.  This does not modify\n\tcode (re-install the compiled versions), just compiles the methods as a kind of static\n\tcheck.\"\n\n\tself allSubclasses do: [:aSubclass | aSubclass compileAll]\n",
          "decompile:": "decompile: selector\n\t\"Find the compiled code associated with the argument, selector, as a message selector\n\tin the receiver's method dictionary and decompile it.  Answer the resulting source\n\tcode as a string.  Create an error if the selector is not in the receiver's method\n\tdictionary.\"\n\n\t^self decompilerClass new decompile: selector in: self\n",
          "recompile:from:": "recompile: selector from: oldClass\n\t\"Recompile the method associated with selector in the receiver's method dictionary.\n\tTake care not to write out any new source code - just generate new bytes.\n\toldClass may differ from self in order to decompile right (if sourceFiles == nil)\n\twhen adding or removing fields of a class.\"\n\n\t| method trailer methodNode |\n\tmethod _ oldClass compiledMethodAt: selector.\n\ttrailer _ (method size - 2 to: method size) collect: [:i | method at: i].\n\tmethodNode _ self compilerClass new\n\t\t\t\tcompile: (oldClass sourceCodeAt: selector)\n\t\t\t\tin: self\n\t\t\t\tnotifying: nil\n\t\t\t\tifFail: [].\n\tmethodNode == nil  \"Try again after proceed from SyntaxError\"\n\t\tifTrue: [^self recompile: selector].\n\tselector == methodNode selector ifFalse: [self error: 'selector changed!'].\n\tself addSelector: selector withMethod: (methodNode generate: trailer).\n",
          "recompile:": "recompile: selector\n\t^ self recompile: selector from: self\n",
          "parserClass": "parserClass\n\t\"Return a parser class to use for parsing methods in this class.\"\n\n\t^self compilerClass preferredParserClass\n",
          "poolHas:ifTrue:": "poolHas: varName ifTrue: assocBlock\n\t\"Behaviors have no pools\"\n\t^false\n",
          "compile:notifying:trailer:ifFail:": "compile: code notifying: requestor trailer: bytes ifFail: failBlock\n\t\"Compile the argument, code, as source code in the context of the receiver and\n\tinstall the result in the receiver's method dictionary.  The argument requestor is to\n\tbe notified if an error occurs. The argument code is either a string or an\n\tobject that converts to a string or a PositionableStream on an object that\n\tconverts to a string.  The trailer is an array of three bytes that should\n\tbe added to the end of the compiled method.  These point to the location\n\tof the source code (on a file).   This method does not save the source code.\n\tEvaluate the failBlock if the compilation does not succeed.\"\n\n\t| methodNode selector |\n\tmethodNode _ self compilerClass new\n\t\t\t\tcompile: code\n\t\t\t\tin: self\n\t\t\t\tnotifying: requestor\n\t\t\t\tifFail: failBlock.\n\tselector _ methodNode selector.\n\tself addSelector: selector withMethod: (methodNode generate: bytes).\n\t^selector\n"
        },
        "accessing instances and variables": {
          "allInstVarNames": "allInstVarNames\n\t\"Answer an Array of the names of the receiver's instance variables.\"\n\t| names |\n\tnames _ OrderedCollection new.\n\tself accumulateInstVarNames: names traversedClasses: Set new.\n\t^names\n",
          "someInstance": "someInstance\n\t\"Answer the first instance of this receiver.  See Object nextInstance.  Fails\n\tif there are none.  Essential.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 77>\n\t^nil\n",
          "allClassVarNames": "allClassVarNames\n\t\"Answer a Set of the names of the receiver's and the receiver's\n\tancestor's class variables.\"\n\n\t^superclass allClassVarNames\n",
          "subclassInstVarNames": "subclassInstVarNames\n\t\"Answer a Set of the names of the receiver's subclasses' instance variables.\"\n\t| vars |\n\tvars _ Set new.\n\tself allSubclasses do: [:aSubclass | vars addAll: aSubclass instVarNames].\n\t^vars\n",
          "instanceCount": "instanceCount\n\t\"Answer the number of instances of the receiver that are currently in use.\"\n\n\t| count |\n\tcount _ 0.\n\tself allInstancesDo: [:x | count _ count + 1].\n\t^count\n",
          "classVarNames": "classVarNames\n\t\"Answer a Set of the receiver's class variable names.  Since the receiver does\n\tnot retain knowledge of class variables, the method fakes it by creating an empty set.\"\n\n\t^Set new\n",
          "instVarNames": "instVarNames\n\t\"Answer an Array of the instance variable names.  Behaviors must make up fake\n\tlocal instance variable names because Behaviors have instance variables for the\n\tpurpose of compiling methods, but these are not named instance variables.  \"\n\n\t| mySize superSize |\n\tmySize _ self instSize.\n\tsuperSize _\n\t\tsuperclass == nil\n\t\t\tifTrue: [0]\n\t\t\tifFalse: [superclass instSize].\n\tmySize = superSize ifTrue: [^#()].\n\t^(superSize + 1 to: mySize) collect: [:i | 'inst' , i printString]\n",
          "allVarNamesSelect:": "allVarNamesSelect: selectBlock\n\t\"Answer a collection of all the static variable names defined for the receiver which satisfy the condition in selectBlock.  Test class and pool variables, including superclass variables.  Also include global variables.\"\n\n\t| set |\n\tset _ self classPool keys select: selectBlock.\n\tself sharedPools do: [:pool | set addAll: (pool keys select: selectBlock)].\n\tsuperclass == nil\n\t\tifTrue:\t[set addAll: (Smalltalk keys select: selectBlock)]\n\t\tifFalse: [set addAll: (superclass allVarNamesSelect: selectBlock)].\n\t^set\n",
          "sharedPools": "sharedPools\n\t\"Answer a Set of the pools, dictionaries, that the receiver shares.  Since the receiver\n\tdoes not retain knowledge of pool dictionaries, the method fakes it by creating an\n\tempty array.  Subclasses, such as class Class, override this message.\"\n\n\t^Set new\n",
          "allSharedPools": "allSharedPools\n\t\"Answer a Set of the pools, dictionaries, that the receiver and the\n\treceiver's ancestors share.  Subclasses, such as class Class, override this message.\"\n\n\t^superclass allSharedPools\n",
          "allInstances": "allInstances\n\t\"Answer a collection of all instances of this class.\"\n\n\t| aCollection |\n\taCollection _ OrderedCollection new.\n\tself allInstancesDo:\n\t\t[:x | x == aCollection ifFalse: [aCollection add: x]].\n\t^aCollection\n"
        },
        "fileIn/Out": {
          "printMethodChunk:on:moveSource:toFile:": "printMethodChunk: selector on: aFileStream moveSource: moveSource toFile: fileIndex\n\t\"Print the source code for the method associated with the argument selector onto\n\tthe fileStream. aFileStream, and, for backup, if the argument moveSource (a Boolean)\n\tis true, also set the file index within the method to be the argument fileIndex.\"\n\n\t| position |\n\taFileStream cr; cr.\n\tmoveSource ifTrue: [position _ aFileStream position].\n\taFileStream nextChunkPut: (self sourceMethodAt: selector) asString.\n\tmoveSource\n\t\tifTrue: [(self compiledMethodAt: selector)\n\t\t\t\t\tsetSourcePosition: position inFile: fileIndex]\n"
        },
        "printing": {
          "printOn:": "printOn: aStream\n\taStream nextPutAll: 'a descendent of '.\n\tsuperclass printOn: aStream\n",
          "printHierarchy": "printHierarchy\n\t\"Answer a description containing the names and instance variable\n\tnames of all of the subclasses and superclasses of the receiver.\"\n\n\t| aStream index supers |\n\tindex _ 0.\n\taStream _ WriteStream on: (String new: 16).\n\tself allDynamicSuperclasses reverseDo:\n\t\t[:aClass |\n\t\taStream crtab: index.\n\t\tindex _ index + 1.\n\t\taStream nextPutAll: aClass name.\n\t\taStream space.\n\t\taStream print: aClass instVarNames.\n\t\tsupers _ aClass superclasses.\n\t\tsupers size>1 ifTrue:\n\t\t\t[aStream nextPutAll: '  [also a '.\n\t\t\t(supers copyFrom: 2 to: supers size) do:\n\t\t\t\t[:s | aStream space; nextPutAll: s name; space; print: s allInstVarNames].\n\t\t\taStream nextPut: $]  ]].\n\taStream cr.\n\tself printSubclassesOn: aStream callingSuperclass: self dynamicSuperclass level: index.\n\t^aStream contents\n"
        },
        "instance creation": {
          "new": "new\n\t\"Answer a new instance of the receiver (which is a class) with no indexable\n\tvariables.  Fail if the class is indexable.  Essential.  See Object documentation\n\twhatIsAPrimitive. \"\n\n\t<primitive: 70>\n\tself isVariable ifTrue: [^self new: 0].\n\tself primitiveFailed\n",
          "basicNew:": "basicNew: anInteger\n\t\"Answer a new instance of the receiver (which is a class) with the number of\n\tindexable variables specified by the argument, anInteger.  Fail if the class is not\n\tindexable or if the argument is not a positive Integer.  Essential.  See Object\n\tdocumentation whatIsAPrimitive.\"\n\n\t<primitive: 71>\n\tself primitiveFailed\n",
          "new:": "new: anInteger\n\t\"Answer a new instance of the receiver (which is a class) with the number of\n\tindexable variables specified by the argument, anInteger.  Fail if the class is not\n\tindexable or if the argument is not a positive Integer.  Essential.  See Object\n\tdocumentation whatIsAPrimitive.\"\n\n\t<primitive: 71>\n\tself primitiveFailed\n",
          "basicNew": "basicNew\n\t\"Answer a new instance of the receiver (which is a class) with no indexable\n\tvariables.  Fail if the class is indexable.  Essential.  See Object documentation\n\twhatIsAPrimitive.\"\n\n\t<primitive: 70>\n\tself isVariable ifTrue: [^self basicNew: 0].\n\tself primitiveFailed\n"
        },
        "creating class hierarchy": {
          "removeSubclass:": "removeSubclass: aSubclass\n\t\"If the argument, aSubclass, is one of the receiver's subclasses, remove it.\"\n\tsubclasses == nil ifFalse:\n\t\t[subclasses remove: aSubclass ifAbsent: [].\n\t\tsubclasses isEmpty ifTrue: [subclasses _ nil]]\n",
          "addSubclass:": "addSubclass: aSubclass\n\t\"Make the argument, aSubclass, be one of the subclasses of the receiver.\"\n\n\t(aSubclass superclasses includes: self)\n\t\tifTrue: [subclasses == nil\n\t\t\t\t\tifTrue:\t[subclasses _ Set with: aSubclass]\n\t\t\t\t\tifFalse:\t[subclasses add: aSubclass]]\n\t\tifFalse: [self error: aSubclass name , ' is not my subclass']\n",
          "superclass:": "superclass: aClass\n\t\"Change the receiver's superclass to be aClass.\"\n\n\t(aClass isKindOf: Behavior)\n\t\tifTrue: [superclass _ aClass]\n\t\tifFalse: [self error: 'superclass must be a class-describing object']\n"
        },
        "testing": {
          "isBytes": "isBytes\n\t\"Answer whether the receiver has 8-bit instance variables.\"\n\t^format noMask: 8192\n",
          "isVariable": "isVariable\n\t\"Answer whether the receiver has a variable (indexable) part.\"\n\n\t^(format bitAnd: 4096) ~= 0\n",
          "isWords": "isWords\n\t\"Answer whether the receiver has 16-bit instance variables.\"\n\n\t^self isBytes not\n",
          "instSize": "instSize\n\t\"Answer the number of named instance variables (as opposed to indexed\n\tvariables) of the receiver.\"\n\n\t^format bitAnd: 255\n",
          "isFixed": "isFixed\n\t\"Answer whether the receiver does not have a variable (indexable) part.\"\n\n\t^self isVariable not\n",
          "isPointers": "isPointers\n\t\"Answer whether the receiver contains just pointers (not bits).\"\n\n\t^self isBits not\n",
          "isBits": "isBits\n\t\"Answer whether the receiver contains just bits (not pointers).\"\n\n\t^format noMask: -16384\n"
        },
        "copying": {
          "copy": "copy\n\t\"Make a copy of the receiver without a list of subclasses.\"\n\n\t| myCopy savedSubclasses |\n\tsavedSubclasses _ subclasses.\n\tsubclasses _ nil.\n\tmyCopy _ self shallowCopy.\n\tsubclasses _ savedSubclasses.\n\t^myCopy methodDictionary: methodDict copy\n"
        },
        "accessing method dictionary": {
          "methodDescriptionAt:": "methodDescriptionAt: selector\n\t\"return a method description for the method for 'selector' \"\n\t| local copied conflict |\n\tlocal _ methodDict includesKey: selector.\n\tcopied _ (SelectorsOfCopiedMethods at: selector ifAbsent: [Array new]) includes: self.\n\tconflict _ (SelectorsOfConflictMethods at: selector ifAbsent: [Array new]) includes: self.\n\tlocal & copied not & conflict not\n\t\tifTrue: [^MethodDescription whichClass: self selector: selector].\n\t^self superMethodDescriptionAt: selector\n",
          "selectorAtMethod:setClass:": "selectorAtMethod: method setClass: classResultBlock\n\t\"Answer both the message selector associated with the compiled method\n\tand the class in which that selector is defined.\"\n\n\t| sel |\n\tsel _ methodDict keyAtValue: method\n\t\t\t\tifAbsent:\n\t\t\t\t\t[superclass == nil\n\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t[classResultBlock value: self.\n\t\t\t\t\t\t\t^self defaultSelectorForMethod: method].\n\t\t\t\t\tsel _ superclass selectorAtMethod: method setClass: classResultBlock.\n\t\t\t\t\t\"Set class to be self, rather than that returned from\n\t\t\t\t\tsuperclass. \"\n\t\t\t\t\tsel == (self defaultSelectorForMethod: method) ifTrue: [classResultBlock value: self].\n\t\t\t\t\t^sel].\n\tclassResultBlock value: self.\n\t^sel\n",
          "sourceMethodAt:": "sourceMethodAt: selector\n\t\"Answer the paragraph corresponding to the source code for the argument.\"\n\n\t^(self sourceCodeAt: selector) asText makeSelectorBoldIn: self\n",
          "checkSuperAddSelector:": "checkSuperAddSelector: selector\n\t| local |\n\tlocal _ self includesSelector: selector.\n\tself hasMultipleSuperclasses\n\t\tifFalse:\n\t\t\t[local ifTrue: [^self].\n\t\t\t^ self subclasses do: [:sub | sub checkSuperAddSelector: selector]].\n\t(self checkMethodFor: selector) ifFalse:  \"Copy or note conflict\"\n\t\t[Transcript cr; show: 'conflicting methods for ' , selector, ' in ', self name].\n\tlocal ifTrue: [^self].  \"Was local before, so no change below\"\n\t^ self subclasses do: [:sub | sub checkSuperAddSelector: selector]\n",
          "sourceCodeForMethod:at:": "sourceCodeForMethod: method at: messageSelector\n\t\"Answer the string corresponding to the source code for the argument.\"\n\t| newSource index|\n\tSensor leftShiftDown\n\t\tifTrue: [newSource _\n\t\t\t\t\t(self decompilerClass new\n\t\t\t\t\t\tdecompile: messageSelector\n\t\t\t\t\t\tin: self\n\t\t\t\t\t\tmethod: method) decompileString]\n\t\tifFalse:\n\t\t\t[newSource _ method getSource.\n\t\t\tnewSource == nil\n\t\t\t\tifTrue: [newSource _\n\t\t\t\t\t\t\t(self decompilerClass new\n\t\t\t\t\t\t\t\tdecompile: messageSelector\n\t\t\t\t\t\t\t\tin: self\n\t\t\t\t\t\t\t\tmethod: method) decompileString]\n\t\t\t\tifFalse:\t[((newSource at: newSource size) isSeparator)\n\t\t\t\t\t\t\tifTrue:\t[index _ newSource size. \"tidy up for file out\"\n\t\t\t\t\t\t\t\t\t[((newSource at: index) isSeparator)\n\t\t\t\t\t\t\t\t\t\tand: [index > 1]]\n\t\t\t\t\t\t\t\t\t\twhileTrue:\t[index _ index - 1].\n\t\t\t\t\t\t\t\t\tnewSource _ newSource copyFrom: 1 to: index]]].\n\t^newSource\n",
          "dynamicMethodDescriptionAt:": "dynamicMethodDescriptionAt: selector\n\t\"return a method description for the method for 'selector' that would\n\t be found by dynamic lookup\"\n\t(methodDict includesKey: selector) ifTrue:\n\t\t[^MethodDescription whichClass: self selector: selector].\n\tsuperclass == nil ifTrue:\n\t\t[^MethodDescription makeMethodNotImplemented].\n\t^superclass dynamicMethodDescriptionAt: selector\n",
          "superMethodDescriptionAt:": "superMethodDescriptionAt: selector\n\t\"return a method description for the method for 'selector' inherited from my superclasses\"\n\t| descr result |\n\tresult _ MethodDescription makeMethodNotImplemented.\n\tself superclasses do:\n\t\t[: each | descr _ each methodDescriptionAt: selector.\n\t\t descr isMethodNotImplemented ifFalse:\n\t\t \t[result isMethodNotImplemented\n\t\t\t\tifTrue: [result _ descr]\n\t\t\t\tifFalse: [result=descr ifFalse:\n\t\t\t\t\t\t\t[^MethodDescription makeConflictingMethods]]]].\n\t^result\n",
          "allSelectors": "allSelectors\n\t\"Answer a set of all the message selectors that instances of the receiver can\n\tunderstand.\"\n\t| aSet |\n\taSet _ Set new.\n\tself withAllSuperclasses do: [:each | aSet addAll: each selectors].\n\t^aSet\n\n\t\"Point allSelectors.\"\n",
          "sourceCodeAt:": "sourceCodeAt: messageSelector\n\t\"Answer the string corresponding to the source code for the argument.\"\n\t^ self sourceCodeForMethod: (methodDict at: messageSelector) at: messageSelector\n",
          "checkChangeSelector:": "checkChangeSelector: selector\n\t| descr classes class |\n\t\"The method for selector has been changed or removed.\n\t Check all copied versions for the method in question.\"\n\t(SelectorsOfCopiedMethods at: selector ifAbsent: [Array new]) do:\n\t\t[:class |\n\t\t(class inheritsFrom: self) ifTrue:\n\t\t\t[(class checkMethodFor: selector) ifFalse:\n\t\t\t\t[Transcript cr; show: 'conflicting methods for ' , selector, ' in ', class name]\n\t\t\t\t]].\n\t\"Remove all versions copied for directed access (eg Point.max) \"\n\t(SelectorsOfDirectedMethods at: selector ifAbsent: [Array new]) do:\n\t\t[:class |\n\t\t(class inheritsFrom: self) ifTrue:\n\t\t\t[(class compoundSelectorsMatching: selector) do:\n\t\t\t\t[:sel | class removeSelectorUnchecked: sel].\n\t\tself removeClass: class selector: selector in: SelectorsOfDirectedMethods]]\n",
          "compiledMethodAt:": "compiledMethodAt: selector\n\t\"Answer the compiled method associated with the message selector in the\n\treceiver's method dictionary.  If the selector is not in the dictionary,\n\tcreate an error notification.\"\n\n\t^methodDict at: selector\n",
          "selectors": "selectors\n\t\"Answer a Set of all the message selectors specified in the receiver's\n\tmethod dictionary.\"\n\n\t^methodDict keys\n\n\t\"Point selectors.\"\n"
        },
        "accessing": {
          "format": "format\n\t\"Answer an Integer that encodes the kinds and numbers of variables of instances\n\tof the receiver.\"\n\n\t^format\n"
        },
        "private": {
          "removeFromInheritanceTable:": "removeFromInheritanceTable: table\n\t\"I have been deleted -- remove me from the given inheritance table\"\n\t| keys list |\n\t\"get keys first, since we may be deleting entries in the midst of the loop that follows\"\n\tkeys _ table keys.\n\tkeys do:\n\t\t[:key | list _ (table at: key) copyWithout: self.\n\t\tlist size = 0\n\t\t\tifTrue: [table removeKey: key]\n\t\t\tifFalse: [table at: key put: list]]\n",
          "format:variable:words:pointers:": "format: nInstVars variable: isVar words: isWords pointers: isPointers\n\t\"Set the format for the receiver (a Class).\"\n\n\tformat _ nInstVars +\n\t\t\t\t(isVar\n\t\t\t\t\t\tifTrue: [4096]\n\t\t\t\t\t\tifFalse: [0]) +\n\t\t\t\t(isWords\n\t\t\t\t\t\tifTrue: [8192]\n\t\t\t\t\t\tifFalse: [0]) +\n\t\t\t\t(isPointers\n\t\t\t\t\t\tifTrue: [-16384]\n\t\t\t\t\t\tifFalse: [0])\n",
          "unmovedVarsFrom:": "unmovedVarsFrom: sup\n\t\"Answer with an Array with true for fields with the same offset in this class as in super\"\n\t| allInstVarNames supNames |\n\tallInstVarNames _ self allInstVarNames.\n\tsupNames _ sup allInstVarNames.\n\t^ ((1 to: sup instSize) collect: [:i | (supNames at: i) = (allInstVarNames at: i)])\n",
          "updateInheritanceTable:oldSelf:": "updateInheritanceTable: table oldSelf: oldSelf\n\t\"I have replaced an old behavior or class.  Update the given multiple inheritance table\"\n\ttable do:\n\t\t[:array | 1 to: array size do:\n\t\t\t[:i | (array at: i)==oldSelf ifTrue: [array at: i put: self]]]\n",
          "removeClass:selector:in:": "removeClass: aClass selector: selector in: aDictionary\n\t| list |\n\tlist _ (aDictionary at: selector) copyWithout: aClass.\n\tlist size = 0\n\t\tifTrue: [aDictionary removeKey: selector]\n\t\tifFalse: [aDictionary at: selector put: list]\n",
          "defaultSelectorForMethod:": "defaultSelectorForMethod: aMethod\n\t\"Given a method, invent an appropriate selector, that is, one that will parse with\n\tthe correct number of arguments.\"\n\n\t| aStream |\n\taStream _ WriteStream on: (String new: 16).\n\taStream nextPutAll: 'unboundMethod'.\n\t1 to: aMethod numArgs do: [:i | aStream nextPutAll: 'with:'].\n\t^aStream contents asSymbol\n",
          "checkMethodFor:": "checkMethodFor: selector\n\t\"copy method from superclass if necessary.  Answer true if no conflict detected\"\n\t| descr unmoved copyOK local copied conflict |\n\tlocal _ methodDict includesKey: selector.\n\tcopied _ (SelectorsOfCopiedMethods at: selector ifAbsent: [Array new]) includes: self.\n\tconflict _ (SelectorsOfConflictMethods at: selector ifAbsent: [Array new]) includes: self.\n\tlocal & copied not & conflict not\n\t\tifTrue: [^true].\n\tdescr _ self superMethodDescriptionAt: selector.\n\tdescr isMethodNotImplemented\n\t\tifTrue: [self removeSelectorUnchecked: selector.  ^true].\n\tdescr isConflictingMethods\n\t\tifTrue: [self compileConflictCodeFor: selector.  ^false].\n\n\tconflict ifTrue:  \"Not conflicting any more, so remove if it had been.\"\n\t\t[self removeSelectorUnchecked: selector.\n\t\tself removeClass: self selector: selector in: SelectorsOfConflictMethods].\n\n\t\"If this method isnt on the dynamic chain, copy it.\"\n\tdescr = (self dynamicMethodDescriptionAt: selector) ifFalse:\n\t\t[unmoved _ self unmovedVarsFrom: descr whichClass.\n\t\tcopyOK _ true.  \"If method doesnt touch any vars which moved\"\n\t\tdescr method fieldsTouched do:\n\t\t\t[:field | copyOK _ copyOK & (unmoved at: field)].\n\t\tcopyOK\n\t\t\tifTrue:  \"then can just install that same method\"\n\t\t\t\t[self addSelectorUnchecked: descr selector withMethod: descr method]\n\t\t\tifFalse:  \"otherwise have to recompile it here\"\n\t\t\t\t[self compileUnchecked: descr sourceCode].\n\t\tself insertClass: self selector: selector in: SelectorsOfCopiedMethods].\n\t^true\n",
          "printSubclassesOn:callingSuperclass:level:": "printSubclassesOn: aStream callingSuperclass: whichSuper level: level\n\t\"As part of the algorithm for printing a description of the receiver, print the\n\tsubclass on the file stream, aStream, indenting level times.\"\n\t| subs supers |\n\taStream crtab: level.\n\taStream nextPutAll: self name.\n\taStream space; print: self instVarNames.\n\tsupers _ self superclasses.\n\tsupers size>1 ifTrue:\n\t\t[aStream nextPutAll: '  [also a'.\n\t\t(supers copyWithout: whichSuper) do:\n\t\t\t[:s | aStream space; nextPutAll: s name; space; print: s allInstVarNames].\n\t\taStream nextPut: $]  ].\n\tsubs _ self subclasses.\n\tself == Class ifTrue:\n\t\t[aStream crtab: level+1; nextPutAll: '... all the Metaclasses ...'.\n\t\tsubs _ subs reject: [:sub | sub isMeta]].\n\t\"Print subclasses in alphabetical order\"\n\t(subs asSortedCollection: [:x :y | x name < y name]) do:\n\t\t[:sub |\n\t\tsub printSubclassesOn: aStream callingSuperclass: self level: level + 1]\n",
          "insertClass:selector:in:": "insertClass: aClass selector: selector in: aDictionary\n\t| previous |\n\tprevious _ aDictionary at: selector ifAbsent: [Array new].\n\t(previous includes: aClass) ifFalse:\n\t\t[aDictionary at: selector put: (previous copyWith: aClass)]\n",
          "flushCache": "flushCache\n\t\"Tell the interpreter to remove the contents of its method lookup cache, if it has\n\tone.  Essential.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 89>\n\tself primitiveFailed\n",
          "sourceTextAt:": "sourceTextAt: selector\n\t\"Answer with the string of the source code for the message selector.\"\n\n\t| newSource method |\n\tmethod _ methodDict at: selector.\n\tSensor leftShiftDown\n\t\tifTrue: [newSource _\n\t\t\t\t\tself decompilerClass new\n\t\t\t\t\t\tdecompile: selector\n\t\t\t\t\t\tin: self\n\t\t\t\t\t\tmethod: method]\n\t\tifFalse:\n\t\t\t[newSource _ method getSource.\n\t\t\tnewSource == nil\n\t\t\t\tifTrue: [newSource _\n\t\t\t\t\t\t\tself decompilerClass new\n\t\t\t\t\t\t\t\tdecompile: selector\n\t\t\t\t\t\t\t\tin: self\n\t\t\t\t\t\t\t\tmethod: method]].\n\t^newSource asText\n",
          "copyMethods": "copyMethods  \"copy all methods from superclasses not on the dynamic lookup chain\"\n\t| noConflicts |\n\tnoConflicts _ true.\n\tself allSelectors do:\n\t\t[:selector | noConflicts _ noConflicts & (self checkMethodFor: selector)].\n\tnoConflicts ifFalse:\n\t\t[Transcript cr; show: self name , ' has conflicting inherited methods\n  -- consult browser for their names']\n",
          "compoundSelectorsMatching:": "compoundSelectorsMatching: simple\n\t^ self selectors select:\n\t\t[:sel | sel isCompound and: [sel selectorPart = simple]]\n",
          "updateInheritanceTables:": "updateInheritanceTables: oldSelf\n\t\"I have replaced an old behavior or class.  Update the multiple inheritance tables\"\n\tself updateInheritanceTable: SelectorsOfConflictMethods oldSelf: oldSelf.\n\tself updateInheritanceTable: SelectorsOfCopiedMethods oldSelf: oldSelf.\n\tself updateInheritanceTable: SelectorsOfDirectedMethods oldSelf: oldSelf\n",
          "conflictCodeFor:": "conflictCodeFor: sel  \"return some code that indicates a conflicting definition\"\n\t| code parser |\n\tcode _ (self dynamicMethodDescriptionAt: sel) sourceCode.\n\t(parser _ self parserClass new) parseSelector: code.\n\t^ (code copyFrom: 1 to: (parser endOfLastToken min: code size)) ,\n\t\t(String with: Character cr) ,\n\t\t'\t^self conflictingInheritanceError'\n",
          "removeFromInheritanceTables": "removeFromInheritanceTables\n\t\"I have been deleted.  Remove me from multiple inheritance tables\"\n\tself removeFromInheritanceTable: SelectorsOfConflictMethods.\n\tself removeFromInheritanceTable: SelectorsOfCopiedMethods.\n\tself removeFromInheritanceTable: SelectorsOfDirectedMethods\n",
          "removeSelectorSimply:": "removeSelectorSimply: selector\n\t\"Remove the message selector from the receiver's method dictionary.\n\tInternal access from compiler.\"\n\n\tmethodDict removeKey: selector ifAbsent: [^self].\n\tself flushCache\n",
          "accumulateInstVarNames:traversedClasses:": "accumulateInstVarNames: names traversedClasses: classSet\n\t\"accumulate instance variable names in 'names'.  Do this in depth-first,\n\t  left-to-right order.  This will give the ordering of instance variable names\n\t  expected by the compiler and other parts of the system.\"\n\tself superclasses do:\n\t\t[:each | each accumulateInstVarNames: names traversedClasses: classSet].\n\t(classSet includes: self) ifFalse:\n\t\t[names addAll: self instVarNames.\n\t\tclassSet add: self]\n",
          "compileConflictCodeFor:": "compileConflictCodeFor: selector\n\t| classes |\n\tclasses _ SelectorsOfConflictMethods at: selector ifAbsent: [Array new].\n\t(classes includes: self name)  \"This class already has conflict code for this selector\"\n\t\tifTrue: [^self].\n\tself compile: (self conflictCodeFor: selector)\n\t\tclassified: 'conflicting inherited methods'\n\t\tnotifying: nil.\n\tself insertClass: self selector: selector in: SelectorsOfConflictMethods\n"
        },
        "initialize-release": {
          "obsolete": "obsolete\n\t\"Invalidate and recycle local messages.  Remove the receiver from its superclass'\n\tsubclass list.\"\n\n\tmethodDict _ MethodDictionary new.\n\tself superclasses do: [:each | each removeSubclass: self].\n\tself removeFromInheritanceTables\n"
        },
        "accessing class hierarchy": {
          "allDynamicSuperclasses": "allDynamicSuperclasses\n\t\"Answer an OrderedCollection of the receiver and the receiver's ancestor's\n\tdynamic superclasses;  ordered with immediate superclass first.\"\n\t| temp |\n\tsuperclass == nil\n\t\tifTrue: [^OrderedCollection new]\n\t\tifFalse: [temp _ superclass allDynamicSuperclasses.\n\t\t\t\ttemp addFirst: superclass.\n\t\t\t\t^temp]\n",
          "allSuperclassesInto:": "allSuperclassesInto: orderedCollection\n\t\"Add all my superclasses to orderedCollection if not already there.\n\t  Use breadth-first order.\"\n\t| mysupers |\n\tmysupers _ self superclasses.\n\tmysupers do: [:each | each allSuperclassesInto: orderedCollection].\n\tmysupers reverseDo:\n\t\t[:each | (orderedCollection includes: each) ifFalse: [orderedCollection addFirst: each]]\n",
          "superclasses": "superclasses\n\t\"Answer with an array of all the receiver's superclasses.\"\n\tsuperclass == nil ifTrue: [^#()].\n\tself hasMultipleSuperclasses\n\t\tifTrue: [^ (Array with: superclass) , self class otherSuperclasses].\n\t^ Array with: superclass\n",
          "hasMultipleSuperclasses": "hasMultipleSuperclasses\n\t^false\n",
          "allSuperclasses": "allSuperclasses\n\t\"Answer an OrderedCollection of the receiver's superclasses and the receiver's ancestor's\n\tsuperclasses in breadth-first order, with the immediate superclasses first.\"\n\t| coll |\n\tcoll _ OrderedCollection new.\n\tself allSuperclassesInto: coll.\n\t^coll\n",
          "withAllSubclasses": "withAllSubclasses\n\t\"Answer an OrderedCollection of subclasses including this class in breadth first order.\"\n\t| subs |\n\tsubs _ self allSubclasses.\n\tsubs addFirst: self.\n\t^subs\n",
          "dynamicSuperclass": "dynamicSuperclass\n\t\"Answer the receiver's superclass.  Only returns the first one - use 'superclasses'\n\t to find them all.\"\n\n\t^superclass\n",
          "allSubclasses": "allSubclasses\n\t\"Answer an OrderedCollection of the receiver's subclasses and the receiver's ancestor's\n\tsubclasses in breadth-first order, with the immediate subclasses first.\"\n\t| coll |\n\tcoll _ OrderedCollection new.\n\tcoll addAll: self subclasses.\n\tself subclasses do: [:eachSubclass | coll addAll: eachSubclass allSubclasses].\n\t^coll\n",
          "superclass": "superclass\n\t\"Answer the receiver's superclass.  Only returns the first one\n\t\t- use 'superclasses' to find them all.\"\n\t^superclass\n",
          "subclasses": "subclasses\n\t\"Answer the receiver's subclasses.  Return a copy so that callers who\n\tadd or delete subclasses won't get confused.\"\n\n\tsubclasses == nil\n\t\tifTrue: [^Set new]\n\t\tifFalse: [^subclasses copy]\n",
          "withAllSuperclasses": "withAllSuperclasses\n\t\"Answer an OrderedCollection of superclasses including this class in breadth first order.\"\n\t| subs |\n\tsubs _ self allSuperclasses.\n\tsubs addFirst: self.\n\t^subs\n"
        },
        "creating method dictionary": {
          "methodDictionary:": "methodDictionary: aDictionary\n\t\"Store the argument, aDictionary, as the method dictionary of the receiver.\"\n\n\tmethodDict _ aDictionary\n",
          "removeSelectorUnchecked:": "removeSelectorUnchecked: selector\n\t\"Assuming that the message selector is in the receiver's method dictionary,\n\tremove it.  If the selector is not in the method dictionary, create an error\n\tnotification.  Do not check for effect on (multiple) inheritance.\"\n\n\tmethodDict removeKey: selector.\n\tself flushCache\n",
          "addSelector:withMethod:": "addSelector: selector withMethod: compiledMethod\n\t\"Add the message selector with the corresponding compiled method to the receiver's\n\tmethod dictionary.\"\n\t| wasThere |\n\twasThere _ methodDict includesKey: selector.\n\tmethodDict at: selector put: compiledMethod.\n\tself flushCache.\n\t\"if the selector is indexed in SelectorsOfConflictMethods or SelectorsOfCopiedMethods,\n\t remove it\"\n\t((SelectorsOfConflictMethods at: selector ifAbsent: [Array new]) includes: self)\n\t\tifTrue: [self removeClass: self selector: selector in: SelectorsOfConflictMethods].\n\t((SelectorsOfCopiedMethods at: selector ifAbsent: [Array new]) includes: self)\n\t\tifTrue: [self removeClass: self selector: selector in: SelectorsOfCopiedMethods].\n\twasThere\n\t\tifTrue: [self checkChangeSelector: selector]\n\t\tifFalse: [self subclasses do:\n\t\t\t[:sub | sub checkSuperAddSelector: selector]]\n",
          "tryCopyingCodeFor:": "tryCopyingCodeFor: selector\n\t\"Check if 'selector' is compound, and if so, try to copy down the appropriate code.\n\t  Return #OK if sucessful,\n\t\t#HierarchyViolation if the class part is not one of my immediate superclasses,\n\t\tor #NotFound if the class part is OK but the\n\t\tselector part is not found in the inheritance hierarchy.\"\n\t| classPart whichClass simpleSelector descr |\n\tselector isCompound ifFalse: [^#NotFound].\n\tclassPart _ selector classPart.\n\tsimpleSelector _ selector selectorPart.\n\t\"check for special class parts\"\n\tclassPart==#all ifTrue:\n\t\t[self compileBroadcastCodeFor: simpleSelector.\n\t\tself insertClass: self selector: simpleSelector in: SelectorsOfDirectedMethods.\n\t\t^#OK].\n\tclassPart==#super\n\t\tifTrue: [descr _ self superMethodDescriptionAt: simpleSelector]\n\t\tifFalse: [whichClass _ Smalltalk at: classPart.\n\t\t\t\t\"if I'm a metaclass, get the metaclass of whichClass\"\n\t\t\t\tself isMeta ifTrue: [whichClass _ whichClass class].\n\t\t\t\t\"check that whichClass is one of my superclasses\"\n\t\t\t\t(self inheritsFrom: whichClass) ifFalse: [^#HierarchyViolation].\n\t\t\t\tdescr _ whichClass methodDescriptionAt: simpleSelector].\n\tdescr isBad ifTrue: [^#NotFound].\n\tself compileUnchecked: classPart , '.' , descr sourceCode.\n\tself insertClass: self selector: simpleSelector in: SelectorsOfDirectedMethods.\n\t^#OK\n",
          "removeSelector:": "removeSelector: selector\n\t\"Assuming that the message selector is in the receiver's method dictionary,\n\tremove it.  If the selector is not in the method dictionary, create an error\n\tnotification.\"\n\n\tmethodDict removeKey: selector.\n\tself flushCache.\n\tself checkChangeSelector: selector\n",
          "addSelectorUnchecked:withMethod:": "addSelectorUnchecked: selector withMethod: compiledMethod\n\t\"Add the message selector with the corresponding compiled method to the receiver's\n\tmethod dictionary.  Do not check for effect on (multiple) inheritance.\"\n\n\tmethodDict at: selector put: compiledMethod.\n\tself flushCache\n"
        },
        "enumerating": {
          "browseAllCallsOn:": "browseAllCallsOn: aSymbol\n\t\"Create and schedule a message browser on each method that calls on aSymbol.\n\tFor example,\n\t\tNumber browseAllCallsOn: #/.\t\"\n\n\t| label key |\n\t(aSymbol isMemberOf: Association)\n\t\tifTrue: [key _ aSymbol key. \tlabel _ 'Users of ' , key]\n\t\tifFalse: [key _ aSymbol. \t\tlabel _ 'Senders of ', key].\n\n\t^ BrowserView\n\t\topenListBrowserOn: (self allCallsOn: aSymbol)\n\t\tlabel: label, ' from ', self name\n\t\tinitialSelection: key asSymbol keywords first\n",
          "crossReference": "crossReference\n\t\"Answer an array of arrays of size 2 whose first element is a message selector\n\tin the receiver's method dictionary and whose second element is a set of all message\n\tselectors in the method dictionary whose methods send a message with that selector.\n\tSubclasses are not included.\"\n\n\t^self selectors asSortedCollection asArray collect:\n\t\t[:x |\n\t\tArray\n\t\t\twith: (String with: Character cr), x\n\t\t\twith: (self whichSelectorsReferTo: x)]\n\n\t\"Point crossReference.\"\n",
          "allSubclassesDo:": "allSubclassesDo: aBlock\n\t\"Evaluate the argument, aBlock, for each of the receiver's subclasses.\"\n\n\tself subclasses do:\n\t\t[:cl |\n\t\taBlock value: cl.\n\t\tcl allSubclassesDo: aBlock]\n",
          "allInstancesDo:": "allInstancesDo: aBlock\n\t\"Evaluate the argument, aBlock, for each of the current instances of the receiver.\"\n\n\t| inst next |\n\tinst _ self someInstance.\n\tinst == nil\n\t\tifFalse:\n\t\t\t[[next _ inst nextInstance.\n\t\t\taBlock value: inst.\n\t\t\tnext == nil]\n\t\t\t\twhileFalse: [inst _ next]].\n\tnil class == self ifTrue: [aBlock value: nil]\n",
          "browseAllAccessesTo:": "browseAllAccessesTo: instanceVariable\n\t\"Create and schedule a Message Set browser for all the receiver's methods or any methods of a subclass that refer to the instance variable name.  If the instance variable name is not defined for the receiver, the notification 'Nobody' occurs in the System Transcript.\"\n\n\tBrowserView\n\t\t\topenListBrowserOn: (self allAccessesTo: instanceVariable)\n\t\t\tlabel: instanceVariable\n\t\t\tinitialSelection: instanceVariable\n",
          "showVariableMenu:collect:": "showVariableMenu: generatorBlock collect: valueBlock\n\t\"Construct a menu of variable names supplied by the generatorBlock,\n\twith lines between classes in the superclass chain.  Show the menu,\n\treturning the variable chosen by the user, or nil if no\n\tvariable was chosen.\"\n\n\t| eachClass aStream lines count lastLine variables index |\n\taStream _ WriteStream on: (String new: 200).\n\tlines _ OrderedCollection new.\n\tcount _ 0.\n\tlastLine _ 0.\n\tvariables _ OrderedCollection new.\n\tself withAllSuperclasses reverseDo:\n\t\t[:eachClass |\n\t\tcount = lastLine ifFalse: [lines add: count.  lastLine _ count].\n\t\t(generatorBlock value: eachClass) do:\n\t\t\t[:var |\n\t\t\taStream nextPutAll: ((valueBlock value: var) contractTo: 20); cr.\n\t\t\tvariables addLast: var.\n\t\t\tcount _ count + 1]].\n\tvariables isEmpty ifTrue: [^nil].  \"Nothing to choose from\"\n\taStream skip: -1.\n\tindex _ (PopUpMenu labels: aStream contents lines: lines) startUp.\n\t^index = 0\n\t\tifTrue: [nil]\n\t\tifFalse: [variables at: index]\n",
          "allAccessesTo:": "allAccessesTo: instVarName\n\t\"Return a list of all methods in my hierarchy that refer to the named instance variable.\"\n\t| coll |\n\tcoll _ OrderedCollection new.\n\tCursor execute\n\t\tshowWhile:\n\t\t\t[(self withAllSuperclasses reverse) , self allSubclasses do:\n\t\t\t\t[:class |\n\t\t\t\t(class whichSelectorsAccess: instVarName) do:\n\t\t\t\t\t[:sel | sel ~~ #DoIt ifTrue: [coll add: class name , ' ' , sel]]]].\n\t^coll\n\t\"Collection allAccessesTo: 'contents'.\"\n",
          "allSubInstancesDo:": "allSubInstancesDo: aBlock\n\t\"Evaluate the argument, aBlock, for each of the current instances of the receiver's\n\tsubclasses.\"\n\n\tself allSubclassesDo: [:sub | sub allInstancesDo: aBlock]\n",
          "allCallsOn:": "allCallsOn: aLiteral\n\t\"Answer a SortedCollection of all the methods that call on aLiteral.\"\n\n\t| aSortedCollection special |\n\taSortedCollection _ SortedCollection new.\n\tspecial _ Smalltalk hasSpecialSelector: aLiteral ifTrueSetByte: [:byte ].\n\t(self withAllSuperclasses reverse) , self allSubclasses do:\n\t\t[:class |\n\t\t(class whichSelectorsReferTo: aLiteral special: special byte: byte) do:\n\t\t\t[:sel | sel ~~ #DoIt ifTrue: [aSortedCollection add: class name , ' ' , sel]].\n\t\t(class class whichSelectorsReferTo: aLiteral special: special byte: byte) do:\n\t\t\t[:sel | sel ~~ #DoIt ifTrue: [aSortedCollection add: class class name , ' ' , sel]].\n\t\t].\n\t^aSortedCollection\n"
        },
        "testing method dictionary": {
          "hasMethods": "hasMethods\n\t\"Answer whether the receiver has any methods in its method dictionary.\"\n\n\t^methodDict size > 0\n",
          "whichSelectorsReferTo:": "whichSelectorsReferTo: literal\n\t\"Answer a set of selectors whose methods access the argument as a literal.\"\n\n\t| special |\n\tspecial _ Smalltalk hasSpecialSelector: literal ifTrueSetByte: [:byte ].\n\t^self whichSelectorsReferTo: literal special: special byte: byte\n\n\t\"Rectangle whichSelectorsReferTo: #+.\"\n",
          "canUnderstand:": "canUnderstand: selector\n\t\"Answer true if the receiver can respond to the message whose selector\n\tis the argument, false otherwise.  The selector can be in the method dictionary\n\tof the receiver's class or any of its superclasses.\"\n\n\t(self includesSelector: selector) ifTrue: [^true].\n\tsuperclass == nil ifTrue: [^false].\n\t^superclass canUnderstand: selector\n",
          "includesSelector:": "includesSelector: aSymbol\n\t\"Answer whether the message whose selector is the argument is in the\n\tmethod dictionary of the receiver's class.\"\n\n\t^methodDict includesKey: aSymbol\n",
          "scopeHas:ifTrue:": "scopeHas: varName ifTrue: assocBlock\n\t\"Look up varName in this class, its superclasses, and Smalltalk.  If it is there,\n\tpass the association to assocBlock, and answer true; else answer false.\"\n\t| assoc |\n\tself withAllSuperclasses do:\n\t\t[:sup |\n\t\t(sup poolHas: varName ifTrue: assocBlock) ifTrue: [^true]].\n\tassoc _ Smalltalk associationAt: varName ifAbsent: [].\n\tassoc == nil\n\t\tifFalse:\n\t\t\t[assocBlock value: assoc.\n\t\t\t^true].\n\t^false\n",
          "whichSelectorsReferTo:special:byte:": "whichSelectorsReferTo: literal special: specialFlag byte: specialByte\n\t\"Answer a collection of selectors whose methods access the argument as a literal.\"\n\n\t| who method methodArray index arraySize |\n\twho_ OrderedCollection new.\n\tmethodArray _ methodDict methodArray.\n\tarraySize _ methodArray size.\n\tindex _ 0.\n\t[(index _ index + 1) <= arraySize] whileTrue:\n\t\t[(method _ methodArray at: index) == nil ifFalse:\n\t\t\t[((method refersToLiteral: literal) or:\n\t\t\t\t[specialFlag and: [method scanFor: specialByte]])\n\t\t\t\t\tifTrue: [who add: (methodDict basicAt: index)]]].\n\t^who\n\n\t\"Rectangle whichSelectorsReferTo: #+.\"\n",
          "whichClassIncludesSelector:": "whichClassIncludesSelector: aSymbol\n\t\"Answer the class on the receiver's superclass chain where the argument, aSymbol\n\t(a message selector), will be found.\"\n\n\t(methodDict includesKey: aSymbol) ifTrue: [^self].\n\tsuperclass == nil ifTrue: [^nil].\n\t^superclass whichClassIncludesSelector: aSymbol\n\n\t\"Rectangle whichClassIncludesSelector: #inspect.\"\n",
          "whichSelectorsAccess:": "whichSelectorsAccess: instVarName\n\t\"Answer a set of selectors whose methods access the argument, instVarName,\n\tas a named instance variable.\"\n\n\t| instVarIndex |\n\tinstVarIndex _ self allInstVarNames indexOf: instVarName ifAbsent: [^Set new].\n\t^methodDict keys select:\n\t\t[:sel |\n\t\t((methodDict at: sel)\n\t\t\treadsField: instVarIndex)\n\t\t\tor: [(methodDict at: sel) writesField: instVarIndex]]\n\n\t\"Point whichSelectorsAccess: 'x'.\"\n"
        },
        "testing class hierarchy": {
          "kindOfSubclass": "kindOfSubclass\n\t\"Answer a string which is the keyword that describes the receiver's kind of\n\tsubclass, either a regular subclass, a variableSubclass, a variableByteSubclass, or\n\ta variableWordSubclass.\"\n\n\tself isVariable\n\t\tifTrue: [self isBits\n\t\t\t\t\tifTrue: [self isBytes\n\t\t\t\t\t\t\t\tifTrue: [^' variableByteSubclass: ']\n\t\t\t\t\t\t\t\tifFalse: [^' variableWordSubclass: ']]\n\t\t\t\t\tifFalse: [^' variableSubclass: ']]\n\t\tifFalse: [^' subclass: ']\n",
          "inheritsFrom:": "inheritsFrom: aClass\n\t\"Answer whether the argument, aClass, is on the receiver's superclass chain.\"\n\tself superclasses do:\n\t\t[:each | (each==aClass or: [each inheritsFrom: aClass]) ifTrue: [^true]].\n\t^false\n"
        }
      }
    },
    "MetaclassForMultipleInheritance": {
      "comment": "This metaclass has an additional field and protocol to support multiple inheritance.\nThe field, otherSupers, contains a collection of additional superclasses (other than the normal dynamic one) from which traits are to be inherited.  Since the otherSupers appears in the metaclass, classes must ask their metas for other supers (sort of the way metas ask their thisClasses for subs).\n\nIt would have been more natural to put otherSupers into a class ClassWithMultSupers, but this would have had to inherit both the multiple supers AND the normal metaclass\ninheritance, thus posing a bootstrapping need for multiple inheritance.\n",
      "class_name": "MetaclassForMultipleInheritance",
      "superclass": "Metaclass",
      "instanceVariables": "otherSuperclasses",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "superclass access": {
          "subclassOf:and:": "subclassOf: sup and: others\n\t| newMeta |\n\tnewMeta _ super subclassOf: sup.\n\tnewMeta setOtherSuperclasses: others.\n\t^newMeta\n"
        }
      },
      "instance_methods": {
        "class hierarchy": {
          "otherSuperclasses": "otherSuperclasses\n\t^ otherSuperclasses\n",
          "superclasses": "superclasses\n\t^ (Array with: superclass) , (otherSuperclasses collect: [:sup | sup class])\n",
          "instHasMultipleSuperclasses": "instHasMultipleSuperclasses\n\t^true\n",
          "setOtherSuperclasses:": "setOtherSuperclasses: others\n\totherSuperclasses _ others\n"
        }
      }
    },
    "ClassDescription": {
      "comment": "Instance Variables:\n\t\tinstanceVariables\t<Array> names of instance fields\n\t\torganization\t\t<ClassOrganizer> provides organization of message protocol\n\nClassDescription adds a number of facilities to basic Behavior:\n\t\t- named instance variables\n\t\t- category organization for methods\n\t\t- the notion of a name of this class (implemented as subclass responsibility)\n\t\t- the maintenance of the Changes set, and logging changes on a file\n\t\t- most of the mechanism for fileOut\nClassDescription is an abstract class: its facilities are intended for inheritance by the two subclasses, Class and Metaclass.\n",
      "class_name": "ClassDescription",
      "superclass": "Behavior",
      "instanceVariables": "instanceVariables organization",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "organization": {
          "logOrganizationChange": "logOrganizationChange\n\t\"Record that the receiver is being reorganized on the changes file.\"\n\t| file |\n\tSourceFiles == nil\n\t\tifFalse:\n\t\t\t[file _ SourceFiles at: 2.\n\t\t\tfile setToEnd; readWriteShorten.\n\t\t\tfile cr; nextChunkPut:\n\t\t\t\tself name, ' organization changeFromString: ',\n\t\t\t\t\tself organization printString storeString.\n\t\t\tfile cr; readOnly]\n",
          "category:": "category: cat\n\t\"Categorize the receiver under the system category, cat, removing it from any\n\tprevious categorization.\"\n\n\t(cat isKindOf: String)\n\t\tifTrue: [SystemOrganization classify: self name under: cat asSymbol]\n\t\tifFalse: [self errorCategoryName]\n",
          "reorganize": "reorganize\n\t\"Record that the receiver is being reorganized and answer the receiver's organization.\"\n\n\tSmalltalk changes reorganizeClass: self.\n\t^self organization\n",
          "whichCategoryIncludesSelector:": "whichCategoryIncludesSelector: aSelector\n\t\"Answer the category of the argument, aSelector, in the organization of the\n\treceiver, or answer nil if the receiver does not inlcude this selector.\"\n\n\t(self includesSelector: aSelector)\n\t\tifTrue: [^organization categoryOfElement: aSelector]\n\t\tifFalse: [^nil]\n",
          "category": "category\n\t\"Answer the system organization category for the receiver.\"\n\n\t^SystemOrganization categoryOfElement: self name\n",
          "organization": "organization\n\t\"Answer the instance of ClassOrganizer that represents the organization\n\tof the messages of the receiver.\"\n\torganization==nil\n\t\tifTrue: [organization _ ClassOrganizer new].\n\t^organization\n"
        },
        "compiling": {
          "compile:classified:notifying:": "compile: code classified: heading notifying: requestor\n\t\"Compile the argument, code, as source code in the context of the receiver and\n\tinstall the result in the receiver's method dictionary under the classification\n\tindicated by the second argument, heading  The third argument,\n\trequestor, is to be notified if an error occurs. The argument code is either a string or\n\tan object that converts to a string or a PositionableStream on an object that converts\n\tto a string.\"\n\n\t| selector |\n\tselector _\n\t\tself compile: code\n\t\t\tnotifying: requestor\n\t\t\ttrailer: #(0 0 0 )\n\t\t\tifFail: [^nil].\n\t(methodDict at: selector)\n\t\tputSource: code asString\n\t\tclass: self\n\t\tcategory: heading\n\t\tinFile: 2.\n\tself organization classify: selector under: heading.\n\t^selector\n",
          "compile:classified:": "compile: code classified: heading\n\t\"Compile the argument, code, as source code in the context of the receiver and\n\tinstall the result in the receiver's method dictionary under the classification\n\tindicated by the second argument, heading. nil is to be notified if an error occurs.\n\tThe argument code is either a string or an object that converts to a string or a\n\tPositionableStream on an object that converts to a string.\"\n\n\t^self\n\t\tcompile: code\n\t\tclassified: heading\n\t\tnotifying: nil\n",
          "compile:notifying:trailer:ifFail:": "compile: code notifying: requestor trailer: bytes ifFail: failBlock\n\t\"Intercept this message in order to remember system changes.\"\n\n\t| methodNode selector |\n\tCursor execute showWhile:\n\t\t[methodNode _\n\t\t\t \tself compilerClass new\n\t\t\t\t\tcompile: code\n\t\t\t\t\tin: self\n\t\t\t\t\tnotifying: requestor\n\t\t\t\t\tifFail: failBlock.\n\tselector _ methodNode selector.\n\t(methodDict includesKey: selector)\n\t\tifTrue: [Smalltalk changes changeSelector: selector class: self]\n\t\tifFalse: [Smalltalk changes addSelector: selector class: self].\n\tself addSelector: selector withMethod: (methodNode generate: bytes)].\n\t^selector\n"
        },
        "instance variables": {
          "instVarNames": "instVarNames\n\t\"Answer an Array of the names of instance variables defined in the receiver.\"\n\n\tinstanceVariables == nil\n\t\tifTrue: [^#()]\n\t\tifFalse: [^instanceVariables]\n",
          "removeInstVarName:": "removeInstVarName: aString\n\t\"Remove the argument, aString, as one of the receiver's instance variables.\"\n\n\tself subclassResponsibility\n",
          "addInstVarName:": "addInstVarName: aString\n\t\"Add the argument, aString, as one of the receiver's instance variables.\"\n\n\tself subclassResponsibility\n"
        },
        "fileIn/Out": {
          "fileOutMessage:fileName:": "fileOutMessage: aString fileName: fileName\n\t\"Create a local file named fileName\n\tand file a description of the receiver's message aString onto it\"\n\n\t| fileStream |\n\tfileStream _ Disk file: fileName.\n\tfileStream timeStamp.\n\tself fileOutMessage: aString\n\t\ton: fileStream\n\t\tmoveSource: false\n\t\ttoFile: 0.\n\tfileStream close\n",
          "fileOutMessage:on:moveSource:toFile:": "fileOutMessage: aString on: aFileStream moveSource: moveSource toFile: fileIndex\n\t\"File a description of the receiver's message, aString, onto aFileStream.  If\n\tthe boolean argument, moveSource, is true, then set the trailing bytes to the position\n\tof aFileStream and to fileIndex in order to indicate where to find the source code.\"\n\n\t| cat |\n\tcat _ self organization categoryOfElement: aString.\n\tcat == nil ifTrue: [^self error: 'no such message'].\n\tself printCategoryChunk: cat on: aFileStream.\n\tself\n\t\tprintMethodChunk: aString\n\t\ton: aFileStream\n\t\tmoveSource: moveSource\n\t\ttoFile: fileIndex.\n\taFileStream nextChunkPut: ' '\n",
          "methodsFor:": "methodsFor: aString\n\t\"Answer a ClassCategoryReader for accessing the messages in the method\n\tdictionary category, aString, of the receiver.\"\n\n\t^ClassCategoryReader class: self category: aString asSymbol\n\t\"False methodsFor: 'logical operations' inspect\"\n",
          "fileOutCategory:on:moveSource:toFile:": "fileOutCategory: aString on: aFileStream moveSource: moveSource toFile: fileIndex\n\t\"File a description of the receiver's category, aString, onto aFileStream.  If\n\tthe boolean argument, moveSource, is true, then set the trailing bytes to the position\n\tof aFileStream and to fileIndex in order to indicate where to find the source code.\"\n\n\tself printCategoryChunk: aString on: aFileStream.\n\t(self organization listAtCategoryNamed: aString)\n\t\tdo: [:sel | self\n\t\t\t\tprintMethodChunk: sel\n\t\t\t\ton: aFileStream\n\t\t\t\tmoveSource: moveSource\n\t\t\t\ttoFile: fileIndex].\n\taFileStream nextChunkPut: ' '\n",
          "fileOutOrganizationOn:": "fileOutOrganizationOn: aFileStream\n\t\"File a description of the receiver's organization onto aFileStream.\"\n\n\taFileStream emphasis: 3.\n\taFileStream cr; nextPut: $!.\n\taFileStream nextChunkPut: self name, ' reorganize'; cr.\n\taFileStream nextChunkPut: self organization printString; cr.\n\taFileStream emphasis: 1\n",
          "printOutCategory:": "printOutCategory: aString\n\t\"Create a readable version of the message category aString, and send to a printer.\n\tDefaults to fileOut.\"\n\tself fileOutCategory: aString\n",
          "kindOfSubclass": "kindOfSubclass\n\t\"Answer a string that describes what kind of subclass the receiver is, i.e.,\n\tvariable, variable byte, variable word, or not variable.\"\n\n\tself isVariable\n\t\tifTrue: [self isBits\n\t\t\t\t\tifTrue: [self isBytes\n\t\t\t\t\t\t\t\tifTrue: [^' variableByteSubclass: ']\n\t\t\t\t\t\t\t\tifFalse: [^' variableWordSubclass: ']]\n\t\t\t\t\tifFalse: [^' variableSubclass: ']]\n\t\tifFalse: [^' subclass: ']\n",
          "fileOutChangedMessages:on:moveSource:toFile:": "fileOutChangedMessages: aSet on: aFileStream moveSource: moveSource toFile: fileIndex\n\t\"File a description of the messages of the receiver that have been changed\n\t(i.e., are entered into the system ChangeSet) onto aFileStream.  If\n\tthe boolean argument, moveSource, is true, then set the trailing bytes to the position\n\tof aFileStream and to fileIndex in order to indicate where to find the source code.\"\n\n\t| org sels |\n\t(org _ self organization) categories do:\n\t\t[:cat |\n\t\tsels _ (org listAtCategoryNamed: cat) select: [:sel | aSet includes: sel].\n\t\tsels size > 0\n\t\t\tifTrue:\n\t\t\t\t[Transcript cr; show: self name , '>' , cat.\n\t\t\t\tself printCategoryChunk: cat on: aFileStream.\n\t\t\t\tsels do: [:sel |\n\t\t\t\t\t\tself\n\t\t\t\t\t\t\tprintMethodChunk: sel\n\t\t\t\t\t\t\ton: aFileStream\n\t\t\t\t\t\t\tmoveSource: moveSource\n\t\t\t\t\t\t\ttoFile: fileIndex].\n\t\t\t\taFileStream nextChunkPut: ' ']]\n",
          "printMethodChunk:on:moveSource:toFile:": "printMethodChunk: aSelector on: aFileStream moveSource: moveSource toFile: fileIndex\n\t\"Print the source code for the method associated with the argument\n\tselector onto\n\tthe fileStream. aFileStream, and, for backup, if the argument\n\tmoveSource (a Boolean)\n\tis true, also set the file index within the method to be the argument\n\tfileIndex. \"\n\n\t| position |\n\taFileStream cr.\n\tCursor write showWhile:\n\t\t[moveSource\n\t\t\tifTrue:\n\t\t\t\t[position _ aFileStream position.\n\t\t\t\taFileStream nextChunkPut: (self sourceCodeAt: aSelector).\n\t\t\t\t(self compiledMethodAt: aSelector)\n\t\t\t\t\tsetSourcePosition: position inFile: fileIndex]\n\t\t\tifFalse: [aFileStream cr; nextChunkPut: (self sourceCodeAt: aSelector)]]\n",
          "fileOutMessage:": "fileOutMessage: aString\n\t\"Create a fileName which is the name of the receiver with -.st as the\n\textension, and file a description of the receiver's message aString onto it\"\n\n\tself fileOutMessage: aString\n\t\tfileName: (Disk checkName: self name , '-' , aString , '.st' fixErrors: true)\n",
          "printOutMessage:": "printOutMessage: aString\n\t\"Create a readable version of the message with selector aString, and send to a printer.\n\tDefaults to fileOut.\"\n\tself fileOutMessage: aString\n",
          "fileOutOn:": "fileOutOn: aFileStream\n\t\"File a description of the receiver on aFileStream.\"\n\n\tself fileOutOn: aFileStream\n\t\tmoveSource: false\n\t\ttoFile: 0\n",
          "fileOutCategory:": "fileOutCategory: aString\n\t\"Create a file whose name is the name of the receiver with -.st- as the\n\textension, and file a description of the receiver's category aString onto it\"\n\n\t| fileName fileStream |\n\tfileName _ Disk checkName: self name , '-' , aString , '.st' fixErrors: true.\n\tfileStream _ Disk file: fileName.\n\tfileStream timeStamp.\n\tself fileOutCategory: aString\n\t\ton: fileStream\n\t\tmoveSource: false\n\t\ttoFile: 0.\n\tfileStream shorten; close\n",
          "moveChangesTo:": "moveChangesTo: newFile\n\t\"Used in the process of condensing changes, this message requests that the source\n\tcode of all methods of the receiver that have been changed should be moved to\n\tnewFile.\"\n\n\t| changes |\n\tself organization moveChangedCommentToFile: newFile numbered: 2.\n\tchanges _ methodDict keys select: [:sel | (methodDict at: sel) fileIndex > 1].\n\tself fileOutChangedMessages: changes\n\t\ton: newFile\n\t\tmoveSource: true\n\t\ttoFile: 2\n",
          "fileOutChangedMessages:on:": "fileOutChangedMessages: aSet on: aFileStream\n\t\"File a description of the messages of the receiver that have been changed\n\t(i.e., are entered into the system ChangeSet) onto aFileStream.\"\n\n\tself fileOutChangedMessages: aSet\n\t\ton: aFileStream\n\t\tmoveSource: false\n\t\ttoFile: 0\n",
          "printCategoryChunk:on:": "printCategoryChunk: aString on: aFileStream\n\t\"print category definition on aFileStream\"\n\n\taFileStream cr; cr; nextPut: $!.\n\taFileStream nextChunkPut:\n\t\t\t\tself name , ' methodsFor: ' , '''' , aString , ''''\n",
          "fileOutOn:moveSource:toFile:": "fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex\n\t\"file me out on aFileStream\"\n\taFileStream emphasis: 5.\t\t\"Meant to be 12 point bold font.\"\n\taFileStream nextChunkPut: self definition.\n\tself organization\n\t\tputCommentOnFile: aFileStream\n\t\tnumbered: fileIndex\n\t\tmoveSource: moveSource.\n\taFileStream cr.\n\tself organization categories do:\n\t\t[:heading |\n\t\tself\n\t\t\tfileOutCategory: heading\n\t\t\ton: aFileStream\n\t\t\tmoveSource: moveSource\n\t\t\ttoFile: fileIndex]\n"
        },
        "printing": {
          "superclassesString": "superclassesString\n\t\"Answer a string of my superclass names separated by spaces.\"\n\t| aStream names |\n\taStream _ WriteStream on: (String new: 100).\n\tself superclasses do: [:each | aStream nextPutAll: each name; space].\n\t^ aStream contents\n",
          "definition": "definition\n\t\"Answer a string that defines the receiver.\"\n\t| aStream |\n\taStream _ WriteStream on: (String new: 300).\n\tself hasMultipleSuperclasses\n\t\tifTrue:\n\t\t\t[aStream nextPutAll: 'Class named: '.\n\t\t\tself name storeOn: aStream.\n\t\t\taStream cr; tab; nextPutAll: 'superclasses: '.\n\t\t\taStream store: self superclassesString.\n\t\t\taStream cr; tab; nextPutAll: 'instanceVariableNames: '.\n\t\t\taStream store: self instanceVariablesString.\n\t\t\taStream cr; tab; nextPutAll: 'classVariableNames: '.\n\t\t\taStream store: self classVariablesString]\n\t\tifFalse:\n\t\t\t[aStream nextPutAll: (superclass == nil ifTrue: ['nil'] ifFalse: [superclass name]).\n\t\t\taStream nextPutAll: self kindOfSubclass.\n\t\t\tself name storeOn: aStream.\n\t\t\taStream cr; tab; nextPutAll: 'instanceVariableNames: '.\n\t\t\taStream store: self instanceVariablesString.\n\t\t\taStream cr; tab; nextPutAll: 'classVariableNames: '.\n\t\t\taStream store: self classVariablesString.\n\t\t\taStream cr; tab; nextPutAll: 'poolDictionaries: '.\n\t\t\taStream store: self sharedPoolsString].\n\taStream cr; tab; nextPutAll: 'category: '.\n\t(SystemOrganization categoryOfElement: self name) asString storeOn: aStream.\n\t^aStream contents\n",
          "sharedPoolsString": "sharedPoolsString\n\t\"Answer a string of my class variable names separated by spaces.\"\n\t| aStream |\n\taStream _ WriteStream on: (String new: 100).\n\tself sharedPools do: [:x | aStream nextPutAll: (Smalltalk keyAtValue: x); space].\n\t^ aStream contents\n",
          "printOn:": "printOn: aStream\n\taStream nextPutAll: self name\n",
          "storeOn:": "storeOn: aStream\n\t\"Clases and Metaclasses have global names.\"\n\taStream nextPutAll: self name\n",
          "instanceVariablesString": "instanceVariablesString\n\t\"Answer a string of my instance variable names separated by spaces.\"\n\t| aStream names |\n\taStream _ WriteStream on: (String new: 100).\n\tnames _ self instVarNames.\n\t1 to: names size do: [:i | aStream nextPutAll: (names at: i); space].\n\t^ aStream contents\n",
          "classVariablesString": "classVariablesString\n\t\"Answer a string of my class variable names separated by spaces, in alphabetical order.\"\n\t| aStream |\n\taStream _ WriteStream on: (String new: 100).\n\tself classPool keys asSortedCollection do: [:key | aStream nextPutAll: key; space].\n\t^ aStream contents\n"
        },
        "testing": {
          "isMeta": "isMeta\n\t^ false\n"
        },
        "copying": {
          "copy:from:classified:": "copy: sel from: class classified: cat\n\t\"Install the method associated with the first arugment, sel, a message selector,\n\tfound in the method dictionary of the second argument, class, as one of the\n\treceiver's methods.  Classify the message under the third argument, cat.\"\n\n\t| code category |\n\t\"Useful when modifying an existing class\"\n\tcode _ class sourceMethodAt: sel.\n\tcode == nil\n\t\tifFalse:\n\t\t\t[cat == nil\n\t\t\t\tifTrue: [category _ class organization categoryOfElement: sel]\n\t\t\t\tifFalse: [category _ cat].\n\t\t\t(methodDict includesKey: sel)\n\t\t\t\tifTrue: [code asString = (self sourceMethodAt: sel) asString\n\t\t\t\t\t\t\tifFalse: [self error: self name\n\t\t\t\t\t\t\t\t\t\t, ' '\n\t\t\t\t\t\t\t\t\t\t, sel\n\t\t\t\t\t\t\t\t\t\t, ' will be redefined if you proceed.']].\n\t\t\tself compile: code classified: category]\n",
          "copyCategory:from:": "copyCategory: cat from: class\n\t\"Specify that one of the categories of messages for the receiver is cat, as found\n\tin the class, aClass.  Copy each message found in this category.\"\n\n\tself copyCategory: cat\n\t\tfrom: class\n\t\tclassified: cat\n",
          "copyAll:from:classified:": "copyAll: selArray from: class classified: cat\n\t\"Install all the methods found in the method dictionary of the second argument, class,\n\tas the receiver's methods.  Classify the messages under the third argument, cat.\"\n\n\tselArray do:\n\t\t[:s | self copy: s\n\t\t\t\tfrom: class\n\t\t\t\tclassified: cat]\n",
          "copyAllCategoriesFrom:": "copyAllCategoriesFrom: aClass\n\t\"Specify that the categories of messages for the receiver include all of those found\n\tin the class, aClass.  Install each of the messages found in these categories into the\n\tmethod dictionary of the receiver, classified under the appropriate categories.\"\n\n\taClass organization categories do: [:cat | self copyCategory: cat from: aClass]\n",
          "copyAll:from:": "copyAll: selArray from: class\n\t\"Install all the methods found in the method dictionary of the second argument, class,\n\tas the receiver's methods.  Classify the messages under -as yet not classified-\"\n\n\tself copyAll: selArray\n\t\tfrom: class\n\t\tclassified: nil\n",
          "copy:from:": "copy: sel from: class\n\t\"Install the method associated with the first arugment, sel, a message selector,\n\tfound in the method dictionary of the second argument, class, as one of the\n\treceiver's methods.  Classify the message under -as yet not classified-\"\n\n\tself copy: sel\n\t\tfrom: class\n\t\tclassified: nil\n",
          "copyCategory:from:classified:": "copyCategory: cat from: aClass classified: newCat\n\t\"Specify that one of the categories of messages for the receiver is the third argument,\n\tnewCat.  Copy each message found in the category cat in class aClass into this\n\tnew category.\"\n\n\tself copyAll: (aClass organization listAtCategoryNamed: cat)\n\t\tfrom: aClass\n\t\tclassified: newCat\n"
        },
        "accessing": {
          "commentTemplate": "commentTemplate\n\t\"Answer an expression to edit and evaluate in order to produce the receiver's comment.\"\n\n\t| aString |\n\taString _ self organization classComment.\n\taString size = 0\n\t\tifTrue: [^self name , ' comment:\n''This class has not yet been commented.  A proper comment should include the purpose of the class and the type and purpose of each instance variable.\n''']\n\t\tifFalse: [^aString]\n",
          "name": "name\n\t\"Answer a String that is the name of the receiver.\"\n\n\tself subclassResponsibility\n",
          "comment:": "comment: aString\n\t\"Set the receiver's comment to be the argument, aString.\"\n\n\t| aStream |\n\taString size = 0\n\t\tifTrue:\n\t\t\t[self organization classComment: aString]\n\t\tifFalse:\n\t\t\t[\"double internal quotes of the comment string\"\n\t\t\taStream _ WriteStream on: (String new: aString size).\n\t\t\taStream nextPutAll: self name , ' comment:'; cr.\n\t\t\taString storeOn: aStream.\n\t\t\tself organization classComment: aStream contents.\n\tSmalltalk changes commentClass: self]\n",
          "comment": "comment\n\t\"Answer the receiver's comment.\"\n\n\t| aString |\n\taString _ self organization classComment.\n\taString size = 0 ifTrue: [^''].\n\t\"get string only of classComment, undoubling quotes\"\n\t^ String readFromString: aString\n"
        },
        "private": {
          "errorCategoryName": "errorCategoryName\n\tself error: 'Category name must be a String'\n"
        },
        "initialize-release": {
          "validateFrom:in:instanceVariableNames:methods:": "validateFrom: oldClass in: environ instanceVariableNames: invalidFields methods: invalidMethods\n\t\"Recompile the receiver, a class, and redefine its subclasses if necessary.\"\n\n\t| sub newSub |\n\tinvalidFields & invalidMethods ifFalse: [^self].\n\tinvalidMethods & self hasMethods\n\t\tifTrue:\n\t\t\t[Transcript show: 'recompiling ' , self name , '...'.\n\t\t\tself compileAllFrom: oldClass.\n\t\t\tTranscript show: ' done'; cr].\n\tself ~~ oldClass ifTrue: [self updateInstancesFrom: oldClass].\n\toldClass subclasses do:\n\t\t[:sub |\n\t\tnewSub _ sub copyForValidation.\n\t\tnewSub\n\t\t\tsubclassOf: self\n\t\t\toldClass: sub\n\t\t\tinstanceVariableNames: sub instVarNames\n\t\t\tvariable: sub isVariable\n\t\t\twords: sub isBytes not\n\t\t\tpointers: sub isBits not\n\t\t\tifBad: [self error: 'terrible problem in recompiling subclasses!'].\n\t\tnewSub\n\t\t\tvalidateFrom: sub\n\t\t\tin: environ\n\t\t\tinstanceVariableNames: invalidFields\n\t\t\tmethods: invalidMethods]\n",
          "subclassOf:oldClass:instanceVariableNames:variable:words:pointers:ifBad:": "subclassOf: newSuper oldClass: oldClass instanceVariableNames: newInstVarString variable: v words: w pointers: p ifBad: badBlock\n\t\"Basic initialization message for creating classes using the information provided\n\tas arguments.  Answer whether old instances will be invalidated.\"\n\n\t| old new usedNames invalid oldSuperMeta newInstVarArray |\n\told _ self allInstVarNames.\n\tusedNames _ #(self super thisContext true false nil ) asSet.\n\tnewInstVarArray _ Scanner new scanFieldNames: newInstVarString.\n\t(invalid _ superclass ~~ newSuper)\n\t\tifTrue:\n\t\t\t[\"superclass changed\"\n\t\t\toldSuperMeta _ superclass class.\n\t\t\tsuperclass removeSubclass: self.\n\t\t\tsuperclass _ newSuper.\n\t\t\tsuperclass addSubclass: self.\n\t\t\tself class superclass == oldSuperMeta\n\t\t\t\tifTrue: [\"Only false when self is a metaclass\"\n\t\t\t\t\t\tself class superclass: newSuper class]].\n\tinstanceVariables _ nil.  \"To give us all super names\"\n\tnew _ self allInstVarNames , newInstVarArray.\n\tnew do:\n\t\t[:fieldName |\n\t\t(usedNames includes: fieldName)\n\t\t\tifTrue:\n\t\t\t\t[self error: fieldName , ' is reserved (maybe in a superclass)'.\n\t\t\t\t^badBlock value].\n\t\tusedNames add: fieldName].\n\tinstanceVariables _ newInstVarArray size = 0\n\t\tifTrue: [nil]\n\t\tifFalse: [newInstVarArray].\n\tinvalid _ invalid | (new ~= old).\n\t\"field names changed\"\n\told _ format.\n\tself\n\t\tformat: new size\n\t\tvariable: v\n\t\twords: w\n\t\tpointers: p.\n\tinvalid _ invalid | (format ~= old).\n\t\"format changed\"\n\t^invalid\n",
          "updateInstancesFrom:": "updateInstancesFrom: oldClass\n\t\"Recreate any existing instances of the argument, oldClass, as\n\tinstances of the receiver, which is a newly changed class.  Permute variables\n\tas necessary.\"\n\n\t| oldInstVarNames map variable old new instSize offset fieldName |\n\toldClass someInstance == nil ifTrue: [^self].\n\t\"no instances to convert\"\n\toldInstVarNames _ oldClass allInstVarNames.\n\tmap _\n\t\tself allInstVarNames\n\t\t\tcollect: [:instVarName | oldInstVarNames indexOf: instVarName].\n\tvariable _ self isVariable.\n\tinstSize _ self instSize.\n\toldClass allInstances do:\n\t\t[:old |\n\t\t\"note allInstsDo would get confused by becoming\"\n\t\tvariable\n\t\t\tifTrue: [new _ self basicNew: old basicSize]\n\t\t\tifFalse: [new _ self basicNew].\n\t\t1 to: instSize do:\n\t\t\t[:offset |\n\t\t\t(map at: offset) > 0\n\t\t\t\tifTrue: [new instVarAt: offset put: (old instVarAt: (map at: offset))]].\n\t\tvariable\n\t\t\tifTrue: [1 to: old basicSize do:\n\t\t\t\t\t\t[:offset | new basicAt: offset put: (old basicAt: offset)]].\n\t\told become: new]\n",
          "obsolete": "obsolete\n\t\"Make the receiver obsolete.\"\n\n\torganization _ nil.\n\tsuper obsolete\n"
        },
        "method dictionary": {
          "removeCategory:": "removeCategory: aString\n\t\"Remove each of the messages categorized under aString in the method dictionary\n\tof the receiver.  Then remove the category aString.\"\n\n\t(self organization listAtCategoryNamed: aString asSymbol) do:\n\t\t[:sel | self removeSelector: sel].\n\tself organization removeEmptyCategories\n",
          "removeSelector:": "removeSelector: aSymbol\n\t\"Remove the message whose selector is aSymbol from the method\n\tdictionary of the receiver, if it is there.  Answer nil otherwise.\"\n\n\t(methodDict includesKey: aSymbol) ifFalse: [^nil].\n\tsuper removeSelector: aSymbol.\n\tself organization removeElement: aSymbol.\n\tSmalltalk changes removeSelector: aSymbol class: self.\n\tSmalltalk logChange: self name , ' removeSelector: #' , aSymbol\n"
        }
      }
    },
    "Class": {
      "comment": "My instances describe the representation and behavior of objects.  I add more comprehensive programming support facilities to the basic attributes of Behavior and the descriptive facilities of ClassDescription.  An example is accessing shared (pool) variables.\n\nInstance Variables:\n\t\tname\t\t<Symbol> name of class for printing and global reference\n\t\tclassPool\t<Dictionary> of variables common to all instances\n\t\tsharedPools\t<Array> of Dictionaries access to other shared variables\n",
      "class_name": "Class",
      "superclass": "ClassDescription",
      "instanceVariables": "name classPool sharedPools",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "named:superclasses:instanceVariableNames:classVariableNames:category:": "named: newClassName superclasses: newSuperNames instanceVariableNames: myInstVarNames classVariableNames: classVarNames category: cat\n\t| newClass supers firstSuper otherSupers fork |\n\t\"find the superclasses corresponding to the superclass names\"\n\tsupers _ self getSuperclasses: newSuperNames.\n\tsupers size=1 ifTrue:\n\t\t[^supers first   \"if there's only one superclass, just use old code\"\n\t\t\tsubclass: newClassName\n\t\t\tinstanceVariableNames: myInstVarNames\n\t\t\tclassVariableNames: classVarNames\n\t\t\tpoolDictionaries: ''\n\t\t\tcategory: cat].\n\tnewClass _ supers first\n\t\tsubclass: newClassName\n\t\totherSupers: (supers copyFrom: 2 to: supers size)\n\t\tinstanceVariableNames: myInstVarNames\n\t\tclassVariableNames: classVarNames\n\t\tcategory: cat.\n\t^newClass\n",
          "getSuperclasses:": "getSuperclasses: superNames\n\t| supers |\n\t\"find the superclasses corresponding to the superclass names\"\n\tsupers _ (Scanner new scanTokens: superNames) collect:\n\t\t[:each | Smalltalk at: each].\n\t\"check that each is a kind of Behavior\"\n\tsupers do: [:each | (each isKindOf: Behavior) ifFalse:\n\t\t[self error: 'superclass must be a class-describing object']].\n\t^supers\n",
          "template:": "template: category\n\t\"Answer an expression that can be edited and evaluated in order to define\n\t a new class.\"\n\n\t^'NameOfSuperclass subclass: #NameOfClass\n\tinstanceVariableNames: ''instVarName1 instVarName2''\n\tclassVariableNames: ''ClassVarName1 ClassVarName2''\n\tpoolDictionaries: ''''\n\tcategory: ''' , category , ''''\n"
        }
      },
      "instance_methods": {
        "compiling": {
          "compileAllFrom:": "compileAllFrom: otherClass\n\tsuper compileAllFrom: otherClass.\n\tself class compileAllFrom: otherClass class\n",
          "poolHas:ifTrue:": "poolHas: varName ifTrue: assocBlock\n\t\"Look up the first argument in the context of the receiver.  If it is there,\n\tpass the association to assocBlock, and answer true, else answer false.\"\n\t| assoc pool |\n\tassoc _ self classPool associationAt: varName ifAbsent: [].\n\tassoc == nil\n\t\tifFalse:\n\t\t\t[assocBlock value: assoc.\n\t\t\t^true].\n\tself sharedPools do:\n\t\t[:pool |\n\t\tassoc _ pool associationAt: varName ifAbsent: [].\n\t\tassoc == nil\n\t\t\tifFalse:\n\t\t\t\t[assocBlock value: assoc.\n\t\t\t\t^true]].\n\t^ false\n"
        },
        "class name": {
          "rename:": "rename: aString\n\t\"The new name of the receiver is the argument, aString.\"\n\n\t| newName |\n\tnewName _ aString asSymbol.\n\t(Smalltalk includesKey: newName)\n\t\tifTrue: [^self error: newName , ' already exists'].\n\tSmalltalk renameClass: self as: newName.\n\tname _ newName.\n\tself comment: self comment.\n\tself class comment: self class comment\n"
        },
        "instance variables": {
          "removeInstVarName:": "removeInstVarName: aString\n\t\"Remove the argument, aString, as one of the receiver's instance variables.\"\n\t| newInstVarString |\n\t(self instVarNames includes: aString)\n\t\tifFalse: [self error: aString , ' is not one of my instance variables'].\n\tnewInstVarString _ ''.\n\t(self instVarNames copyWithout: aString) do:\n\t\t[:varName | newInstVarString _ newInstVarString , ' ' , varName].\n\tsuperclass class\n\t\tname: self name\n\t\tinEnvironment: Smalltalk\n\t\tsubclassOf: superclass\n\t\tinstanceVariableNames: newInstVarString\n\t\tvariable: self isVariable\n\t\twords: self isWords\n\t\tpointers: self isPointers\n\t\tclassVariableNames: self classVariablesString\n\t\tpoolDictionaries: self sharedPoolsString\n\t\tcategory: self category\n\t\tcomment: nil\n\t\tchanged: false\n",
          "addInstVarName:": "addInstVarName: aString\n\t\"Add the argument, aString, as one of the receiver's instance variables.\"\n\tsuperclass class\n\t\tname: self name\n\t\tinEnvironment: Smalltalk\n\t\tsubclassOf: superclass\n\t\tinstanceVariableNames: self instanceVariablesString , aString\n\t\tvariable: self isVariable\n\t\twords: self isWords\n\t\tpointers: self isPointers\n\t\tclassVariableNames: self classVariablesString\n\t\tpoolDictionaries: self sharedPoolsString\n\t\tcategory: self category\n\t\tcomment: nil\n\t\tchanged: false\n"
        },
        "fileIn/Out": {
          "fileOut": "fileOut\n\t\"Create a file whose name is the name of the receiver with -.st- as the\n\textension, and file a description of the receiver onto it\"\n\n\t| fileStream |\n\tTranscript refresh; cr; cr; show: 'Filing out class:'.\n\t\t\t\t\tfileStream _ Disk file: self name , '.st'.\n\tfileStream timeStamp.\n\tself fileOutOn: fileStream\n\t\tmoveSource: false\n\t\ttoFile: 0.\n\tfileStream shorten; close.\n\tself removeFromChanges.\n",
          "removeFromChanges": "removeFromChanges\n\t\"References to the receiver, a class, and its metaclass should no longer be included\n\tin the system ChangeSet.\"\n\tSmalltalk changes removeClassChanges: self\n",
          "printOut": "printOut\n\t\"Create a readable version of my definition, and send to a printer.\n\tDefaults to fileOut.\"\n\tself fileOut\n",
          "fileOutOn:moveSource:toFile:": "fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex\n\t\"File a description of the receiver on aFileStream.  If the boolean argument,\n\tmoveSource, is true, then set the trailing bytes to the position of aFileStream and\n\tto fileIndex in order to indicate where to find the source code.\"\n\n\tTranscript cr; show: name.\n\tsuper\n\t\tfileOutOn: aFileStream\n\t\tmoveSource: moveSource\n\t\ttoFile: fileIndex.\n\tself class nonTrivial\n\t\tifTrue:\n\t\t\t[aFileStream cr; nextPutAll: '\"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \"!'; cr; cr.\n\t\t\tself class\n\t\t\t\tfileOutOn: aFileStream\n\t\t\t\tmoveSource: moveSource\n\t\t\t\ttoFile: fileIndex].\n"
        },
        "class variables": {
          "allClassVarNames": "allClassVarNames\n\t\"Answer a Set of the names of the receiver's class variables, including those\n\tdefined in the superclasses of the receiver.\"\n\t| aSet |\n\tsuperclass == nil\n\t\tifTrue:\n\t\t\t[^self classVarNames]  \"This is the keys so it is a new Set.\"\n\t\tifFalse:\n\t\t\t[aSet _ superclass allClassVarNames.\n\t\t\taSet addAll: self classVarNames.\n\t\t\t^aSet]\n",
          "addClassVarName:": "addClassVarName: aString\n\t\"Add the argument, aString, as a class variable of the receiver.\"\n\n\taString first isLowercase\n\t\tifTrue: [^self error: aString, ' class variable name should be capitalized; proceed to include anyway.'].\n\tself withAllSubclasses do:\n\t\t[:subclass |\n\t\tsubclass\n\t\t\tpoolHas: aString asSymbol\n\t\t\tifTrue:\n\t\t\t\t[:ignored |\n\t\t\t\t^self error: aString , ' is already used as a variable name in ' , subclass name]].\n\tclassPool _ self classPool.  \"might be nil\"\n\tclassPool add: (Association key: aString asSymbol value: nil)\n",
          "classVarNames": "classVarNames\n\t\"Answer a Set of the names of the class variables defined in the receiver.\"\n\n\t^self classPool keys\n",
          "initialize": "initialize\n\t\"Typically used for the initialization of class variables and metaclass instance\n\tvariables.  Does nothing, but may be overridden in Metaclasses.\"\n\t^self\n",
          "removeClassVarName:": "removeClassVarName: aString\n\t\"Remove the class variable whose name is the argument, aString, from the names\n\tdefined in the receiver, a class.\"\n\n\t| anAssoc aSymbol |\n\taSymbol _ aString asSymbol.\n\t(classPool includesKey: aSymbol)\n\t\tifFalse: [^self error: aString, ' is not a class variable'].\n\tanAssoc _ classPool associationAt: aSymbol.\n\tself withAllSubclasses do:\n\t\t[:subclass |\n\t\t(Array with: subclass with: subclass class) do:\n\t\t\t[:classOrMeta |\n\t\t\t(classOrMeta whichSelectorsReferTo: (classPool associationAt: aSymbol))\n\t\t\t\tisEmpty\n\t\t\t\t\tifFalse: [^self error: aString\n\t\t\t\t\t\t\t\t, ' is still used in code of class '\n\t\t\t\t\t\t\t\t, classOrMeta name]]].\n\tclassPool removeKey: aSymbol\n"
        },
        "pool variables": {
          "sharedPools": "sharedPools\n\t\"Answer a Set of the pool dictionaries declared in the receiver.\"\n\n\tsharedPools == nil\n\t\tifTrue: [^Set new]\n\t\tifFalse: [^sharedPools]\n",
          "allSharedPools": "allSharedPools\n\t\"Answer a Set of the pools the receiver shares, including those defined\n\tin the superclasses of the receiver.\"\n\n\t| aSet |\n\tsuperclass == nil\n\t\tifTrue:\n\t\t\t[^self sharedPools copy]\n\t\tifFalse:\n\t\t\t[aSet _ superclass allSharedPools.\n\t\t\taSet addAll: self sharedPools.\n\t\t\t^aSet]\n",
          "removeSharedPool:": "removeSharedPool: aDictionary\n\t\"Remove the pool dictionary, aDictionary, as one of the receiver's pool dictionaries.\n\tCreate an error if the dictionary is not one of the pools.\"\n\n\t| satisfiedSet workingSet aSubclass|\n\t(self sharedPools includes: aDictionary)\n\t\tifFalse: [^self error: 'the dictionary is not in my pool'].\n\n\t\"first see if it is declared in a superclass in which case we can remove it.\"\n\t(self allSuperclasses select: [:class | class sharedPools includes: aDictionary]) isEmpty\n\t\tifFalse: [sharedPools remove: aDictionary.\n\t\t\t\tsharedPools isEmpty ifTrue: [sharedPools _ nil].\n\t\t\t\t^self].\n\n\t\"second get all the subclasses that reference aDictionary through me rather than a\n\tsuperclass that is one of my subclasses.\"\n\n\tworkingSet _ self subclasses asOrderedCollection.\n\tsatisfiedSet _ Set new.\n\t[workingSet isEmpty] whileFalse:\n\t\t[aSubclass _ workingSet removeFirst.\n\t\t(aSubclass sharedPools includes: aDictionary)\n\t\t\tifFalse:\n\t\t\t\t[satisfiedSet add: aSubclass.\n\t\t\t\tworkingSet addAll: aSubclass subclasses]].\n\n\t\"for each of these, see if they refer to any of the variables in aDictionary because\n\tif they do, we can not remove the dictionary.\"\n\tsatisfiedSet add: self.\n\tsatisfiedSet do:\n\t\t[:aSubclass |\n\t\taDictionary associationsDo:\n\t\t\t[:aGlobal |\n\t\t\t(aSubclass whichSelectorsReferTo: aGlobal) isEmpty\n\t\t\t\tifFalse: [^self error: aGlobal key\n\t\t\t\t\t\t\t\t, ' is still used in code of class '\n\t\t\t\t\t\t\t\t, aSubclass name]]].\n\tsharedPools remove: aDictionary.\n\tsharedPools isEmpty ifTrue: [sharedPools _ nil]\n",
          "addSharedPool:": "addSharedPool: aDictionary\n\t\"Add the argument, aDictionary, as one of the receiver's pool dictionaries.  Create\n\tan error if the dictionary is already one of the pools.\"\n\n\t(self sharedPools includes: aDictionary)\n\t\tifTrue: [^self error: 'The dictionary is already in my pool'].\n\tsharedPools == nil\n\t\tifTrue: [sharedPools _ Set with: aDictionary]\n\t\tifFalse: [sharedPools add: aDictionary]\n"
        },
        "copying": {
          "copyForValidation": "copyForValidation\n\t\"Make a copy of the receiver (a class) but do not install the created class\n\tas a new class in the system.  This is used for creating a new version of\n\tthe receiver in which the installation is deferred until all changes are\n\tsuccessfully completed.\"\n\n\t^self class copy new\n\t\tsuperclass: superclass\n\t\tmethodDict: methodDict copy\n\t\tformat: format\n\t\tname: name\n\t\torganization: organization\n\t\tinstVarNames: instanceVariables copy\n\t\tclassPool: classPool\n\t\tsharedPools: sharedPools\n",
          "copy": "copy\n\t| newClass |\n\tnewClass _ self class copy new\n\t\tsuperclass: superclass\n\t\tmethodDict: methodDict copy\n\t\tformat: format\n\t\tname: name\n\t\torganization: organization copy\n\t\tinstVarNames: instanceVariables copy\n\t\tclassPool: classPool copy\n\t\tsharedPools: sharedPools.\n\tClass instSize to: self class instSize do:\n\t\t[:offset | newClass instVarAt: offset put: (self instVarAt: offset)].\n\t^newClass\n"
        },
        "accessing": {
          "name": "name\n\t\"Answer the name of the receiver.\"\n\n\tname == nil\n\t\tifTrue: [^super name]\n\t\tifFalse: [^name]\n",
          "classPool": "classPool\n\t\"Answer the dictionary of class variables.\"\n\n\tclassPool == nil\n\t\tifTrue: [^Dictionary new]\n\t\tifFalse: [^classPool]\n"
        },
        "initialize-release": {
          "validateFrom:in:instanceVariableNames:methods:": "validateFrom: oldClass in: environ instanceVariableNames: invalidFields methods: invalidMethods\n\t\"Recompile the receiver and redefine its subclasses if necessary.\"\n\n\tsuper\n\t\tvalidateFrom: oldClass\n\t\tin: environ\n\t\tinstanceVariableNames: invalidFields\n\t\tmethods: invalidMethods.\n\tself ~~ oldClass\n\t\tifTrue:\n\t\t\t[environ at: name put: self.\n\t\t\tself updateInheritanceTables: oldClass.\n\t\t\toldClass obsolete]\n",
          "removeFromSystem": "removeFromSystem\n\t\"Forget the receiver, and all of its subclasses, from the Smalltalk global dictionary.  Any existing instances will refer to an obsolete version of the receiver.\"\n\n\tSmalltalk removeClassNamed: self name. \t\t\t\"remove from system dictionary\"\n",
          "declare:": "declare: varString\n\t\"Declare class variables common to all instances.  Answer whether\n\trecompilation is advisable.\"\n\n\t| newVars conflicts assoc class |\n\tnewVars _\n\t\t(Scanner new scanFieldNames: varString)\n\t\t\tcollect: [:x | x asSymbol].\n\tnewVars do:\n\t\t[:var | var first isLowercase\n\t\t\tifTrue: [self error: var, ' class variable name should be capitalized; proceed to include anyway.']].\n\tconflicts _ false.\n\tclassPool == nil\n\t\tifFalse: [(classPool keys reject: [:x | newVars includes: x]) do:\n\t\t\t\t\t[:var | self removeClassVarName: var]].\n\t(newVars reject: [:var | self classPool includesKey: var])\n\t\tdo: [:var | \"adding\"\n\t\t\t\"check if new vars defined elsewhere\"\n\t\t\t(self scopeHas: var ifTrue: [:ignored | ignored])\n\t\t\t\tifTrue:\n\t\t\t\t\t[self error: var , ' is defined elsewhere'.\n\t\t\t\t\tconflicts _ true]].\n\tnewVars size > 0\n\t\tifTrue:\n\t\t\t[classPool _ self classPool.\n\t\t\t\"in case it was nil\"\n\t\t\tnewVars do: [:var | classPool declare: var from: Undeclared]].\n\t^conflicts\n",
          "obsolete": "obsolete\n\t\"Change the receiver to an obsolete class by changing its name to have the prefix -AnObsolete-, and nilling the fields of any instances.\"\n\n\tself isPointers ifTrue:\n\t\t[self allInstancesDo: [:instance | instance nilFields]]. \t\"nil fields of instances\"\n\t('AnObsolete*' match: name) ifFalse:\n\t\t[name _ 'AnObsolete' , name].\n\tclassPool _ Dictionary new.\n\tself class obsolete.\n\tsuper obsolete\n",
          "sharing:": "sharing: poolString\n\t\"Set up sharedPools.  Answer whether recompilation is advisable.\"\n\n\t| oldPools poolName pool |\n\toldPools _ self sharedPools.\n\tsharedPools _ Set new.\n\t(Scanner new scanFieldNames: poolString) do:\n\t\t[:poolName |\n\t\tsharedPools add: (Smalltalk at: poolName asSymbol)].\n\tsharedPools isEmpty ifTrue: [sharedPools _ nil].\n\toldPools\n\t\tdetect: [:pool | (self sharedPools includes: pool) not]\n\t\tifNone: [^false].\n\t^true\t\"A pool got deleted - who knows if there are still references?\"\n",
          "superclass:methodDict:format:name:organization:instVarNames:classPool:sharedPools:": "superclass: sup methodDict: md format: ft name: nm organization: org instVarNames: nilOrArray classPool: pool sharedPools: poolSet\n\t\"Answer an instance of me, a new class, using the arguments of the message\n\tas the needed information.\"\n\n\tsuperclass _ sup.\n\tmethodDict _ md.\n\tformat _ ft.\n\tname _ nm.\n\torganization _ org.\n\tinstanceVariables _ nilOrArray.\n\tclassPool _ pool.\n\tsharedPools _ poolSet\n"
        },
        "accessing class hierarchy": {
          "hasMultipleSuperclasses": "hasMultipleSuperclasses\n\t^self class instHasMultipleSuperclasses\n",
          "isObsolete": "isObsolete\n\t\"Answer whether the receiver is an obsolete class.\"\n\n\t^self class isObsolete \t\t\"ask the metaclass\"\n"
        },
        "testing method dictionary": {
          "hasMethods": "hasMethods\n\t\"Answer a Boolean as to whether any methods are defined for the receiver\n\t(includes whether there are methods defined in the receiver's metaclass).\"\n\n\t^super hasMethods or: [self class hasMethods]\n"
        },
        "subclass creation": {
          "subclass:otherSupers:instanceVariableNames:classVariableNames:category:": "subclass: t otherSupers: others instanceVariableNames: f classVariableNames: d category: cat\n\t\"This is the standard initialization message for creating a new class as a subclass\n\tof an existing class (the receiver).\"\n\n\tself isVariable\n\t\tifTrue:\n\t\t\t[self isPointers\n\t\t\t\tifTrue: [^self\n\t\t\t\t\t\t\tvariableSubclass: t\n\t\t\t\t\t\t\tinstanceVariableNames: f\n\t\t\t\t\t\t\tclassVariableNames: d\n\t\t\t\t\t\t\tpoolDictionaries: ''\n\t\t\t\t\t\t\tcategory: cat].\n\t\t\tself isBytes\n\t\t\t\tifTrue: [^self\n\t\t\t\t\t\t\tvariableByteSubclass: t\n\t\t\t\t\t\t\tinstanceVariableNames: f\n\t\t\t\t\t\t\tclassVariableNames: d\n\t\t\t\t\t\t\tpoolDictionaries: ''\n\t\t\t\t\t\t\tcategory: cat].\n\t\t\t^self\n\t\t\t\tvariableWordSubclass: t\n\t\t\t\tinstanceVariableNames: f\n\t\t\t\tclassVariableNames: d\n\t\t\t\tpoolDictionaries: ''\n\t\t\t\tcategory: cat].\n\t^self class\n\t\tname: t\n\t\tinEnvironment: Smalltalk\n\t\tsubclassOf: self and: others\n\t\tinstanceVariableNames: f\n\t\tvariable: false\n\t\twords: true\n\t\tpointers: true\n\t\tclassVariableNames: d\n\t\tpoolDictionaries: ''\n\t\tcategory: cat\n\t\tcomment: nil\n\t\tchanged: false\n",
          "variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:": "variableSubclass: t instanceVariableNames: f\n\tclassVariableNames: d poolDictionaries: s category: cat\n\t\"This is the standard initialization message for creating a new class as a subclass\n\tof an existing class (the receiver) in which the subclass is to have indexable\n\tpointer variables.\"\n\n\tself isBits\n\t\tifTrue:\n\t\t\t[^self error:\n\t\t\t\t'cannot make a pointer subclass of a class with non-pointer fields'].\n\t^self class name: t\n\t\tinEnvironment: Smalltalk\n\t\tsubclassOf: self\n\t\tinstanceVariableNames: f\n\t\tvariable: true\n\t\twords: true\n\t\tpointers: true\n\t\tclassVariableNames: d\n\t\tpoolDictionaries: s\n\t\tcategory: cat\n\t\tcomment: nil\n\t\tchanged: false\n",
          "variableByteSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:": "variableByteSubclass: t instanceVariableNames: f\n\tclassVariableNames: d poolDictionaries: s category: cat\n\t\"This is the standard initialization message for creating a new class as a subclass\n\tof an existing class (the receiver) in which the subclass is to have indexable\n\tbyte-sized nonpointer variables.\"\n\n\tself instSize > 0\n\t\tifTrue: [^self error: 'cannot make a byte subclass of a class with named fields'].\n\t(self isVariable and: [self isWords])\n\t\tifTrue: [^self error: 'cannot make a byte subclass of a class with word fields'].\n\t(self isVariable and: [self isPointers])\n\t\tifTrue: [^self error:\n\t\t\t\t\t'cannot make a byte subclass of a class with pointer fields'].\n\t^self class name: t\n\t\tinEnvironment: Smalltalk\n\t\tsubclassOf: self\n\t\tinstanceVariableNames: f\n\t\tvariable: true\n\t\twords: false\n\t\tpointers: false\n\t\tclassVariableNames: d\n\t\tpoolDictionaries: s\n\t\tcategory: cat\n\t\tcomment: nil\n\t\tchanged: false\n",
          "subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:": "subclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat\n\t\"This is the standard initialization message for creating a new class as a subclass\n\tof an existing class (the receiver).\"\n\n\tself isVariable\n\t\tifTrue:\n\t\t\t[self isPointers\n\t\t\t\tifTrue: [^self\n\t\t\t\t\t\t\tvariableSubclass: t\n\t\t\t\t\t\t\tinstanceVariableNames: f\n\t\t\t\t\t\t\tclassVariableNames: d\n\t\t\t\t\t\t\tpoolDictionaries: s\n\t\t\t\t\t\t\tcategory: cat].\n\t\t\tself isBytes\n\t\t\t\tifTrue: [^self\n\t\t\t\t\t\t\tvariableByteSubclass: t\n\t\t\t\t\t\t\tinstanceVariableNames: f\n\t\t\t\t\t\t\tclassVariableNames: d\n\t\t\t\t\t\t\tpoolDictionaries: s\n\t\t\t\t\t\t\tcategory: cat].\n\t\t\t^self\n\t\t\t\tvariableWordSubclass: t\n\t\t\t\tinstanceVariableNames: f\n\t\t\t\tclassVariableNames: d\n\t\t\t\tpoolDictionaries: s\n\t\t\t\tcategory: cat].\n\t^self class\n\t\tname: t\n\t\tinEnvironment: Smalltalk\n\t\tsubclassOf: self\n\t\tinstanceVariableNames: f\n\t\tvariable: false\n\t\twords: true\n\t\tpointers: true\n\t\tclassVariableNames: d\n\t\tpoolDictionaries: s\n\t\tcategory: cat\n\t\tcomment: nil\n\t\tchanged: false\n",
          "variableWordSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:": "variableWordSubclass: t instanceVariableNames: f\n\tclassVariableNames: d poolDictionaries: s category: cat\n\t\"This is the standard initialization message for creating a new class as a subclass\n\tof an existing class (the receiver) in which the subclass is to have indexable\n\tword-sized nonpointer variables.\"\n\n\tself instSize > 0\n\t\tifTrue: [^self error:\n\t\t\t\t\t'cannot make a word subclass of a class with named fields'].\n\tself isBytes\n\t\tifTrue: [^self error: 'cannot make a word subclass of a class with byte fields'].\n\t(self isVariable and: [self isPointers])\n\t\tifTrue: [^self error:\n\t\t\t\t\t'cannot make a word subclass of a class with pointer fields'].\n\t^self class name: t\n\t\tinEnvironment: Smalltalk\n\t\tsubclassOf: self\n\t\tinstanceVariableNames: f\n\t\tvariable: true\n\t\twords: true\n\t\tpointers: false\n\t\tclassVariableNames: d\n\t\tpoolDictionaries: s\n\t\tcategory: cat\n\t\tcomment: nil\n\t\tchanged: false\n"
        }
      }
    },
    "Metaclass": {
      "comment": "Instance Variables:\n\tthisClass\t<Class> the chief instance of me, which I describe\n\nMetaclasses add instance-specific behavior to various classes in the system.  This typically includes messages for initializing class variables and instance creation messages particular to that class.  There is only one instance of a metaclass, namely the class (thisClass) which is being described.  A metaclass shares the class variables of its instance.\n\n[Subtle] In general, the superclass hierarchy for metaclasses parallels that for classes.  Thus,\n\tInteger superclass == Number, and\n\tInteger class superclass == Number class.\nHowever there is a singularity at Object.  Here the class hierarchy terminates, but the metaclass hierarchy must wrap around to Class, since ALL metaclasses are subclasses of Class.  Thus,\n\tObject superclass == nil, and\n\tObject class superclass == Class.\n",
      "class_name": "Metaclass",
      "superclass": "ClassDescription",
      "instanceVariables": "thisClass",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "subclassOf:": "subclassOf: superMeta\n\t\"Answer a metaclass that is a subclass of metaclass superMeta.\"\n\n\t^self new subclassOf: superMeta\n"
        }
      },
      "instance_methods": {
        "compiling": {
          "scopeHas:ifTrue:": "scopeHas: name ifTrue: assocBlock\n\t^thisClass scopeHas: name ifTrue: assocBlock\n"
        },
        "instance variables": {
          "removeInstVarName:": "removeInstVarName: aString\n\t\"Remove the argument, aString, as one of the receiver's instance variables.\"\n\n\n\t| newArray newString |\n\t(self instVarNames includes: aString)\n\t\tifFalse: [self error: aString , ' is not one of my instance variables'].\n\tnewArray _ self instVarNames copyWithout: aString.\n\tnewString _ ''.\n\tnewArray do: [:aString2 | newString _ aString2 , ' ' , newString].\n\tself instanceVariableNames: newString\n",
          "addInstVarName:": "addInstVarName: aString\n\t\"Add the argument, aString, as one of the receiver's instance variables.\"\n\n\t| fullString |\n\tfullString _ aString.\n\tself instVarNames do: [:aString2 | fullString _ aString2 , ' ' , fullString].\n\tself instanceVariableNames: fullString\n"
        },
        "fileIn/Out": {
          "nonTrivial": "nonTrivial\n\t^self instVarNames size > 0 or: [methodDict size > 0 or: [self comment size > 0]]\n",
          "fileOutOn:moveSource:toFile:": "fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex\n\t\"File me out on aFileStream.\"\n\n\tsuper\n\t\tfileOutOn: aFileStream\n\t\tmoveSource: moveSource\n\t\ttoFile: fileIndex.\n\t(methodDict includesKey: #initialize)\n\t\tifTrue:\n\t\t\t[aFileStream cr.\n\t\t\taFileStream cr.\n\t\t\taFileStream nextChunkPut: thisClass name , ' initialize'.\n\t\t\taFileStream cr]\n"
        },
        "class variables": {
          "addClassVarName:": "addClassVarName: aString\n\t^thisClass addClassVarName: aString\n",
          "classPool": "classPool\n\t\"Answer the dictionary of class variables.\"\n\n\t^thisClass classPool\n"
        },
        "printing": {
          "definition": "definition\n\t\"Answer with a string that defines me\"\n\n\t| aStream names |\n\taStream _ WriteStream on: (String new: 300).\n\tself printOn: aStream.\n\taStream nextPutAll: '\n\tinstanceVariableNames: '''.\n\tnames _ self instVarNames.\n\t1 to: names size do: [:i | aStream nextPutAll: (names at: i); space].\n\taStream nextPut: $'.\n\t^ aStream contents\n"
        },
        "instance creation": {
          "new": "new\n\t\"The receiver can only have one instance.  Create it or complain that\n\tone already exists.\"\n\n\tthisClass == nil\n\t\tifTrue: [^thisClass _ super new]\n\t\tifFalse: [self error: 'A Metaclass should only have one instance!']\n"
        },
        "testing": {
          "isMeta": "isMeta\n\t^ true\n",
          "isObsolete": "isObsolete\n\t\"Answer whether the receiver is an obsolete metaclass.\"\n\n\t^thisClass == nil or: [thisClass ~~ (Smalltalk at: thisClass name ifAbsent: [nil])]\n\t\"should only be true for obsolete metaclass\"\n"
        },
        "copying": {
          "copyForValidation": "copyForValidation\n\t\"Special copy for ClassDescription validateFrom:in:fields:methods:.  Answer a copy\n\tof the receiver without the subclasses.\"\n\n\t^super copy\n",
          "copy": "copy\n\t\"Make a copy of the receiver without a list of subclasses.  Share the\n\treference to the sole instance.\"\n\n\t| copy t |\n\tt _ thisClass.\n\tthisClass _ nil.\n\tcopy _ super copy.\n\tthisClass _ t.\n\t^copy\n"
        },
        "accessing": {
          "name": "name\n\t\"Answer a String that is the name of the receiver, either Metaclass or the\n\tname of the receiver's class followed by the ' class'.\"\n\n\tthisClass == nil\n\t\tifTrue: [^'a Metaclass']\n\t\tifFalse: [^thisClass name , ' class']\n",
          "soleInstance": "soleInstance\n\t\"The receiver has only one instance.  Answer it.\"\n\n\t^thisClass\n"
        },
        "initialize-release": {
          "newNamed:": "newNamed: aSymbol\n\t\"Answer a new instance of me whose name is the argument, aSymbol.\"\n\t^(Metaclass subclassOf: self) new\n\t\tsuperclass: Object\n\t\tmethodDict: MethodDictionary new\n\t\tformat: -8192\n\t\tname: aSymbol\n\t\torganization: ClassOrganizer new\n\t\tinstVarNames: nil\n\t\tclassPool: nil\n\t\tsharedPools: nil\n",
          "instanceVariableNames:": "instanceVariableNames: instVarString\n\t\"Declare additional variables for my instances.\"\n\n\t| newMeta invalid ok |\n\tnewMeta _ self copyForValidation.\n\tinvalid _ newMeta\n\t\t\t\tsubclassOf: superclass\n\t\t\t\toldClass: self\n\t\t\t\tinstanceVariableNames: instVarString\n\t\t\t\tvariable: false\n\t\t\t\twords: true\n\t\t\t\tpointers: true\n\t\t\t\tifBad: [^false].\n\tinvalid\n\t\tifTrue:\n\t\t\t[ok _ newMeta\n\t\t\t\t\t\tvalidateFrom: self\n\t\t\t\t\t\tin: Smalltalk\n\t\t\t\t\t\tinstanceVariableNames: true\n\t\t\t\t\t\tmethods: true.\n\t\t\tSmalltalk changes changeClass: self.\n\t\t\t^ok]\n",
          "subclassOf:": "subclassOf: superMeta\n\t\"Change the receiver to be a subclass of the argument, superMeta, a metaclass.\n\tReset the receiver's method dictionary and properties.\"\n\n\tsuperclass _ superMeta.\n\tmethodDict _ MethodDictionary new.\n\tformat _ superMeta format.\n\tinstanceVariables _ nil\n",
          "newNamed:otherSupers:": "newNamed: aSymbol otherSupers: others\n\t\"Answer a new instance of me whose name is the argument, aSymbol.\"\n\t^ (MetaclassForMultipleInheritance subclassOf: self and: others) new\n\t\tsuperclass: Object\n\t\tmethodDict: MethodDictionary new\n\t\tformat: -8192\n\t\tname: aSymbol\n\t\torganization: ClassOrganizer new\n\t\tinstVarNames: nil\n\t\tclassPool: nil\n\t\tsharedPools: nil\n",
          "obsolete": "obsolete\n\t\"Invalidate and recycle local messages.  Remove the receiver from its superclass'\n\tsubclass list.\"\n\n\tthisClass_ nil.\n\tsuper obsolete\n",
          "superclass:": "superclass: superMeta\n\t\"Change the receiver's superclass to be the argument, superMeta, a metaclass.\"\n\n\tsuperclass _ superMeta\n"
        },
        "class hierarchy": {
          "name:inEnvironment:subclassOf:instanceVariableNames:variable:words:pointers:classVariableNames:poolDictionaries:category:comment:changed:": "name: newName inEnvironment: environ subclassOf: sup instanceVariableNames: instVarString variable: v words: w pointers: p classVariableNames: classVarString poolDictionaries: poolString category: categoryName comment: commentString changed: changed\n\t\"Create a new metaclass from the information provided in the arguments.\n\tCreate an error if the name does not begin with an uppercase letter or if a\n\tclass of the same name already exists.\"\n\n\t| wasPresent oldClass newClass invalidFields invalidMethods |\n\tnewName first isUppercase\n\t\tifFalse:\n\t\t\t[self error: 'Class names must be capitalized'.\n\t\t\t^false].\n\t(wasPresent _ environ includesKey: newName)\n\t\tifTrue:\n\t\t\t[oldClass _ environ at: newName.\n\t\t\t(oldClass isKindOf: Behavior)\n\t\t\t\tifFalse:\n\t\t\t\t\t[self error: newName , ' already exists!  Proceed will store over it'.\n\t\t\t\t\twasPresent _ false.\n\t\t\t\t\toldClass _ self newNamed: newName]]\n\t\tifFalse: [oldClass _ self newNamed: newName].\n\tnewClass _ oldClass copy.\n\tinvalidFields _\n\t\tchanged | (newClass\n\t\t\t\t\tsubclassOf: sup\n\t\t\t\t\toldClass: oldClass\n\t\t\t\t\tinstanceVariableNames: instVarString\n\t\t\t\t\tvariable: v\n\t\t\t\t\twords: w\n\t\t\t\t\tpointers: p\n\t\t\t\t\tifBad: [^false]).\n\tinvalidFields ifFalse: [newClass obsolete.  newClass _ oldClass].\n\tinvalidMethods _ invalidFields | (newClass declare:  classVarString) | (newClass sharing: poolString).\n\tcommentString == nil ifFalse: [newClass comment: commentString].\n\t(environ includesKey: newName)\n\t\tifFalse:\n\t\t\t[environ declare: newName from: Undeclared.\n\t\t\tenviron at: newName put: newClass].\n\tSystemOrganization classify: newClass name under: categoryName asSymbol.\n\tnewClass\n\t\tvalidateFrom: oldClass\n\t\tin: environ\n\t\tinstanceVariableNames: invalidFields\n\t\tmethods: invalidMethods.\n\t\"update subclass lists\"\n\tnewClass superclass removeSubclass: oldClass.\n\tnewClass superclass addSubclass: newClass.\n\t\"Update Changes\"\n\twasPresent\n\t\tifTrue: [Smalltalk changes changeClass: newClass]\n\t\tifFalse: [Smalltalk changes addClass: newClass].\n\t^newClass\n",
          "instHasMultipleSuperclasses": "instHasMultipleSuperclasses\n\t^false\n",
          "subclasses": "subclasses\n\t\"Answer the receiver's subclasses.\"\n\t| temp |\n\tself == Class class\n\t\tifTrue: [\"Meta-Object is exceptional subclass of Class\"\n\t\t\t\ttemp _ thisClass subclasses copy.\n\t\t\t\ttemp remove: Object class.\n\t\t\t\t^temp collect: [:aSubClass | aSubClass class]].\n\tthisClass == nil\n\t\tifTrue: [^Set new]\n\t\tifFalse: [^thisClass subclasses collect: [:aSubClass | aSubClass class]]\n",
          "name:inEnvironment:subclassOf:and:instanceVariableNames:variable:words:pointers:classVariableNames:poolDictionaries:category:comment:changed:": "name: newName inEnvironment: environ subclassOf: sup and: others instanceVariableNames: instVarString variable: v words: w pointers: p classVariableNames: classVarString poolDictionaries: poolString category: categoryName comment: commentString changed: changed\n\t\"Create a new metaclass from the information provided in the arguments.\n\tCreate an error if the name does not begin with an uppercase letter or if a\n\tclass of the same name already exists.\"\n\n\t| wasPresent oldClass newClass invalidFields invalidMethods |\n\tnewName first isUppercase\n\t\tifFalse:\n\t\t\t[self error: 'Class names must be capitalized'.\n\t\t\t^false].\n\t(wasPresent _ environ includesKey: newName)\n\t\tifTrue:\n\t\t\t[oldClass _ environ at: newName.\n\t\t\t(oldClass isKindOf: Behavior)\n\t\t\t\tifFalse:\n\t\t\t\t\t[self error: newName , ' already exists!  Proceed will store over it'.\n\t\t\t\t\twasPresent _ false.\n\t\t\t\t\toldClass _ self newNamed: newName otherSupers: others]]\n\t\tifFalse: [oldClass _ self newNamed: newName otherSupers: others].\n\tnewClass _ oldClass copy.\n\tinvalidFields _\n\t\tchanged | (newClass\n\t\t\t\t\tsubclassOf: sup\n\t\t\t\t\toldClass: oldClass\n\t\t\t\t\tinstanceVariableNames: instVarString\n\t\t\t\t\tvariable: v\n\t\t\t\t\twords: w\n\t\t\t\t\tpointers: p\n\t\t\t\t\tifBad: [^false]).\n\tinvalidFields ifFalse: [newClass obsolete.  newClass _ oldClass].\n\tinvalidMethods _ invalidFields | (newClass declare:  classVarString) | (newClass sharing: poolString).\n\tcommentString == nil ifFalse: [newClass comment: commentString].\n\t(environ includesKey: newName)\n\t\tifFalse:\n\t\t\t[environ declare: newName from: Undeclared.\n\t\t\tenviron at: newName put: newClass].\n\tSystemOrganization classify: newClass name under: categoryName asSymbol.\n\tnewClass\n\t\tvalidateFrom: oldClass\n\t\tin: environ\n\t\tinstanceVariableNames: invalidFields\n\t\tmethods: invalidMethods.\n\t\"update subclass lists\"\n\tnewClass superclasses do:\n\t\t[:sup | sup removeSubclass: oldClass; addSubclass: newClass].\n\t\"Update Changes\"\n\twasPresent\n\t\tifTrue: [Smalltalk changes changeClass: newClass]\n\t\tifFalse: [Smalltalk changes addClass: newClass].\n\t\"Now check for possible conflicting definitions in superclasses\"\n\tinvalidFields ifTrue:\n\t\t[newClass copyMethods.\n\t\tnewClass class copyMethods].\n\t^newClass\n"
        }
      }
    }
  },
  "Kernel-Methods": {
    "ContextPart": {
      "comment": "Instance Variables:\n\tstackp\t<Integer> indicating the offset of the top of my temporary value stack\n\nTo the instruction parsing ability of InstructionStream I add the actual semantics for execution.  The execution state is stored in my subclasses indexable fields, which store temporary variables and a stack of values used in evaluating expressions.  The actual semantics of execution can be found in my category \"simulator\", which exactly parallels the operation of the Smalltalk machine itself.\n",
      "class_name": "ContextPart",
      "superclass": "InstructionStream",
      "instanceVariables": "stackp",
      "classInstanceVariables": "",
      "classVariables": "TryPrimitiveMethods",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initPrimitives": "initPrimitives\n\t\"The methods (from class Object) that are cached in tryPrimitiveMethods are\n\tused by the simulator to catch failures when simulating primitives\"\n\n\t| method |\n\tTryPrimitiveMethods _\n\t\t#(tryPrimitive0 tryPrimitive1: tryPrimitive2:with: tryPrimitive3:with:with:\n\t\t\ttryPrimitive4:with:with:with: )\n\t\t\tcollect:\n\t\t\t\t[:sel |\n\t\t\t\tmethod _ Object compiledMethodAt: sel.\n\t\t\t\tmethod numLiterals = 3 ifFalse: [self error: 'doPrimitive assumes 3'].\n\t\t\t\tmethod]\n"
        },
        "examples": {
          "tallyInstructions:": "tallyInstructions: aBlock\n\t\"This method uses the simulator to count the number of occurrences of\n\teach of the Smalltalk instructions executed during evaluation of aBlock.\n\tResults appear in order of the byteCode set.\"\n\t| current tallies |\n\ttallies _ Bag new.\n\tthisContext sender\n\t\trunSimulated: aBlock\n\t\tcontextAtEachStep:\n\t\t\t[:current | tallies add: current nextByte].\n\t^tallies sortedElements\n\n\t\"ContextPart tallyInstructions: [3.14159 printString].\"\n",
          "trace:": "trace: aBlock\n\t\"This method uses the simulator to print calls and returned values in the Transcript\"\n\t| prev current |\n\tprev _ aBlock.\n\t^ thisContext sender\n\t\trunSimulated: aBlock\n\t\tcontextAtEachStep:\n\t\t\t[:current |\n\t\t\tcurrent == prev\n\t\t\t\tifFalse:\n\t\t\t\t\t[prev sender == nil ifTrue:  \"returning\"\n\t\t\t\t\t\t[Transcript space; nextPut: $^; print: current top].\n\t\t\t\t\tTranscript cr;\n\t\t\t\t\t\tnextPutAll: (String new: (current depthBelow: aBlock) withAll: $ );\n\t\t\t\t\t\tprint: current receiver; space; nextPutAll: current selector; endEntry.\n\t\t\t\t\tprev _ current]]\n\n\t\"ContextPart trace: [3 factorial]\"\n",
          "runSimulated:": "runSimulated: aBlock\n\t\"The simulator is a group of methods in class ContextPart which do what the\n\tSmalltalk interpreter does.  They execute Smalltalk bytecodes.  By adding code\n\tto the simulator, you could take statistics on the running of Smalltalk methods.\n\tSee also trace: callStatistics: and instructionStatistics: for sample uses\"\n\n\t^ thisContext sender\n\t\trunSimulated: aBlock\n\t\tcontextAtEachStep: [:ignored]\n\n\t\"ContextPart runSimulated: [Pen new defaultNib: 5; go: 100]\"\n",
          "tallyMethods:": "tallyMethods: aBlock\n\t\"This method uses the simulator to count the number of calls on each method\n\tinvoked in evaluating aBlock.  Results are given in order of decreasing counts.\"\n\t| prev current tallies |\n\ttallies _ Bag new.\n\tprev _ aBlock.\n\tthisContext sender\n\t\trunSimulated: aBlock\n\t\tcontextAtEachStep:\n\t\t\t[:current |\n\t\t\tcurrent == prev ifFalse: \"call or return\"\n\t\t\t\t[prev sender == nil ifFalse: \"call only\"\n\t\t\t\t\t[tallies add: current printString].\n\t\t\t\tprev _ current]].\n\t^tallies sortedCounts\n\n\t\"ContextPart tallyMethods: [3.14159 printString].\"\n"
        }
      },
      "instance_methods": {
        "controlling": {
          "blockCopy:": "blockCopy: numArgs\n\t\"Distinguish a block of code from its enclosing method by creating a new\n\tBlockContext for that block.  The compiler inserts into all methods that contain\n\tblocks the bytecodes to send the message blockCopy:.  Do not use blockCopy: in\n\tcode that you write!  Only the compiler can decide to send the message\n\tblockCopy:.  Fail if numArgs is not a SmallInteger.  Optional.  No Lookup.  See\n\tObject documentation whatIsAPrimitive.\"\n\n\t<primitive: 80>\n\t^(BlockContext new: self size)\n\t\thome: self home\n\t\tstartpc: pc + 2\n\t\tnargs: numArgs\n",
          "send:to:with:super:": "send: selector to: rcvr with: args super: superFlag\n\t\"Simulates the action of sending a message with selector, selector,\n\tand arguments, args, to receiver.  The argument, superFlag, tells\n\twhether the receiver of the message was specified with\n\t'super' in the source method.\"\n\n\t| class meth val |\n\tclass _\n\t\tsuperFlag\n\t\t\tifTrue: [(self method literalAt: self method numLiterals) value superclass]\n\t\t\tifFalse: [rcvr class].\n\t[class == nil]\n\t\twhileFalse:\n\t\t\t[(class includesSelector: selector)\n\t\t\t\tifTrue:\n\t\t\t\t\t[meth _ class compiledMethodAt: selector.\n\t\t\t\t\tval _\n\t\t\t\t\t\tself tryPrimitiveFor: meth\n\t\t\t\t\t\t\treceiver: rcvr\n\t\t\t\t\t\t\targs: args.\n\t\t\t\t\tval == #primitiveFail ifFalse: [^val].\n\t\t\t\t\t^self\n\t\t\t\t\t\tactivateMethod: meth\n\t\t\t\t\t\twithArgs: args\n\t\t\t\t\t\treceiver: rcvr\n\t\t\t\t\t\tclass: class].\n\t\t\tclass _ class superclass].\n\tself error: 'Simulated message ' , selector , ' not understood'\n",
          "activateMethod:withArgs:receiver:class:": "activateMethod: newMethod withArgs: args receiver: rcvr class: class\n\t\"Answer a new context initialized with the arguments.\"\n\n\t^MethodContext\n\t\tsender: self\n\t\treceiver: rcvr\n\t\tmethod: newMethod\n\t\targuments: args\n",
          "pop": "pop\n\t\"Answer the top of the receiver's stack and remove the top of the stack.\"\n\n\t| val |\n\tval _ self at: stackp.\n\tself at: stackp put: nil.\n\tstackp _ stackp - 1.\n\t^val\n",
          "return:to:": "return: value to: sendr\n\t\"Simulate the return of value to sendr.\"\n\n\tself releaseTo: sendr.\n\t^sendr push: value\n",
          "push:": "push: val\n\t\"Push val on the receiver's stack.\"\n\tself at: (stackp _ stackp + 1) put: val\n",
          "top": "top\n\t\"Answer the top of the receiver's stack.\"\n\n\t^self at: stackp\n"
        },
        "instruction decoding": {
          "pushReceiver": "pushReceiver\n\t\"Simulates the action of bytecode that pushes the the active\n\tcontext's receiver on the top of the stack.\"\n\n\tself push: self receiver\n",
          "methodReturnConstant:": "methodReturnConstant: value\n\t\"Simulates the action of a 'return constant' bytecode whose\n\tvalue is the argument, value.  This corresponds to a source\n\texpression like '^0'.\"\n\n\t^self return: value to: self home sender\n",
          "doPop": "doPop\n\t\"Simulates the action of a 'remove top of stack' bytecode.\"\n\n\tself pop\n",
          "pushLiteralVariable:": "pushLiteralVariable: value\n\t\"Simulates the action of bytecode that pushes the contents\n\tof the literal variable whose index is the argument, index,\n\ton the top of the stack.\"\n\n\tself push: value value\n",
          "jump:": "jump: distance\n\t\"Simulates the action of a 'unconditional jump' bytecode whose\n\toffset is the argument, distance.\"\n\n\tpc _ pc + distance\n",
          "storeIntoLiteralVariable:": "storeIntoLiteralVariable: value\n\t\"Simulates the action of bytecode that stores the top of the stack\n\tinto a literal variable of my method.\"\n\n\tvalue value: self top\n",
          "pushActiveContext": "pushActiveContext\n\t\"Simulates the action of bytecode that pushes the the active\n\tcontext on the top of its own stack.\"\n\n\tself push: self\n",
          "popIntoReceiverVariable:": "popIntoReceiverVariable: offset\n\t\"Simulates the action of bytecode that removes the top of the stack and\n\tstores it into an instance variable of my receiver.\"\n\n\tself receiver instVarAt: offset + 1 put: self pop\n",
          "jump:if:": "jump: distance if: condition\n\t\"Simulates the action of a 'conditional jump' bytecode whose\n\toffset is the argument, distance, and whose condition is the\n\targument, condition.\"\n\n\t(self pop eqv: condition) ifTrue: [self jump: distance]\n",
          "methodReturnReceiver": "methodReturnReceiver\n\t\"Simulates the action of a 'return receiver' bytecode.  This\n\tcorresponds to the source expression '^self'.\"\n\n\t^self return: self receiver to: self home sender\n",
          "pushReceiverVariable:": "pushReceiverVariable: offset\n\t\"Simulates the action of bytecode that pushes the contents\n\tof the receiver's instance variable whose index is the argument, index,\n\ton the top of the stack.\"\n\n\tself push: (self receiver instVarAt: offset + 1)\n",
          "storeIntoReceiverVariable:": "storeIntoReceiverVariable: offset\n\t\"Simulates the action of bytecode that stores the top of the stack\n\tinto an instance variable of my receiver.\"\n\n\tself receiver instVarAt: offset + 1 put: self top\n",
          "send:super:numArgs:": "send: selector super: superFlag numArgs: numArgs\n\t\"Simulates the action of bytecodes that send a message\n\twith selector, selector.  The argument, superFlag, tells\n\twhether the receiver of the message was specified with\n\t'super' in the source method.  The arguments of the message\n\tare found in the top numArgs locations on the stack and\n\tthe receiver just below them.\"\n\n\t| receiver arguments |\n\targuments _ OrderedCollection new.\n\tnumArgs timesRepeat: [arguments addFirst: self pop].\n\treceiver _ self pop.\n\t(selector == #halt or: [selector == #halt:]) ifTrue:\n\t\t[self error: 'Cant simulate halt.  Proceed to bypass it.'.\n\t\tself push: nil. ^self].\n\t^self send: selector to: receiver with: arguments super: superFlag\n",
          "popIntoLiteralVariable:": "popIntoLiteralVariable: value\n\t\"Simulates the action of bytecode that removes the top of the stack and\n\tstores it into a literal variable of my method.\"\n\n\tvalue value: self pop\n",
          "storeIntoTemporaryVariable:": "storeIntoTemporaryVariable: offset\n\t\"Simulates the action of bytecode that stores the top of the stack\n\tinto one of my temporary variables.\"\n\n\tself home at: offset + 1 put: self top\n",
          "pushConstant:": "pushConstant: value\n\t\"Simulates the action of bytecode that pushes the constant, value, on\n\tthe top of the stack.\"\n\n\tself push: value\n",
          "pushTemporaryVariable:": "pushTemporaryVariable: offset\n\t\"Simulates the action of bytecode that pushes the contents\n\tof the temporary variable whose index is the argument, index,\n\ton the top of the stack.\"\n\n\tself push: (self home at: offset + 1)\n",
          "methodReturnTop": "methodReturnTop\n\t\"Simulates the action of a 'return top of stack' bytecode.  This\n\tcorresponds to source expressions like '^something'.\"\n\n\t^self return: self pop to: self home sender\n",
          "doDup": "doDup\n\t\"Simulates the action of a 'duplicate top of stack' bytecode.\"\n\n\tself push: self top\n",
          "popIntoTemporaryVariable:": "popIntoTemporaryVariable: offset\n\t\"Simulates the action of bytecode that removes the top of the stack and\n\tstores it into one of my temporary variables.\"\n\n\tself home at: offset + 1 put: self pop\n"
        },
        "system simulation": {
          "step": "step\n\t\"Simulate the execution of the receiver's next bytecode.\n\tAnswer the context that would be the active context\n\tafter this bytecode.\"\n\n\t^self interpretNextInstructionFor: self\n",
          "completeCallee:": "completeCallee: aContext\n\t\"Simulate the execution of bytecodes until a return to the receiver.\"\n\n\t| ctxt current |\n\tself class initPrimitives.\n\tctxt _ aContext.\n\t[ctxt == current or: [ctxt hasSender: self]]\n\t\twhileTrue:\n\t\t\t[current _ ctxt.\n\t\t\tctxt _ ctxt step].\n\tself stepToSendOrReturn\n",
          "stepToSendOrReturn": "stepToSendOrReturn\n\t\"Simulate the execution of bytecodes until either sending a message\n\tor returning a value to the receiver (that is, until switching contexts).\"\n\n\t[self willSend | self willReturn]\n\t\twhileFalse: [self step]\n",
          "runSimulated:contextAtEachStep:": "runSimulated: aBlock contextAtEachStep: block2\n\t\"Simulate the execution of aBlock until it ends.  aBlock MUST NOT contain an ^.\n\tEvaluate block2 with current context prior each instruction executed.\n\tAnswer with the simulated value of aBlock.\"\n\t| current |\n\taBlock hasMethodReturn\n\t\tifTrue: [self error: 'simulation of blocks with ^ can run loose'].\n\tself class initPrimitives.\n\tcurrent _ aBlock.\n\tcurrent pushArgs: Array new from: self.\n\t[current == self]\n\t\twhileFalse:\n\t\t\t[block2 value: current.\n\t\t\tcurrent _ current step].\n\t^self pop\n"
        },
        "printing": {
          "printOn:": "printOn: aStream\n\t| mclass selector class |\n\tselector _\n\t\t(class _ self receiver class)\n\t\t\tselectorAtMethod: self method\n\t\t\tsetClass: [:mclass].\n\tselector == #?\n\t\tifTrue:\n\t\t\t[aStream nextPut: $?; print: self method who.\n\t\t\t^self].\n\taStream nextPutAll: class name.\n\tmclass == class\n\t\tifFalse:\n\t\t\t[aStream nextPut: $(.\n\t\t\taStream nextPutAll: mclass name.\n\t\t\taStream nextPut: $)].\n\taStream nextPutAll: '>>'.\n\taStream nextPutAll: selector\n"
        },
        "debugger access": {
          "shortStack": "shortStack\n\t\"Answer a string showing the top five contexts on my sender chain.\"\n\n\t| shortStackStream |\n\tshortStackStream _ WriteStream on: (String new: 400).\n\t(self stackOfSize: 5) do:\n\t\t[:item | shortStackStream print: item; cr].\n\t^shortStackStream contents\n",
          "releaseTo:": "releaseTo: caller\n\t\"Remove information from the receiver and the contexts on its\n\tsender chain up to caller in order to break circularities.\"\n\n\t| c s |\n\tc _ self.\n\t[c == nil or: [c == caller]]\n\t\twhileFalse:\n\t\t\t[s _ c sender.\n\t\t\tc singleRelease.\n\t\t\tc _ s]\n",
          "swapSender:": "swapSender: coroutine\n\t\"Replace the receiver's sender with coroutine and answer the receiver's previous sender.\n\tFor use in coroutining.\"\n\n\t| oldSender |\n\toldSender _ sender.\n\tsender _ coroutine.\n\t^oldSender\n",
          "stackOfSize:": "stackOfSize: limit\n\t\"Answer an array of the top 'limit' contexts on the receiver's sender chain.\"\n\n\t| a stack |\n\tstack _ OrderedCollection new: 100.\n\tstack addLast: (a _ self).\n\t[(a _ a sender) ~~ nil and: [stack size < limit]]\n\t\twhileTrue:\n\t\t\t[stack addLast: a].\n\t^ stack\n",
          "stack": "stack\n\t\"Answer an array of the contexts on the receiver's sender chain.\"\n\t^self stackOfSize: 9999\n",
          "mclass": "mclass\n\t\"Answer the class in which the receiver's method was found.\"\n\n\t| mclass |\n\tself receiver class selectorAtMethod: self method setClass: [:mclass].\n\t^mclass\n",
          "hasSender:": "hasSender: context\n\t\"Answer true if the receiver is strictly above context on the stack.\"\n\n\t| s |\n\tself == context ifTrue: [^false].\n\ts _ sender.\n\t[s == nil]\n\t\twhileFalse:\n\t\t\t[s == context ifTrue: [^true].\n\t\t\ts _ s sender].\n\t^false\n",
          "singleRelease": "singleRelease\n\t\"Remove information from the receiver in order to break circularities.\"\n\n\tstackp == nil ifFalse: [1 to: stackp do: [:i | self at: i put: nil]].\n\tsender _ nil\n",
          "sender": "sender\n\t\"Answer the context that sent the message that created the receiver.\"\n\n\t^sender\n",
          "pc": "pc\n\t\"Answer the index of the next bytecode to be executed.\"\n\n\t^pc\n",
          "release": "release\n\t\"Remove information from the receiver and all of the contexts on its\n\tsender chain in order to break circularities.\"\n\n\tself releaseTo: nil\n",
          "selector": "selector\n\t\"Answer the selector of the method that created the receiver.\"\n\n\t^self receiver class\n\t\tselectorAtMethod: self method\n\t\tsetClass: [:ignored]\n",
          "depthBelow:": "depthBelow: aContext\n\t\"Answer how many calls between this and aContext.\"\n\t| this depth |\n\tthis _ self.\n\tdepth _ 0.\n\t[this == aContext or: [this == nil]]\n\t\twhileFalse:\n\t\t\t[this _ this sender.\n\t\t\tdepth _ depth + 1].\n\t^depth\n"
        },
        "accessing": {
          "method": "method\n\tself subclassResponsibility\n",
          "home": "home\n\t\"Answer the context in which the receiver was defined.\"\n\n\tself subclassResponsibility\n",
          "sourceCode": "sourceCode\n\t\"Answer the source form of the receiver's method.\"\n\t| mclass selector method |\n\tmethod _ self method.\n\tselector _ self receiver class selectorAtMethod: method setClass: [:mclass].\n\t^ mclass sourceCodeForMethod: method at: selector\n",
          "receiver": "receiver\n\t\"Answer the receiver of the message that created this context.\"\n\n\tself subclassResponsibility\n"
        },
        "private": {
          "tryPrimitiveFor:receiver:args:": "tryPrimitiveFor: method receiver: receiver args: arguments\n\t\"Simulate a primitive method, method for the receiver and arguments given\n\tas arguments to this message.  Answer resuming the context if successful, else\n\tanswer the symbol, #primitiveFail.\"\n\n\t| flag primIndex |\n\t(method objectAt: 1) > 0 ifTrue: [^#primitiveFail].\n\t\"fast check flags < 4\"\n\t(flag _ method flags) < 5 ifTrue: [^#primitiveFail].\n\tflag = 5 ifTrue: [^self push: receiver].\n\tflag = 6 ifTrue: [^self push: (receiver instVarAt: method numTempsField + 1)].\n\tflag = 7\n\t\tifTrue:\n\t\t\t[(primIndex _ method primitive) = 0 ifTrue: [^#primitiveFail].\n\t\t\t^self doPrimitive: primIndex receiver: receiver args: arguments]\n",
          "doPrimitive:receiver:args:": "doPrimitive: primitiveIndex receiver: receiver args: arguments\n\t\"Simulate a primitive method whose index is primitiveIndex.  The\n\tsimulated receiver and arguments are given as arguments to this message.\"\n\n\t| numberArguments primitiveMethod value |\n\t\"If successful, push result and return resuming context, else ^#primitiveFail\"\n\t(primitiveIndex = 80 and: [receiver isKindOf: ContextPart])\n\t\tifTrue: [^self push:\n\t\t\t\t\t((BlockContext new: receiver size)\n\t\t\t\t\t\thome: receiver home\n\t\t\t\t\t\tstartpc: pc + 2\n\t\t\t\t\t\tnargs: arguments first)].\n\t(primitiveIndex = 81 and: [receiver isMemberOf: BlockContext])\n\t\tifTrue: [^receiver pushArgs: arguments from: self].\n\tprimitiveIndex = 83\n\t\tifTrue: [^self\n\t\t\t\t\tsend: arguments first\n\t\t\t\t\tto: receiver\n\t\t\t\t\twith: (arguments copyFrom: 2 to: arguments size)\n\t\t\t\t\tsuper: false].\n\tnumberArguments _ arguments size.\n\tnumberArguments > 4 ifTrue: [^#primitiveFail].\n\t\"currently fails text primitive\"\n\tprimitiveMethod _ TryPrimitiveMethods at: numberArguments + 1.\n\tprimitiveMethod\n\t\tliteralAt: 2\n\t\tput: ((primitiveMethod literalAt: 2) bitAnd: -256) + primitiveIndex.\n\t\"slam num into primitive\"\n\t\"Instead of 100 such messages in Object\"\n\tClass flushCache.\n\t\"in case interp caches primitive #\"\n\tnumberArguments = 0 ifTrue: [value _ receiver tryPrimitive0].\n\tnumberArguments = 1 ifTrue: [value _ receiver tryPrimitive1: (arguments at: 1)].\n\tnumberArguments = 2 ifTrue: [value _ receiver tryPrimitive2: (arguments at: 1)\n\t\t\t\t\twith: (arguments at: 2)].\n\tnumberArguments = 3 ifTrue: [value _ receiver\n\t\t\t\t\ttryPrimitive3: (arguments at: 1)\n\t\t\t\t\twith: (arguments at: 2)\n\t\t\t\t\twith: (arguments at: 3)].\n\tnumberArguments = 4 ifTrue: [value _ receiver\n\t\t\t\t\ttryPrimitive4: (arguments at: 1)\n\t\t\t\t\twith: (arguments at: 2)\n\t\t\t\t\twith: (arguments at: 3)\n\t\t\t\t\twith: (arguments at: 4)].\n\tnumberArguments > 4 ifTrue: [self error: 'too many arguments to this primitive'].\n\tvalue == #primitiveFail\n\t\tifTrue: [^value]\n\t\tifFalse: [^self push: value]\n"
        },
        "temporaries": {
          "tempAt:": "tempAt: index\n\t\"Answer the value of the temporary variable whose index is the argument, index.\"\n\tself subclassResponsibility\n",
          "tempNames": "tempNames\n\t\"Answer an OrderedCollection of the names of the receiver's temporary\n\tvariables, which are strings.\"\n\n\t| names |\n\tself method setTempNamesIfCached: [:names | ^names].\n\tnames _ (self mclass compilerClass new\n\t\t\tparse: self sourceCode\n\t\t\tin: self mclass\n\t\t\tnotifying: nil) tempNames.\n\tself method cacheTempNames: names.\n\t^names\n",
          "tempAt:put:": "tempAt: index put: value\n\t\"Store the argument, value, as the temporary variable whose\n\tindex is the argument, index.\"\n\tself subclassResponsibility\n"
        }
      }
    },
    "BlockContext": {
      "comment": "My instances function similarly to instances of MethodContext, but they hold the dynamic state for execution of a block in Smalltalk.  They access all temporary variables and the method sender via their home pointer, so that those values are effectively shared.  Their indexable part is used to store their independent value stack during execution.\n\nMy instance must hold onto its home in order to work.  This can cause circularities if the home is also pointing (via a temp, perhaps) to the instance.  In the rare event that this happens (as in SortedCollection sortBlock:) the message fixTemps will replace home with a copy of home, thus defeating the sharing of temps but, nonetheless, eliminating the circularity.\n\nInstance Variables: *indexed*\n\tnargs\t<Integer> number of block arguments\n\tstartpc\t<Integer>\n\thome\t<Context>\n",
      "class_name": "BlockContext",
      "superclass": "ContextPart",
      "instanceVariables": "nargs startpc home",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "controlling": {
          "whileTrue": "whileTrue\n\t\"Evaluate the receiver once and then repeatedly as long as the value\n\treturned by the evaluation is true.\"\n\n\t^[self value] whileTrue: []\n",
          "whileFalse:": "whileFalse: aBlock\n\t\"Evaluate the argument, aBlock, as long as the value\n\tof the receiver is false. Ordinarily compiled in-line.\n\tBut could also be done in Smalltalk as follows\"\n\n\t^self value\n\t\tifFalse:\n\t\t\t[aBlock value.\n\t\t\tself whileFalse: aBlock]\n",
          "whileTrue:": "whileTrue: aBlock\n\t\"Evaluate the argument, aBlock, as long as the value\n\tof the receiver is true. Ordinarily compiled in-line.\n\tBut could also be done in Smalltalk as follows\"\n\n\t^self value\n\t\tifTrue:\n\t\t\t[aBlock value.\n\t\t\tself whileTrue: aBlock]\n",
          "whileFalse": "whileFalse\n\t\"Evaluate the receiver once and then repeatedly as long as the value\n\treturned by the evaluation is false.\"\n\n\t^[self value] whileFalse: []\n"
        },
        "instruction decoding": {
          "blockReturnTop": "blockReturnTop\n\t\"Simulate the interpreter's action when a ReturnTopOfStack\n\tbytecode is encountered in the receiver.\"\n\n\t| save dest |\n\tsave _ home.\t\"Needed because return code will nil it\"\n\tdest _ self return: self pop to: self sender.\n\thome _ save.\n\tsender _ nil.\n\t^dest\n",
          "pushArgs:from:": "pushArgs: args from: sendr\n\t\"Simulates action of the value primitive.\"\n\n\targs size ~= nargs ifTrue: [^self error: 'incorrect number of args'].\n\tstackp _ 0.\n\targs do: [:arg | self push: arg].\n\tsender _ sendr.\n\tpc _ startpc\n"
        },
        "scheduling": {
          "newProcessWith:": "newProcessWith: anArray\n\t\"Answer a new process running the code in the receiver.\n\tThe receiver's block arguments are bound to the contents\n\tof the argument, anArray.  The process is not scheduled.\"\n\n\t^Process\n\t\tforContext:\n\t\t\t[self valueWithArguments: anArray.\n\t\t\tProcessor terminateActive]\n\t\tpriority: Processor activePriority\n",
          "fork": "fork\n\t\"Create and schedule a process running the code in the receiver.\"\n\n\tself newProcess resume\n",
          "forkAt:": "forkAt: priority\n\t\"Create and schedule a process running the code in the receiver.\n\tThe priority of the process is the argument, priority.\"\n\n\t| forkedProcess |\n\tforkedProcess _ self newProcess.\n\tforkedProcess priority: priority.\n\tforkedProcess resume\n",
          "newProcess": "newProcess\n\t\"Answer a new process running the code in the receiver.\n\tThe process is not scheduled.\"\n\n\t^Process\n\t\tforContext:\n\t\t\t[self value.\n\t\t\tProcessor terminateActive]\n\t\tpriority: Processor activePriority\n"
        },
        "evaluating": {
          "value": "value\n\t\"Evaluate the block represented by the receiver.  Fail if the block expects any\n\targuments or if the block is already being executed.  Optional.  No Lookup.  See\n\tObject documentation whatIsAPrimitive.\"\n\n\t<primitive: 81>\n\t^self valueWithArguments: #()\n",
          "value:": "value: arg\n\t\"Evaluate the block represented by the receiver.  Fail if the block expects other\n\tthan one argument or if the block is already being executed.  Optional.  No\n\tLookup.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 81>\n\t^self valueWithArguments: (Array with: arg)\n",
          "valueWithArguments:": "valueWithArguments: anArray\n\t\"Evaluate the block represented by the receiver.  The argument is an Array\n\twhose elements are the arguments for the block.  Fail if the length of the Array\n\tis not the same as the the number of arguments that the block was expecting.\n\tFail if the block is already being executed.  Essential.  See Object\n\tdocumentation whatIsAPrimitive.\"\n\n\t<primitive: 82>\n\tnargs = anArray size\n\t\tifTrue: [self valueError]\n\t\tifFalse: [self error: 'The block needs more or fewer arguments defined']\n",
          "value:value:value:": "value: arg1 value: arg2 value: arg3\n\t\"Evaluate the block represented by the receiver.  Fail if the block expects other\n\tthan three arguments or if the block is already being executed.  Optional.  See\n\tObject documentation whatIsAPrimitive.\"\n\n\t<primitive: 81>\n\t^self valueWithArguments:\n\t\t(Array\n\t\t\twith: arg1\n\t\t\twith: arg2\n\t\t\twith: arg3)\n",
          "value:value:": "value: arg1 value: arg2\n\t\"Evaluate the block represented by the receiver.  Fail if the block expects other\n\tthan two arguments or if the block is already being executed.  Optional.  See\n\tObject documentation whatIsAPrimitive.\"\n\n\t<primitive: 81>\n\t^self valueWithArguments: (Array with: arg1 with: arg2)\n"
        },
        "printing": {
          "printOn:": "printOn: aStream\n\thome == nil ifTrue: [^aStream nextPutAll: 'a BlockContext with home=nil'].\n\taStream nextPutAll: '[] in '.\n\tsuper printOn: aStream\n"
        },
        "accessing": {
          "method": "method\n\t\"Answer the compiled method in which the receiver was defined.\"\n\n\t^home method\n",
          "hasMethodReturn": "hasMethodReturn\n\t\"answer true if there is an ^ in the code of this block\"\n\t| method scanner end |\n\tmethod _ self method.\n\t\"Determine end of block from long jump preceding it\"\n\tend _ (method at: startpc-2)\\\\16-4*256 + (method at: startpc-1) + startpc - 1.\n\tscanner _ InstructionStream new method: method pc: startpc.\n\tscanner scanFor: [:byte | (byte between: 120 and: 124) or: [scanner pc > end]].\n\t^ scanner pc <= end\n",
          "home": "home\n\t\"Answer the context in which the receiver was defined.\"\n\n\t^home\n",
          "fixTemps": "fixTemps\n\t\"Fix the values of the temporary variables used in the block that are\n\tordinarily shared with the method in which the block is defined.\"\n\n\thome _ home copy.\n\thome swapSender: nil\n",
          "receiver": "receiver\n\t^home receiver\n"
        },
        "private": {
          "valueError": "valueError\n\tself error: 'Incompatible number of args, or already active'\n"
        },
        "initialize-release": {
          "home:startpc:nargs:": "home: aContextPart startpc: position nargs: anInteger\n\t\"This is the initialization message.  The receiver has been\n\tinitialized with the correct size only.\"\n\n\thome _ aContextPart.\n\tstartpc _ position.\n\tnargs _ anInteger.\n\tpc _ position.\n\tstackp _ 0\n"
        },
        "temporaries": {
          "tempAt:": "tempAt: index\n\t^home at: index\n",
          "tempAt:put:": "tempAt: index put: value\n\t^home at: index put: value\n"
        }
      }
    },
    "MethodContext": {
      "comment": "My instances hold all the dynamic state associated with the execution of a CompiledMethod.  In addition to their inherited state, this includes the receiver, a method, and temporary space in the variable part of the context.\n\nMethodContexts, though normal in their variable size, are actually only used in two sizes, small and large, which are determined by the temporary space required by the method being executed.\n\nInstance Variables:  *indexed*\n\tmethod\t\t\t<CompiledMethod>\n\treceiverMap\t\tunused (we expect to use it later for multiple inheritance)\n\treceiver\t\t\t<Object>\n",
      "class_name": "MethodContext",
      "superclass": "ContextPart",
      "instanceVariables": "method receiverMap receiver",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "sender:receiver:method:arguments:": "sender: s receiver: r method: m arguments: args\n\t^(self new: m frameSize) setSender: s receiver: r method: m arguments: args\n"
        }
      },
      "instance_methods": {
        "accessing": {
          "method": "method\n\t^method\n",
          "removeSelf": "removeSelf\n\t\"Nil the receiver pointer and answer the former value.\"\n\n\t| tempSelf |\n\ttempSelf _ receiver.\n\treceiver _ nil.\n\t^tempSelf\n",
          "home": "home\n\t^self\n",
          "receiver": "receiver\n\t^receiver\n"
        },
        "private": {
          "setSender:receiver:method:arguments:": "setSender: s receiver: r method: m arguments: args\n\t\"Create the receiver's initial state.\"\n\n\tsender _ s.\n\treceiver _ r.\n\tmethod _ m.\n\tpc _ method initialPC.\n\tstackp _ method numTemps.\n\t1 to: args size do: [:i | self at: i put: (args at: i)]\n"
        },
        "initialize-release": {
          "restart": "restart\n\t\"Reinitialize the receiver so that it is in the state it was at its creation.\"\n\n\tpc _ method initialPC.\n\tstackp _ method numArgs + method numTemps\n",
          "restartWith:": "restartWith: aCompiledMethod\n\t\"Reinitialize the receiver as though it had been for a different method.  Used\n\tby a Debugger when one of the methods to which it refers is recompiled.\"\n\n\tmethod _ aCompiledMethod.\n\t^self restart\n"
        },
        "temporaries": {
          "tempAt:": "tempAt: index\n\t^self at: index\n",
          "tempAt:put:": "tempAt: index put: value\n\t^self at: index put: value\n"
        }
      }
    },
    "InstructionPrinter": {
      "comment": "Instance Variables:\n\tstream\t<WriteStream> accumulates symbolic output\n\toldPC\t<integer> remembers where current instruction started\n\nAn InstructionPrinter can print the object code of a CompiledMethod in symbolic format.  It prints into stream, and uses oldPC to know how many bytes to print in the listing.\nThe inherited variable \"sender\" is used in an ugly way to hold the method being printed.\n",
      "class_name": "InstructionPrinter",
      "superclass": "InstructionStream",
      "instanceVariables": "stream oldPC",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "instruction decoding": {
          "pushReceiver": "pushReceiver\n\t\"Print the Push the Active Context's Receiver on the Top of the Stack bytecode.\"\n\tself print: 'self'\n",
          "methodReturnConstant:": "methodReturnConstant: value\n\t\"Print the Return Constant bytecode.\"\n\tself print: 'return: ' , value printString\n",
          "doPop": "doPop\n\t\"Print the Remove Top of Stack bytecode.\"\n\tself print: 'pop'\n",
          "pushLiteralVariable:": "pushLiteralVariable: anAssociation\n\t\"Print the Push the Contents of anAssociation on the Top of the Stack bytecode.\"\n\tself print: 'pushLit: ' , anAssociation key\n",
          "jump:": "jump: offset\n\t\"Print the Unconditional Jump bytecode.\"\n\tself print: 'jumpTo: ' , (pc + offset) printString\n",
          "storeIntoLiteralVariable:": "storeIntoLiteralVariable: anAssociation\n\t\"Print the Store the Top of the Stack into a Literal Variable of the Method bytecode.\"\n\tself print: 'storeIntoLit: ' , anAssociation key\n",
          "pushActiveContext": "pushActiveContext\n\t\"Print the Push the Active Context on the Top of its Own Stack bytecode.\"\n\tself print: 'pushThisContext: '\n",
          "popIntoReceiverVariable:": "popIntoReceiverVariable: offset\n\t\"Print the Removes the Top of the Stack and Stores it into an Instance Variable\n\tbytecode.\"\n\tself print: 'popIntoRcvr: ' , offset printString\n",
          "blockReturnTop": "blockReturnTop\n\t\"Print the ReturnTopOfStack bytecode.\"\n\tself print: 'blockReturn'\n",
          "jump:if:": "jump: offset if: condition\n\t\"Print the Conditional Jump bytecode.\"\n\tself print:\n\t\t(condition\n\t\t\tifTrue: ['jumpTrue: ']\n\t\t\tifFalse: ['jumpFalse: '])\n\t\t\t, (pc + offset) printString\n",
          "methodReturnReceiver": "methodReturnReceiver\n\t\"Print the Return Self bytecode.\"\n\tself print: 'returnSelf'\n",
          "pushReceiverVariable:": "pushReceiverVariable: offset\n\t\"Print the Push the Contents of the Receiver's Instance Variable whose Index\n\tis the argument, offset, on the Top of the Stack bytecode.\"\n\tself print: 'pushRcvr: ' , offset printString\n",
          "storeIntoReceiverVariable:": "storeIntoReceiverVariable: offset\n\t\"Print the Store the Top of the Stack into an Instance Variable of the Method\n\tbytecode.\"\n\tself print: 'storeIntoRcvr: ' , offset printString\n",
          "send:super:numArgs:": "send: selector super: supered numArgs: numberArguments\n\t\"Print the Send a Message with Selector, selector, bytecode.  The argument,\n\tsupered, indicates whether the receiver of the message is specified with\n\t'super' in the source method.  The arguments of the message\n\tare found in the top numArguments locations on the stack and\n\tthe receiver just below them.\"\n\tself print: (supered ifTrue: ['superSend: '] ifFalse: ['send: ']) , selector\n",
          "popIntoLiteralVariable:": "popIntoLiteralVariable: anAssociation\n\t\"Print the Removes the Top of the Stack and Stores it into a Literal Variable\n\tbytecode.\"\n\tself print: 'popIntoLit: ' , anAssociation key\n",
          "storeIntoTemporaryVariable:": "storeIntoTemporaryVariable: offset\n\t\"Print the Store the Top of the Stack into a Temporary Variable of the Method\n\tbytecode.\"\n\tself print: 'storeIntoTemp: ' , offset printString\n",
          "pushConstant:": "pushConstant: value\n\t\"Print the Push the Constant, value, on the Top of the Stack bytecode.\"\n\tself print: 'pushConstant: ' , value printString\n",
          "pushTemporaryVariable:": "pushTemporaryVariable: offset\n\t\"Print the Push the Contents of the Temporary Variable whose Index is the\n\targument, offset, on the Top of the Stack bytecode.\"\n\tself print: 'pushTemp: ' , offset printString\n",
          "methodReturnTop": "methodReturnTop\n\t\"Print the Return Top of Stack bytecode.\"\n\tself print: 'returnTop'\n",
          "doDup": "doDup\n\t\"Print the Duplicate Top of Stack bytecode.\"\n\tself print: 'dup'\n",
          "popIntoTemporaryVariable:": "popIntoTemporaryVariable: offset\n\t\"Print the Removes the Top of the Stack and Stores it into a Temporary Variable\n\tbytecode.\"\n\tself print: 'popIntoTemp: ' , offset printString\n"
        },
        "printing": {
          "print:": "print: instruction\n\t\"Append to the receiver a description of the bytecode, instruction.\"\n\n\t| code |\n\tstream print: oldPC; space.\n\tstream nextPut: $<.\n\toldPC to: pc - 1 do:\n\t\t[:i |\n\t\tcode _ (self method at: i) storeStringRadix: 16.\n\t\tstream nextPut:\n\t\t\t(code size < 5\n\t\t\t\tifTrue: [$0]\n\t\t\t\tifFalse: [code at: 4]).\n\t\tstream nextPut: code last; space].\n\tstream skip: -1.\n\tstream nextPut: $>.\n\tstream space.\n\tstream nextPutAll: instruction.\n\tstream cr.\n\toldPC _ pc\n\t\"(InstructionPrinter compiledMethodAt: #print:) symbolic.\"\n"
        },
        "initialize-release": {
          "printInstructionsOn:": "printInstructionsOn: aStream\n\t\"Append to the stream, aStream, a description of each bytecode in the instruction\n\tstream.\"\n\n\t| end |\n\tstream _ aStream.\n\tend _ self method endPC.\n\toldPC _ pc.\n\t[pc <= end]\n\t\twhileTrue: [super interpretNextInstructionFor: self]\n"
        }
      }
    },
    "InstructionStream": {
      "comment": "Instance Variables:\n\tsender\t<Context>, sometimes <CompiledMethod>\n\tpc\t\t<Integer> pointing into my method\n\nAs a superclass of contexts, I store the return pointer in sender, and the current position in my method in pc.\n\nThis class by itself has the ability to interpret the byte-encoded Smalltalk instruction set and maintains a program counter (pc) for streaming through CompiledMethods.  Contexts thus inherit all this capability and, for other users, sender can hold a method to be similarly interpreted.  The unclean re-use of sender to hold the method was to avoid a trivial subclass for the stand-alone scanning funtion.\n",
      "class_name": "InstructionStream",
      "superclass": "Object",
      "instanceVariables": "sender pc",
      "classInstanceVariables": "",
      "classVariables": "SpecialConstants",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"Initialize an array of special constants returned by single-bytecode returns.\"\n\n\tSpecialConstants _\n\t\t(Array with: true with: false with: nil)\n\t\t\t, (Array with: -1 with: 0 with: 1 with: 2)\n\t\"InstructionStream initialize.\"\n"
        },
        "instance creation": {
          "on:": "on: method\n\t\"Answer a new InstructionStream on the argument, method.\"\n\n\t^self new method: method pc: method initialPC\n"
        }
      },
      "instance_methods": {
        "scanning": {
          "followingByte": "followingByte\n\t\"Answer the following bytecode.\"\n\t^self method at: pc + 1\n",
          "nextByte": "nextByte\n\t\"Answer the next bytecode.\"\n\t^self method at: pc\n",
          "scanFor:": "scanFor: scanBlock\n\t\"Answer the index of the first bytecode for which scanBlock answer\n\ttrue when supplied with that bytecode.\"\n\n\t| method end byte type |\n\tmethod _ self method.\n\tend _ method endPC.\n\t[pc <= end]\n\t\twhileTrue:\n\t\t\t[(scanBlock value: (byte _ method at: pc)) ifTrue: [^true].\n\t\t\ttype _ byte // 16.\n\t\t\tpc _\n\t\t\t\ttype = 8\n\t\t\t\t\tifTrue: [\"extensions\"\n\t\t\t\t\t\t\tpc + (#(2 2 2 2 3 2 3 1 1 1 ) at: byte \\\\ 16 + 1)]\n\t\t\t\t\tifFalse: [type = 10\n\t\t\t\t\t\t\t\tifTrue: [pc + 2\"long jumps\"]\n\t\t\t\t\t\t\t\tifFalse: [pc + 1]]].\n\t^false\n",
          "method": "method\n\t\"Answer the compiled method that supplies the receiver's bytecodes.\"\n\n\t^sender\t\t\"method access when used alone (not as part of a context)\"\n",
          "addFieldIndexTo:": "addFieldIndexTo: set\n\t\"If this instruction is an instVar reference, add its index (offset+1) to set.\"\n\t| byte byte2 |\n\tbyte _ self method at: pc.\n\tbyte < 16 ifTrue: [^ set add: byte + 1].  \"load field\"\n\t(byte >= 96 and: [byte <= 130]) ifTrue:\n\t\t[(byte between: 96 and: 103) ifTrue:  \"short store-pop\"\n\t\t\t[^ set add: byte - 96 + 1].\n\t\t(byte between: 128 and: 130) ifTrue:  \"extended field access\"\n\t\t\t[byte2 _ self method at: pc+1.\n\t\t\tbyte2 < 64 ifTrue: [^ set add: byte2 \\\\ 64 + 1]]]\n",
          "addSelectorTo:": "addSelectorTo: set\n\t\"If this instruction is a send, add its selector to set.\"\n\n\t| byte literalNumber |\n\tbyte _ self method at: pc.\n\tbyte < 128 ifTrue: [^self].\n\tbyte >= 176\n\t\tifTrue:\n\t\t\t[\"special byte or short send\"\n\t\t\tbyte >= 208\n\t\t\t\tifTrue: [set add: (self method literalAt: (byte bitAnd: 15) + 1)]\n\t\t\t\tifFalse: [set add: (Smalltalk specialSelectorAt: byte - 176 + 1)]]\n\t\tifFalse:\n\t\t\t[(byte between: 131 and: 134)\n\t\t\t\tifTrue:\n\t\t\t\t\t[literalNumber _ byte odd\n\t\t\t\t\t\t\t\tifTrue: [(self method at: pc + 1) \\\\ 32]\n\t\t\t\t\t\t\t\tifFalse: [self method at: pc + 2].\n\t\t\t\t\tset add: (self method literalAt: literalNumber + 1)]]\n",
          "pc": "pc\n\t\"Answer the index of the next bytecode.\"\n\n\t^pc\n"
        },
        "decoding": {
          "interpretNextInstructionFor:": "interpretNextInstructionFor: client\n\t\"Send to the argument, client, a message that specifies the type of the\n\tthe next instruction.\"\n\n\t| byte type offset method |\n\tmethod_ self method.\n\tbyte_ method at: pc.\n\ttype_ byte // 16.\n\toffset_ byte \\\\ 16.\n\tpc_ pc+1.\n\ttype=0 ifTrue: [^client pushReceiverVariable: offset].\n\ttype=1 ifTrue: [^client pushTemporaryVariable: offset].\n\ttype=2 ifTrue: [^client pushConstant: (method literalAt: offset+1)].\n\ttype=3 ifTrue: [^client pushConstant: (method literalAt: offset+17)].\n\ttype=4 ifTrue: [^client pushLiteralVariable: (method literalAt: offset+1)].\n\ttype=5 ifTrue: [^client pushLiteralVariable: (method literalAt: offset+17)].\n\ttype=6\n\t\tifTrue: [offset<8\n\t\t\t\t\tifTrue: [^client popIntoReceiverVariable: offset]\n\t\t\t\t\tifFalse: [^client popIntoTemporaryVariable: offset-8]].\n\ttype=7\n\t\tifTrue: [offset=0 ifTrue: [^client pushReceiver].\n\t\t\t\toffset<8 ifTrue: [^client pushConstant: (SpecialConstants at: offset)].\n\t\t\t\toffset=8 ifTrue: [^client methodReturnReceiver].\n\t\t\t\toffset<12 ifTrue: [^client methodReturnConstant:\n\t\t\t\t\t\t\t\t\t\t\t\t(SpecialConstants at: offset-8)].\n\t\t\t\toffset=12 ifTrue: [^client methodReturnTop].\n\t\t\t\toffset=13 ifTrue: [^client blockReturnTop].\n\t\t\t\toffset>13 ifTrue: [^self error: 'unusedBytecode']].\n\ttype=8 ifTrue: [^self interpretExtension: offset in: method for: client].\n\ttype=9\n\t\tifTrue:  \"short jumps\"\n\t\t\t[offset<8 ifTrue: [^client jump: offset+1].\n\t\t\t^client jump: offset-8+1 if: false].\n\ttype=10\n\t\tifTrue:  \"long jumps\"\n\t\t\t[byte_ method at: pc.  pc_ pc+1.\n\t\t\toffset<8 ifTrue: [^client jump: offset-4*256 + byte].\n\t\t\t^client jump: (offset bitAnd: 3)*256 + byte if: offset<12].\n\ttype=11\n\t\tifTrue:\n\t\t\t[^client\n\t\t\t\tsend: (Smalltalk specialSelectorAt: offset+1)\n\t\t\t\tsuper: false\n\t\t\t\tnumArgs: (Smalltalk specialNargsAt: offset+1)].\n\ttype=12\n\t\tifTrue:\n\t\t\t[^client\n\t\t\t\tsend: (Smalltalk specialSelectorAt: offset+17)\n\t\t\t\tsuper: false\n\t\t\t\tnumArgs: (Smalltalk specialNargsAt: offset+17)].\n\ttype>12\n\t\tifTrue:\n\t\t\t[^client send: (method literalAt: offset+1)\n\t\t\t\t\tsuper: false\n\t\t\t\t\tnumArgs: type-13]\n",
          "interpretJump": "interpretJump\n\t| t |\n\tt _ self method at: pc.\n\t(t between: 144 and: 151) ifTrue:\n\t\t[pc _ pc + 1.  ^t - 143].\n\t(t between: 160 and: 167) ifTrue:\n\t\t[pc _ pc + 2.  ^(t - 164) * 256 + (self method at: pc - 1)].\n\t^nil\n"
        },
        "testing": {
          "willStorePop": "willStorePop\n\t\"Answer whether the next bytecode is a store-pop.\"\n\n\t| byte |\n\tbyte _ self method at: pc.\n\t^byte = 130 or: [byte between: 96 and: 111]\n",
          "willReturn": "willReturn\n\t\"Answer whether the next bytecode is a return.\"\n\n\t^(self method at: pc) between: 120 and: 125\n",
          "willSend": "willSend\n\t\"Answer whether the next bytecode is a message-send.\"\n\t| byte |\n\tbyte _ self method at: pc.\n\tbyte < 128 ifTrue: [^ false].\n\tbyte >= 176\t\"special send or short send\"\n\t\tifTrue: [^ byte ~= 200].  \"but not blockCopy\"\n\t^ byte between: 131 and: 134\t\"long sends\"\n"
        },
        "private": {
          "method:pc:": "method: method pc: startpc\n\tsender _ method.\n\t\"allows this class to stand alone as a method scanner\"\n\tpc _ startpc\n",
          "interpretExtension:in:for:": "interpretExtension: offset in: method for: client\n\t| numberArguments literalNumber type offset2 |\n\t\"pc has already been incremented by 1\"\n\toffset < 3\n\t\tifTrue:\n\t\t\t[\"extended pushes and pops\"\n\t\t\ttype _ (method at: pc) // 64.\n\t\t\toffset2 _ (method at: pc) \\\\ 64.\n\t\t\tpc _ pc + 1.\n\t\t\toffset = 0\n\t\t\t\tifTrue:\n\t\t\t\t\t[type = 0 ifTrue: [^client pushReceiverVariable: offset2].\n\t\t\t\t\ttype = 1 ifTrue: [^client pushTemporaryVariable: offset2].\n\t\t\t\t\ttype = 2\n\t\t\t\t\t\tifTrue: [^client pushConstant: (method literalAt: offset2 + 1)].\n\t\t\t\t\ttype = 3\n\t\t\t\t\t\tifTrue: [^client pushLiteralVariable:\n\t\t\t\t\t\t\t\t\t(method literalAt: offset2 + 1)]].\n\t\t\toffset = 1\n\t\t\t\tifTrue:\n\t\t\t\t\t[type = 0 ifTrue: [^client storeIntoReceiverVariable: offset2].\n\t\t\t\t\ttype = 1 ifTrue: [^client storeIntoTemporaryVariable: offset2].\n\t\t\t\t\ttype = 2 ifTrue: [self error: 'illegalStore'].\n\t\t\t\t\ttype = 3\n\t\t\t\t\t\tifTrue: [^client storeIntoLiteralVariable:\n\t\t\t\t\t\t\t\t\t(method literalAt: offset2 + 1)]].\n\t\t\toffset = 2\n\t\t\t\tifTrue:\n\t\t\t\t\t[type = 0 ifTrue: [^client popIntoReceiverVariable: offset2].\n\t\t\t\t\ttype = 1 ifTrue: [^client popIntoTemporaryVariable: offset2].\n\t\t\t\t\ttype = 2 ifTrue: [self error: 'illegalStore'].\n\t\t\t\t\ttype = 3\n\t\t\t\t\t\tifTrue: [^client popIntoLiteralVariable:\n\t\t\t\t\t\t\t\t\t(method literalAt: offset2 + 1)]]].\n\toffset < 7\n\t\tifTrue:\n\t\t\t[\"extended sends\"\n\t\t\toffset odd\n\t\t\t\tifTrue:\n\t\t\t\t\t[numberArguments _ (method at: pc) // 32.\n\t\t\t\t\tliteralNumber _ (method at: pc) \\\\ 32.\n\t\t\t\t\tpc _ pc + 1]\n\t\t\t\tifFalse:\n\t\t\t\t\t[numberArguments _ method at: pc.\n\t\t\t\t\tliteralNumber _ method at: pc + 1.\n\t\t\t\t\tpc _ pc + 2].\n\t\t\t^client\n\t\t\t\tsend: (method literalAt: literalNumber + 1)\n\t\t\t\tsuper: offset > 4\n\t\t\t\tnumArgs: numberArguments].\n\toffset = 7 ifTrue: [^client doPop].\n\toffset = 8 ifTrue: [^client doDup].\n\toffset = 9 ifTrue: [^client pushActiveContext].\n\tself error: 'unusedBytecode'\n"
        }
      }
    },
    "Message": {
      "comment": "I represent a selector and its argument values.\n\nGenerally, the system does not use instances of Message.  However, when a message is not understood by its receiver, the interpreter will make up a Message (to capture the information involved in an actual message transmission) and send it as an argument with the message doesNotUnderstand:.\n",
      "class_name": "Message",
      "superclass": "Object",
      "instanceVariables": "selector args",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "selector:": "selector: aSymbol\n\t\"Answer an instance of me with unary selector, aSymbol.\"\n\n\t^self new setSelector: aSymbol arguments: (Array new: 0)\n",
          "selector:argument:": "selector: aSymbol argument: anObject\n\t\"Answer an instance of me whose selector is aSymbol and single argument\n\tis anObject.\"\n\n\t^self new setSelector: aSymbol arguments: (Array with: anObject)\n",
          "selector:arguments:": "selector: aSymbol arguments: anArray\n\t\"Answer an instance of me with selector, aSymbol, and arguments,\n\tanArray.\"\n\n\t^self new setSelector: aSymbol arguments: anArray\n"
        }
      },
      "instance_methods": {
        "printing": {
          "printOn:": "printOn: aStream\n\taStream nextPutAll: 'a Message with selector: '.\n\tselector printOn: aStream.\n\taStream nextPutAll: ' and arguments: '.\n\targs printOn: aStream.\n\t^aStream\n",
          "storeOn:": "storeOn: aStream\n\taStream nextPut: $(.\n\taStream nextPutAll: 'Message selector: '.\n\tselector storeOn: aStream.\n\taStream nextPutAll: ' arguments: '.\n\targs storeOn: aStream.\n\taStream nextPut: $)\n"
        },
        "accessing": {
          "selector": "selector\n\t\"Answer the selector of the receiver.\"\n\t^selector\n",
          "arguments": "arguments\n\t\"Answer the arguments of the receiver.\"\n\t^args\n"
        },
        "private": {
          "setSelector:arguments:": "setSelector: aSymbol arguments: anArray\n\tselector _ aSymbol.\n\targs _ anArray\n"
        }
      }
    },
    "CompiledMethod": {
      "comment": "I represent a method suitable for interpretation by the virtual machine.  My instances have pointer fields, including a header and some literals, followed by non-pointer fields comprising the byte encoded instructions for the method.  The header encodes the number of arguments, the number of literals, and the amount of temporary space needed (for context allocation).\n\nAn extra three bytes are added after the executable code.  These contain an external file address to the source code for the method.\n\nInstance Variables: *byte indexed*\n",
      "class_name": "CompiledMethod",
      "superclass": "ByteArray",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "BytesForHeader BytesPerLiteral LargeFrame SmallFrame SpecialConstants TempNameCache",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"Initialize class variables specifying the size of the temporary frame\n\tneeded to run instances of me, and the size of my instances' header\n\tand literals (which may be system-dependent.)\"\n\n\tSmallFrame _ 12.\t\"Context range for temps+stack\"\n\tLargeFrame _ 32.\n\tBytesForHeader _ (self newMethod: 0 header: 0) size.  \"Just a header, no literals\"\n\tBytesPerLiteral _ (self newMethod: 0 header: 1) size - BytesForHeader.  \"1 literal\"\n\t\"CompiledMethod initialize.\"\n"
        },
        "instance creation": {
          "toReturnField:": "toReturnField: field\n\t\"Answer an instance of me that is a quick return of the instance\n\tvariable indexed by the argument, field.\"\n\n\t^self\n\t\tnewBytes: 0\n\t\tflags: 6\n\t\tnTemps: field\n\t\tnStack: 0\n\t\tnLits: 0\n",
          "newMethod:header:": "newMethod: numberOfBytes header: headerWord\n\t\"Answer an instance of me.  The number of literals (and other\n\tinformation) is specified the headerWord.  The first argument specifies the\n\tnumber of fields for bytecodes in the method.  Fail if either argument is not a\n\tSmallInteger, or if numberOfBytes is negative.  Once the header of a method is\n\tset by this primitive, it cannot be changed in any way.  Essential.  See Object\n\tdocumentation whatIsAPrimitive. \"\n\n\t<primitive: 79>\n\t^self primitiveFailed\n",
          "newBytes:flags:nTemps:nStack:nLits:": "newBytes: numberOfBytes flags: flags nTemps: numberTemps nStack: stackSpace nLits: numberLiterals\n\t\"Answer an instance of me.  The header is specified by the message\n\targuments.  The remaining parts are not as yet determined.\"\n\n\t| flagBits |\n\tflags >= 4 ifTrue: [flagBits _ flags - 8]\n\t\t\tifFalse: [flagBits _ flags].\n\t\"ensure 15-bit integer result\"\n\t^self\n\t\tnewMethod: numberOfBytes + 3 \t\"+3 to store source location\"\n\t\theader: flagBits * 4096 + (numberTemps * 128)\n\t\t\t\t+ (numberTemps + stackSpace > SmallFrame\n\t\t\t\t\t\tifTrue: [64]\n\t\t\t\t\t\tifFalse: [0])\n\t\t\t\t+ numberLiterals\n",
          "toReturnSelf": "toReturnSelf\n\t\"Answer an instance of me that is a quick return of the instance (^self).\"\n\n\t^self\n\t\tnewBytes: 0\n\t\tflags: 5\n\t\tnTemps: 0\n\t\tnStack: 0\n\t\tnLits: 0\n"
        }
      },
      "instance_methods": {
        "printing": {
          "printOn:": "printOn: aStream\n\t\"Overrides method inherited from the byte arrayed collection\"\n\n\taStream nextPutAll: 'a CompiledMethod'\n",
          "storeOn:": "storeOn: aStream\n\t| noneYet index |\n\taStream nextPutAll: '(('.\n\taStream nextPutAll: self class name.\n\taStream nextPutAll: ' newMethod: '.\n\taStream store: self size - self initialPC + 1.\n\taStream nextPutAll: ' header: '.\n\taStream store: self header.\n\taStream nextPut: $).\n\tnoneYet _ self storeElementsFrom: self initialPC to: self endPC on: aStream.\n\t1 to: self numLiterals do:\n\t\t[:index |\n\t\tnoneYet\n\t\t\tifTrue: [noneYet _ false]\n\t\t\tifFalse: [aStream nextPut: $;].\n\t\taStream nextPutAll: ' literalAt: '.\n\t\taStream store: index.\n\t\taStream nextPutAll: ' put: '.\n\t\taStream store: (self literalAt: index)].\n\tnoneYet ifFalse: [aStream nextPutAll: '; yourself'].\n\taStream nextPut: $)\n",
          "who": "who\n\t\"Answer an Array of the class in which the receiver is defined and\n\tthe selector to which it corresponds.\"\n\n\tSmalltalk allBehaviorsDo:\n\t\t[:class |\n\t\tclass selectors do:\n\t\t\t[:sel |\n\t\t\t(class compiledMethodAt: sel) == self\n\t\t\t\tifTrue: [^Array with: class with: sel]]]\n",
          "symbolic": "symbolic\n\t\"Answer a String that contains a list of all the byte codes in a method\n\twith a short description of each.\"\n\n\t| aStream |\n\tself isQuick\n\t\tifTrue:\n\t\t\t[self isReturnSelf ifTrue: [^'Quick return self'].\n\t\t\t^'Quick return field ' , self returnField printString , ' (0-based)'].\n\taStream _ WriteStream on: (String new: 1000).\n\tself primitive > 0\n\t\tifTrue:\n\t\t\t[aStream nextPutAll: '<primitive: '.\n\t\t\taStream print: self primitive.\n\t\t\taStream nextPut: $>.\n\t\t\taStream cr].\n\t(InstructionPrinter on: self) printInstructionsOn: aStream.\n\t^aStream contents\n"
        },
        "scanning": {
          "scanFor:": "scanFor: byte\n\t\"Answer whether the receiver contains the argument as a bytecode.\"\n\n\t| instr |\n\t^(InstructionStream on: self) scanFor: [:instr | instr = byte]\n",
          "messages": "messages\n\t\"Answer a Set of all the message selectors sent by this method.\"\n\n\t| scanner aSet |\n\taSet _ Set new.\n\tscanner _ InstructionStream on: self.\n\tscanner\n\t\tscanFor:\n\t\t\t[:x |\n\t\t\tscanner addSelectorTo: aSet.\n\t\t\tfalse\t\"keep scanning\"].\n\t^aSet\n",
          "fieldsTouched": "fieldsTouched\n\t\"Answer a Set of fields touched by this method.\"\n\t| scanner aSet |\n\tself isReturnField ifTrue: [^ Set with: self returnField + 1].\n\tself isReturnSelf ifTrue: [^ Set new].\n\taSet _ Set new.\n\tscanner _ InstructionStream on: self.\n\tscanner\n\t\tscanFor:\n\t\t\t[:x |\n\t\t\tscanner addFieldIndexTo: aSet.\n\t\t\tfalse\t\"keep scanning\"].\n\t^aSet\n",
          "writesField:": "writesField: field\n\t\"Answer whether the receiver stores into the instance variable indexed\n\tby the argument.\"\n\n\tself isQuick ifTrue: [^false].\n\t(field <= 8 and: [self scanFor: 96 + field - 1])\n\t\tifTrue: [^true]\n\t\tifFalse: [^self scanLongStore: field - 1]\n",
          "readsField:": "readsField: varIndex\n\t\"Answer whether the receiver loads the instance variable indexed\n\tby the argument.\"\n\n\tself isReturnField ifTrue: [^self returnField + 1 = varIndex].\n\tvarIndex <= 16 ifTrue: [^self scanFor: varIndex - 1].\n\t^self scanLongLoad: varIndex - 1\n",
          "scanLongLoad:": "scanLongLoad: extension\n\t\"Answer whether the receiver contains a long load whose extension is the\n\targument.\"\n\n\t| scanner |\n\tscanner _ InstructionStream on: self.\n\t^scanner scanFor: [:instr | instr = 128 and: [scanner followingByte = extension]]\n",
          "readsRef:": "readsRef: literalAssociation\n\t\"Answer whether the receiver loads the argument.\"\n\n\t| lit |\n\tlit _ self literals indexOf: literalAssociation ifAbsent: [^false].\n\tlit <= 32 ifTrue: [^self scanFor: 64 + lit - 1].\n\t^self scanLongLoad: 192 + lit - 1\n",
          "writesRef:": "writesRef: ref\n\t\"Answer whether the receiver stores the argument.\"\n\n\t| lit |\n\tlit _ self literals indexOf: ref ifAbsent: [^false].\n\t^self scanLongStore: 192 + lit - 1\n",
          "scanLongStore:": "scanLongStore: extension\n\t\"Answer whether the receiver contains a long store whose extension is the\n\targument.\"\n\n\t| scanner |\n\tscanner _ InstructionStream on: self.\n\t^scanner scanFor:\n\t\t[:instr |\n\t\t(instr between: 129 and: 130) and: [scanner followingByte = extension]]\n"
        },
        "testing": {
          "isReturnField": "isReturnField\n\t\"Answer whether the receiver is a quick return of an instance variable.\"\n\n\t^self flags = 6\n",
          "isQuick": "isQuick\n\t\"Answer whether the receiver is a quick return (of self or of an\n\tinstance variable).\"\n\n\t^self flags between: 5 and: 6\n",
          "isReturnSelf": "isReturnSelf\n\t\"Answer whether the receiver is a quick return of self.\"\n\n\t^self flags = 5\n",
          "needsLargeFrame": "needsLargeFrame\n\t^self header allMask: 64\n"
        },
        "accessing": {
          "primitive": "primitive\n\t\"Answer the primitive index associated with the receiver.  Zero indicates\n\tthat there is either no primitive or just a quick primitive.\"\n\n\tself flags < 7\n\t\tifTrue: [^0]\n\t\tifFalse: [^(self literalAt: self numLiterals - 1) bitAnd: 255\t]\n",
          "frameSize": "frameSize\n\t\"Answer the size of temporary frame needed to run the receiver.\"\n\tself needsLargeFrame\n\t\tifTrue: [^ LargeFrame]\n\t\tifFalse: [^ SmallFrame]\n",
          "endPC": "endPC\n\t\"Answer the index of the last bytecode.\"\n\n\t(self last between: 120 and: 124) ifTrue: [^self size].\n\t^self size - 3\n",
          "returnField": "returnField\n\t\"Answer the index of the instance variable returned by a quick\n\treturn method.\"\n\n\tself flags ~= 6\n\t\tifTrue: [self error: 'only meaningful for quick-return']\n\t\tifFalse: [^self numTempsField]\n",
          "numArgs": "numArgs\n\t\"Answer the number of arguments the receiver takes.\"\n\n\t| flags |\n\t(flags _ self flags) <= 4 ifTrue: [^flags].\n\tflags < 7 ifTrue: [^0].\n\t^((self literalAt: self numLiterals - 1)\n\t\tbitShift: -8)\n\t\tbitAnd: 31\n",
          "initialPC": "initialPC\n\t\"Answer the program counter for the receiver's first bytecode.\"\n\n\t^self numLiterals * BytesPerLiteral + BytesForHeader + 1\n",
          "numTempsField": "numTempsField\n\t\"Answer the 5-bit number that indicates the number of temporary\n\tvariables the receiver uses.\"\n\n\t^self header // 128 bitAnd: 31\n",
          "numLiterals": "numLiterals\n\t\"Answer the number of literals used by the receiver.\"\n\n\tself isQuick ifTrue: [^0].\n\t^self header bitAnd: 63\n",
          "numTemps": "numTemps\n\t\"Answer the number of temporary variables used by the receiver.\"\n\n\tself isQuick\n\t\tifTrue: [^0]\n\t\tifFalse: [^self numTempsField]\n",
          "flags": "flags\n\t\"Answer the 3-bit number that indicates the number of arguments\n\tthe receiver takes and whether it is associated with a primitive.\"\n\n\t^(self header bitShift: -12) bitAnd: 7\n",
          "numStack": "numStack\n\t\"Answer the size of the available stack.\"\n\n\tself isQuick\n\t\tifTrue: [^0] \"The method was simply a return of self or instance variable.\"\n\t\tifFalse: [^self frameSize - self numTemps - self numArgs]\n"
        },
        "initialize-release": {
          "needsStack:encoder:": "needsStack: newStackSize encoder: encoder\n\t\"If newStackSize does not fit in the receiver, then the receiver\n\tbecomes a method with large stack.\"\n\n\t| newMethod newNumLits extraBytes largeBit |\n\t(self numTemps + newStackSize + 1) <= SmallFrame\n\t\tifTrue: [\"no problem\" ^ self].\n\t(self numTemps + newStackSize + 1) > LargeFrame\n\t\tifTrue: [^self error: 'Stack (including temps) is too deep'].\n\tnewMethod _ CompiledMethod\n\t\t\t\tnewBytes: self endPC - self initialPC + 1\n\t\t\t\tflags: self flags\n\t\t\t\tnTemps: self numTemps\n\t\t\t\tnStack: newStackSize\n\t\t\t\tnLits: self numLiterals.\n\t\t1 to: self numLiterals do:\n\t\t\t[:index | newMethod literalAt: index put: (self literalAt: index)].\n\t\textraBytes _ 0.\n\n\tself initialPC to: self size do:\n\t\t[:index | newMethod at: index+extraBytes put: (self at: index)].\n\tself become: newMethod\n"
        },
        "literals": {
          "refersToLiteral:": "refersToLiteral: literal\n\t\"Answer whether the receiver references the argument, literal.\n\tThe last literal, if used for super, will not cause a true answer\"\n\n\t| flags header numLiteralsPlus1 index |\n\t\"numLiteralsPlus1 _ self numLiterals + 1. -- expanded for speed\"\n\theader _ self objectAt: 1.\n\tflags _ \t(header bitShift: -12) bitAnd: 7.\n\t(flags = 6 or: [flags = 5]) ifTrue: [^ false].\n\tnumLiteralsPlus1 _ (header bitAnd: 63) + 1.\n\tindex _ 1.\n\t[(index _ index + 1) <= numLiteralsPlus1]\n\t\twhileTrue:\n\t\t[literal == (self objectAt: index)\n\t\t\tifTrue:\n\t\t\t[index < numLiteralsPlus1 ifTrue: [^ true].\n\t\t\t\"slow check for last literal which might just be super\"\n\t\t\t^ (literal isMemberOf: Association) not\n\t\t\t\tor: [(self readsRef: literal) or: [self writesRef: literal]]]].\n\t^ false\n",
          "literalAt:put:": "literalAt: index put: value\n\t\"Replace the literal indexed by the first argument with the\n\tsecond argument.\"\n\n\t^self objectAt: index + 1 put: value\n",
          "objectAt:": "objectAt: index\n\t\"Answer with the method header (if index=1) or a literal (if index >1) from the\n\treceiver.  Essential.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 68>\n\tself primitiveFailed\n",
          "objectAt:put:": "objectAt: index put: value\n\t\"Store the value argument into a literal in the receiver.   An index of 2\n\tcorresponds to the first literal.  Fails if the index is less than 2 or greater than\n\tthe number of literals.  Answer the value as the result.  Normally only the\n\tcompiler sends this message, because only the compiler stores values in\n\tCompiledMethods.  Essential.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 69>\n\tself primitiveFailed\n",
          "literalAt:": "literalAt: index\n\t\"Answer the literal indexed by the argument.\"\n\n\t^self objectAt: index + 1\n",
          "header": "header\n\t\"Answer the word containing the information about the form of the\n\treceiver and the form of the context needed to run the receiver.\"\n\n\t^self objectAt: 1\n",
          "literals": "literals\n\t\"Answer with an array of the literals referenced by the receiver.\"\n\n\t| literals numberLiterals index |\n\tliterals _ Array new: (numberLiterals _ self numLiterals).\n\tindex _ 0.\n\t[(index _ index + 1) <= numberLiterals]\n\t\twhileTrue: [literals at: index put: (self objectAt: index + 1)].\n\t^literals\n"
        },
        "source code management": {
          "putSource:inFile:": "putSource: sourceStr inFile: fileIndex\n\t\"Store the source code for the receiver on an external file.\n\tIf no sources are specified, i.e., SourceFile is nil, then do nothing.\n\tIf the fileIndex is 1, print on *.sources;  if it is 2, print on *.changes.\"\n\n\t| file remoteString |\n\tSourceFiles == nil ifTrue: [^self].\n\tfile _ SourceFiles at: fileIndex.\n\tfile setToEnd; readWriteShorten.\n\tfile cr; nextPut: $!; nextChunkPut: 'Behavior method'; cr.\n\tremoteString _\n\t\tRemoteString\n\t\t\tnewString: sourceStr\n\t\t\tonFileNumber: fileIndex\n\t\t\ttoFile: file.\n\tfile nextChunkPut: ' '; readOnly.\n\tself setSourcePosition: remoteString position inFile: fileIndex\n",
          "setTempNamesIfCached:": "setTempNamesIfCached: aBlock\n\tTempNameCache == nil ifTrue: [^self].\n\tTempNameCache key == self\n\t\tifTrue: [aBlock value: TempNameCache value]\n",
          "getSource": "getSource\n\t\"Answer the source code for the receiver.  Answer nil if there are\n\tno source files specified in the global SourceFiles.\"\n\n\t| end highByte position source |\n\tSourceFiles == nil ifTrue: [^nil].\n\tCursor read\n\t\tshowWhile:\n\t\t\t[end _ self size.\n\t\t\thighByte _ self at: end.\n\t\t\tposition _ highByte bitAnd: 63.\n\t\t\tposition _ position * 256 + (self at: end - 1).\n\t\t\tposition _ position * 256 + (self at: end - 2).\n\t\t\tposition = 0\n\t\t\t\tifTrue: [source _ nil]\n\t\t\t\tifFalse: [source _\n\t\t\t\t\t\t\t(RemoteString newFileNumber:\n\t\t\t\t\t\t\t\t(highByte bitShift: -6) + 1 position: position) string]].\n\t^source\n",
          "cacheTempNames:": "cacheTempNames: names\n\tTempNameCache _ Association key: self value: names\n",
          "fileIndex": "fileIndex\n\t\"Answer 1 if the source code of the receiver is on the *.sources file\n\tand 2 if it is on the *.changes file.\"\n\n\t(self last between: 120 and: 124)\n\t\tifTrue: [self error: 'Somehow a method does not have a file index.'].\n\t^self last // 64 + 1\n",
          "setSourcePosition:inFile:": "setSourcePosition: position inFile: fileIndex\n\t\"Store the location of the source code for the receiver in the receiver.  The\n\tlocation consists of which source file (*.sources or *.changes) and the position\n\tin that file.\"\n\n\t| index hiByte middleByte lowByte |\n\t\"set last three bytes to be position in file (1-4)\"\n\tfileIndex > 4 ifTrue: [^self error: 'invalid file number'].\n\tindex _ self size - 2.\n\tmiddleByte _ position bitShift: -8.\n\thiByte _ middleByte bitShift: -8.\n\tmiddleByte _ middleByte bitAnd: 255.\n\tlowByte _ position bitAnd: 255.\n\thiByte > 62 ifTrue: [Transcript show: 'Source file is getting full!!'; cr].\n\tself at: index + 2 put: fileIndex - 1 * 64 + hiByte.\n\tself at: index + 1 put: middleByte.\n\tself at: index put: lowByte\n",
          "putSource:class:category:inFile:": "putSource: sourceStr class: class category: catName inFile: fileIndex\n\t\"Print an expression that is a message to the argument, class, asking the\n\tclass to accept the source code, sourceStr, as a method in category, catName.\n\tThis is part of the format for writing descriptions of methods on files.\n\tIf no sources are specified, i.e., SourceFile is nil, then do nothing.\n\tIf the fileIndex is 1, print on *.sources;  if it is 2, print on *.changes.\"\n\n\t| file remoteString |\n\tSourceFiles == nil ifTrue: [^self].\n\tfile _ SourceFiles at: fileIndex.\n\tfile setToEnd; readWriteShorten.\n\tclass printCategoryChunk: catName on: file.\n\tfile cr.\n\tremoteString _\n\t\tRemoteString\n\t\t\tnewString: sourceStr\n\t\t\tonFileNumber: fileIndex\n\t\t\ttoFile: file.\n\tfile nextChunkPut: ' '; readOnly.\n\tself setSourcePosition: remoteString position inFile: fileIndex\n"
        }
      }
    },
    "MethodDescription": {
      "comment": "I model the result of looking up a selector name.  Usually I simply identify an existing method in some class in the system.  However, the lookup may fail, in which case I know the message would not be understood.  Also, in multiple inheritance situations, the lookup may yield conflicting results, in which case I will know that as well.\n",
      "class_name": "MethodDescription",
      "superclass": "Object",
      "instanceVariables": "status whichClass selector",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "whichClass:selector:": "whichClass: c selector: s\n\t^self new setWhichClass: c setSelector: s\n",
          "makeConflictingMethods": "makeConflictingMethods\n\t^self new setStatus: #conflictingMethods\n",
          "makeMethodNotImplemented": "makeMethodNotImplemented\n\t^self new setStatus: #methodNotImplemented\n"
        }
      },
      "instance_methods": {
        "comparing": {
          "=": "= descr\n\tself isConflictingMethods ifTrue: [^descr isConflictingMethods].\n\tself isMethodNotImplemented ifTrue: [^descr isMethodNotImplemented].\n\t^(whichClass == descr whichClass) & (selector == descr selector)\n"
        },
        "printing": {
          "printOn:": "printOn: strm\n\tstatus==#methodNotImplemented ifTrue:\n\t\t[strm nextPutAll: 'MethodDescription(methodNotImplemented)'.  ^self].\n\tstatus==#conflictingMethods ifTrue:\n\t\t[strm nextPutAll: 'MethodDescription(conflictingMethods)'.  ^self].\n\tstrm nextPutAll: 'MethodDescription(';\n\t\tnextPutAll: whichClass name;\n\t\tnextPut: $, ;\n\t\tnextPutAll: selector;\n\t\tnextPut: $)\n"
        },
        "testing": {
          "isConflictingMethods": "isConflictingMethods\n\t^status == #conflictingMethods\n",
          "isMethodNotImplemented": "isMethodNotImplemented\n\t^status == #methodNotImplemented\n",
          "isBad": "isBad\n\t^status == #conflictingMethods or: [status == #methodNotImplemented]\n"
        },
        "accessing": {
          "method": "method\n\t^whichClass compiledMethodAt: selector\n",
          "whichClass": "whichClass\n\t^whichClass\n",
          "selector": "selector\n\t^selector\n",
          "sourceCode": "sourceCode\n\t^whichClass sourceCodeAt: selector\n"
        },
        "private": {
          "setStatus:": "setStatus: s\n\tstatus _ s\n",
          "setWhichClass:setSelector:": "setWhichClass: c setSelector: s\n\twhichClass _ c.\n\tselector _ s\n"
        }
      }
    }
  },
  "Kernel-Objects": {
    "UndefinedObject": {
      "comment": "I describe the behavior of my sole instance, nil.  nil represents a prior value for variables that have not been initialized, or for results which are meaningless.\n",
      "class_name": "UndefinedObject",
      "superclass": "Object",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\tself error: 'You may not create any more undefined objects--use nil'\n"
        }
      },
      "instance_methods": {
        "dependents access": {
          "addDependent:": "addDependent: ignored\n\tself error: 'Nil should not have dependents'\n"
        },
        "printing": {
          "printOn:": "printOn: aStream\n\taStream nextPutAll: 'nil'\n",
          "storeOn:": "storeOn: aStream\n\taStream nextPutAll: 'nil'\n"
        },
        "testing": {
          "isNil": "isNil\n\t^true\n",
          "notNil": "notNil\n\t^false\n"
        },
        "copying": {
          "deepCopy": "deepCopy\n\t\"Only one instance of UndefinedObject should ever be made, so answer\n\twith self.\"\n",
          "shallowCopy": "shallowCopy\n\t\"Only one instance of UndefinedObject should ever be made, so answer\n\twith self.\"\n"
        },
        "initialize-release": {
          "release": "release\n\t\"Nil release is a no-op\"\n"
        }
      }
    },
    "Object": {
      "comment": "Object is the superclass of all classes.  It thus provides default behavior common to all objects, such as class access, copying and printing.\n",
      "class_name": "Object",
      "superclass": "nil",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "DependentsFields ErrorRecursion",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t(self confirm: 'Do you really want to initialize\nclass Object?  It will reset all dependents.')\n\t\tifTrue:\n\t\t\t[self initializeDependentsFields.\n\t\t\tself initializeErrorRecursion]\n\n\t\"Object initialize\"\n"
        },
        "documentation": {
          "howToModifyPrimitives": "howToModifyPrimitives\n\t\"You are allowed to write methods which specify primitives, but please use\n\tcaution.  If you make a subclass of a class which contains a primitive method,\n\tthe subclass inherits the primitive.  The message which is implemented\n\tprimitively may be overridden in the subclass (E.g., see at:put: in String's\n\tsubclass Symbol).  The primitive behavior can be invoked using super (see\n\tSymbol string:).\n\n\tA class which attempts to mimic the behavior of another class without being\n\tits subclass may or may not be able to use the primitives of the original class.\n\tIn general, if the instance variables read or written by a primitive have the\n\tsame meanings and are in the same fields in both classes, the primitive will\n\twork.\n\n\tFor certain frequently used 'special selectors', the compiler emits a\n\tsend-special-selector bytecode instead of a send-message bytecode.\n\tSpecial selectors were created because they offer two advantages.  Code\n\twhich sends special selectors compiles into fewer bytes than normal.  For\n\tsome pairs of receiver classes and special selectors, the interpreter jumps\n\tdirectly to a primitive routine without looking up the method in the class.\n\tThis is much faster than a normal message lookup.\n\n\tA selector which is a special selector solely in order to save space has a\n\tnormal behavior.  Methods whose selectors are special in order to\n\tgain speed contain the comment, 'No Lookup'.  When the interpreter\n\tencounters a send-special-selector bytecode, it checks the class of the\n\treceiver and the selector.  If the class-selector pair is a no-lookup pair,\n\tthen the interpreter swiftly jumps to the routine which implements the\n\tcorresponding primitive.  (A special selector whose receiver is not of the\n\tright class to make a no-lookup pair, is looked up normally).  The pairs are\n\tlisted below.  No-lookup methods contain a primitive number specification,\n\t<primitive: xx>, which is redundant.  Since the method is not normally looked\n\tup, deleting the primitive number specification cannot prevent this\n\tprimitive from running.  If a no-lookup primitive fails, the method is looked\n\tup normally, and the expressions in it are executed.\n\n\tNo Lookup pairs of (class, selector)\n\n\tSmallInteger with any of\t\t+ - * /  \\\\  bitOr: bitShift: bitAnd:  //\n\tSmallInteger with any of\t\t=  ~=  >  <  >=  <=\n\tAny class with\t\t\t\t\t==\n\tAny class with \t\t\t\t\t@\n\tPoint with either of\t\t\t\tx y\n\tContextPart with\t\t\t\t\tblockCopy:\n\tBlockContext with either of \t\tvalue value:\n\t\"\n\n\tself error: 'comment only'\n",
          "whatIsAPrimitive": "whatIsAPrimitive\n\t\"Some messages in the system are responded to primitively. A primitive\n\tresponse is performed directly by the interpreter rather than by evaluating\n\texpressions in a method. The methods for these messages indicate the\n\tpresence of a primitive response by including <primitive: xx> before the\n\tfirst expression in the method.\n\n\tPrimitives exist for several reasons. Certain basic or 'primitive'\n\toperations cannot be performed in any other way. Smalltalk without\n\tprimitives can move values from one variable to another, but cannot add two\n\tSmallIntegers together. Many methods for arithmetic and comparison\n\tbetween numbers are primitives. Some primitives allow Smalltalk to\n\tcommunicate with I/O devices such as the disk, the display, and the keyboard.\n\tSome primitives exist only to make the system run faster; each does the same\n\tthing as a certain Smalltalk method, and its implementation as a primitive is\n\toptional.\n\n\tWhen the Smalltalk interpreter begins to execute a method which specifies a\n\tprimitive response, it tries to perform the primitive action and to return a\n\tresult. If the routine in the interpreter for this primitive is successful,\n\tit will return a value and the expressions in the method will not be evaluated.\n\tIf the primitive routine is not successful, the primitive 'fails', and the\n\tSmalltalk expressions in the method are executed instead. These\n\texpressions are evaluated as though the primitive routine had not been\n\tcalled.\n\n\tThe Smalltalk code that is evaluated when a primitive fails usually\n\tanticipates why that primitive might fail. If the primitive is optional, the\n\texpressions in the method do exactly what the primitive would have done (See\n\tNumber @). If the primitive only works on certain classes of arguments, the\n\tSmalltalk code tries to coerce the argument or appeals to a superclass to find\n\ta more general way of doing the operation (see SmallInteger +). If the\n\tprimitive is never supposed to fail, the expressions signal an error (see\n\tSmallInteger asFloat).\n\n\tEach method that specifies a primitive has a comment in it. If the primitive is\n\toptional, the comment will say 'Optional'. An optional primitive that is not\n\timplemented always fails, and the Smalltalk expressions do the work\n\tinstead.\n\n\tIf a primitive is not optional, the comment will say, 'Essential'. Some\n\tmethods will have the comment, 'No Lookup'. See Object\n\thowToModifyPrimitives for an explanation of special selectors which are\n\tnot looked up.\n\n\tFor the primitives for +, -, *, and bitShift: in SmallInteger, and truncated\n\tin Float, the primitive constructs and returns a 16-bit\n\tLargePositiveInteger when the result warrants it. Returning 16-bit\n\tLargePositiveIntegers from these primitives instead of failing is\n\toptional in the same sense that the LargePositiveInteger arithmetic\n\tprimitives are optional. The comments in the SmallInteger primitives say,\n\t'Fails if result is not a SmallInteger', even though the implementor has the\n\toption to construct a LargePositiveInteger. For further information on\n\tprimitives, see the 'Primitive Methods' part of the chapter on the formal\n\tspecification of the interpreter in the Smalltalk book.\"\n\n\tself error: 'comment only'\n"
        },
        "instance creation": {
          "readFrom:": "readFrom: aStream\n\t\"Create an object based on the contents of aStream.\"\n\n\t| object |\n\tobject _ Compiler evaluate: aStream.\n\t(object isKindOf: self) ifFalse: [self error: self name, ' expected'].\n\t^object\n"
        },
        "private": {
          "initializeDependentsFields": "initializeDependentsFields\n\tDependentsFields _ IdentityDictionary new: 4\n\n\t\"Object initializeDependentsFields\"\n",
          "initializeErrorRecursion": "initializeErrorRecursion\n\tErrorRecursion _ false\n\n\t\"Object initializeErrorRecursion\"\n"
        }
      },
      "instance_methods": {
        "comparing": {
          "hash": "hash\n\t\"Answer a SmallInteger whose value is half of the receiver's object pointer\n\t(interpreting object pointers as 16-bit signed quantities).  Fails if the\n\treceiver is a SmallInteger.  Essential.  See documentation in Object metaclass.\"\n\n\t<primitive: 75>\n\tself primitiveFailed\n",
          "~~": "~~ anObject\n\t\"Answer true if the receiver and the argument are not the same object\n\t(have the same object pointer) and false otherwise.\"\n\n\t^(self == anObject) not\n",
          "=": "= anObject\n\t\"Answer true if the receiver and the argument represent the same object\n\tand false otherwise. If = is redefined in any subclass, consider also\n\tredefining the message hash.\"\n\n\t^self == anObject\n",
          "hashMappedBy:": "hashMappedBy: map\n\t\"Answer what my hash would be if oops changed according to map\"\n\t^ map newHashFor: self hash\n",
          "~=": "~= anObject\n\t\"Answer true if the receiver and the argument do not represent the same\n\tobject and false otherwise.\"\n\n\t^self = anObject == false\n",
          "==": "== anObject\n\t\"Answer true if the receiver and the argument are the same object (have the same\n\tobject pointer) and false otherwise.  Do not redefine the message == in any\n\tother class!  Essential.  No Lookup.  See documentation in Object metaclass.\"\n\n\t<primitive: 110>\n\tself primitiveFailed\n"
        },
        "class membership": {
          "class": "class\n\t\"Answer the object which is the receiver's class. Essential.  See\n\tdocumentation in Object metaclass.\"\n\n\t<primitive: 111>\n\tself primitiveFailed\n",
          "respondsTo:": "respondsTo: aSymbol\n\t\"Answer a Boolean as to whether the method dictionary of the receiver's class\n\tcontains aSymbol as a message selector.\"\n\n\t^self class canUnderstand: aSymbol\n",
          "isMemberOf:": "isMemberOf: aClass\n\t\"Answer a Boolean as to whether the receiver is an instance of the class, aClass.\"\n\n\t^self class == aClass\n",
          "isKindOf:": "isKindOf: aClass\n\t\"Answer a Boolean as to whether the class, aClass, is a superclass or class of\n\tthe receiver.\"\n\n\tself class == aClass\n\t\tifTrue: [^true]\n\t\tifFalse: [^self class inheritsFrom: aClass]\n"
        },
        "dependents access": {
          "addDependent:": "addDependent: anObject\n\t\"Add anObject as one of the receiver's dependents.\"\n\t(DependentsFields at: self ifAbsent: [self setDependents])\n\t\tadd: anObject.\n\t^anObject\n",
          "removeDependent:": "removeDependent: anObject\n\t\"Remove the argument, anObject, as one of the receiver's dependents.\"\n\t| dependents |\n\tdependents _ DependentsFields at: self ifAbsent: [^ anObject].\n\tdependents remove: anObject ifAbsent: [].\n\tdependents isEmpty ifTrue: [self breakDependents].\n\t^anObject\n",
          "dependents": "dependents\n\t\"Answer an OrderedCollection of the objects that are dependent on the\n\treceiver, that is, the objects that should be notified if the receiver changes.\"\n\n\t^ DependentsFields at: self ifAbsent: [OrderedCollection new]\n"
        },
        "system simulation": {
          "tryPrimitive2:with:": "tryPrimitive2: arg1 with: arg2\n\t\"Warning!! This is not a real primitive.  This method is a template that the\n\tSmalltalk simulator uses execute primitives with two arguments.  See\n\tContextPart class|initPrimitives and ContextPart|doPrimitive:receiver:args:.\"\n\n\t<primitive: 007>\n\t^#primitiveFail\n",
          "tryPrimitive4:with:with:with:": "tryPrimitive4: arg1 with: arg2 with: arg3 with: arg4\n\t\"Warning!! This is not a real primitive.  This method is a template that the\n\tSmalltalk simulator uses execute primitives with four arguments.  See\n\tContextPart class|initPrimitives and ContextPart|doPrimitive:receiver:args:.\"\n\n\t<primitive: 007>\n\t^#primitiveFail\n",
          "tryPrimitive3:with:with:": "tryPrimitive3: arg1 with: arg2 with: arg3\n\t\"Warning!! This is not a real primitive.  This method is a template that the\n\tSmalltalk simulator uses execute primitives with three arguments.  See\n\tContextPart class|initPrimitives and ContextPart|doPrimitive:receiver:args:.\"\n\n\t<primitive: 007>\n\t^#primitiveFail\n",
          "tryPrimitive0": "tryPrimitive0\n\t\"Warning!! This is not a real primitive.  This method is a template that the\n\tSmalltalk simulator uses to execute primitives with no arguments.  See\n\tContextPart class initPrimitives and ContextPart doPrimitive:receiver:args:.\"\n\n\t<primitive: 007>\n\t^#primitiveFail\n",
          "tryPrimitive1:": "tryPrimitive1: arg1\n\t\"Warning!! This is not a real primitive.  This method is a template that the\n\tSmalltalk simulator uses execute primitives with one argument.  See\n\tContextPart class|initPrimitives and ContextPart|doPrimitive:receiver:args:.\"\n\n\t<primitive: 007>\n\t^#primitiveFail\n"
        },
        "printing": {
          "isLiteral": "isLiteral\n\t\"Answer whether the receiver has a literal text form recognized by the compiler.\"\n\n\t^false\n",
          "printOn:": "printOn: aStream\n\t\"Append to the argument aStream a sequence of characters that identifies the receiver.\"\n\n\t| title |\n\ttitle _ self class name.\n\taStream nextPutAll: ((title at: 1) isVowel\n\t\t\t\t\t\t\tifTrue: ['an ']\n\t\t\t\t\t\t\tifFalse: ['a '])\n\t\t\t\t\t\t, title\n",
          "storeOn:": "storeOn: aStream\n\t\"Append to the argument aStream a sequence of characters that is an expression\n\twhose evaluation creates an object similar to the receiver.\"\n\n\taStream nextPut: $(.\n\tself class isVariable\n\t\tifTrue: [aStream nextPutAll: '(', self class name, ' basicNew: ';\n\t\t\t\t\tstore: self basicSize;\n\t\t\t\t\tnextPutAll: ') ']\n\t\tifFalse: [aStream nextPutAll: self class name, ' basicNew'].\n\t1 to: self class instSize do:\n\t\t[:i |\n\t\taStream nextPutAll: ' instVarAt: ';\n\t\t\tstore: i;\n\t\t\tnextPutAll: ' put: ';\n\t\t\tstore: (self instVarAt: i);\n\t\t\tnextPut: $;].\n\t1 to: self basicSize do:\n\t\t[:i |\n\t\taStream nextPutAll: ' basicAt: ';\n\t\t\tstore: i;\n\t\t\tnextPutAll: ' put: ';\n\t\t\tstore: (self basicAt: i);\n\t\t\tnextPut: $;].\n\taStream nextPutAll: ' yourself)'\n",
          "printString": "printString\n\t\"Answer a String whose characters are a description of the receiver.\"\n\n\t| aStream |\n\taStream _ WriteStream on: (String new: 16).\n\tself printOn: aStream.\n\t^aStream contents\n",
          "storeString": "storeString\n\t\"Answer a String representation of the receiver from which the receiver\n\tcan be reconstructed.\"\n\n\t| aStream |\n\taStream _ WriteStream on: (String new: 16).\n\tself storeOn: aStream.\n\t^aStream contents\n"
        },
        "updating": {
          "update:": "update: aParameter\n\t\"Receive a change notice from an object of whom the receiver is a dependent.\n\tThe default behavior is to do nothing;  a subclass might want to change\n\titself in some way.\"\n\n\t^self\n",
          "broadcast:with:": "broadcast: aSymbol with: anObject\n\t\"Send the argument, aSymbol, as a keyword message with argument anObject to\n\tall of the receiver's dependents.\"\n\n\tself dependents ~~ nil\n\t\tifTrue: [self dependents do:\n\t\t\t\t\t[:aDependent | aDependent perform: aSymbol with: anObject]]\n",
          "changeRequestFrom:": "changeRequestFrom: requestor\n\t\"Receiver wants to change; check with all dependents (other than requestor) that it is OK.\"\n\n\tself dependents do: [:dep | (dep == requestor or: [dep updateRequest]) ifFalse: [^false]].\n\t^true\n",
          "updateRequest": "updateRequest\n\t\"Default behavior is to grant update requests;  a subclass might want to override\n\tthis behavior if it is in the middle of making another change.\"\n\n\t^ true\n",
          "changed:": "changed: aParameter\n\t\"Receiver changed.  The change is denoted by the argument aParameter.\n\tUsually the argument is a Symbol that is part of the dependent's change\n\tprotocol.  Inform all of the dependents.\"\n\n\tself dependents do: [:aDependent | aDependent update: aParameter]\n",
          "changeRequest": "changeRequest\n\t\"Receiver wants to change; check with all dependents that it is OK.\"\n\n\tself dependents do: [:dep | dep updateRequest ifFalse: [^false]].\n\t^true\n",
          "changed": "changed\n\t\"Receiver changed in a general way; inform all the dependents by sending\n\teach dependent an update: message.\"\n\n\tself changed: self\n",
          "broadcast:": "broadcast: aSymbol\n\t\"Send the argument, aSymbol, as a unary message to all of the receiver's dependents.\"\n\n\tself dependents ~~ nil\n\t\tifTrue: [self dependents do:\n\t\t\t\t\t[:aDependent | aDependent perform: aSymbol]]\n"
        },
        "testing": {
          "isNil": "isNil\n\t\"Coerces nil to true and everything else to false.  UndefinedObject\n\toverrides with ^true\"\n\n\t^false\n",
          "notNil": "notNil\n\t\"Coerces nil to false and everything else to true.  UndefinedObject\n\toverrides with ^false\"\n\n\t^true\n",
          "isInteger": "isInteger\n\t\"Coerces Integers to true and everything else to false.  Integer\n\toverrides with ^true\"\n\n\t^false\n"
        },
        "copying": {
          "deepCopy": "deepCopy\n\t\"Answer a copy of the receiver with its own copy of each instance variable.\"\n\n\t| newObject class index |\n\tclass _ self class.\n\t(class == Object) ifTrue: [^self].\n\tclass isVariable\n\t\tifTrue:\n\t\t\t[index _ self basicSize.\n\t\t\tnewObject _ class basicNew: index.\n\t\t\t[index > 0]\n\t\t\t\twhileTrue:\n\t\t\t\t\t[newObject basicAt: index put: (self basicAt: index) deepCopy.\n\t\t\t\t\tindex _ index - 1]]\n\t\tifFalse: [newObject _ class basicNew].\n\tindex _ class instSize.\n\t[index > 0]\n\t\twhileTrue:\n\t\t\t[newObject instVarAt: index put: (self instVarAt: index) deepCopy.\n\t\t\tindex _ index - 1].\n\t^newObject\n",
          "shallowCopy": "shallowCopy\n\t\"Answer a copy of the receiver which shares the receiver's instance\n\tvariables. \"\n\n\t| class newObject index |\n\tclass _ self class.\n\t\"I don't understand why the following check is here.  Object is not\n\tsupposed to have any instances at all.\"\n\tclass == Object ifTrue: [^self].\n\tclass isVariable\n\t\tifTrue:\n\t\t\t[index _ self basicSize.\n\t\t\tnewObject _ class basicNew: index.\n\t\t\t[index > 0]\n\t\t\t\twhileTrue:\n\t\t\t\t\t[newObject basicAt: index put: (self basicAt: index).\n\t\t\t\t\tindex _ index - 1]]\n\t\tifFalse: [newObject _ class basicNew].\n\tindex _ class instSize.\n\t[index > 0]\n\t\twhileTrue:\n\t\t\t[newObject instVarAt: index put: (self instVarAt: index).\n\t\t\tindex _ index - 1].\n\t^newObject\n",
          "copy": "copy\n\t\"Answer another instance just like the receiver. Subclasses typically override\n\tthis method;  they typically do not override shallowCopy\"\n\n\t^self shallowCopy\n"
        },
        "accessing": {
          "readFromString:": "readFromString: aString\n\t\"Create an object based on the contents of aString.\"\n\n\t^self readFrom: (ReadStream on: aString)\n",
          "at:put:": "at: index put: value\n\t\"Store the argument value in the indexable field of the receiver indicated by\n\tindex. Fail if the index is not an Integer or is out of bounds. Or fail if the\n\tvalue is not of the right type for this kind of collection. Answer the\n\tvalue that was stored. Essential. See documentation in Object metaclass.\"\n\n\t<primitive: 61>\n\tindex isInteger\n\t\tifTrue: [(index >= 1 and: [index <= self size])\n\t\t\t\t\tifTrue: [self errorImproperStore]\n\t\t\t\t\tifFalse: [self errorSubscriptBounds: index]].\n\t(index isKindOf: Number)\n\t\tifTrue: [^self at: index truncated put: value]\n\t\tifFalse: [self errorNonIntegerIndex]\n",
          "at:": "at: index\n\t\"Answer the value of an indexable field in the receiver. Fail if the\n\targument index is not an Integer or is out of bounds. Essential. See\n\tdocumentation in Object metaclass.\"\n\n\t<primitive: 60>\n\tindex isInteger\n\t\tifTrue: [self errorSubscriptBounds: index].\n\t(index isKindOf: Number)\n\t\tifTrue: [^self at: index truncated]\n\t\tifFalse: [self errorNonIntegerIndex]\n",
          "basicSize": "basicSize\n\t\"Answer the number of indexable fields in the receiver. This value is the\n\tsame as the largest legal subscript. Essential. See documentation in Object\n\tmetaclass. Do not override in any subclass.\"\n\n\t<primitive: 62>\n\t\"The number of indexable fields of fixed-length objects is 0\"\n\t^0\n",
          "yourself": "yourself\n\t\"Answer self.\"\n",
          "basicAt:put:": "basicAt: index put: value\n\t\"Store the second argument value in the indexable field of the receiver\n\tindicated by index. Fail if the index is not an Integer or is out of bounds. Or\n\tfail if the value is not of the right type for this kind of collection. Answer\n\tthe value that was stored. Essential. See documentation in Object\n\tmetaclass. Do not override in a subclass.\"\n\n\t<primitive: 61>\n\t(index isKindOf: Integer)\n\t\tifTrue: [(index >= 1 and: [index <= self size])\n\t\t\t\t\tifTrue: [self errorImproperStore]\n\t\t\t\t\tifFalse: [self errorSubscriptBounds: index]].\n\t(index isKindOf: Number)\n\t\tifTrue: [^self basicAt: index truncated put: value]\n\t\tifFalse: [self errorNonIntegerIndex]\n",
          "size": "size\n\t\"Answer the number of indexable fields in the receiver.  This value is the\n\tsame as the largest legal subscript.  Essential.  See documentation in Object\n\tmetaclass. \"\n\n\t<primitive: 62>\n\t\"The number of indexable fields of fixed-length objects is 0\"\n\t^0\n",
          "basicAt:": "basicAt: index\n\t\"Answer the value of an indexable field in the receiver. Fail if the\n\targument index is not an Integer or is out of bounds. Essential. See\n\tdocumentation in Object metaclass.  Do not override this message in any\n\tsubclass.\"\n\n\t<primitive: 60>\n\t(index isKindOf: Integer) ifTrue: [self errorSubscriptBounds: index].\n\t(index isKindOf: Number)\n\t\tifTrue: [^self basicAt: index truncated]\n\t\tifFalse: [self errorNonIntegerIndex]\n"
        },
        "private": {
          "errorNonIntegerIndex": "errorNonIntegerIndex\n\t\"Create an error notification that an improper object was used as an index.\"\n\n\tself error: 'only integers should be used as indices'\n",
          "mustBeBoolean": "mustBeBoolean\n\t\"Catches attempts to test truth of non-Booleans.  This message is sent from the\n\tinterpreter.\"\n\n\tself error: 'NonBoolean receiver--proceed for truth.'.\n\t^true\n",
          "setDependents": "setDependents\n\t\"Allocate the soft field for the receiver's dependents.\"\n\t| dependents |\n\tdependents _ OrderedCollection new.\n\tDependentsFields add: (Association key: self value: dependents).\n\t^ dependents\n",
          "forkEmergencyEvaluatorAt:": "forkEmergencyEvaluatorAt: priority\n\t\"Fork a process running a simple Smalltalk evaluator using as little of the system as possible.  Used for desperate debugging.  may be invoked by control-shift-C.\"\n\n\t| stream char |\n\t\t[Display white: (0@0 extent: 1024@36).\n\t\t'EMERGENCY EVALUATOR (priority ', priority printString, ') -- type an expression terminated by ESC' displayAt: 50@0.\n\t\tDisplay reverse: (0@0 extent: 1024@36).\n\t\tstream _ WriteStream on: String new.\n\t\t[[Sensor keyboardPressed] whileFalse.\n\t\t(char _ Sensor keyboard) = 160 asCharacter] whileFalse:\n\t\t\t[char = Character backspace\n\t\t\t\tifTrue: [stream skip: -1.  Display black: (0@18 extent: 1024@18)]\n\t\t\t\tifFalse: [stream nextPut: char].\n\t\t\tstream contents displayAt: 50@18].\n\t\tDisplay black: (0@0 extent: 1024@18).\n\t\t(Compiler evaluate: stream contents) printString displayAt: 50@0] forkAt: priority\n",
          "nilFields": "nilFields\n\t\"Store nil into all pointer fields of the receiver.\"\n\n\tself class isPointers ifFalse: [^self].\n\t1 to: self basicSize do:\n\t\t[:index | self basicAt: index put: nil].\n\t1 to: self class instSize do:\n\t\t[:index | self instVarAt: index put: nil].\n",
          "errorImproperStore": "errorImproperStore\n\t\"Create an error notification that an improper store was attempted.\"\n\n\tself error: 'Improper store into indexable object'\n",
          "errorSubscriptBounds:": "errorSubscriptBounds: index\n\t\"Create an error notification that an improper integer was used as an index.\"\n\n\tself error: 'subscript is out of bounds: ' , index printString\n",
          "breakDependents": "breakDependents\n\t\"Deallocate the soft field for the receiver's dependents.\"\n\n\tDependentsFields removeKey: self ifAbsent: []\n",
          "primitiveError:": "primitiveError: aString\n\t\"This method is called when the error handling results in a recursion in calling\n\ton error: or halt or halt:.\"\n\n\t| context key |\n\tTranscript cr.\n\tTranscript show: '**System Error Handling Failed** '.\n\tTranscript show: aString.\n\tTranscript cr.\n\tcontext _ thisContext sender sender.\n\t3 timesRepeat:\n\t\t[context == nil ifFalse: [Transcript print: (context _ context sender); cr]].\n\n\t[Transcript show: '**type <s> for more stack; anything else restarts scheduler**'.\n\tTranscript cr.\n\tkey _ Sensor keyboard.\n\tkey = $s | (key = $S)]\n\t\twhileTrue:\n\t\t\t[5 timesRepeat:\n\t\t\t\t[context == nil\n\t\t\t\t\tifFalse: [Transcript print: (context _ context sender); cr]]].\n\tScheduledControllers searchForActiveController\n",
          "species": "species\n\t\"Answer the preferred class for reconstructing the receiver.  For example,\n\tcollections create new collections whenever enumeration messages such as\n\tcollect: or select: are invoked.  The new kind of collection is determined by\n\tthe species of the original collection.  Species and class are not always the\n\tsame.  For example, the species of Interval is Array.\"\n\n\t^self class\n"
        },
        "initialize-release": {
          "release": "release\n\t\"Remove references to objects that may refer to the receiver. Answers self.\n\tThis message should be overidden by subclasses with any cycles, in which\n\tcase the subclass should also include the expression super release.\"\n\n\tself breakDependents\n"
        },
        "system primitives": {
          "become:": "become: otherObject\n\t\"Swap the instance pointers of the receiver and the argument, otherObject.  All\n\tvariables in the entire system that used to point to the receiver now point to the\n\targument, and vice-versa.  Fails if either object in a SmallInteger.  Answer the\n\targument which is now the same instance pointer that formerly denoted the receiver.  \tEssential.  See documentation in Object metaclass.\"\n\n\t<primitive: 72>\n\tself primitiveFailed\n",
          "asOop": "asOop\n\t\"Answer an Integer which is unique to me.  See below.\n\tEssential.  See also documentation in Object metaclass.\"\n\t<primitive: 75>\n\tself primitiveFailed\n\t\"\n\tNon-Stretch mapping between objects and asOop value:\n\toops 0...16K-1\t\t\t-->\t0...16K-1\n\toops 16K...32K-1\t\t\t-->\t-16K...-1\n\tSmallIntegers 0...16K\t\t-->\t32K...48K-1\n\tSmallIntegers -16K...0\t-->\t48K...64K-1\n\n\tStretch mapping between objects and asOop value:\n\toops 0...48K-1\t\t\t-->\t0...48K-1\n\tSmallIntegers -8K...-1\t-->\t-16K...-2 even\n\tSmallIntegers 0...8K-1\t-->\t-(16K-1)...-1 odd\n\n\tNon-Stretch Consistency check:\n\t| obj |\n\t-16384 to: 16383 do:\n\t\t[:i | obj _ i asObject.\n\t\t(obj == #NonExistentObject or: [obj asOop = i])\n\t\t\tifFalse: [self error: 'inconsistency']].\n\t32768 to: 65536 do:\n\t\t[:i | obj _ i asObject.\n\t\t(obj == #NonExistentObject or: [obj asOop = i])\n\t\t\tifFalse: [self error: 'inconsistency']].\n\n\tStretch Consistency check:\n\t| obj |\n\t-16384 to: 49151 do:\n\t\t[:i | obj _ i asObject.\n\t\t(obj == #NonExistentObject or: [obj asOop = i])\n\t\t\tifFalse: [self error: 'inconsistency']].\n\t\"\n",
          "instVarAt:": "instVarAt: index\n\t\"Answer a fixed variable in an object.  The numbering of the variables\n\tcorresponds to the named instance variables.  Fail if the index is not an\n\tInteger or is not the index of a fixed variable.  Essential.  See documentation in\n\tObject metaclass.\"\n\n\t<primitive: 73>\n\t\"Access beyond fixed variables.\"\n\t^self basicAt: index - self class instSize\n",
          "instVarAt:put:": "instVarAt: anInteger put: anObject\n\t\"Store a value into a fixed variable in the receiver.  The numbering of the variables\n\tcorresponds to the named instance variables.  Fail if the index is not an\n\tInteger or is not the index of a fixed variable.   Answer the value stored as the\n\tresult.  Using this message violates the principle that each object has\n\tsovereign control over the storing of values into its instance variables.\n\tEssential.  See documentation in Object metaclass.\"\n\n\t<primitive: 74>\n\t\"Access beyond fixed fields\"\n\t^self basicAt: anInteger - self class instSize put: anObject\n",
          "nextInstance": "nextInstance\n\t\"Answer the next instance after the receiver in the enumeration of all\n\tinstances of this class.  Fails if all instances have been enumerated.\n\tEssential.  See documentation in Object metaclass.\"\n\n\t<primitive: 78>\n\t^nil\n"
        },
        "error handling": {
          "subclassResponsibility": "subclassResponsibility\n\t\"This message sets up a framework for the behavior of the class' subclasses.\n\tAnnounce that the subclass should have implemented this message.\"\n\n\tself error: 'My subclass should have overridden one of my messages.'\n",
          "conflictingInheritanceError": "conflictingInheritanceError\n\t\"Browse to the method which called this,\n\t\tredefine it appropriately,\n\t\tand then restart that calling method. \"\n\n\tself error: 'Conflicting methods due to multiple inheritance'\n",
          "primitiveFailed": "primitiveFailed\n\t\"Announce that a primitive has failed and there is no appropriate\n\tSmalltalk code to run.\"\n\n\tself error: 'a primitive has failed'\n",
          "doesNotUnderstand:": "doesNotUnderstand: aMessage\n\t\"First check for a compound selector.  If found, try copying down code\n\tinto the receiver's class.  If this is unsuccessful,\n\tannounce that the receiver does not understand the argument, aMessage,\n\tas a message.  The default behavior is to create a Notifier containing the\n\tappropriate message and to allow the user to open a Debugger.\n\tSubclasses can override this message in order to modify this behavior.\"\n\t| status gripe |\n\n\tstatus _ self class tryCopyingCodeFor: aMessage selector.\n\tstatus==#OK ifTrue:\n\t\t[^self perform: aMessage selector withArguments: aMessage arguments].\n\n\tgripe _ status==#HierarchyViolation\n\t\tifTrue: [aMessage selector classPart , ' is not one of my superclasses: ']\n\t\tifFalse: ['Message not understood: '].\n\tNotifierView\n\t\topenContext: thisContext\n\t\tlabel: gripe , aMessage selector\n\t\tcontents: thisContext shortStack.\n\t\"Try the message again if the programmer decides to proceed.\"\n\t^self perform: aMessage selector withArguments: aMessage arguments\n\n\t\"3 zork.\"\n",
          "confirm:": "confirm: aString\n\t\"Create and start up a BinaryChoice menu with the argument as the message in order\n\tto determine true or false.  Answers true or false.\"\n\t| answer |\n\tanswer _ false.\n\tBinaryChoice\n\t\tmessage: aString\n\t\tdisplayAt: Sensor cursorPoint\n\t\tcentered: true\n\t\tifTrue: [answer _ true]\n\t\tifFalse: [answer _ false].\n\t^answer\n",
          "error:": "error: aString\n\t\"The default behavior for error: is the same as halt:.\n\tThis additional message is the one a subclass should override in order to\n\tchange the handling of errors.\"\n\n\tNotifierView\n\t\topenContext: thisContext\n\t\tlabel: aString\n\t\tcontents: thisContext shortStack\n\n\t\"nil error: 'error message'.\"\n",
          "halt:": "halt: aString\n\t\"This message can be used for inserting breakpoints during debugging.\n\tIt creates and schedules a Debugger with the argument, aString, as the label.\"\n\n\tNotifierView\n\t\topenContext: thisContext\n\t\tlabel: aString\n\t\tcontents: thisContext shortStack\n\n\t\"nil halt: 'Test of halt:.'.\"\n",
          "notify:": "notify: aString\n\t\"Create and schedule a Notifier with the argument as the message in order\n\tto request confirmation before a process can proceed.\"\n\n\n\tNotifierView\n\t\topenContext: thisContext\n\t\tlabel: 'Notifier'\n\t\tcontents: aString\n\n\t\"nil notify: 'confirmation message'.\"\n",
          "shouldNotImplement": "shouldNotImplement\n\t\"Announce that although the receiver inherits this message, it\n\tshould not implement it.\"\n\n\tself error: 'This message is not appropriate for this object'\n",
          "halt": "halt\n\t\"This is a simple message to use for inserting breakpoints during debugging.\"\n\n\tNotifierView\n\t\topenContext: thisContext\n\t\tlabel: 'Halt encountered.'\n\t\tcontents: thisContext shortStack\n\n\t\"nil halt.\"\n"
        },
        "user interface": {
          "inspect": "inspect\n\t\"Create and schedule an Inspector in which the user can examine the\n\treceiver's variables.\"\n\tself basicInspect\n",
          "basicInspect": "basicInspect\n\t\"Create and schedule an Inspector in which the user can examine the\n\treceiver's variables.  This method should not be overwritten.\"\n\n\tInspectorView open: (Inspector inspect: self)\n"
        },
        "message handling": {
          "perform:with:with:with:": "perform: aSymbol with: firstObject with: secondObject with: thirdObject\n\t\"Send the receiver the keyword message indicated by the arguments. The first\n\targument is the selector of the message. The other arguments are the\n\targuments of the message to be sent. Invoke messageNotUnderstood: if\n\tthe number of arguments expected by the selector is not three. Optional.\n\tSee documentation in Object metaclass.\"\n\n\t<primitive: 83>\n\t^self perform: aSymbol withArguments: (Array\n\t\t\twith: firstObject\n\t\t\twith: secondObject\n\t\t\twith: thirdObject)\n",
          "perform:with:with:": "perform: aSymbol with: firstObject with: secondObject\n\t\"Send the receiver the keyword message indicated by the arguments. The first\n\targument is the selector of the message. The other arguments are the\n\targuments of the message to be sent. Invoke messageNotUnderstood: if\n\tthe number of arguments expected by the selector is not two. Optional.\n\tSee documentation in Object metaclass.\"\n\n\t<primitive: 83>\n\t^self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)\n",
          "perform:withArguments:": "perform: selector withArguments: anArray\n\t\"Send the receiver the keyword message indicated by the arguments. The argument\n\tselector is the selector of the message. The arguments of the message are the\n\telements of anArray. Invoke messageNotUnderstood: if the number of\n\targuments expected by the selector is not the same as the length of\n\tanArray. Essential. See documentation in Object metaclass.\"\n\n\t<primitive: 84>\n\tself primitiveFailed\n",
          "perform:": "perform: aSymbol\n\t\"Send the receiver the unary message indicated by the argument. The argument is\n\tthe selector of the message. Invoke messageNotUnderstood: if the number of\n\targuments expected by the selector is not zero. Optional. See documentation\n\tin Object metaclass.\"\n\n\t<primitive: 83>\n\t^self perform: aSymbol withArguments: (Array new: 0)\n",
          "perform:with:": "perform: aSymbol with: anObject\n\t\"Send the receiver the keyword message indicated by the arguments. The first\n\targument is the selector of the message. The other argument is the\n\targument of the message to be sent. Invoke messageNotUnderstood: if the\n\tnumber of arguments expected by the selector is not one. Optional. See\n\tdocumentation in Object metaclass.\"\n\n\t<primitive: 83>\n\t^self perform: aSymbol withArguments: (Array with: anObject)\n"
        }
      }
    },
    "Boolean": {
      "comment": "I implement behavior common to true and false.\n",
      "class_name": "Boolean",
      "superclass": "Object",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\tself error: 'You may not create any more Booleans - this is two-valued logic'\n"
        }
      },
      "instance_methods": {
        "controlling": {
          "ifFalse:ifTrue:": "ifFalse: falseAlternativeBlock ifTrue: trueAlternativeBlock\n\t\"Same as ifTrue:ifFalse:\"\n\tself subclassResponsibility\n",
          "ifFalse:": "ifFalse: alternativeBlock\n\t\"If the receiver is true (i.e., the condition is true), then the value is the true\n\talternative, which is nil.  Otherwise answer the result of evaluating the argument,\n\talternativeBlock.  Create an error if the receiver is nonBoolean.  Execution does not\n\tactually reach here because the expression is compiled in-line.\"\n\tself subclassResponsibility\n",
          "and:": "and: alternativeBlock\n\t\"Nonevaluating conjunction -- if the receiver is true, answer the value of\n\tthe argument, alternativeBlock; otherwise answer false without evaluating the\n\targument.\"\n\tself subclassResponsibility\n",
          "ifTrue:ifFalse:": "ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock\n\t\"If the receiver is true (i.e., the condition is true), then answer the value of the\n\targument trueAlternativeBlock.  If the receiver is false, answer the result of\n\tevaluating the argument falseAlternativeBlock.  If the receiver is a nonBoolean\n\tthen create an error message.  Execution does not actually reach here because the\n\texpression is compiled in-line.\"\n\tself subclassResponsibility\n",
          "ifTrue:": "ifTrue: alternativeBlock\n\t\"If the receiver is false (i.e., the condition is false), then the value is the false\n\talternative, which is nil.  Otherwise answer the result of evaluating the argument,\n\talternativeBlock.  Create an error if the receiver is nonBoolean.  Execution does not\n\tactually reach here because the expression is compiled in-line.\"\n\tself subclassResponsibility\n",
          "or:": "or: alternativeBlock\n\t\"Nonevaluating disjunction -- if the receiver is false, answer the value of\n\tthe argument, alternativeBlock; otherwise answer true without evaluating the\n\targument.\"\n\tself subclassResponsibility\n"
        },
        "printing": {
          "storeOn:": "storeOn: aStream\n\tself printOn: aStream\n"
        },
        "copying": {
          "deepCopy": "deepCopy\n\t\"Receiver has two concrete subclasses, True and False.\n\tOnly one instance of each should be made, so return self.\"\n",
          "shallowCopy": "shallowCopy\n\t\"Receiver has two concrete subclasses, True and False.\n\tOnly one instance of each should be made, so return self.\"\n"
        },
        "logical operations": {
          "eqv:": "eqv: aBoolean\n\t\"Answer true if the receiver is equivalent to aBoolean.\"\n\n\t^self == aBoolean\n",
          "not": "not\n\t\"Negation-- answer true if the receiver is false, answer false if the receiver is true.\"\n\tself subclassResponsibility\n",
          "&": "& aBoolean\n\t\"Evaluating conjunction -- Evaluate the argument.  Then answer true if both the\n\treceiver and the argument are true.\"\n\tself subclassResponsibility\n",
          "xor:": "xor: aBoolean\n\t\"Exclusive OR -- answer true if the receiver is not equivalent to aBoolean.\"\n\n\t^(self == aBoolean) not\n",
          "|": "| aBoolean\n\t\"Evaluating disjunction (OR) -- Evaluate the argument.  Then answer true if\n\teither the receiver or the argument is true.\"\n\tself subclassResponsibility\n"
        }
      }
    },
    "True": {
      "comment": "I describe the behavior of my sole instance, true\n",
      "class_name": "True",
      "superclass": "Boolean",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "controlling": {
          "ifFalse:ifTrue:": "ifFalse: falseAlternativeBlock ifTrue: trueAlternativeBlock\n\t\"Answer the value of trueAlternativeBlock. Execution does not\n\tactually reach here because the expression is compiled in-line.\"\n\n\t^trueAlternativeBlock value\n",
          "ifFalse:": "ifFalse: alternativeBlock\n\t\"Since the condition is true, the value is the true alternative, which is nil.\n\tExecution does not actually reach here because the expression is compiled\n\tin-line.\"\n\n\t^nil\n",
          "and:": "and: alternativeBlock\n\t\"Nonevaluating conjunction -- answer the value of alternativeBlock since\n\tthe receiver is true.\"\n\n\t^alternativeBlock value\n",
          "ifTrue:ifFalse:": "ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock\n\t\"Answer with the value of trueAlternativeBlock. Execution does not\n\tactually reach here because the expression is compiled in-line.\"\n\n\t^trueAlternativeBlock value\n",
          "ifTrue:": "ifTrue: alternativeBlock\n\t\"Answer the value of alternativeBlock. Execution does not actually\n\treach here because the expression is compiled in-line.\"\n\n\t^alternativeBlock value\n",
          "or:": "or: alternativeBlock\n\t\"Nonevaluating disjunction -- answer true since the receiver is true.\"\n\n\t^self\n"
        },
        "printing": {
          "printOn:": "printOn: aStream\n\taStream nextPutAll: 'true'\n"
        },
        "logical operations": {
          "not": "not\n\t\"Negation--answer false since the receiver is true.\"\n\n\t^false\n",
          "&": "& alternativeObject\n\t\"Evaluating conjunction -- answer alternativeObject since receiver is true.\"\n\n\t^alternativeObject\n",
          "|": "| aBoolean\n\t\"Evaluating disjunction (OR) -- answer true since the receiver is true.\"\n\n\t^self\n"
        }
      }
    },
    "False": {
      "comment": "I describe the behavior of my sole instance, false\n",
      "class_name": "False",
      "superclass": "Boolean",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "controlling": {
          "ifFalse:ifTrue:": "ifFalse: falseAlternativeBlock ifTrue: trueAlternativeBlock\n\t\"Answer the value of falseAlternativeBlock. Execution does not\n\tactually reach here because the expression is compiled in-line.\"\n\n\t^falseAlternativeBlock value\n",
          "ifFalse:": "ifFalse: alternativeBlock\n\t\"Answer the value of alternativeBlock. Execution does not actually\n\treach here because the expression is compiled in-line.\"\n\n\t^alternativeBlock value\n",
          "and:": "and: alternativeBlock\n\t\"Nonevaluating conjunction -- answer with false since the receiver is false.\"\n\n\t^self\n",
          "ifTrue:ifFalse:": "ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock\n\t\"Answer the value of falseAlternativeBlock. Execution does not\n\tactually reach here because the expression is compiled in-line.\"\n\n\t^falseAlternativeBlock value\n",
          "ifTrue:": "ifTrue: alternativeBlock\n\t\"Since the condition is false, answer the value of the false alternative,\n\twhich is nil. Execution does not actually reach here because the\n\texpression is compiled in-line.\"\n\n\t^nil\n",
          "or:": "or: alternativeBlock\n\t\"Nonevaluating disjunction -- answer value of alternativeBlock.\"\n\n\t^alternativeBlock value\n"
        },
        "printing": {
          "printOn:": "printOn: aStream\n\t\"Print false.\"\n\taStream nextPutAll: 'false'\n"
        },
        "logical operations": {
          "not": "not\n\t\"Negation -- answer true since the receiver is false.\"\n\n\t^true\n",
          "&": "& alternativeObject\n\t\"Evaluating conjunction -- answer false since receiver is false.\"\n\n\t^self\n",
          "|": "| aBoolean\n\t\"Evaluating disjunction (OR) -- answer with the argument, aBoolean.\"\n\n\t^aBoolean\n"
        }
      }
    }
  },
  "Kernel-Processes": {
    "SharedQueue": {
      "comment": "I provide synchronized communication of arbitrary objects between Processes.  An object is sent by sending me the message nextPut: and received by sending me the message next.  If no object has been sent when a next message is sent, the Process requesting the object will be suspended until one is sent.\n",
      "class_name": "SharedQueue",
      "superclass": "Object",
      "instanceVariables": "contentsArray readPosition writePosition accessProtect readSynch",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t\"Answer a new instance of SharedQueue that has 10 elements.\"\n\n\t^self new: 10\n",
          "new:": "new: anInteger\n\t^super new init: anInteger\n"
        }
      },
      "instance_methods": {
        "testing": {
          "isEmpty": "isEmpty\n\t\"Answer whether any objects have been sent through the receiver\n\tand not yet received by anyone.\"\n\n\t^readPosition = writePosition\n"
        },
        "accessing": {
          "nextPut:": "nextPut: value\n\t\"Send value through the receiver.  If a Process has been suspended waiting to\n\treceive a value through the receiver, allow it to proceed.\"\n\n\taccessProtect\n\t\tcritical: [writePosition > contentsArray size\n\t\t\t\t\t\tifTrue: [self makeRoomAtEnd].\n\t\t\t\t contentsArray at: writePosition put: value.\n\t\t\t\t writePosition _ writePosition + 1].\n\treadSynch signal.\n\t^value\n",
          "peek": "peek\n\t\"Answer the object that was sent through the receiver first and has not yet\n\tbeen received by anyone but do not remove it from the receiver. If no object has\n\tbeen sent, suspend the requesting process until one is.\"\n\n\t| value |\n\taccessProtect\n\t\tcritical: [readPosition >= writePosition\n\t\t\t\t\tifTrue: [readPosition _ 1.\n\t\t\t\t\t\t\twritePosition _ 1.\n\t\t\t\t\t\t\tvalue _ nil]\n\t\t\t\t\tifFalse: [value _ contentsArray at: readPosition]].\n\t^value\n",
          "next": "next\n\t\"Answer the object that was sent through the receiver first and has not yet\n\tbeen received by anyone.  If no object has been sent, suspend the\n\trequesting process until one is.\"\n\n\t| value |\n\treadSynch wait.\n\taccessProtect\n\t\tcritical: [readPosition = writePosition\n\t\t\t\t\tifTrue:\n\t\t\t\t\t\t[self error: 'Error in SharedQueue synchronization'.\n\t\t\t\t\t\t value _ nil]\n\t\t\t\t\tifFalse:\n\t\t\t\t\t\t[value _ contentsArray at: readPosition.\n\t\t\t\t\t\t contentsArray at: readPosition put: nil.\n\t\t\t\t\t\t readPosition _ readPosition + 1]].\n\t^value\n",
          "size": "size\n\t\"Answer the number of objects that have been sent through the\n\treceiver and not yet received by anyone.\"\n\n\t^writePosition - readPosition\n"
        },
        "private": {
          "init:": "init: size\n\tcontentsArray _ Array new: size.\n\treadPosition _ 1.\n\twritePosition _ 1.\n\taccessProtect _ Semaphore forMutualExclusion.\n\treadSynch _ Semaphore new\n",
          "makeRoomAtEnd": "makeRoomAtEnd\n\t| contentsSize |\n\treadPosition = 1\n\t\tifTrue:\n\t\t\t[contentsArray grow]\n\t\tifFalse:\n\t\t\t[contentsSize _ writePosition - readPosition.\n\t\t\t1 to: contentsSize do:\n\t\t\t\t[:index |\n\t\t\t\tcontentsArray\n\t\t\t\t\tat: index\n\t\t\t\t\tput: (contentsArray at: index + readPosition - 1)].\n\t\t\treadPosition _ 1.\n\t\t\twritePosition _ contentsSize + 1]\n"
        },
        "initialize-release": {
          "release": "release\n\tcontentsArray _ nil\n"
        }
      }
    },
    "Semaphore": {
      "comment": "I provide synchronized communication of a single bit of information (a \"signal\") between Processes.  A signal is sent by sending me the message signal and received by sending me the message wait.  If no signal has been sent when a wait message is sent, the sending Process will be suspended until a signal is sent.\n",
      "class_name": "Semaphore",
      "superclass": "LinkedList",
      "instanceVariables": "excessSignals",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t\"Answer a new instance of Semaphore that contains no signals.\"\n\n\t^self basicNew initSignals\n",
          "forMutualExclusion": "forMutualExclusion\n\t\"Answer a new instance of me that contains a single signal.\n\tThis new instance can now be used for mutual exclusion (see the\n\tcritical: message to Semaphore).\"\n\n\t^self new signal\n"
        }
      },
      "instance_methods": {
        "mutual exclusion": {
          "critical:": "critical: mutuallyExcludedBlock\n\t\"Evaluate mutuallyExcludedBlock only if the receiver is not currently in the\n\tprocess of running the critical: message.  If the receiver is, evaluate\n\tmutuallyExcludedBlock after the other critical: message is finished.\"\n\n\t| blockValue |\n\tself wait.\n\tblockValue _ mutuallyExcludedBlock value.\n\tself signal.\n\t^blockValue\n"
        },
        "initialize-release": {
          "initSignals": "initSignals\n\t\"Consume any excess signals the receiver may have accumulated.\"\n\n\texcessSignals _ 0\n",
          "terminateProcess": "terminateProcess\n\tself isEmpty\n\t\tifFalse: [self removeFirst terminate]\n"
        },
        "communication": {
          "signal": "signal\n\t\"Send a signal through the receiver. If one or more processes have been\n\tsuspended trying to receive a signal, allow the first one to proceed. If no\n\tprocess is waiting, remember the excess signal. Essential. See Object documentation\n\twhatIsAPrimitive. \"\n\n\t<primitive: 85>\n\tself primitiveFailed\n\n\t\"self isEmpty\n\t\tifTrue: [excessSignals _ excessSignals+1]\n\t\tifFalse: [Processor resume: self removeFirstLink]\"\n",
          "wait": "wait\n\t\"The active Process must receive a signal through the receiver before\n\tproceeding.  If no signal has been sent, the active Process will be suspended\n\tuntil one is sent.  Essential.  See\n\tObject whatIsAPrimitive.\"\n\n\t<primitive: 86>\n\tself primitiveFailed\n\n\t\"excessSignals>0\n\t\tifTrue: [excessSignals _ excessSignals-1]\n\t\tifFalse: [self addLastLink: Processor activeProcess suspend]\"\n"
        }
      }
    },
    "ProcessorScheduler": {
      "comment": "Instance Variables:\n\t\tquiescentProcessLists\t\t<Array of LinkedLists> on which to suspend processes\n\t\tactiveProcess\t\t\t<Process> currently executing process\n\nMy single instance, named Processor, coordinates the use of the physical processor by all Processes requiring service\n",
      "class_name": "ProcessorScheduler",
      "superclass": "Object",
      "instanceVariables": "quiescentProcessLists activeProcess",
      "classInstanceVariables": "",
      "classVariables": "BackgroundProcess HighIOPriority LowIOPriority SystemBackgroundPriority SystemRockBottomPriority TimingPriority UserBackgroundPriority UserInterruptPriority UserSchedulingPriority",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\tSystemRockBottomPriority _ 1.\n\tSystemBackgroundPriority _ 2.\n\tUserBackgroundPriority _ 3.\n\tUserSchedulingPriority _ 4.\n\tUserInterruptPriority _ 5.\n\tLowIOPriority _ 6.\n\tHighIOPriority _ 7.\n\tTimingPriority _ 8\n\t\"ProcessorScheduler initialize.\"\n"
        },
        "background process": {
          "background:": "background: aBlock\n\t\"Replace the background process with a process running the code\n\tin aBlock.\"\n\n\tBackgroundProcess == nil ifFalse: [BackgroundProcess terminate].\n\tBackgroundProcess _ aBlock newProcess.\n\tBackgroundProcess priority: SystemRockBottomPriority.\n\tBackgroundProcess resume\n",
          "hiddenBackgroundProcess": "hiddenBackgroundProcess\n\t\"Install a default background process which is invisible.\"\n\n\tself background:\n\t\t[[true] whileTrue: []]\n",
          "sweepHandBackgroundProcess": "sweepHandBackgroundProcess\n\t\"Install the default background process which shows a sweeping circle\n\tof Xor-ed bits on the screen.\"\n\n\t| sweepHand |\n\tsweepHand _ Pen new.\n\tsweepHand defaultNib: 2.\n\tsweepHand combinationRule: 6.\n\tself background:\n\t\t[[true]\n\t\t\twhileTrue: [2 timesRepeat:\n\t\t\t\t\t\t\t[sweepHand north.\n\t\t\t\t\t\t\t36 timesRepeat:\n\t\t\t\t\t\t\t\t[sweepHand place: Display boundingBox topRight + (-25@25).\n\t\t\t\t\t\t\t\tsweepHand go: 20.\n\t\t\t\t\t\t\t\tsweepHand turn: 10]]]]\n"
        },
        "instance creation": {
          "new": "new\n\t\"New instances of ProcessorScheduler should not be created.\"\n\n\tself error:\n'New ProcessSchedulers should not be created since\nthe integrity of the system depends on a unique scheduler'\n"
        }
      },
      "instance_methods": {
        "timing": {
          "signal:atTime:": "signal: aSemaphore atTime: timeInterval\n\t\"Signal aSemaphore when the system's millisecond clock reaches\n\ttimeInterval (an Integer)\"\n\n\t| milliseconds |\n\t(timeInterval digitLength > 4 or: [timeInterval negative])\n\t\tifTrue: [self error: 'Can''t convert time to double word'].\n\tmilliseconds _ ByteArray new: 4.\n\tmilliseconds at: 1 put: (timeInterval digitAt: 1).\n\tmilliseconds at: 2 put: (timeInterval digitAt: 2).\n\tmilliseconds at: 3 put: (timeInterval digitAt: 3).\n\tmilliseconds at: 4 put: (timeInterval digitAt: 4).\n\t^self signal: aSemaphore atMilliseconds: milliseconds\n"
        },
        "accessing": {
          "activeProcess": "activeProcess\n\t\"Answer the currently running Process.\"\n\n\t^activeProcess\n",
          "highestPriority:": "highestPriority: newHighestPriority\n\t\"Change the number of priority levels currently available for use.\"\n\n\t| continue newProcessLists |\n\t(quiescentProcessLists size > newHighestPriority\n\t\tand: [self anyProcessesAbove: newHighestPriority])\n\t\t\tifTrue: [self error: 'There are processes with priority higher than '\n\t\t\t\t\t\t\t\t\t\t\t\t\t,newHighestPriority printString].\n\tnewProcessLists _ Array new: newHighestPriority.\n\t1 to: ((quiescentProcessLists size) min: (newProcessLists size)) do:\n\t\t[:priority | newProcessLists at: priority put: (quiescentProcessLists at: priority)].\n\tquiescentProcessLists size to: newProcessLists size do:\n\t\t[:priority | newProcessLists at: priority put: LinkedList new].\n\tquiescentProcessLists become: newProcessLists\n",
          "highestPriority": "highestPriority\n\t\"Answer the number of priority levels currently available for use.\"\n\n\t^quiescentProcessLists size\n",
          "activePriority": "activePriority\n\t\"Answer the priority level of the currently running Process.\"\n\n\t^activeProcess priority\n"
        },
        "private": {
          "anyProcessesAbove:": "anyProcessesAbove: highestPriority\n\t\"Do any instances of Process exist with higher priorities?\"\n\n\t^(Process allInstances select: [:aProcess | aProcess priority > highestPriority]) isEmpty\n",
          "signal:atMilliseconds:": "signal: aSemaphore atMilliseconds: milliseconds\n\t\"Signal the semaphore when the millisecond clock reaches the value of\n\tthe second argument.  The second argument is a byte indexable object at\n\tleast four bytes long (a 32-bit unsigned number with the low order\n\t8-bits stored in the byte with the lowest index).  Fail if the first\n\targument is neither a Semaphore nor nil.  Essential.  See Object\n\tdocumentation whatIsAPrimitive.\"\n\n\t<primitive: 100>\n\tself primitiveFailed\n"
        },
        "priority names": {
          "systemBackgroundPriority": "systemBackgroundPriority\n\t\"Answer the priority at which system background processes should\n\trun.  Examples are an incremental garbage collector or status checker.\"\n\n\t^SystemBackgroundPriority\n",
          "highIOPriority": "highIOPriority\n\t\"Answer the priority at which the most time critical input/output\n\tprocesses should run.  An example is the process handling input from a\n\tnetwork.\"\n\n\t^HighIOPriority\n",
          "userSchedulingPriority": "userSchedulingPriority\n\t\"Answer the priority at which the window scheduler should run.\"\n\n\t^UserSchedulingPriority\n",
          "timingPriority": "timingPriority\n\t\"Answer the priority at which the system processes keeping track of\n\treal time should run.\"\n\n\t^TimingPriority\n",
          "lowIOPriority": "lowIOPriority\n\t\"Answer the priority at which most input/output processes should run.\n\tExamples are the process handling input from the user (keyboard,\n\tpointing device, etc.) and the process distributing input from a network.\"\n\n\t^LowIOPriority\n",
          "userInterruptPriority": "userInterruptPriority\n\t\"Answer the priority at which user processes desiring immediate\n\tservice should run.  Processes run at this level will preempt the window\n\tscheduler and should, therefore, not consume the processor forever.\"\n\n\t^UserInterruptPriority\n",
          "userBackgroundPriority": "userBackgroundPriority\n\t\"Answer the priority at which user background processes should run.\"\n\n\t^UserBackgroundPriority\n"
        },
        "removing": {
          "remove:ifAbsent:": "remove: aProcess ifAbsent: aBlock\n\t\"Remove aProcess from the list on which it is waiting for the processor. If\n\tit is not waiting, evaluate aBlock.\"\n\n\t(quiescentProcessLists at: aProcess priority)\n\t\tremove: aProcess ifAbsent: aBlock.\n\t^aProcess\n"
        },
        "process state change": {
          "yield": "yield\n\t\"Give other Processes at the current priority a chance to run\"\n\n\t| semaphore |\n\tsemaphore _ Semaphore new.\n\t[semaphore signal] fork.\n\tsemaphore wait\n",
          "suspendFirstAt:ifNone:": "suspendFirstAt: aPriority ifNone: noneBlock\n\t\"Suspend the first Process that is waiting to run with priority aPriority.\n\tIf no Process is waiting, evaluate noneBlock\"\n\n\t| aList |\n\taList _ quiescentProcessLists at: aPriority.\n\taList isEmpty\n\t\tifTrue: [^noneBlock value]\n\t\tifFalse: [^aList first suspend]\n",
          "suspendFirstAt:": "suspendFirstAt: aPriority\n\t\"Suspend the first Process that is waiting to run with priority aPriority.\"\n\n\t^self suspendFirstAt: aPriority\n\t\t  ifNone: [self error: 'No Process to suspend']\n",
          "terminateActive": "terminateActive\n\t\"Terminate the process that is currently running.\"\n\n\tactiveProcess terminate\n"
        }
      }
    },
    "Delay": {
      "comment": "I represent a realtime delay in the execution of a Process.  See the howToUse message in the class messages.\n\nInstance Variables:\n\t\tdelayDuration\t\t<Integer> number of milliseconds to delay process\n\t\tresumptionTime\t\t<Integer> value of millisecond clock at which to resume\n\t\tdelaySemaphore\t\t<Semaphore> on which to delay process\n\t\tdelayInProgress\t\t<Boolean> true if delaying now\n",
      "class_name": "Delay",
      "superclass": "Object",
      "instanceVariables": "delayDuration resumptionTime delaySemaphore delayInProgress",
      "classInstanceVariables": "",
      "classVariables": "AccessProtect ActiveDelay SuspendedDelays TimingSemaphore",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initializeTimingProcess": "initializeTimingProcess\n\t[[true]\n\t\twhileTrue:\n\t\t\t[TimingSemaphore wait.\n\t\t\tActiveDelay delayInProgress: false.\n\t\t\tAccessProtect wait.\n\t\t\tActiveDelay resume.\n\t\t\tSuspendedDelays isEmpty\n\t\t\t\tifTrue: [ActiveDelay _ nil]\n\t\t\t\tifFalse: [SuspendedDelays removeFirst activate].\n\t\t\tAccessProtect signal]]\n\t\tforkAt: Processor timingPriority\n",
          "initialize": "initialize\n\t\"Initialize class variables that keep track of active Delays.\"\n\n\tTimingSemaphore _ Semaphore new.\n\tAccessProtect _ Semaphore forMutualExclusion.\n\tSuspendedDelays _\n\t\tSortedCollection sortBlock:\n\t\t\t[:oldDelay :addedDelay |\n\t\t\toldDelay resumptionTime <= addedDelay resumptionTime].\n\tActiveDelay _ nil.\n\tself initializeTimingProcess\n\t\"Delay initialize.\"\n"
        },
        "documentation": {
          "howToUse": "howToUse\n\t\"An instance of Delay will respond to the message #wait by\n\tsuspending the active process for a certain amount of time.\n\n\tThe time for resumption of the active process is specified\n\twhen the Delay is created.\n\n\tThe resumption time can be specified relative to the current\n\ttime with the messages {Delay forMilliseconds: anInteger} and\n\t{Delay forSeconds: anInteger}.\n\tDelays created in this way can be sent the message #wait\n\tagain after they have finished a previous delay.\n\n\tThe resumption time can also be specified at an absolute time\n\twith respect to the system's millisecond clock with the message\n\t{Delay untilMillisecond: anInteger}.\n\tDelays created in this way cannot be sent the message #wait\n\trepeatedly.\n\t\"\n"
        },
        "snapshots": {
          "postSnapshot": "postSnapshot\n\tActiveDelay~~nil\n\t\tifTrue: [ActiveDelay postSnapshot.\n\t\t\t\t  SuspendedDelays do: [ :delay | delay postSnapshot].\n\t\t\t\t  ActiveDelay reactivate].\n\tAccessProtect signal\n",
          "preSnapshot": "preSnapshot\n\tAccessProtect wait.\n\tActiveDelay~~nil\n\t\tifTrue: [ActiveDelay preSnapshot].\n\tSuspendedDelays do:\n\t\t[ :delay | delay preSnapshot]\n"
        },
        "instance creation": {
          "forSeconds:": "forSeconds: secondCount\n\t\"Answer a new instance that will delay the active process for secondCount seconds when sent the message wait.\"\n\n\t^self new delay: (secondCount * 1000) rounded\n",
          "untilMilliseconds:": "untilMilliseconds: millisecondCount\n\t\"Answer a new instance that will delay the active process until the\n\tsystem's millisecond clock value is millisecondCount when sent the\n\tmessage wait.\"\n\n\t^self new resumption: millisecondCount\n",
          "forMilliseconds:": "forMilliseconds: millisecondCount\n\t\"Answer a new instance that will delay the active process for\n\tmillisecondCount milliseconds when sent the message wait.\"\n\n\t^self new delay: millisecondCount\n"
        },
        "testing": {
          "testAbsoluteDelayOf:for:label:": "testAbsoluteDelayOf: delay for: testCount label: label\n\t| time |\n\ttime _ Delay millisecondClockValue.\n\t[1 to: testCount do:\n\t\t[:index |\n\t\t(Delay untilMilliseconds: time + (index * delay)) wait.\n\t\tTranscript show: label.\n\t\tTranscript show: index printString.\n\t\tTranscript space]]\n\t\tforkAt: Processor userInterruptPriority\n\n\t\"Transcript cr.\n\t Delay testAbsoluteDelayOf: 1000 for: 10 label: 'A'.\n\t Delay testAbsoluteDelayOf: 1500 for: 10 label: 'B'.\n\t\"\n",
          "testRelativeDelayOf:for:label:": "testRelativeDelayOf: delay for: testCount label: label\n\t| myDelay |\n\tmyDelay _ Delay forMilliseconds: delay.\n\t[1 to: testCount do:\n\t\t[:index |\n\t\tmyDelay wait.\n\t\tTranscript show: label.\n\t\tTranscript show: index printString.\n\t\tTranscript space]]\n\t\tforkAt: Processor userInterruptPriority\n\n\t\"Transcript cr.\n\t Delay testRelativeDelayOf: 1000 for: 10 label: 'A'.\n\t Delay testRelativeDelayOf: 1500 for: 10 label: 'B'.\n\t\"\n"
        },
        "general inquiries": {
          "millisecondClockValue": "millisecondClockValue\n\t\"Answer the current value of the system's millisecond clock.\"\n\n\t^Time millisecondClockValue\n"
        }
      },
      "instance_methods": {
        "process delay": {
          "disable": "disable\n\tAccessProtect wait.\n\tdelayInProgress ifTrue:\n\t\t[ActiveDelay == self\n\t\t\tifTrue: [SuspendedDelays isEmpty\n\t\t\t\t\t\tifTrue: [Processor signal: nil atTime: 0.\n\t\t\t\t\t\t\t\tActiveDelay _ nil]\n\t\t\t\t\t\tifFalse: [SuspendedDelays removeFirst activate]]\n\t\t\tifFalse: [SuspendedDelays remove: self].\n\t\tdelaySemaphore terminateProcess.\n\t\tdelayInProgress _ false].\n\tAccessProtect signal\n",
          "wait": "wait\n\t\"Suspend the active process for an amount of time specified when the receiver\n\twas initialized.\"\n\n\tAccessProtect wait.\n\tself setResumption.\n\tActiveDelay == nil\n\t\tifTrue: [self activate]\n\t\tifFalse: [resumptionTime < ActiveDelay resumptionTime\n\t\t\t\tifTrue:\n\t\t\t\t\t[SuspendedDelays add: ActiveDelay.\n\t\t\t\t\tself activate]\n\t\t\t\tifFalse: [SuspendedDelays add: self]].\n\tAccessProtect signal.\n\tdelaySemaphore wait\n"
        },
        "accessing": {
          "resumptionTime": "resumptionTime\n\t\"Answer the value of the system's millisecondClock at which the receiver's\n\tsuspended Process will resume.\"\n\n\t^resumptionTime\n"
        },
        "private": {
          "postSnapshot": "postSnapshot\n\t| pendingDelay |\n\tdelayInProgress\n\t\tifTrue:\n\t\t\t[resumptionTime == nil\n\t\t\t\tifTrue: [self error: 'uninitialized Delay']\n\t\t\t\tifFalse: [\"convert from milliseconds since Jan. 1 1901 to local millisecond clock\"\n\t\t\t\t\t\tpendingDelay _ resumptionTime - (Time totalSeconds * 1000).\n\t\t\t\t\t\tpendingDelay _ pendingDelay max: 0.\n\t\t\t\t\t\tresumptionTime _ Time millisecondClockValue + pendingDelay]]\n\n\t\t\"if false then this delay must be ready and waiting (on AccessProtect) to resume\"\n",
          "setResumption": "setResumption\n\tdelayInProgress\n\t\tifTrue: [self error: 'This Delay is already waiting']\n\t\tifFalse:\n\t\t\t[delayDuration == nil\n\t\t\t\tifTrue: [resumptionTime == nil ifTrue: [self error: 'uninitialized Delay']]\n\t\t\t\tifFalse: [resumptionTime _ Time millisecondClockValue + delayDuration].\n\t\t\tdelayInProgress _ true]\n",
          "delay:": "delay: millisecondCount\n\tdelayDuration _ millisecondCount.\n\tdelayInProgress _ false.\n\tdelaySemaphore _ Semaphore new\n",
          "activate": "activate\n\t\"For the moment, the receiver will be the next Delay to resume the\n\treciever's suspended process.\"\n\n\tActiveDelay _ self.\n\tTimingSemaphore initSignals.\n\tProcessor signal: TimingSemaphore atTime: resumptionTime\n",
          "delayInProgress:": "delayInProgress: aBoolean\n\n\tdelayInProgress _ aBoolean\n",
          "preSnapshot": "preSnapshot\n\t| pendingDelay |\n\tdelayInProgress\n\t\tifTrue:\n\t\t\t[resumptionTime == nil\n\t\t\t\tifTrue: [self error: 'uninitialized Delay']\n\t\t\t\tifFalse: [\"convert from local millisecond clock to milliseconds since Jan. 1 1901\"\n\t\t\t\t\t\tpendingDelay _ resumptionTime - Time millisecondClockValue.\n\t\t\t\t\t\tresumptionTime _ Time totalSeconds * 1000 + pendingDelay]]\n\t\tifFalse:\n\t\t\t[self error: 'This Delay is not waiting']\n",
          "resume": "resume\n\t\"The receiver's delay duration has expired, the process the receiver\n\tsuspended will resume now. \"\n\n\tProcessor signal: nil atTime: 0.\n\tdelayInProgress _ false.\n\tdelaySemaphore signal\n",
          "resumption:": "resumption: millisecondCount\n\tdelayDuration _ nil.\n\tresumptionTime _ millisecondCount.\n\tdelayInProgress _ false.\n\tdelaySemaphore _ Semaphore new\n",
          "reactivate": "reactivate\n\t\"Make sure the timer is armed to go off for this delay.\"\n\n\tdelayInProgress ifTrue:\n\t\t[TimingSemaphore initSignals.\n\t\tProcessor signal: TimingSemaphore atTime: resumptionTime]\n\n\t\"if false then the timer has already fired for this delay and it is waiting (on AccessProtect) to resume\"\n"
        }
      }
    },
    "Process": {
      "comment": "Instance Variables:\n\t\tsuspendedContext\t<Context> activeContext at time of process suspension\n\t\tpriority\t\t\t\t<Integer> partial indication of relative scheduling\n\t\tmyList\t\t\t\t<LinkedList> on which I am suspended\n\nI represent an independent path of control in the system.  This path of control may be stopped (by sending me the message suspend) in such a way that it can later be restarted (by sending me the message restore).  When any one of several paths of control can be advanced, the single instance of ProcessorScheduler named Processor determines which one will actually be advanced partly using my priority.\n",
      "class_name": "Process",
      "superclass": "Link",
      "instanceVariables": "suspendedContext priority myList",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "forContext:priority:": "forContext: aContext priority: anInteger\n\t\"Answer an instance of me that has suspended aContext at priority anInteger.\"\n\n\t| newProcess |\n\tnewProcess _ self new.\n\tnewProcess suspendedContext: aContext.\n\tnewProcess priority: anInteger.\n\t^newProcess\n"
        }
      },
      "instance_methods": {
        "printing": {
          "printOn:": "printOn: aStream\n\tsuper printOn: aStream.\n\taStream nextPutAll: ' in '.\n\tsuspendedContext printOn: aStream\n"
        },
        "accessing": {
          "suspendingList": "suspendingList\n\t\"Answer the list on which the receiver has been suspended.\"\n\t^myList\n",
          "priority:": "priority: anInteger\n\t\"Set the receiver's priority to anInteger.\"\n\n\tanInteger<=Processor highestPriority\n\t\tifTrue: [priority _ anInteger]\n\t\tifFalse: [self error: 'priority too high']\n",
          "offList": "offList\n\t\"Inform the receiver that it has been taken off a list that it was suspended\n\ton.  This is to break a backpointer.\"\n\n\tmyList _ nil\n",
          "priority": "priority\n\t\"Answer the priority of the receiver.\"\n\t^priority\n",
          "suspendedContext": "suspendedContext\n\t\"Answer the context the receiver has suspended.\"\n\t^suspendedContext\n"
        },
        "private": {
          "suspendedContext:": "suspendedContext: aContext\n\tsuspendedContext _ aContext\n"
        },
        "changing process state": {
          "suspend": "suspend\n\t\"Stop the process that the receiver represents in such a way that it can be\n\trestarted at a later time (by sending the receiver the message resume). If\n\tthe receiver represents the activeProcess, suspend it. Otherwise fail and\n\tthe code below will remove the receiver from the list of waiting\n\tprocesses. Essential. See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 88>\n\tProcessor activeProcess == self\n\t\tifTrue: [self primitiveFailed]\n\t\tifFalse:\n\t\t\t[Processor remove: self ifAbsent: [self error: 'This process was not active'].\n\t\t\tmyList _ nil]\n",
          "terminate": "terminate\n\t\"Perhaps this method should be primitive.  If the a process might run at\n\tany moment (like a Delay), and another process is trying to terminate it,\n\tthere is a race condition in this method.  The remove:ifAbsent: may get\n\tconfused.  One way to avoid this is to let Delays terminate themselves.\n\tSee MessageTally spyEvery:on: for an example. \"\n\n\t| context |\n\tProcessor activeProcess == self\n\t\tifTrue:\n\t\t\t[thisContext sender == nil ifFalse: [thisContext sender release].\n\t\t\tthisContext removeSelf suspend]\n\t\tifFalse:\n\t\t\t[\"remove me first, then destroy me\"\n\t\t\tmyList == nil\n\t\t\t\tifFalse:\n\t\t\t\t\t[myList remove: self ifAbsent: [].\n\t\t\t\t\tmyList _ nil].\n\t\t\tcontext _ suspendedContext.\n\t\t\tsuspendedContext _ nil.\n\t\t\t(context ~~ nil and: [context sender ~~ nil])\n\t\t\t\tifTrue: [context sender release]]\n",
          "resume": "resume\n\t\"Allow the process that the receiver represents to continue. Put the receiver\n\tin line to become the activeProcess. Fail if the receiver is already waiting\n\tin a queue (in a Semaphore or ProcessScheduler). Essential. See Object\n\tdocumentation whatIsAPrimitive.\"\n\n\t<primitive: 87>\n\tself primitiveFailed\n"
        },
        "changing suspended state": {
          "install:": "install: aContext\n\t\"Replace the suspendedContext with aContext.\"\n\n\tself == Processor activeProcess\n\t\tifTrue: [^self error: 'The active process cannot install contexts'].\n\tsuspendedContext _ aContext\n",
          "popTo:": "popTo: aContext\n\t\"Replace the suspendedContext with aContext, releasing all contexts\n\tbetween the currently suspendedContext and it.\"\n\n\tself == Processor activeProcess\n\t\tifTrue: [^self error: 'The active process cannot pop contexts'].\n\tsuspendedContext releaseTo: aContext.\n\tsuspendedContext _ aContext\n"
        }
      }
    }
  },
  "Kernel-Support": {
    "SystemOrganizer": {
      "comment": "Provides an organization for the classes in the system just as ClassOrganizer organizes the messages within a class.  The only difference is the filout/printing messages.\n",
      "class_name": "SystemOrganizer",
      "superclass": "ClassOrganizer",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "fileIn/Out": {
          "printOutCategory:": "printOutCategory: category\n\t\"Create a file with readable version of the classes in this category.\n\tDefault to fileOut.\"\n\n\tself fileOutCategory: category\n",
          "superclassOrder:": "superclassOrder: category\n\t\"Answer an ordered collection containing the classes in category (a string).\n\tThe classes are ordered with superclasses first so they can be filed in.\"\n\t| list |\n\tlist _\n\t\t(self listAtCategoryNamed: category asSymbol)\n\t\t\tcollect: [:title | Smalltalk at: title].\n\t^ ChangeSet superclassOrder: list\n",
          "fileOutCategory:on:": "fileOutCategory: category on: aFileStream\n\t| class first |\n\tfirst _ true.\n\t(self superclassOrder: category) do:\n\t\t[:class |\n\t\tfirst\n\t\t\tifTrue: [first _ false]\n\t\t\tifFalse: [aFileStream cr; nextPut: Character newPage; cr].\n\t\tclass\n\t\t\tfileOutOn: aFileStream\n\t\t\tmoveSource: false\n\t\t\ttoFile: 0.\n\t\tclass removeFromChanges]\n",
          "fileOutCategory:": "fileOutCategory: category\n\t| aFileStream |\n\taFileStream _ Disk file: (category , '.st.') asFileName.\n\tself fileOutCategory: category on: aFileStream.\n\taFileStream shorten; close\n"
        },
        "accessing": {
          "changeFromString:": "changeFromString: aString\n\t\"Intercept to notify the system change set of the system reorganization.\"\n\n\t| file |\n\tSourceFiles == nil\n\t\tifFalse:\n\t\t\t[file _ SourceFiles at: 2.\n\t\t\tfile setToEnd; readWriteShorten.\n\t\t\tfile cr; nextChunkPut: 'SystemOrganization changeFromString: ',\n\t\t\t\t\tSystemOrganization printString storeString.\n\t\t\tfile cr; readOnly].\n\tSmalltalk changes reorganizeSystem.\n\tsuper changeFromString: aString.\n"
        }
      }
    },
    "ClassCategoryReader": {
      "comment": "Instance Variables:\n\tclass\t\t<ClassDescription> the class being read in\n\tcategory\t<String> the category for methods being read in\n\nI am created during fileIn in response to \"class methodsFor: cat\" message.  I subsequently scan consecutive \"chunks\" from the fileIn stream and ask class to compile them in this category.  I continue in this way until an empty chunk is found.\n",
      "class_name": "ClassCategoryReader",
      "superclass": "Object",
      "instanceVariables": "class category",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "class:category:": "class: aClass category: aCategory\n\t\"Answer a new instance of ClassCategoryReader for the category,\n\taCategory, of the class, aClass.\"\n\n\t^self new setClass: aClass category: aCategory\n"
        }
      },
      "instance_methods": {
        "fileIn/Out": {
          "scanFrom:": "scanFrom: aStream\n\t\"Files in methods from the stream, aStream.  Prints the name and\n\tcategory of the methods in the transcript view.\"\n\n\t| string |\n\t[string _ aStream nextChunk.\n\tstring size > 0]\t\t\t\t\t\t\"done when double terminators\"\n\t\twhileTrue: [class compile: string classified: category].\n\tTranscript show: class name , '<' , category , '\n'\n"
        },
        "private": {
          "setClass:category:": "setClass: aClass category: aCategory\n\tclass _ aClass.\n\tcategory _ aCategory\n"
        }
      }
    },
    "RemoteString": {
      "comment": "Instance Variables:\n\tsourceFileNumber\t<Integer> index into SourceFiles\n\tfilePositionHi\t\t<Integer>\n\tfilePositionLo\t\t<Integer>\n\nI hold the file reference to the class comment (or any other piece of executable text).\n",
      "class_name": "RemoteString",
      "superclass": "Object",
      "instanceVariables": "sourceFileNumber filePositionHi filePositionLo",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "newFileNumber:position:": "newFileNumber: sourceIndex position: anInteger\n\t\"Answer a new instance of RemoteString for file indexed by sourceIndex,\n\tat the position anInteger.  Assumes that the string is already stored\n\ton the file and the instance will be used to access it.\"\n\n\t^self new fileNumber: sourceIndex position: anInteger\n",
          "newString:onFileNumber:": "newString: aString onFileNumber: sourceIndex\n\t\"Answer a new instance of RemoteString for string, aString, on file indexed by\n\tsourceIndex.  Puts the string on the file and creates the remote reference.\"\n\n\t^self new string: aString onFileNumber: sourceIndex\n",
          "newString:onFileNumber:toFile:": "newString: aString onFileNumber: sourceIndex toFile: aFileStream\n\t\"Answer a new instance of RemoteString for string, aString, on file indexed by\n\tsourceIndex.  Puts the string on the file, aFileStream, and creates the remote\n\treference.  Assumes that the index corresponds properly to aFileStream.\"\n\n\t^self new string: aString onFileNumber: sourceIndex toFile: aFileStream\n"
        }
      },
      "instance_methods": {
        "accessing": {
          "sourceFileNumber": "sourceFileNumber\n\t\"Answer the index of the file on which the string is stored.\"\n\t^sourceFileNumber\n",
          "position": "position\n\t\"Answer the location of the string on a file.\"\n\n\t^(filePositionHi bitShift: 8) + filePositionLo\n",
          "string": "string\n\t\"Answer the receiver's string if remote files are enabled.\"\n\n\t| theFile |\n\t(SourceFiles == nil or: [sourceFileNumber == nil])\n\t\tifTrue: [^'']\n\t\tifFalse:\n\t\t\t[theFile _ SourceFiles at: sourceFileNumber.\n\t\t\ttheFile position: (filePositionHi bitShift: 8) + filePositionLo.\n\t\t\t^theFile nextChunk]\n"
        },
        "private": {
          "string:onFileNumber:toFile:": "string: aString onFileNumber: anInteger toFile: aFileStream\n\t\"Store this as the receiver's string if source files exist.\"\n\n\t| position |\n\tsourceFileNumber _ anInteger.\n\tfilePositionHi _ (position _ aFileStream position) bitShift: -8.\n\tfilePositionLo _ position bitAnd: 255.\n\taFileStream nextChunkPut: aString\n",
          "fileNumber:position:": "fileNumber: sourceIndex position: anInteger\n\tsourceFileNumber _ sourceIndex.\n\tfilePositionHi _ anInteger bitShift: -8.\n\tfilePositionLo _ anInteger bitAnd: 255\n",
          "string:onFileNumber:": "string: aString onFileNumber: anInteger\n\t\"Store this as my string if source files exist\"\n\n\t| theFile |\n\tSourceFiles == nil\n\t\tifFalse:\n\t\t\t[theFile _ SourceFiles at: anInteger.\n\t\t\ttheFile setToEnd; readWriteShorten; cr.\n\t\t\tself string: aString\n\t\t\t\tonFileNumber: anInteger\n\t\t\t\ttoFile: theFile.\n\t\t\ttheFile readOnly]\n"
        }
      }
    },
    "ClassOrganizer": {
      "comment": "Instance variables:\n\tglobalComment\t\t<RemoteString> comment for the class as a whole\n\tcategoryArray\t\t<Array of: String> category names\n\tcategoryStops\t\t<Array of: Integer> see below\n\telementArray\t\t<Array of: Symbol> message selectors\n\nClassOrganizers contain the categorization information for classes.  A ClassOrganizer consists of an Array of category names (categoryArray), each of which refers to an Array of elements (elementArray).  This association is made through an Array of stop indices (categoryStops), each of which is the index in elementArray of the last element (if any) of the corresponding category.\n\tFor example:\n\t\tcategories _ Array with: #firstCat with: secondCat with: thirdCat\n\t\tstops _ Array with: 1 with: 4 with: 4\n\t\telements _ Array with: #a with: #b with: #c with: #d\n\tmeans that category firstCat has ony #a, secondCat has #b, #c, and #d,\n\t\tand thirdCat has no elements.\n\tThis means that stops at: stops size must be the same as elements size.\n",
      "class_name": "ClassOrganizer",
      "superclass": "Object",
      "instanceVariables": "globalComment categoryArray categoryStops elementArray",
      "classInstanceVariables": "",
      "classVariables": "Default",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "defaultProtocol": "defaultProtocol\n\t^Default\n",
          "initialize": "initialize\n\tDefault _ 'As yet unclassified' asSymbol\n\t\"ClassOrganizer initialize\"\n"
        },
        "instance creation": {
          "new": "new\n\t\"Answer a new instance of ClassOrganizer with no initial elements.\"\n\t^super new setDefaultList\n"
        }
      },
      "instance_methods": {
        "fileIn/Out": {
          "scanFrom:": "scanFrom: aStream\n\t\"Reads in the organization from the next chunk on aStream.  Categories or elements not found in the definition are not affected.  New elements are ignored.\"\n\n\tself changeFromString: aStream nextChunk\n"
        },
        "comment": {
          "classComment:": "classComment: aString\n\t\"Store the comment, aString, associated with the object that refers to the receiver.\"\n\n\taString size = 0\n\t\tifTrue: [globalComment _ nil]\n\t\tifFalse: [globalComment _ RemoteString newString: aString onFileNumber: 2]\n",
          "classComment": "classComment\n\t\"Answer the comment associated with the object that refers to the receiver.\"\n\n\tglobalComment == nil ifTrue: [^''].\n\t^globalComment string\n",
          "hasNoComment": "hasNoComment\n\t\"Answer whether the class classified by the receiver has a comment.\"\n\n\t^globalComment == nil\n",
          "moveChangedCommentToFile:numbered:": "moveChangedCommentToFile: aFileStream numbered: sourceIndex\n\t\"This is part of source code compression.  Move the comment about the\n\tclass classified by the receiver from the file referenced by\n\tsourceIndex and to the stream, aFileStream.\"\n\n\t(globalComment ~~ nil and: [globalComment sourceFileNumber > 1])\n\t\tifTrue:\n\t\t\t[aFileStream cr; cr.\n\t\t\tglobalComment _\n\t\t\t\tRemoteString\n\t\t\t\t\tnewString: globalComment string\n\t\t\t\t\tonFileNumber: sourceIndex\n\t\t\t\t\ttoFile: aFileStream]\n",
          "putCommentOnFile:numbered:moveSource:": "putCommentOnFile: aFileStream numbered: sourceIndex moveSource: moveSource\n\t\"Store the comment about the class onto file, aFileStream.\"\n\n\t| newRemoteString saveEmphasis |\n\tsaveEmphasis _ aFileStream emphasis.\n\taFileStream emphasis: 3.\t\t\"meant to be 10 point italic font\"\n\tglobalComment ~~ nil\n\t\tifTrue:\n\t\t\t[aFileStream cr.\n\t\t\tnewRemoteString _\n\t\t\t\tRemoteString\n\t\t\t\t\t\tnewString: globalComment string\n\t\t\t\t\t\tonFileNumber: sourceIndex\n\t\t\t\t\t\ttoFile: aFileStream.\n\t\t\tmoveSource ifTrue: [globalComment _ newRemoteString]].\n\taFileStream emphasis: saveEmphasis.\n"
        },
        "printing": {
          "printOn:": "printOn: aStream\n\t| elementIndex lastStop |\n\telementIndex _ 1.\n\tlastStop _ 1.\n\t1 to: categoryArray size do:\n\t\t[:i |\n\t\taStream nextPut: $(.\n\t\t(categoryArray at: i) asString printOn: aStream.\n\t\t[elementIndex <= (categoryStops at: i)]\n\t\t\twhileTrue:\n\t\t\t\t[aStream space.\n\t\t\t\t(elementArray at: elementIndex) printOn: aStream.\n\t\t\t\telementIndex _ elementIndex + 1].\n\t\taStream nextPut: $).\n\t\taStream cr]\n"
        },
        "elements": {
          "removeElement:": "removeElement: element\n\t\"Remove the selector, element, from all categories.\"\n\n\t| categoryIndex elementIndex nextStop newElements |\n\tcategoryIndex _ 1.\n\telementIndex _ 0.\n\tnextStop _ 0.\n\t\"nextStop keeps track of the stops in the new element array\"\n\tnewElements _ WriteStream on: (Array new: elementArray size).\n\t[(elementIndex _ elementIndex + 1) <= elementArray size]\n\t\twhileTrue:\n\t\t\t[[elementIndex > (categoryStops at: categoryIndex)]\n\t\t\t\twhileTrue:\n\t\t\t\t\t[categoryStops at: categoryIndex put: nextStop.\n\t\t\t\t\tcategoryIndex _ categoryIndex + 1].\n\t\t\telement = (elementArray at: elementIndex)\n\t\t\t\tifFalse:\n\t\t\t\t\t[nextStop _ nextStop + 1.\n\t\t\t\t\tnewElements nextPut: (elementArray at: elementIndex)]].\n\t[categoryIndex <= categoryStops size]\n\t\twhileTrue:\n\t\t\t[categoryStops at: categoryIndex put: nextStop.\n\t\t\tcategoryIndex _ categoryIndex + 1].\n\telementArray _ newElements contents\n",
          "classify:under:": "classify: element under: heading\n\t\"Store the argument, element, in the category named heading.\"\n\n\t| catName catIndex elemIndex realHeading |\n\trealHeading _ heading asSymbol.\n\n\t(catName _ self categoryOfElement: element) ~~ nil\n\t\tifTrue:  \"Element already there\"\n\t\t\t[realHeading = Default ifTrue: [^self].\t\"Default causes no change\"\n\t\t\trealHeading = catName ifTrue: [^self].\t\"heading didnt change\"\n\t\t\tself removeElement: element].\t\"remove from old heading if did change\"\n\n\t(categoryArray indexOf: realHeading) = 0 ifTrue: [self addCategory: realHeading].\n\t\"add realHeading if not there already\"\n\n\tcatIndex _ categoryArray indexOf: realHeading.\n\telemIndex _\n\t\tcatIndex > 1\n\t\t\tifTrue: [categoryStops at: catIndex - 1]\n\t\t\tifFalse: [0].\n\t[(elemIndex _ elemIndex + 1) <= (categoryStops at: catIndex)\n\t\tand: [element >= (elementArray at: elemIndex)]] whileTrue.\n\n\t\"elemIndex is now the index for inserting the element. Do the insertion before it.\"\n\telementArray _\n\t\t(elementArray copyFrom: 1 to: elemIndex - 1)\n\t\t\t, (Array with: element)\n\t\t\t, (elementArray copyFrom: elemIndex to: elementArray size).\t\"insertion\"\n\n\t\"add one to stops for this and later categories\"\n\tcatIndex to: categoryArray size do:\n\t\t[:i | categoryStops at: i put: (categoryStops at: i) + 1].\n\n\t\"remove empty default category if any\"\n\tcategoryArray indexOf: Default ifAbsent: [^self].\n\t(self listAtCategoryNamed: Default) size = 0\n\t\tifTrue: [self removeCategory: Default].\n",
          "listAtCategoryNamed:": "listAtCategoryNamed: categoryName\n\t\"Answer the array of elements associated with the name, categoryName.\"\n\n\t| i |\n\ti _ categoryArray indexOf: categoryName ifAbsent: [^Array new].\n\t^self listAtCategoryNumber: i\n",
          "classifyAll:under:": "classifyAll: aCollection under: heading\n\taCollection do:\n\t\t[:element | self classify: element under: heading]\n",
          "includesElement:": "includesElement: element\n\t^ (self categoryOfElement: element) ~~ nil\n"
        },
        "accessing": {
          "changeFromString:": "changeFromString: aString\n\t\"Parse the string and make this be the receiver's structure.  Categories or elements not found are not affected.  New elements are ignored.\"\n\n\t| scanner oldElements newElements newCategories newStops currentStop anArray |\n\tscanner _ Scanner new scanTokens: aString.\n\t\"If nothing was scanned and I had no elements before, then default me\"\n\t(scanner size = 0 and: [elementArray size = 0])\n\t\tifTrue: [^self setDefaultList].\n\n\toldElements _ elementArray asSet.\n\tnewCategories _ Array new: scanner size.\n\tnewStops _ Array new: scanner size.\n\tcurrentStop _ 0.\n\tnewElements _ WriteStream on: (Array new: 16).\n\t1 to: scanner size do:\n\t\t[:i |\n\t\tanArray _ scanner at: i.\n\t\tnewCategories at: i put: anArray first asSymbol.\n\t\t(anArray copyFrom: 2 to: anArray size) asSortedCollection do:\n\t\t\t[:elem |\n\t\t\t(oldElements remove: elem ifAbsent: [nil]) notNil ifTrue:\n\t\t\t\t[newElements nextPut: elem.\n\t\t\t\tcurrentStop _ currentStop+1]].\n\t\tnewStops at: i put: currentStop].\n\n\t\"Ignore extra elements but don't lose any existing elements!\"\n\toldElements _ oldElements collect:\n\t\t[:elem | Array with: (self categoryOfElement: elem) with: elem].\n\tnewElements _ newElements contents.\n\tcategoryArray _ newCategories.\n\tcategoryStops _ newStops.\n\telementArray _ newElements.\n\toldElements do: [:pair | self classify: pair last under: pair first].\n"
        },
        "private": {
          "listAtCategoryNumber:": "listAtCategoryNumber: index\n\t\"Answer the array of elements stored at the position index.\"\n\t| firstIndex lastIndex |\n\tfirstIndex _ index = 1\n\t\t\tifTrue: [1]\n\t\t\tifFalse: [(categoryStops at: index - 1) + 1].\n\tlastIndex _ categoryStops at: index.\n\t^ elementArray copyFrom: firstIndex to: lastIndex\n",
          "setDefaultList": "setDefaultList\n\tself classComment: ''.\n\tcategoryArray _ categoryStops _ elementArray _ Array new\n",
          "setDefaultList:": "setDefaultList: aSortedCollection\n\tself classComment: ''.\n\tcategoryArray _ Array with: Default.\n\tcategoryStops _ Array with: aSortedCollection size.\n\telementArray _ aSortedCollection asArray\n",
          "numberOfCategoryOfElement:": "numberOfCategoryOfElement: element\n\t\"Answer the index of the category with which the argument, element,\n\tis associated.\"\n\n\t| categoryIndex elementIndex |\n\tcategoryIndex _ 1.\n\telementIndex _ 0.\n\t[(elementIndex _ elementIndex + 1) <= elementArray size]\n\t\twhileTrue:\n\t\t\t[\"point to correct category\"\n\t\t\t[elementIndex > (categoryStops at: categoryIndex)]\n\t\t\t\twhileTrue: [categoryIndex _ categoryIndex + 1].\n\t\t\t\"see if this is element\"\n\t\t\telement = (elementArray at: elementIndex) ifTrue: [^categoryIndex]].\n\t^0\n"
        },
        "categories": {
          "addCategory:": "addCategory: heading\n\t\"Add a new category named heading.\"\n\t^ self addCategory: heading before: nil\n",
          "addCategory:before:": "addCategory: heading before: nextHeading\n\t| nextIndex elements |\n\t\"Add a new category named heading.  If nextHeading is specified (not nil)\n\tand can be found, then INSERT before that entry.  Otherwise ADD it at the end.\n\tIf heading already exists, then MOVE it where it would have gone otherwise.\"\n\n\t(categoryArray indexOf: heading) > 0\n\t\tifTrue:  \"already there - maybe move\"\n\t\t\t[\"slow but sure;  remove all, then insert all\"\n\t\t\telements _ self listAtCategoryNamed: heading.\t\"Save elements\"\n\t\t\telements do: [:elt | self removeElement: elt].\n\t\t\tself removeCategory: heading.\t\t\"Remove old entry\"\n\t\t\tself addCategory: heading before: nextHeading.\t\"Now insert anew\"\n\t\t\tself classifyAll: elements under: heading.\t\t\t\"And restore elements\"\n\t\t\t^self].\n\tnextIndex _ categoryArray indexOf: nextHeading\n\t\t\t\t\t\t\tifAbsent: [categoryArray size+1].\n\tcategoryArray _ categoryArray  \"insert before nextIndex\"\n\t\t\tcopyReplaceFrom: nextIndex\n\t\t\tto: nextIndex-1\n\t\t\twith: (Array with: heading).\n\tcategoryStops _ categoryStops\n\t\t\tcopyReplaceFrom: nextIndex\n\t\t\tto: nextIndex-1\n\t\t\twith: (Array with: (nextIndex=1\n\t\t\t\t\tifTrue: [0]\n\t\t\t\t\tifFalse: [categoryStops at: nextIndex-1])).\n",
          "removeCategory:": "removeCategory: cat\n\t\"Remove the category named, cat.  Create an error if the category has\n\tany elements in it.\"\n\n\t| index lastStop |\n\tindex _ categoryArray indexOf: cat ifAbsent: [^self].\n\tlastStop _\n\t\tindex = 1\n\t\t\tifTrue: [0]\n\t\t\tifFalse: [categoryStops at: index - 1].\n\t(categoryStops at: index) - lastStop > 0\n\t\tifTrue: [^self error: 'cannot remove non-empty category'].\n\tcategoryArray _\n\t\t(categoryArray copyFrom: 1 to: index - 1)\n\t\t\t, (categoryArray copyFrom: index + 1 to: categoryArray size).\n\tcategoryStops _\n\t\t(categoryStops copyFrom: 1 to: index - 1)\n\t\t\t, (categoryStops copyFrom: index + 1 to: categoryStops size).\n\tcategoryArray size = 0\n\t\tifTrue:\n\t\t\t[categoryArray _ Array with: Default.\n\t\t\tcategoryStops _ Array with: 0]\n",
          "renameCategory:to:": "renameCategory: oldName to: newName\n\t\"Answer the array of elements associated with the name, categoryName.\"\n\t| i symbol |\n\ti _ categoryArray indexOf: oldName\n\t\tifAbsent: [^ false].\n\tsymbol _ newName asSymbol.\n\tcategoryArray indexOf: symbol\n\t\tifAbsent: [categoryArray at: i put: symbol.  ^ true].\n\t^ false  \"newName was already there\"\n",
          "removeEmptyCategories": "removeEmptyCategories\n\t\"Remove empty categories.\"\n\t| categoryIndex currentStop keptCategories keptStops |\n\tkeptCategories _ WriteStream on: (Array new: 16).\n\tkeptStops _ WriteStream on: (Array new: 16).\n\tcurrentStop _ categoryIndex _ 0.\n\t[(categoryIndex _ categoryIndex + 1) <= categoryArray size]\n\t\twhileTrue:\n\t\t\t[(categoryStops at: categoryIndex) > currentStop\n\t\t\t\tifTrue:\n\t\t\t\t\t[keptCategories nextPut: (categoryArray at: categoryIndex).\n\t\t\t\t\tkeptStops nextPut: (currentStop _ categoryStops at: categoryIndex)]].\n\tcategoryArray _ keptCategories contents.\n\tcategoryStops _ keptStops contents.\n\tcategoryArray size = 0\n\t\tifTrue:\n\t\t\t[categoryArray _ Array with: Default.\n\t\t\tcategoryStops _ Array with: 0]\n\n\t\"ClassOrganizer allInstancesDo: [:co | co removeEmptyCategories].\"\n",
          "categoryOfElement:": "categoryOfElement: element\n\t\"Answer the category associated with the argument, element.\"\n\n\t| index |\n\tindex _ self numberOfCategoryOfElement: element.\n\tindex = 0\n\t\tifTrue: [^nil]\n\t\tifFalse: [^categoryArray at: index]\n",
          "categories:": "categories: anArray\n\t\"Reorder my categories to be in the order of anArray.  If the\n\tresulting organization does not include all elements, then give an error.\"\n\t| newCategories newStops newElements catName list runningTotal |\n\tnewCategories _ Array new: anArray size.\n\tnewStops _ Array new: anArray size.\n\tnewElements _ Array new: 0.\n\trunningTotal _ 0.\n\t1 to: anArray size do:\n\t\t[:i |\n\t\tcatName _ (anArray at: i) asSymbol.\n\t\tlist _ self listAtCategoryNamed: catName.\n\t\t\t\tnewElements _ newElements, list.\n\t\t\t\tnewCategories at: i put: catName.\n\t\t\t\tnewStops at: i put: (runningTotal _ runningTotal + list size)].\n\telementArray do:\n\t\t[:element | \"check to be sure all elements are included\"\n\t\t(newElements includes: element)\n\t\t\tifFalse: [^self error: 'New categories must match old ones']].\n\t\"Everything is good, now update my three arrays.\"\n\tcategoryArray _ newCategories.\n\tcategoryStops _ newStops.\n\telementArray _ newElements\n",
          "categories": "categories\n\t\"Answer an array of categories (names).\"\n\n\t(categoryArray size = 1\n\t\tand: [categoryArray first = Default & (elementArray size = 0)])\n\t\tifTrue: [^Array new].\n\t^categoryArray\n"
        }
      }
    },
    "MethodDictionary": {
      "comment": "MethodDictionaries behave just the same as IdentityDictionaries, except that\nremoval is implemented as an atomic operation.  This allows the interpreter\nto access methodDictionaries removal without getting confused.\n",
      "class_name": "MethodDictionary",
      "superclass": "IdentityDictionary",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "dictionary removing": {
          "methodArray": "methodArray\n\t^valueArray\n",
          "removeKey:ifAbsent:": "removeKey: key ifAbsent: errorBlock\n\t\"Remove the key from a copy and then use become: to effect and atomic update\"\n\tself become: (self copy removeDangerouslyKey: key ifAbsent: [^errorBlock value])\n"
        }
      }
    }
  },
  "Numeric-Magnitudes": {
    "Date": {
      "comment": "Implements dates.\n",
      "class_name": "Date",
      "superclass": "Magnitude",
      "instanceVariables": "day year",
      "classInstanceVariables": "",
      "classVariables": "DaysInMonth FirstDayOfMonth MonthNames SecondsInDay WeekDayNames",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"Initialize class variables representing the names of the months and days and\n\tthe number of seconds, days in each month, and first day of each month.\"\n\n\tMonthNames _\n\t\t#(January February March April May June\n\t\t\tJuly August September October November December ).\n\tSecondsInDay _ 24 * 60 * 60.\n\tDaysInMonth _ #(31 28 31 30 31 30 31 31 30 31 30 31 ).\n\tFirstDayOfMonth _ #(1 32 60 91 121 152 182 213 244 274 305 335 ).\n\tWeekDayNames _\n\t\t#(Monday Tuesday Wednesday Thursday Friday Saturday Sunday )\n\n\t\"Date initialize.\"\n"
        },
        "instance creation": {
          "today": "today\n\t\"Answer with the Date representing the day and year right now.\"\n\n\t^self dateAndTimeNow at: 1\n",
          "newDay:month:year:": "newDay: day month: monthName year: year\n\t\"Answer an instance of me which is the day'th day of the month named\n\tmonthName in the year'th year. The year may be specified as the actual\n\tnumber of years since the beginning of the Roman calendar or the\n\tnumber of years since the beginning of the century.\"\n\n\t| monthIndex daysInMonth firstDayOfMonth |\n\tyear < 100 ifTrue: [^self\n\t\t\tnewDay: day\n\t\t\tmonth: monthName\n\t\t\tyear: 1900 + year].\n\tmonthIndex _ self indexOfMonth: monthName.\n\tmonthIndex = 2\n\t\tifTrue: [daysInMonth _ (DaysInMonth at: monthIndex)\n\t\t\t\t\t\t+ (self leapYear: year)]\n\t\tifFalse: [daysInMonth _ DaysInMonth at: monthIndex].\n\tmonthIndex > 2\n\t\tifTrue: [firstDayOfMonth _ (FirstDayOfMonth at: monthIndex)\n\t\t\t\t\t\t+ (self leapYear: year)]\n\t\tifFalse: [firstDayOfMonth _ FirstDayOfMonth at: monthIndex].\n\t(day < 1 or: [day > daysInMonth])\n\t\tifTrue: [self error: 'illegal day in month']\n\t\tifFalse: [^self new day: day - 1 + firstDayOfMonth year: year]\n",
          "newDay:year:": "newDay: dayCount year: referenceYear\n\t\"Answer with a Date which is dayCount days after the beginning of the\n\tyear referenceYear.\"\n\n\t| day year daysInYear |\n\tday _ dayCount.\n\tyear _ referenceYear.\n\t[day > (daysInYear _ self daysInYear: year)]\n\t\twhileTrue:\n\t\t\t[year _ year + 1.\n\t\t\t day _ day - daysInYear].\n\t[day <= 0]\n\t\twhileTrue:\n\t\t\t[year _ year - 1.\n\t\t\t day _ day + (self daysInYear: year)].\n\t^self new day: day year: year\n",
          "fromDays:": "fromDays: dayCount\n\t\"Answer an instance of me that is dayCount days after Jan 1 1901.\"\n\t^self\n\t\tnewDay: 1 + (dayCount truncated rem: 1461)\n\t\t\t\t\t\t\t\"There are 1461 days in a 4-year cycle.\n\t\t\t\t\t\t\t 2000 is a leap year, so no extra correction is necessary. \"\n\t\tyear: 1901 + ((dayCount truncated quo: 1461) * 4)\n",
          "readFrom:": "readFrom: aStream\n\t\"Read a Date from the stream in any of the forms:\n\t\t<day> <monthName> <year>\t\t(5 April 1982; 5-APR-82)\n\t\t<monthName> <day> <year>\t\t(April 5, 1982)\n\t\t<monthNumber> <day> <year>\t(4/5/82)\"\n\n\t| day month |\n\taStream peek isDigit ifTrue: [day _ Integer readFrom: aStream].\n\t[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].\n\taStream peek isLetter\n\t\tifTrue:\t\t\"number/name... or name...\"\n\t\t\t[month _ WriteStream on: (String new: 10).\n\t\t\t[aStream peek isLetter] whileTrue: [month nextPut: aStream next].\n\t\t\tmonth _ month contents.\n\t\t\tday isNil ifTrue:\t\t\"name/number...\"\n\t\t\t\t[[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].\n\t\t\t\tday _ Integer readFrom: aStream]]\n\t\tifFalse:\t\t\"number/number...\"\n\t\t\t[month _ Date nameOfMonth: day.\n\t\t\tday _ Integer readFrom: aStream].\n\t[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].\n\t^self newDay: day month: month year: (Integer readFrom: aStream)\n\n\t\"Date readFrom: (ReadStream on: '5APR82')\"\n"
        },
        "general inquiries": {
          "nameOfMonth:": "nameOfMonth: monthIndex\n\t\"Answer a symbol representing the name of the month indexed by monthIndex,\n\t1 - 12.\"\n\n\t^MonthNames at: monthIndex\n",
          "daysInMonth:forYear:": "daysInMonth: monthName forYear: yearInteger\n\t\"Answer the number of days in the month named monthName in the\n\tyear yearInteger.\"\n\n\t^(self newDay: 1\n\t\t  month: monthName\n\t\t  year: yearInteger) daysInMonth\n",
          "daysInYear:": "daysInYear: yearInteger\n\t\"Answer the number of days in the year, yearInteger.\"\n\n\t^365 + (self leapYear: yearInteger)\n",
          "dateAndTimeNow": "dateAndTimeNow\n\t\"Answer an array with first element Date today and second element Time now.\"\n\n\t^Time dateAndTimeNow\n",
          "indexOfMonth:": "indexOfMonth: monthName\n\t\"Answer the index, 1 - 12, of the month monthName.  Create an\n\terror if no such month exists.\"\n\n\t1 to: 12 do:\n\t\t[ :index |\n\t\t\t(monthName , '*' match: (MonthNames at: index))\n\t\t\t\t\t\tifTrue: [^index]].\n\tself error: monthName , ' is not a recognized month name'\n",
          "leapYear:": "leapYear: yearInteger\n\t\"Answer 1 if the year yearInteger is a leap year;  answer 0 if it is not.\"\n\n\t(yearInteger \\\\ 4 ~= 0 or: [yearInteger \\\\ 100 = 0 and: [yearInteger \\\\ 400 ~= 0]])\n\t\tifTrue: [^0]\n\t\tifFalse: [^1]\n",
          "dayOfWeek:": "dayOfWeek: dayName\n\t\"Answer the index in a week, 1 - 7, of the day named dayName.  Create an\n\terror if no such day exists.\"\n\n\t1 to: 7 do: [:index | (WeekDayNames at: index)\n\t\t\t= dayName ifTrue: [^index \\\\ 7]].\n\tself error: dayName asString , ' is not a day of the week'\n",
          "nameOfDay:": "nameOfDay: dayIndex\n\t\"Answer a symbol representing the name of the day indexed by dayIndex, 1 - 7.\"\n\n\t^WeekDayNames at: dayIndex\n"
        }
      },
      "instance_methods": {
        "comparing": {
          "hash": "hash\n\t\"Hash is reimplemented because = is implemented.\"\n\n\t^(year hash bitShift: 3) bitXor: day\n",
          "<": "< aDate\n\t\"Answer whether aDate precedes the date of the receiver.\"\n\n\tyear = aDate year\n\t\tifTrue: [^day < aDate day]\n\t\tifFalse: [^year < aDate year]\n",
          "=": "= aDate\n\t\"Answer whether aDate is the same day as the receiver.\"\n\n\tself species = aDate species\n\t\tifTrue: [^day = aDate day & (year = aDate year)]\n\t\tifFalse: [^false]\n"
        },
        "inquiries": {
          "daysInYear": "daysInYear\n\t\"Answer the number of days in the year represented by the receiver.\"\n\n\t^Date daysInYear: self year\n",
          "daysLeftInYear": "daysLeftInYear\n\t\"Answer the number of days in the year after the date of the receiver.\"\n\n\t^self daysInYear - self day\n",
          "daysInMonth": "daysInMonth\n\t\"Answer the number of days in the month represented by the receiver.\"\n\n\t^(DaysInMonth at: self monthIndex)\n\t\t+ (self monthIndex = 2\n\t\t\t\tifTrue: [self leap]\n\t\t\t\tifFalse: [0])\n",
          "firstDayOfMonth": "firstDayOfMonth\n\t\"Answer the index of the day of the year that is the first day\n\tof the receiver's month\"\n\n\t^self firstDayOfMonthIndex: self monthIndex\n",
          "dayOfMonth": "dayOfMonth\n\t\"Answer which day of the month is represented by the receiver.\"\n\n\t^day - (self firstDayOfMonthIndex: self monthIndex) + 1\n",
          "previous:": "previous: dayName\n\t\"Answer the previous date whose weekday name is dayName.\"\n\n\t^self subtractDays: 7 + self weekdayIndex - (Date dayOfWeek: dayName) \\\\ 7\n"
        },
        "printing": {
          "printFormat:": "printFormat: formatArray\n\t\"Answer a string description of the receiver.  The argument\n\tformatArray is the print format, where\n\t1-3\tpositions to print day,month,year respectively\n\t4\tcharacter separator\n\t5\tmonth format (1 month #, 2 first 3 chars, 3 entire name)\n\t6\tyear format (1 year #, 2 year # \\\\ 100)\"\n\n\t| aStream |\n\taStream _ WriteStream on: (String new: 16).\n\tself printOn: aStream format: formatArray.\n\t^aStream contents\n",
          "printOn:": "printOn: aStream\n\tself printOn: aStream format: #(1 2 3 32 3 1 )\n",
          "printOn:format:": "printOn: aStream format: formatArray\n\t\"Print a description of the receiver on aStream.  The argument\n\tformatArray is the print format, where\n\t1-3\tpositions to print day,month,year respectively\n\t4\tcharacter separator\n\t5\tmonth format (1 month #, 2 first 3 chars, 3 entire name)\n\t6\tyear format (1 year #, 2 year # \\\\ 100)\"\n\n\t| monthIndex element monthFormat |\n\tmonthIndex _ self monthIndex.\n\t1 to: 3 do:\n\t\t[:elementIndex |\n\t\telement _ formatArray at: elementIndex.\n\t\telement = 1 ifTrue: [day - self firstDayOfMonth + 1 printOn: aStream].\n\t\telement = 2\n\t\t\tifTrue:\n\t\t\t\t[monthFormat _ formatArray at: 5.\n\t\t\t\tmonthFormat = 1\n\t\t\t\t\tifTrue: [monthIndex printOn: aStream].\n\t\t\t\tmonthFormat = 2\n\t\t\t\t\tifTrue: [aStream nextPutAll: ((MonthNames at: monthIndex)\n\t\t\t\t\t\t\t\t\t\t\t\t\tcopyFrom: 1 to: 3)].\n\t\t\t\tmonthFormat = 3\n\t\t\t\t\tifTrue: [aStream nextPutAll: (MonthNames at: monthIndex)]].\n\t\telement = 3\n\t\t\tifTrue:\n\t\t\t\t[(formatArray at: 6) = 1\n\t\t\t\t\tifTrue: [year printOn: aStream]\n\t\t\t\t\tifFalse: [(year \\\\ 100) printOn: aStream]].\n\t\telementIndex < 3\n\t\t\tifTrue:\n\t\t\t\t[(formatArray at: 4) ~= 0\n\t\t\t\t\tifTrue: [aStream nextPut: (formatArray at: 4) asCharacter]]]\n",
          "storeOn:": "storeOn: aStream\n\taStream nextPutAll: '(', self class name, ' readFromString: ';\n\t\tprint: self printString;\n\t\tnextPut: $)\n"
        },
        "accessing": {
          "day": "day\n\t\"Answer the day of the year represented by the receiver.\"\n\n\t^day\n",
          "monthName": "monthName\n\t\"Answer the name of the month in which the receiver falls.\"\n\n\t^MonthNames at: self monthIndex\n",
          "monthIndex": "monthIndex\n\t\"Answer the index of the month in which the receiver falls.\"\n\n\t| leap firstDay |\n\tleap _ self leap.\n\t12 to: 1 by: -1 do:\n\t\t[ :monthIndex |\n\t\t\tfirstDay _ (FirstDayOfMonth at: monthIndex)\n\t\t\t\t\t\t\t+ (monthIndex > 2 ifTrue: [leap] ifFalse: [0]).\n\t\t\tfirstDay<= day\n\t\t\t\tifTrue: [^monthIndex]].\n\tself error: 'illegal month'\n",
          "leap": "leap\n\t\"Answer whether the receiver's year is a leap year.\"\n\n\t^Date leapYear: year\n",
          "year": "year\n\t\"Answer the year in which the receiver falls.\"\n\n\t^year\n",
          "weekday": "weekday\n\t\"Answer the name of the day of the week on which the receiver falls.\"\n\n\t^WeekDayNames at: self weekdayIndex\n"
        },
        "private": {
          "firstDayOfMonthIndex:": "firstDayOfMonthIndex: monthIndex\n\t\"Answer the day of the year (an Integer) that is the first day of my month\"\n\n\t^(FirstDayOfMonth at: monthIndex)\n\t\t+ (monthIndex > 2\n\t\t\t\tifTrue: [self leap]\n\t\t\t\tifFalse: [0])\n",
          "weekdayIndex": "weekdayIndex\n\t\"Sunday=1, ... , Saturday=7\"\n\n\t| yearIndex dayIndex |\n\tday < (self firstDayOfMonthIndex: 3)\n\t\tifTrue:\n\t\t\t[yearIndex _ year - 1.\n\t\t\tdayIndex _ 307]\n\t\tifFalse:\n\t\t\t[yearIndex _ year.\n\t\t\tdayIndex _ -58 - self leap].\n\n\t^dayIndex + day + yearIndex + (yearIndex // 4)\n\t\t\t\t+ (yearIndex // 400) - (yearIndex // 100) \\\\ 7 + 1\n",
          "day:year:": "day: dayInteger year: yearInteger\n\tday _ dayInteger.\n\tyear _ yearInteger\n"
        },
        "converting": {
          "asSeconds": "asSeconds\n\t\"Answer the seconds between a time on1 January 1901 and the same time\n\tin the receiver's day.\"\n\n\t^SecondsInDay * (self subtractDate: (Date newDay: 1 year: 1901))\n"
        },
        "arithmetic": {
          "addDays:": "addDays: dayCount\n\t\"Answer a new Date that is dayCount more days than the receiver.\"\n\n\t^Date newDay: day + dayCount\n\t\t  year: year\n",
          "subtractDays:": "subtractDays: dayCount\n\t\"Answer a new Date that is dayCount days before the receiver.\"\n\n\t^Date newDay: day - dayCount year: year\n",
          "subtractDate:": "subtractDate: aDate\n\t\"Answer the number of days between the receiver and aDate.\"\n\n\tyear = aDate year\n\t\tifTrue: [^day - aDate day]\n\t\tifFalse: [^year - 1 // 4 - (aDate year // 4) + day\n\t\t\t\t\t\t+ aDate daysLeftInYear + (year - 1 - aDate year * 365)]\n"
        }
      }
    },
    "Time": {
      "comment": "Implements times of day.\n",
      "class_name": "Time",
      "superclass": "Magnitude",
      "instanceVariables": "hours minutes seconds",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "fromSeconds:": "fromSeconds: secondCount\n\t\"Answer with a Time that is secondCount seconds since midnight.\"\n\n\t| secondsInHour hours |\n\thours _ secondCount truncated // 3600.\n\tsecondsInHour _ secondCount truncated \\\\ 3600.\n\t^self new hours: hours\n\t\t\t   minutes: secondsInHour // 60\n\t\t\t   seconds: secondsInHour \\\\ 60\n",
          "readFrom:": "readFrom: aStream\n\t\"Read a Time from the stream in the form:\n\t\t<hour>:<minute>:<second> <am/pm>\n\n\t<minute>, <second> or <am/pm> may be omitted.  e.g. 1:59:30 pm; 8AM; 15:30\"\n\n\t| hour minute second |\n\thour _ Integer readFrom: aStream.\n\tminute _ 0.\n\tsecond _ 0.\n\t(aStream peekFor: $:) ifTrue:\n\t\t[minute _ Integer readFrom: aStream.\n\t\t(aStream peekFor: $:) ifTrue:\n\t\t\t[second _ Integer readFrom: aStream]].\n\taStream skipSeparators.\n\t(aStream atEnd not and: [aStream peek isLetter])\n\t\tifTrue:\n\t\t\t[aStream next asLowercase = $p ifTrue: [hour _ hour + 12].\n\t\t\t(aStream peekFor: $m) ifFalse: [aStream peekFor: $M]].\n\t^self fromSeconds: 60*(60*hour+minute)+second\n\n\t\"Time readFrom: (ReadStream on: '2:23:09 pm')\"\n",
          "now": "now\n\t\"Answer with a Time representing the time right now--this is a 24 hour clock.\"\n\n\t^self dateAndTimeNow at: 2\n"
        },
        "private": {
          "millisecondClockInto:": "millisecondClockInto: aByteArray\n\t\"The argument is a byte indexable object of length at least four (a\n\tLargePositiveInteger).  Store into the first four bytes of the argument the\n\tnumber of milliseconds since the millisecond clock was last reset or rolled\n\tover (a 32-bit unsigned number).  The low-order 8-bits are stored in\n\tthe byte indexed by 1 and the high-order 8-bits in the byte indexed 4.\n\tEssential.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 99>\n\tself primitiveFailed\n",
          "currentTime:": "currentTime: formatted\n\t\"If formatted is #seconds, answer with the total seconds from Jan 1 1901\n\tcorrected for time zone and daylight savings time.\n\tOtherwise, answer an array of (Date today, Time now).\n\tm570 and m571 are time zone specific parameters, set for California.\"\n\n\t| secondCount d dd t dfirst dlast m570 m571 |\n\tsecondCount _ LargePositiveInteger new: 4.\n\tself secondClockInto: secondCount.\n\tsecondCount _ secondCount truncated.\n\tm570 _ 16505.\n\tm571 _ 305.\n\t\"adjust for time zone\"\n\tsecondCount _\n\t\tsecondCount\n\t\t\t+ ((m570 >= 0\n\t\t\t\t\tifTrue: [-1]\t\"west\"\n\t\t\t\t\tifFalse: [1]\t\"east\")\n\t\t\t\t* (3600 * ((m570 bitAnd: 30720) bitShift: -11)\n\t\t\t\t\t\t\t+ (60 * ((m571 bitAnd: 32256) bitShift: -9)))).\n\n\t\"Guess the number of days since Jan 1 1901.\"\n\td _ Date fromDays: secondCount // 86400.\n\n\t\"The formatted test makes it possible to skip some work if all you want is to correct\n\tthe total number of seconds.  secondCount \\\\ 86400 is the number of seconds that\n\twere left over from the estimate of days\"\n\tformatted==#seconds ifFalse: [t _ Time fromSeconds: secondCount \\\\ 86400].\n\n\t\"check for daylight savings time (DST). correct DST parameters for nonleap\n\tyears and round to previous Sunday if necessary\"\n\n\t\"day of the year on or before which DST takes effect\"\n\tdfirst _ m570 bitAnd: 511.\n\t(dfirst = 366\n\t\tifTrue: [false\"DST not in effect\"]\n\t\tifFalse: [(dd _ d day) >= (dfirst _ dfirst + d leap - 1)\n\t\t\t\tifTrue:\n\t\t\t\t\t[\"day of the year on or before which DST ends\"\n\t\t\t\t\tdlast _ (m571 bitAnd: 511) + d leap - 1.\n\t\t\t\t\tdd < dlast and:\n\t\t\t\t\t\t[dd < ((Date newDay: dlast year: d year)\n\t\t\t\t\t\t\t\tprevious: #Sunday) day]]\n\t\t\t\tifFalse: [\"possibly earlier than or at beginning of range\"\n\t\t\t\t\t\tdd >= ((Date newDay: dfirst year: d year)\n\t\t\t\t\t\t\t\tprevious: #Sunday) day]])\n\t\tifTrue: [formatted==#seconds\n\t\t\t\t\tifTrue: [\"daylight savings time in effect. add an hour\"\n\t\t\t\t\t\t\tsecondCount _ secondCount + 3600]\n\t\t\t\t\tifFalse: [t hours = 23\n\t\t\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t\t\t[d _ d addDays: 1.\n\t\t\t\t\t\t\t\t\tt hours: 0]\n\t\t\t\t\t\t\t\tifFalse: [t hours: t hours + 1]]].\n\tformatted==#seconds\n\t\tifTrue: [^secondCount]\n\t\tifFalse: [^Array with: d with: t]\n",
          "secondClockInto:": "secondClockInto: aByteArray\n\t\"The argument is a byte indexable object of length at least four.  Store\n\tinto the first four bytes of the argument the number of seconds since\n\t00:00 in the morning of January 1, 1901 (a 32-bit unsigned number).\n\tThe low-order 8-bits are stored in the byte indexed by 1 and the high-\n\torder 8-bits in the byte indexed 4.  Essential.  See Object documentation\n\twhatIsAPrimitive. \"\n\n\t<primitive: 98>\n\tself primitiveFailed\n"
        },
        "general inquiries": {
          "timeWords": "timeWords\n\t\"Answer with the seconds (in GMT) since Jan 1 1901: as a four element\n\tByteArray.  The high-order 8-bits of the answer are stored in the byte\n\tindexed by 1 and the low-order 8-bits in the byte indexed 4.  Note: this\n\torder is not consistent with the primitives or the other time messages,\n\tbut it is what the Alto file system uses (see AltoFile updateLeader:).\"\n\n\t| seconds bytes |\n\tseconds _ ByteArray new: 4.\n\tself secondClockInto: seconds.\n\tbytes _ ByteArray new: 4.\n\t\"Reverse the bytes\"\n\t1 to: 4 do: [:i | bytes at: i put: (seconds at: 5 - i)].\n\t^bytes\n",
          "dateAndTimeNow": "dateAndTimeNow\n\t\"Answer an array of (Date today, Time now).\"\n\n\t^self currentTime: #dateAndTime\n",
          "millisecondClockValue": "millisecondClockValue\n\t\"Answer with the number of milliseconds since the millisecond clock was\n\tlast reset or rolled over.\"\n\n\t| milliseconds |\n\tmilliseconds _ LargePositiveInteger new: 4.\n\tself millisecondClockInto: milliseconds.\n\t^milliseconds truncated\n",
          "millisecondsToRun:": "millisecondsToRun: timedBlock\n\t\"Answer with the number of milliseconds timedBlock takes to return its value.\"\n\n\t| initialMilliseconds |\n\tinitialMilliseconds _ self millisecondClockValue.\n\ttimedBlock value.\n\t^self millisecondClockValue - initialMilliseconds\n",
          "totalSeconds": "totalSeconds\n\t\"Answer with the total seconds from Jan 1 1901 corrected for time zone\n\tand daylight savings time.\"\n\n\t^self currentTime: #seconds\n"
        }
      },
      "instance_methods": {
        "comparing": {
          "hash": "hash\n\t\"Hash must be redefined since = was redefined.\"\n\t^((hours hash bitShift: 3) bitXor: minutes) bitXor: seconds\n",
          "<": "< aTime\n\t\"Answer whether aTime is earlier than the receiver.\"\n\n\thours ~= aTime hours ifTrue: [^hours < aTime hours].\n\tminutes ~= aTime minutes ifTrue: [^minutes < aTime minutes].\n\t^seconds < aTime seconds\n",
          "=": "= aTime\n\t\"Answer whether aTime represents the same second as the receiver.\"\n\n\tself species = aTime species\n\t\tifTrue: [^hours = aTime hours\n\t\t\t\t\t& (minutes = aTime minutes)\n\t\t\t\t\t& (seconds = aTime seconds)]\n\t\tifFalse: [^false]\n"
        },
        "printing": {
          "printOn:": "printOn: aStream\n\t\"Format is h:mm:ss am/pm\"\n\n\thours > 12\n\t\tifTrue: [hours - 12 printOn: aStream]\n\t\tifFalse: [hours < 1\n\t\t\t\t\tifTrue: [12 printOn: aStream]\n\t\t\t\t\tifFalse: [hours printOn: aStream]].\n\taStream nextPutAll: (minutes < 10\n\t\t\t\t\t\t\tifTrue: [':0']\n\t\t\t\t\t\t\tifFalse: [':']).\n\tminutes printOn: aStream.\n\taStream nextPutAll: (seconds < 10\n\t\t\t\t\t\t\tifTrue: [':0']\n\t\t\t\t\t\t\tifFalse: [':']).\n\tseconds printOn: aStream.\n\taStream nextPutAll: (hours < 12\n\t\t\t\t\t\t\tifTrue: [' am']\n\t\t\t\t\t\t\tifFalse: [' pm'])\n",
          "storeOn:": "storeOn: aStream\n\taStream nextPutAll: '(', self class name, ' readFromString: ';\n\t\tprint: self printString;\n\t\tnextPut: $)\n"
        },
        "accessing": {
          "seconds": "seconds\n\t\"Answer the number of seconds the receiver represents.\"\n\t^seconds\n",
          "hours": "hours\n\t\"Answer the number of hours the receiver represents.\"\n\t^hours\n",
          "minutes": "minutes\n\t\"Answer the number of minutes the receiver represents.\"\n\t^minutes\n"
        },
        "private": {
          "hours:": "hours: anInteger\n\thours _ anInteger\n",
          "hours:minutes:seconds:": "hours: hourInteger minutes: minInteger seconds: secInteger\n\thours _ hourInteger.\n\tminutes _ minInteger.\n\tseconds _ secInteger\n"
        },
        "converting": {
          "asSeconds": "asSeconds\n\t\"Answer the number of seconds since midnight of the receiver.\"\n\n\t^3600 * hours + (60 * minutes + seconds)\n"
        },
        "arithmetic": {
          "subtractTime:": "subtractTime: timeAmount\n\t\"Answer a new Time that is timeAmount before the receiver.  timeAmount is an\n\tinstance of Date or Time.\"\n\n\t^Time fromSeconds: self asSeconds - timeAmount asSeconds\n",
          "addTime:": "addTime: timeAmount\n\t\"Answer a new Time that is timeAmount after the receiver.  timeAmount is an\n\tinstance of Date or Time.\"\n\n\t^Time fromSeconds: self asSeconds + timeAmount asSeconds\n"
        }
      }
    },
    "Magnitude": {
      "comment": "This abstract class assists subclasses which measure something linear like dates or times.\n",
      "class_name": "Magnitude",
      "superclass": "Object",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "comparing": {
          "min:": "min: aMagnitude\n\t\"Answer the receiver or the argument, whichever has the lesser magnitude.\"\n\n\tself < aMagnitude\n\t\tifTrue: [^self]\n\t\tifFalse: [^aMagnitude]\n",
          "hash": "hash\n\t\"Hash must be redefined whenever = is redefined.\"\n\n\t^self subclassResponsibility\n",
          "between:and:": "between: min and: max\n\t\"Answer whether the receiver is less than or equal to the argument, max,\n\tand greater than or equal to the argument, min.\"\n\n\t^self >= min and: [self <= max]\n",
          ">": "> aMagnitude\n\t\"Compare the receiver with the argument and answer with true if the\n\treceiver is greater than the argument. Otherwise answer false.\"\n\n\t^aMagnitude < self\n",
          "max:": "max: aMagnitude\n\t\"Answer the receiver or the argument, whichever has the greater magnitude.\"\n\n\tself > aMagnitude\n\t\tifTrue: [^self]\n\t\tifFalse: [^aMagnitude]\n",
          "<": "< aMagnitude\n\t\"Compare the receiver with the argument and answer with true if the\n\treceiver is less than the argument. Otherwise answer false.\"\n\n\t^self subclassResponsibility\n",
          "=": "= aMagnitude\n\t\"Compare the receiver with the argument and answer with true if the\n\treceiver is equal to the argument. Otherwise answer false.\"\n\n\t^self subclassResponsibility\n",
          "hashMappedBy:": "hashMappedBy: map\n\t\"My hash is independent of my oop\"\n\t^ self hash\n",
          ">=": ">= aMagnitude\n\t\"Compare the receiver with the argument and answer with true if the\n\treceiver is greater than or equal to the argument. Otherwise answer false.\"\n\n\t^(self < aMagnitude) not\n",
          "<=": "<= aMagnitude\n\t\"Compare the receiver with the argument and answer with true if the\n\treceiver is less than or equal to the argument. Otherwise answer false.\"\n\n\t^(self > aMagnitude) not\n"
        }
      }
    }
  },
  "Numeric-Numbers": {
    "SmallInteger": {
      "comment": "SmallIntegers are optimized for the interpreter, stored in two-s complement form.  The allowable range is from minVal to maxVal.\n",
      "class_name": "SmallInteger",
      "superclass": "Integer",
      "instanceVariables": "",
      "classInstanceVariables": "minVal maxVal maxBits maxBytes",
      "classVariables": "Digitbuffer",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"Initialize the digit buffer, and discover the range of\n\tSmallIntegers on this system.\"\n\n\t| val bits |\n\tDigitbuffer _ Array new: 32.  \"Big enough for 32-bit systems\"\n\t\"Discover minVal and maxVal dynamically.  Assume that\n\tminVal is -2^N and maxVal is (2^N)-1.\"\n\tval _ -1.\n\tbits _ 0.\n\t[(val subtractOrFail: 1) notNil]\n\t\twhileTrue:\n\t\t\t[val _ val + val.\n\t\t\tbits _ bits + 1].\n\tminVal _ val.\n\tmaxVal _ (val + 1) negated.\n\tmaxBits _ bits.\n\tmaxBytes _ bits + 7 // 8.\n\t\"SmallInteger initialize.\"\n"
        },
        "documentation": {
          "guideToDivision": "guideToDivision\n\t\"Handy guide to the kinds of Integer division:\n\t/  exact division, returns a fraction if result is not a whole integer.\n\t//  returns an Integer, rounded towards negative infinity.\n\t\\\\ is modulo rounded towards negative infinity.\n\tquo:  truncated division, rounded towards zero.\"\n"
        },
        "constants": {
          "maxBytes": "maxBytes\n\t\"Answer N such that maxVal < 256^N.\"\n\t^maxBytes\n",
          "minVal": "minVal\n\t\"Answer the minimum value for a Small Integer\"\n\t^minVal\n",
          "maxVal": "maxVal\n\t\"Answer the maximum value for a SmallInteger\"\n\t^maxVal\n",
          "maxBits": "maxBits\n\t\"Answer N such that maxVal is (2^N)-1.\"\n\t^maxBits\n"
        },
        "instance creation": {
          "new": "new\n\tself error: 'SmallIntegers can only be created by performing arithmetic'\n"
        }
      },
      "instance_methods": {
        "comparing": {
          "hash": "hash\n\t^self\n",
          ">": "> aNumber\n\t\"Compare the receiver with the argument and answer true if the receiver is\n\tgreater than the argument.  Otherwise answer false.  Fail if the argument is not a\n\tSmallInteger.  Essential.  No Lookup.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 4>\n\t^super > aNumber\n",
          "<": "< aNumber\n\t\"Compare the receiver with the argument and answer with true if the receiver is less\n\tthan the argument.  Otherwise answer false.  Fail if the argument is not a\n\tSmallInteger.  Essential.  No Lookup.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 3>\n\t^super < aNumber\n",
          "=": "= aNumber\n\t\"Compare the receiver with the argument and answer true if the receiver is\n\tequal to the argument.  Otherwise answer false.  Fail if the argument is not a\n\tSmallInteger.  Essential.  No Lookup.  See Object documentation\n\twhatIsAPrimitive. \"\n\n\t<primitive: 7>\n\t^super = aNumber\n",
          "hashMappedBy:": "hashMappedBy: map\n\t\"My hash is independent of my oop\"\n\t^ self hash\n",
          ">=": ">= aNumber\n\t\"Compare the receiver with the argument and answer true if the receiver is\n\tgreater than or equal to the argument.  Otherwise answer false.  Fail if the\n\targument is not a SmallInteger.  Optional.  No Lookup.  See Object\n\tdocumentation whatIsAPrimitive.\"\n\n\t<primitive: 6>\n\t^super >= aNumber\n",
          "~=": "~= aNumber\n\t\"Compare the receiver with the argument and answer true if the receiver is not\n\tequal to the argument.  Otherwise answer false.  Fail if the argument is not a\n\tSmallInteger.  Essential.  No Lookup.  See Object documentation\n\twhatIsAPrimitive. \"\n\n\t<primitive: 8>\n\t^super ~= aNumber\n",
          "<=": "<= aNumber\n\t\"Compare the receiver with the argument and answer true if the receiver is less\n\tthan or equal to the argument.  Otherwise answer false.  Fail if the argument is\n\tnot a SmallInteger.  Optional.  No Lookup.  See Object documentation\n\twhatIsAPrimitive. \"\n\n\t<primitive: 5>\n\t^super <= aNumber\n"
        },
        "coercing": {
          "coerce:": "coerce: n\n\t^n truncated\n",
          "generality": "generality\n\t^20\n"
        },
        "bit manipulation": {
          "bitShift:": "bitShift: arg\n\t\"Answers with a SmallInteger whose value (in twos-complement\n\trepresentation) is the receiver's value (in twos-complement representation)\n\tshifted left by the number of bits indicated by the argument.  Negative\n\targuments shift right.  Zeros are shifted in from the right in left shifts.  The sign\n\tbit is extended in right shifts.  Fail if the result cannot be represented as a\n\tSmallInteger.  Essential.  No Lookup.  See Object documentation\n\twhatIsAPrimitive. \"\n\n\t<primitive: 17>\n\t^super bitShift: arg\n",
          "highBit": "highBit\n\t| i bit |\n\tself < 0 ifTrue: [^self error: 'highBit is not defined for negative numbers'].\n\tself = 0 ifTrue: [^0].\n\ti _ 1.\n\tbit _ 1.\n\t[self > bit]\n\t\twhileTrue:\n\t\t\t[i _ i + 1.\n\t\t\tbit _ bit + bit + 1].\n\t^i\n",
          "bitOr:": "bitOr: arg\n\t\"Logical OR the twos-complement representation of the receiver with the\n\targument and answer with the result.  Fail if the argument is not a SmallInteger.\n\tEssential.  No Lookup.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 15>\n\t^arg bitOr: self\n",
          "bitXor:": "bitXor: arg\n\t\"Exclusive OR the twos-complement representation of the receiver with the\n\targument and answer with the result.  Fail if the argument is not a\n\tSmallInteger.  Essential.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 16>\n\t^arg bitXor: self\n",
          "bitAnd:": "bitAnd: arg\n\t\"Logical AND the twos-complement representation of the receiver with the\n\targument and answer with the result.  Fail if the argument is not a SmallInteger.\n\tEssential.  No Lookup.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 14>\n\t^arg bitAnd: self\n"
        },
        "printing": {
          "printOn:base:": "printOn: aStream base: b\n\t| i x |\n\t(x _ self) < 0\n\t\tifTrue:\n\t\t\t[aStream nextPut: $-.\n\t\t\tx _ self negated].\n\ti _ 0.\n\t[x >= b]\n\t\twhileTrue:\n\t\t\t[Digitbuffer at: (i _ i + 1) put: x \\\\ b.\n\t\t\tx _ x // b].\n\tDigitbuffer at: (i _ i + 1) put: x.\n\t[i > 0]\n\t\twhileTrue:\n\t\t\t[aStream nextPut: (Character digitValue: (Digitbuffer at: i)).\n\t\t\ti _ i - 1]\n"
        },
        "testing": {
          "odd": "odd\n\t^(self bitAnd: 1) = 1\n",
          "even": "even\n\t^(self bitAnd: 1) = 0\n"
        },
        "copying": {
          "deepCopy": "deepCopy\n",
          "shallowCopy": "shallowCopy\n"
        },
        "private": {
          "fromString:radix:": "fromString: str radix: radix\n\t| maxdigit c val |\n\tmaxdigit _\n\t\tradix + (radix > 10\n\t\t\t\t\tifTrue: [55 - 1]\n\t\t\t\t\tifFalse: [48 - 1]).\n\tval _ 0.\n\t1 to: str size do:\n\t\t[:i |\n\t\tc _ str at: i.\n\t\t(c < 48 ifFalse: [c > maxdigit])\n\t\t\tifTrue: [^false].\n\t\tval _ val * radix + (c <= 57\n\t\t\t\t\t\t\tifTrue: [c - 48]\n\t\t\t\t\t\t\tifFalse:\n\t\t\t\t\t\t\t\t[c < 65 ifTrue: [^false].\n\t\t\t\t\t\t\t\tc - 55])].\n\t^val\n",
          "subtractOrFail:": "subtractOrFail: aNumber\n\t\"This is a private copy of the subtraction primitive,\n\tused by SmallInteger class initialize to discover the\n\tcorrect value of SmallInteger minVal.\"\n\n\t<primitive: 2>\n\t^nil\n"
        },
        "converting": {
          "asFloat": "asFloat\n\t\"Create and answer an instance of Float whose value is the value of the receiver.\n\tEssential.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 40>\n\tself primitiveFailed\n"
        },
        "arithmetic": {
          "-": "- aNumber\n\t\"Subtract the argument from the receiver and answer with the result if it is a\n\tSmallInterger.  Fail if the argument or the result is not a SmallInteger.\n\tEssential.  No Lookup.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 2>\n\t^super - aNumber\n",
          "/": "/ aNumber\n\t\"This primitive (for /) divides the receiver by the argument and returns the\n\tresult if the division is exact.  Fail if the result is not a whole integer.  Fail if the\n\targument is 0 or is not a SmallInteger.  Optional.  No Lookup.  See Object\n\tdocumentation whatIsAPrimitive.\"\n\n\t<primitive: 10>\n\taNumber = 0 ifTrue: [^self error: 'division by 0'].\n\t(aNumber isMemberOf: SmallInteger)\n\t\tifTrue: [^(Fraction numerator: self denominator: aNumber) reduced]\n\t\tifFalse: [^super / aNumber]\n",
          "*": "* aNumber\n\t\"Multiply the receiver by the argument and answer with the result if it is a\n\tSmallInterger.  Fail if the argument or the result is not a SmallInteger.\n\tEssential.  No Lookup.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 9>\n\tself = 0 ifTrue: [^0].\n\t\"This eliminates the need for a self=0 check in LargeInteger *\"\n\t^super * aNumber\n",
          "quo:": "quo: aNumber\n\t\"Divide the receiver by the argument and answer with the result.  Round the\n\tresult down towards zero to make it a whole integer.  Fail if the argument is 0 or is\n\tnot a SmallInteger.  Optional.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 13>\n\taNumber = 0 ifTrue: [^self error: 'Attempt to divide by zero'].\n\t(aNumber isMemberOf: SmallInteger)\n\t\tifTrue: [self primitiveFailed]\n\t\tifFalse: [^super quo: aNumber]\n",
          "\\\\": "\\\\ aNumber\n\t\"Take the receiver modulo the argument.  The result is the remainder rounded\n\ttowards negative infinity, of the receiver divided by the argument.  Fail if the\n\targument is 0 or is not a SmallInteger.  Optional.  No Lookup.  See Object\n\tdocumentation whatIsAPrimitive. \"\n\n\t<primitive: 11>\n\t^super \\\\ aNumber\"Do with // if primitive fails\"\n",
          "//": "// aNumber\n\t\"Divide the receiver by the argument and answer with the result.  Round the result\n\tdown towards negative infinity to make it a whole integer.  Fail if the\n\targument is 0 or is not a SmallInteger.  Essential.  No Lookup.  See Object\n\tdocumentation whatIsAPrimitive. \"\n\n\t<primitive: 12>\n\t^super // aNumber\"Do with quo: if primitive fails\"\n",
          "+": "+ aNumber\n\t\"Add the receiver to the argument and answer with the result if it is a SmallInterger.\n\tFail if the argument or the result is not a SmallInteger.  Essential.  No Lookup.\n\tSee Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 1>\n\t^super + aNumber\n"
        },
        "system primitives": {
          "digitLength": "digitLength\n\t\"Answer with the number of indexable fields in the receiver.  This value is the\n\tsame as the largest legal subscript.  Included so that a SmallInteger can behave\n\tlike a LargeInteger.\"\n\n\t| maxSize minValue size |\n\t(self < 16r100 and: [self > -16r100]) ifTrue: [^1].\n\tmaxSize _ SmallInteger maxBytes.\n\tmaxSize = 2 ifTrue: [^2].  \"Make things go fast for 16-bit systems\"\n\tminValue _ -16r100.\n\tsize _ 2.\n\t[size < maxSize]\n\t\twhileTrue:\n\t\t\t[minValue _ minValue bitShift: 8.\n\t\t\t(self <= (-1 - minValue) and: [self > minValue]) ifTrue: [^size].\n\t\t\tsize _ size + 1].\n\t^maxSize\n",
          "digitAt:put:": "digitAt: n put: value\n\t\"Fails. The digits of a small integer can not be modified.\"\n\n\tself error: 'You cant store in a SmallInteger'\n",
          "asObject": "asObject\n\t\"This is the inverse of Object.asOop; look there for details.\n\tSee also Object documentation whatIsAPrimitive.\"\n\t<primitive: 76>\n\t^self primitiveFailed\n",
          "digitAt:": "digitAt: n\n\t\"Answer the value of an apparent indexable field.\n\tThis is provided for compatibility with LargeInteger.\"\n\n\t n = 1\n\t\tifTrue:\n\t\t\t[\"Negate carefully in case I am SmallInteger minVal\"\n\t\t\tself < 0\n\t\t\t\tifTrue: [^-256 - self bitAnd: 255].\n\t\t\t^self bitAnd: 255]\n\t\tifFalse:\n\t\t\t[self < 0\n\t\t\t\tifTrue: [^(-256 - self bitShift: -8) + 1 digitAt: n - 1].\n\t\t\t^(self bitShift: 8 - (n bitShift: 3)) bitAnd: 255]\n",
          "asOop": "asOop\n\t\"Answer an integer which is unique to me, consistent with Object.asOop.\n\tSee Object.asOop for detailed documentation\"\n\tself >= 0\n\t\tifTrue: [^ 32768 + self]\t\t\"0...16K-1 --> 32K...48K-1\"\n\t\tifFalse: [^ 65536 + self]\t\t\"-16k...-1 --> 48K...64K-1\"\n",
          "instVarAt:": "instVarAt: i\n\t\"small integer has to be specially handled\"\n\n\ti = 1 ifTrue: [^self].\n\tself error: 'argument too big for small integer instVarAt:'\n"
        }
      }
    },
    "LargeNegativeInteger": {
      "comment": "A negative large integer.  Nearly all the work is done in Integer: LargeNegativeInteger just overrides a few messages.\n",
      "class_name": "LargeNegativeInteger",
      "superclass": "Integer",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "MinHi",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"If a LargeNegativeInteger is exactly SmallInteger maxBytes in size,\n\tand its high-order byte does not exceed MaxHi, the number\n\tshould be a SmallInteger.\"\n\n\tSmallInteger initialize.\n\tMinHi _ (SmallInteger minVal bitShift: (SmallInteger maxBytes - 1 * -8)) negated\n\t\"LargeNegativeInteger initialize.\"\n"
        }
      },
      "instance_methods": {
        "truncation and round off": {
          "truncated": "truncated\n\t\"If I can be represented as a SmallInteger, return the\n\tconverted result.  This message should really be called\n\tsomething else, since it is only used internally after\n\tarithmetic and bit operations.\"\n\n\t| size partial maxSize |\n\tsize _ self digitLength.\n\tsize = 0 ifTrue: [^0].\n\tpartial _ self digitAt: size.\n\tpartial = 0 ifTrue: [^(self growby: -1) truncated].\n\tmaxSize _ SmallInteger maxBytes.\n\t(size < maxSize or: [size = maxSize and: [partial < MinHi or: [partial = MinHi and: [(self anyBitTo: maxSize - 1 * 8) not]]]])\n\t\tifTrue:\n\t\t\t[\"Convert back to a SmallInteger.\"\n\t\t\tpartial _ 0 - partial.\n\t\t\t[(size _ size - 1) > 0]\n\t\t\t\twhileTrue:\n\t\t\t\t\t[partial _ (partial bitShift: 8) - (self digitAt: size)].  \"Can't overflow\"\n\t\t\t^partial]\n"
        },
        "bit manipulation": {
          "highBit": "highBit\n\tself error: 'highBit not defined for negative numbers'\n"
        },
        "printing": {
          "printOn:base:": "printOn: aStream base: b\n\taStream nextPut: $-.\n\tsuper printOn: aStream base: b\n"
        },
        "testing": {
          "positive": "positive\n\t^false\n",
          "negative": "negative\n\t^true\n"
        },
        "converting": {
          "asObject": "asObject\n\t\"This is the inverse of Object.asOop; look there for details.\n\tOnly Stretch should encounter this code.\"\n\tself >= -16384\n\t\tifTrue:\n\t\t\t[self even\n\t\t\t\tifTrue: [^ self // 2]         \"even --> negative\"\n\t\t\t\tifFalse: [^ (self+1) // -2]]  \"odd --> positive\"\n\t\tifFalse:\n\t\t\t[^ #NonExistentObject]\n"
        },
        "arithmetic": {
          "abs": "abs\n\t^self negated\n",
          "negated": "negated\n\t^self copyto: (LargePositiveInteger new: self digitLength)\n"
        },
        "system primitives": {
          "digitLength": "digitLength\n\t\"Answer the number of indexable fields in the receiver.  This value is the\n\tsame as the largest legal subscript.  Essential.  See Object documentation\n\twhatIsAPrimitive.\"\n\n\t<primitive: 62>\n\tself primitiveFailed\n",
          "digitAt:put:": "digitAt: index put: value\n\t\"Store the second argument (value) in the indexable field of the receiver\n\tindicated by index.  Fail if the value is negative or is larger than 255.  Fail if\n\tthe index is not an Integer or is out of bounds.  Answer the value that was\n\tstored.  Essential.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 61>\n\t^super at: index put: value\n",
          "digitAt:": "digitAt: index\n\t\"Answer the value of an indexable field in the receiver.  Fail if the argument\n\t(the index) is not an Integer or is out of bounds.  Essential.  See Object\n\tdocumentation whatIsAPrimitive.\"\n\n\t<primitive: 60>\n\tself digitLength < index\n\t\tifTrue: [^0]\n\t\tifFalse: [^super at: index]\n"
        }
      }
    },
    "LargePositiveInteger": {
      "comment": "A positive large integer.  Nearly all the work is done in Integer: LargePositiveInteger just overrides a few messages.\n",
      "class_name": "LargePositiveInteger",
      "superclass": "Integer",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "MaxHi",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"If a LargePositiveInteger is exactly SmallInteger maxBytes in size,\n\tand its high-order byte does not exceed MaxHi, the number\n\tshould be a SmallInteger.\"\n\n\tSmallInteger initialize.\n\tMaxHi _ SmallInteger maxVal bitShift: (SmallInteger maxBytes - 1 * -8)\n\t\"LargePositiveInteger initialize.\"\n"
        }
      },
      "instance_methods": {
        "comparing": {
          ">": "> anInteger\n\t\"Compare the receiver with the argument and return true if the receiver is\n\tgreater than the argument.  Otherwise return false.  Fail if the argument is not a\n\tSmallInteger or a LargePositiveInteger less than 65536.  Optional.  See Object\n\tdocumentation whatIsAPrimitive.\"\n\n\t<primitive: 24>\n\t^super > anInteger\n",
          "<": "< anInteger\n\t\"Compare the receiver with the argument and return true if the receiver is less\n\tthan the argument.  Otherwise return false.  Fail if the argument is not a\n\tSmallInteger or a LargePositiveInteger less than 65536.  Optional.  See Object\n\tdocumentation whatIsAPrimitive.\"\n\n\t<primitive: 23>\n\t^super < anInteger\n",
          "=": "= anInteger\n\t\"Compare the receiver with the argument and return true if the receiver is\n\tequal to the argument.  Otherwise return false.  Fail if the argument is not a\n\tSmallInteger or a LargePositiveInteger less than 65536.  Optional.  See Object\n\tdocumentation whatIsAPrimitive.\"\n\n\t<primitive: 27>\n\t^super = anInteger\n",
          ">=": ">= anInteger\n\t\"Compare the receiver with the argument and answer with true if the receiver\n\tis greater than or equal to the argument.  Otherwise return false.  Fail if the\n\targument is not a SmallInteger or a LargePositiveInteger less than 65536.\n\tOptional.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 26>\n\t^super >= anInteger\n",
          "~=": "~= anInteger\n\t\"Compare the receiver with the argument and answer true if the receiver is not\n\tequal to the argument.  Otherwise answer false.  Fail if the argument is not a\n\tSmallInteger or a LargePositiveInteger less than 65536.  Optional.  See Object\n\tdocumentation whatIsAPrimitive.\"\n\n\t<primitive: 28>\n\t^super ~= anInteger\n",
          "<=": "<= anInteger\n\t\"Compare the receiver with the argument and return true if the receiver is less\n\tthan or equal to the argument.  Otherwise return false.  Fail if the argument is\n\tnot a SmallInteger or a LargePositiveInteger less than 65536.  Optional.  See\n\tObject documentation whatIsAPrimitive.\"\n\n\t<primitive: 25>\n\t^super <= anInteger\n"
        },
        "truncation and round off": {
          "truncated": "truncated\n\t\"If I can be represented as a SmallInteger, return the\n\tconverted result.  This message should really be called\n\tsomething else, since it is only used internally after\n\tarithmetic and bit operations, and in a few external\n\tplaces that construct LargePositiveIntegers in non-\n\tstandard ways.\"\n\n\t| size partial maxSize |\n\tsize _ self digitLength.\n\tsize = 0 ifTrue: [^0].\n\tpartial _ self digitAt: size.\n\tpartial = 0 ifTrue: [^(self growby: -1) truncated].\n\tmaxSize _ SmallInteger maxBytes.\n\t(size < maxSize or: [size = maxSize and: [partial <= MaxHi]])\n\t\tifTrue:\n\t\t\t[\"Convert back to a SmallInteger.\"\n\t\t\t[(size _ size - 1) > 0]\n\t\t\t\twhileTrue:\n\t\t\t\t\t[partial _ (partial bitShift: 8) + (self digitAt: size)].  \"Can't overflow\"\n\t\t\t^partial]\n"
        },
        "bit manipulation": {
          "bitShift:": "bitShift: anInteger\n\t\"Answer with a Integer whose value (in twos-complement representation) is the\n\treceiver's value (in twos-complement representation) shifted left by the\n\tnumber of bits indicated by the argument.  Negative arguments shift right.\n\tZeros are shifted in from the right in left shifts.  The sign bit is extended in right\n\tshifts.  Fail if the result cannot be represented as a SmallInteger or a\n\tLargePositiveInteger less than 65536.  Optional.  See Object documentation\n\twhatIsAPrimitive.\"\n\n\t<primitive: 37>\n\t^super bitShift: anInteger\n",
          "highBit": "highBit\n\t\"Answer with the index of the high order bit of the binary representation of this\n\tnumber \"\n\n\t^self lastDigit highBit + (8 * (self digitLength - 1))\n",
          "bitOr:": "bitOr: anInteger\n\t\"Logical OR the twos-complement representation of the receiver with the\n\targument and return the result.  Fail if either the argument or the result is not a\n\tSmallInteger or a LargePositiveInteger less than 65536.  Optional.  See Object\n\tdocumentation whatIsAPrimitive.\"\n\n\t<primitive: 35>\n\t^super bitOr: anInteger\n",
          "bitXor:": "bitXor: anInteger\n\t\"Logical XOR the twos-complement representation of the receiver with the\n\targument and return the result.  Fail if either the argument or the result is not a\n\tSmallInteger or a LargePositiveInteger less than 65536.  Optional.  See Object\n\tdocumentation whatIsAPrimitive.\"\n\n\t<primitive: 36>\n\t^super bitXor: anInteger\n",
          "bitAnd:": "bitAnd: anInteger\n\t\"Logical AND the twos-complement representation of the receiver with the\n\targument and return the result.  Fail if either the argument or the result is not a\n\tSmallInteger or a LargePositiveInteger less than 65536.  Optional.  See Object\n\tdocumentation whatIsAPrimitive.\"\n\n\t<primitive: 34>\n\t^super bitAnd: anInteger\n"
        },
        "testing": {
          "positive": "positive\n\t^true\n",
          "negative": "negative\n\t^false\n"
        },
        "converting": {
          "asObject": "asObject\n\t\"This is the inverse of Object.asOop; look there for details.\"\n\t<primitive: 76>\n\tself < 32768\n\t\tifTrue: [^ (self-32768) asObject].  \"16K...32K-1 synonym for -16K...-1\"\n\tself < 49152\n\t\tifTrue: [^ self-32768].\t\"32K...48K-1 --> SmallIntegers 0...16K-1\"\n\tself < 65536\n\t\tifTrue: [^ self-65536].\t\"48K...64K-1 --> SmallIntegers -16K...-1\"\n\t^ #NonExistentObject\n"
        },
        "arithmetic": {
          "-": "- anInteger\n\t\"Subtract the argument from the receiver and answer with an Integer result.  Fail if\n\teither the argument or the result is not a SmallInteger or a\n\tLargePositiveInteger less than 65536.  Optional.  See Object documentation\n\twhatIsAPrimitive. \"\n\n\t<primitive: 22>\n\t^super - anInteger\n",
          "/": "/ anInteger\n\t\"Divide the receiver by the argument and answer with the result if the division\n\tis exact.  Fail if the result is not a whole integer.  Fail if the argument is 0.  Fail if\n\teither the argument or the result is not a SmallInteger or a\n\tLargePositiveInteger less than 65536.  Optional.  See Object documentation\n\twhatIsAPrimitive. \"\n\n\t<primitive: 30>\n\t^super / anInteger\n",
          "*": "* anInteger\n\t\"Multiply the receiver by the argument and answer with an Integer result.  Fail if\n\teither the argument or the result is not a SmallInteger or a\n\tLargePositiveInteger less than 65536.  Optional.  See Object documentation\n\twhatIsAPrimitive. \"\n\n\t<primitive: 29>\n\t^super * anInteger\n",
          "quo:": "quo: anInteger\n\t\"Divide the receiver by the argument and return the result.  Round the result\n\tdown towards zero to make it a whole integer.  Fail if the argument is 0.  Fail if\n\teither the argument or the result is not a SmallInteger or a\n\tLargePositiveInteger less than 65536.  Optional.  See Object documentation\n\twhatIsAPrimitive.\"\n\n\t<primitive: 33>\n\t^super quo: anInteger\n",
          "\\\\": "\\\\ anInteger\n\t\"Take the receiver modulo the argument.  The result is the remainder rounded\n\ttowards negative infinity, of the receiver divided by the argument.  Fail if the\n\targument is 0.  Fail if either the argument or the result is not a SmallInteger or a\n\tLargePositiveInteger less than 65536.  Optional.  See Object documentation\n\twhatIsAPrimitive.\"\n\n\t<primitive: 31>\n\t^super \\\\ anInteger\n",
          "//": "// anInteger\n\t\"Divide the receiver by the argument and return the result.  Round the result\n\tdown towards negative infinity to make it a whole integer.  Fail if the\n\targument is 0.  Fail if either the argument or the result is not a SmallInteger or a\n\tLargePositiveInteger less than 65536.  Optional.  See Object documentation\n\twhatIsAPrimitive. \"\n\n\t<primitive: 32>\n\t^super // anInteger\n",
          "+": "+ anInteger\n\t\"Add the receiver to the argument and answer with an Integer result.  Fail if either\n\tthe argument or the result is not a SmallInteger or a LargePositiveInteger less than\n\t65536.  Optional.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 21>\n\t^super + anInteger\n",
          "abs": "abs\n",
          "negated": "negated\n\t| minVal |\n\t((self digitAt: 1) = 0 and: [self digitLength = 1]) ifTrue: [^self].\n\t\"Zero\"\n\tminVal _ SmallInteger minVal.\n\t((self digitAt: 2) = (0 - (minVal // 256)) and: [(self digitAt: 1) = 0])\n\t\tifTrue: [^minVal].\n\t^self copyto: (LargeNegativeInteger new: self digitLength)\n"
        },
        "system primitives": {
          "digitLength": "digitLength\n\t\"Answer with the number of indexable fields in the receiver.  This value is the\n\tsame as the largest legal subscript.  Essential.  See Object documentation\n\twhatIsAPrimitive.\"\n\n\t<primitive: 62>\n\tself primitiveFailed\n",
          "digitAt:put:": "digitAt: index put: value\n\t\"Store the second argument (value) in the indexable field of the receiver\n\tindicated by index.  Fail if the value is negative or is larger than 255.  Fail if the\n\tindex is not an Integer or is out of bounds.  Answer with the value that was\n\tstored.  Essential.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 61>\n\t^super at: index put: value\n",
          "digitAt:": "digitAt: index\n\t\"Answer with the value of an indexable field in the receiver. Fail if the\n\targument (the index) is not an Integer or is out of bounds. Essential. See Object\n\tdocumentation whatIsAPrimitive.\"\n\n\t<primitive: 60>\n\tself digitLength < index\n\t\tifTrue: [^0]\n\t\tifFalse: [^super at: index]\n"
        }
      }
    },
    "Number": {
      "comment": "The abstract class Number is at the top of the number hierarchy.  Its subclasses are Float, Fraction, and Integer.\n",
      "class_name": "Number",
      "superclass": "Magnitude",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "readFrom:": "readFrom: aStream\n\t\"Answer an instance of me as described on the stream, aStream\"\n\n\t| value radix fraction fracpos |\n\tradix _ 10.\n\tvalue _ Integer readFrom: aStream.\n\t(aStream peekFor: $r)\n\t\tifTrue:\n\t\t\t[\"<radix>r<integer>\"\n\t\t\t(radix _ value) < 2 ifTrue: [^self error: 'INVALID RADIX'].\n\t\t\tvalue _ Integer readFrom: aStream radix: radix].\n\t(aStream peekFor: $.)\n\t\tifTrue:\n\t\t\t[\"<integer>.<fraction>\"\n\t\t\t(aStream atEnd not and: [aStream peek digitValue between: 0 and: radix - 1])\n\t\t\t\tifTrue:\n\t\t\t\t\t[fracpos _ aStream position.\n\t\t\t\t\tfraction _ Integer readFrom: aStream radix: radix.\n\t\t\t\t\tradix _ radix asFloat.\n\t\t\t\t\tfraction _\n\t\t\t\t\t\tfraction asFloat / (radix raisedTo: aStream position - fracpos).\n\t\t\t\t\tvalue _ value asFloat + (value < 0\n\t\t\t\t\t\t\t\t\tifTrue: [fraction negated]\n\t\t\t\t\t\t\t\t\tifFalse: [fraction])]\n\t\t\t\tifFalse:\n\t\t\t\t\t[\"oops - just <integer>.\"\n\t\t\t\t\taStream skip: -1.\t\t\"un-gobble the period\"\n\t\t\t\t\t^value\n\t\t\t\t\t\t\t\t\t\"Number readFrom: (ReadStream on: '3r-22.2')\"]].\n\t(aStream peekFor: $e)\n\t\tifTrue:\n\t\t\t[\"<integer>e<exponent>\"\n\t\t\t^value * (radix raisedTo: (Integer readFrom: aStream))].\n\t^value\n"
        }
      },
      "instance_methods": {
        "coercing": {
          "coerce:": "coerce: aNumber\n\t\"Answer with a number representing the argument, aNumber, that is\n\trepresented the same kind of Number as is the receiver.\n\tMust be defined by all Number classes.\"\n\n\tself subclassResponsibility\n",
          "generality": "generality\n\t\"Answer the number representing the ordering of the receiving in the\n\tgenerality hierarchy.  A number in this hierarchy coerces to numbers\n\thigher in hierarhcy (i.e., with larger generality numbers).\"\n\n\tself subclassResponsibility\n",
          "retry:coercing:": "retry: aSymbol coercing: aNumber\n\t\"Arithmetic represented by the symbol, aSymbol,\n\tcould not be performed with the receiver and the argument,\n\taNumber, because of the differences in representation.  Coerce either the\n\treceiver or the argument, depending on which has higher generality, and\n\ttry again.  If the symbol is the equals sign, answer false if the argument is\n\tnot a Number.  If the generalities are the same, create an error message.\"\n\n\t(aSymbol == #= and: [(aNumber isKindOf: Number) == false])\n\t\tifTrue: [^false].\n\tself generality < aNumber generality\n\t\tifTrue: [^(aNumber coerce: self) perform: aSymbol with: aNumber].\n\tself generality > aNumber generality\n\t\tifTrue: [^self perform: aSymbol with: (self coerce: aNumber)].\n\tself error: 'coercion attempt failed'\n"
        },
        "truncation and round off": {
          "roundTo:": "roundTo: aNumber\n\t\"Answer the integer that is a multiple of aNumber that is nearest the receiver.\"\n\t^(self / aNumber) rounded * aNumber\n",
          "truncateTo:": "truncateTo: aNumber\n\t\"Answer the next multiple of aNumber toward zero that is nearest the receiver.\"\n\n\t^(self quo: aNumber)\n\t\t* aNumber\n",
          "truncated": "truncated\n\t\"Answer an integer nearest the receiver toward zero.\"\n\t^self quo: 1\n",
          "rounded": "rounded\n\t\"Answer the integer nearest the receiver.\"\n\t^(self + (self sign / 2)) truncated\n",
          "ceiling": "ceiling\n\t\"Answer the integer nearest the receiver toward positive infinity.\"\n\n\tself <= 0.0\n\t\tifTrue: [^self truncated]\n\t\tifFalse: [^self negated floor negated]\n",
          "floor": "floor\n\t\"Answer the integer nearest the receiver toward negative infinity.\"\n\n\t| truncation |\n\ttruncation _ self truncated.\n\tself >= 0 ifTrue: [^truncation].\n\tself = truncation\n\t\tifTrue: [^truncation]\n\t\tifFalse: [^truncation - 1]\n"
        },
        "printing": {
          "storeOn:": "storeOn: aStream\n\t\"Numbers print in a form which is recognized by the compiler.\"\n\n\tself printOn: aStream\n"
        },
        "intervals": {
          "to:by:do:": "to: stop by: step do: aBlock\n\t\"Create an Interval from the receiver up to the argument, stop,\n\tincrementing by step.  For each element of the interval, evaluate the\n\tblock, aBlock.\"\n\n\t| nextValue |\n\tnextValue _ self.\n\tstep < 0\n\t\tifTrue: [[stop <= nextValue]\n\t\t\t\twhileTrue:\n\t\t\t\t\t[aBlock value: nextValue.\n\t\t\t\t\tnextValue _ nextValue + step]]\n\t\tifFalse: [[stop >= nextValue]\n\t\t\t\twhileTrue:\n\t\t\t\t\t[aBlock value: nextValue.\n\t\t\t\t\tnextValue _ nextValue + step]]\n",
          "to:by:": "to: stop by: step\n\t\"Answer an Interval from the receiver up to the argument, stop,\n\tincrementing by step.\"\n\n\t^Interval from: self to: stop by: step\n",
          "to:": "to: stop\n\t\"Answer an Interval from the receiver up to the argument, stop,\n\tincrementing by 1.\"\n\n\t^Interval from: self to: stop by: 1\n",
          "to:do:": "to: stop do: aBlock\n\t\"Create an Interval from the receiver up to the argument, stop,\n\tincrementing by 1.  For each element of the interval, evaluate the\n\tblock, aBlock.\"\n\n\t| nextValue |\n\tnextValue _ self.\n\t[nextValue <= stop]\n\t\twhileTrue:\n\t\t\t[aBlock value: nextValue.\n\t\t\tnextValue _ nextValue + 1]\n"
        },
        "testing": {
          "strictlyPositive": "strictlyPositive\n\t\"Answer whether the receiver is greater than 0.\"\n\n\t^self > 0\n",
          "sign": "sign\n\t\"Answer 1 if the receiver is greater than 0, -1 if less than 0, else 0.\"\n\n\tself > 0 ifTrue: [^1].\n\tself < 0 ifTrue: [^-1].\n\t^0\n",
          "odd": "odd\n\t\"Answer whether the receiver is an odd number.\"\n\t^self even == false\n",
          "positive": "positive\n\t\"Answer whether the receiver is greater than or equal to 0.\"\n\t^self >= 0\n",
          "even": "even\n\t\"Answer whether the receiver is an even number.\"\n\n\t^self \\\\ 2 = 0\n",
          "negative": "negative\n\t\"Answer whether the receiver is less than 0.\"\n\t^self < 0\n"
        },
        "converting": {
          "radiansToDegrees": "radiansToDegrees\n\t\"The receiver is assumed to represent radians.  Answer the\n\tconversion to degrees.\"\n\t^self asFloat radiansToDegrees\n",
          "degreesToRadians": "degreesToRadians\n\t\"The receiver is assumed to represent degrees.  Answer the\n\tconversion to radians.\"\n\t^self asFloat degreesToRadians\n",
          "@": "@ y\n\t\"Answer a new Point whose x value is the receiver and whose y value is the\n\targument.  Optional.  No Lookup.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 18>\n\t^Point x: self y: y\n",
          "asInteger": "asInteger\n\t\"Answer an integer nearest the receiver toward zero.\"\n\t^self truncated\n",
          "asPoint": "asPoint\n\t\"Answer a new Point with the receiver as both coordinates;\n\toften used to supply the same value in two dimensions, as with\n\tsymmetrical gridding or scaling.\"\n\n\t^self @ self\n"
        },
        "arithmetic": {
          "-": "- aNumber\n\t\"Answer the difference between the receiver and aNumber.\"\n\tself subclassResponsibility\n",
          "rem:": "rem: aNumber\n\t\"Remainder defined in terms of quo:. Answer a Number with the same\n\tsign as self.  e.g. 9 rem: 4 = 1,  -9 rem: 4 = -1.  0.9 rem: 0.4 = 0.1\"\n\n\t^self - ((self quo: aNumber) * aNumber)\n",
          "reciprocal": "reciprocal\n\t\"Answer 1 divided by the receiver.  Create an error if the\n\treceiver is 0.\"\n\n\tself = 0\n\t\tifTrue: [^self error: 'zero has no reciprocal']\n\t\tifFalse: [^1 / self]\n",
          "/": "/ aNumber\n\t\"Answer the result of dividing receiver by aNumber.\"\n\tself subclassResponsibility\n",
          "*": "* aNumber\n\t\"Answer the result of multiplying the receiver by aNumber.\"\n\tself subclassResponsibility\n",
          "quo:": "quo: aNumber\n\t\"Integer quotient defined by division with truncation toward zero.\n\t -9 quo: 4 = -2,  -0.9 quo: 0.4 = -2.\n\trem: answers the remainder from this division.\"\n\n\t^(self / aNumber) truncated\n",
          "\\\\": "\\\\ aNumber\n\t\"modulo.  Remainder defined in terms of //.  Answer a Number with the\n\tsame sign as aNumber.  e.g.  9\\\\4 = 1,  -9\\\\4 = 3, 9\\\\-4 =  -3,  0.9\\\\0.4 = 0.1\"\n\n\t^self - (self // aNumber * aNumber)\n",
          "//": "// aNumber\n\t\"Integer quotient defined by division with truncation toward negative\n\tinfinity.  9//4 = 2,  -9//4 = -3.  -0.9//0.4 = -3.\n\t\\\\ answers the remainder from this division.\"\n\n\t^(self / aNumber) floor\n",
          "+": "+ aNumber\n\t\"Answer the sum of the receiver and aNumber.\"\n\tself subclassResponsibility\n",
          "abs": "abs\n\t\"Answer a Number that is the absolute value (positive magnitude) of the receiver.\"\n\n\tself < 0\n\t\tifTrue: [^self negated]\n\t\tifFalse: [^self]\n",
          "negated": "negated\n\t\"Answer a Number that is the negation of the receiver.\"\n\t^0 - self\n"
        },
        "mathematical functions": {
          "floorLog:": "floorLog: radix\n\t\"Answer the floor of the log base radix of the receiver.\"\n\t^self asFloat floorLog: radix\n",
          "arcSin": "arcSin\n\t\"Answer with the angle in radians.\"\n\n\t^self asFloat arcSin\n",
          "squared": "squared\n\t\"Answer the receiver multipled by itself.\"\n\t^self * self\n",
          "raisedTo:": "raisedTo: aNumber\n\t\"Answer the receiver raised to aNumber.\"\n\n\taNumber isInteger\n\t\tifTrue: [\"Do the special case of integer power\"\n\t\t\t\t^self raisedToInteger: aNumber].\n\taNumber = 0 ifTrue: [^1].\t\t\"Special case of exponent=0\"\n\taNumber = 1 ifTrue: [^self].\t\t\"Special case of exponent=1\"\n\t^(aNumber * self ln) exp\t\t\"Otherwise raise it to the power using logarithms\"\n",
          "sin": "sin\n\t\"Answer with the angle in radians.\"\n\n\t^self asFloat sin\n",
          "exp": "exp\n\t\"Answer the exponential of the receiver as a floating point number.\"\n\t^self asFloat exp\n",
          "arcTan": "arcTan\n\t\"Answer with the angle in radians.\"\n\n\t^self asFloat arcTan\n",
          "arcCos": "arcCos\n\t^self asFloat arcCos\n",
          "sqrt": "sqrt\n\t\"Answer the square root of the receiver.\"\n\t^self asFloat sqrt\n",
          "log:": "log: aNumber\n\t\"Answer the log base aNumber of the receiver.\"\n\t^self ln / aNumber ln\n",
          "ln": "ln\n\t\"Answer the natural log of the receiver.\"\n\t^self asFloat ln\n",
          "cos": "cos\n\t\"Answer with the angle in radians.\"\n\n\t^self asFloat cos\n",
          "raisedToInteger:": "raisedToInteger: anInteger\n\t\"Answer the receiver raised to the power anInteger where the\n\targument must be a kind of Integer.  This is a special case of raisedTo:.\"\n\n\tanInteger isInteger\n\t\tifFalse: [^self error: 'raisedToInteger: only works for integral arguments'].\n\tanInteger = 0 ifTrue: [^1].\n\tanInteger = 1 ifTrue: [^self].\n\tanInteger > 1\n\t\tifTrue: [^(self * self raisedToInteger: anInteger // 2)\n\t\t\t\t\t* (self raisedToInteger: anInteger \\\\ 2)].\n\t^(self raisedToInteger: anInteger negated) reciprocal\n",
          "tan": "tan\n\t\"Answer with the angle in radians.\"\n\n\t^self asFloat tan\n"
        }
      }
    },
    "Float": {
      "comment": "I represent floating-point numbers in IEEE 32-bit format.\n\nThese floating-point numbers are good for about 8 or 9 digits of accuracy, and the range is between plus and minus 10^32.\nHere are some valid floating-point examples:\n\t8.0   13.3   0.3   2.5e6   1.27e-30  1.27e-31 -12.987654e12\nMainly: no imbedded blanks, little e for tens power, and a digit on both sides of the decimal point.\n",
      "class_name": "Float",
      "superclass": "Number",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "ExpPCoefficients ExpQCoefficients Fourthpi Halfpi Ln2 LnCoefficients Pi RadiansPerDegree SinCoefficients Sqrt2 TanCoefficients Twopi",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"constants from Computer Approximations, pp. 182-183\n\tPi = 3.14159265358979323846264338327950288\n\tPi/2 = 1.57079632679489661923132169163975144\n\tPi/4 = 0.78539816339744830961566084581987572\n\tPi*2 = 6.28318530717958647692528676655900576\n\tPi/180 = 0.01745329251994329576923690768488612\n\t2.0 ln = 0.69314718055994530941723212145817657\n\t2.0 sqrt = 1.41421356237309504880168872420969808\"\n\n\tPi _ 3.14159.\n\tHalfpi _ Pi / 2.0.\n\tFourthpi _ Pi / 4.0.\n\tTwopi _ Pi * 2.0.\n\tRadiansPerDegree _ Pi / 180.0.\n\tLn2 _ 0.693147.\n\tSqrt2 _ 1.41421.\n\tSinCoefficients _ #(-0.166667 0.00833333 -1.98409e-4 2.7526e-6 -2.39e-8 ).\n\tTanCoefficients _ #(0.333331 0.133392 0.0533741 0.0245651 0.00290052 0.00951681 ).\n\tExpPCoefficients _ #(28.8756 2525.04 ).\n\tExpQCoefficients _ #(1.0 375.022 7285.73 ).\n\tLnCoefficients _ #(0.237625 0.285254 0.400006 0.666667 2.0 )\n\t\"Float initialize.\"\n"
        },
        "constants": {
          "pi": "pi\n\t\"Answer the constant, Pi.\"\n\t^Pi\n"
        },
        "instance creation": {
          "readFrom:": "readFrom: aStream\n\t\"Answer a new Float as described on the stream, aStream.\"\n\n\t^(super readFrom: aStream) asFloat\n"
        }
      },
      "instance_methods": {
        "comparing": {
          "hash": "hash\n\t\"Hash is reimplemented because = is implemented.\"\n\n\t^(self basicAt: 1) bitAnd: 16383\t\t\"High bits as an Integer\"\n",
          ">": "> aNumber\n\t\"Compare the receiver with the argument and return true if the receiver is\n\tgreater than the argument.  Otherwise return false.  Fail if the argument is not a\n\tFloat.  Essential.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 44>\n\t^self retry: #> coercing: aNumber\n",
          "<": "< aNumber\n\t\"Compare the receiver with the argument and return true if the receiver is less\n\tthan the argument.  Otherwise return false.  Fail if the argument is not a Float.\n\tEssential.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 43>\n\t^self retry: #< coercing: aNumber\n",
          "=": "= aNumber\n\t\"Compare the receiver with the argument and return true if the receiver is\n\tequal to the argument.  Otherwise return false.  Fail if the argument is not a\n\tFloat.  Essential.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 47>\n\t^self retry: #= coercing: aNumber\n",
          ">=": ">= aNumber\n\t\"Compare the receiver with the argument and return true if the receiver is\n\tgreater than or equal to the argument.  Otherwise return false.  Fail if the\n\targument is not a Float.  Optional.  See Object documentation\n\twhatIsAPrimitive. \"\n\n\t<primitive: 46>\n\t^super >= aNumber\n",
          "~=": "~= aNumber\n\t\"Compare the receiver with the argument and return true if the receiver is not\n\tequal to the argument.  Otherwise return false.  Fail if the argument is not a\n\tFloat.  Optional.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 48>\n\t^super ~= aNumber\n",
          "<=": "<= aNumber\n\t\"Compare the receiver with the argument and return true if the receiver is less\n\tthan or equal to the argument.  Otherwise return false.  Fail if the argument is\n\tnot a Float.  Optional.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 45>\n\t^super <= aNumber\n"
        },
        "coercing": {
          "coerce:": "coerce: aNumber\n\t^aNumber asFloat\n",
          "generality": "generality\n\t^80\n"
        },
        "truncation and round off": {
          "integerPart": "integerPart\n\t\"Answer with a new Float whose value is the receiver's truncated value.\"\n\n\t^self - self fractionPart\n",
          "fractionPart": "fractionPart\n\t\"Answer a new Float whose value is the difference between the receiver and the\n\treceiver's truncated value.  Optional.  See Object documentation\n\twhatIsAPrimitive.\"\n\n\t<primitive: 52>\n\t^self - self truncated\n",
          "truncated": "truncated\n\t\"Answer with a SmallInteger equal to the value of the receiver without\n\tits fractional part. The primitive fails if the truncated value cannot be\n\trepresented as a SmallInteger. In that case, the code below will compute\n\ta LargeInteger truncated value. Essential. See Object documentation\n\twhatIsAPrimitive. \"\n\n\t<primitive: 51>\n\t^(self quo: 16383.0) * 16383 + (self rem: 16383.0) truncated\n",
          "rounded": "rounded\n\t\"Answer the integer nearest the receiver.\"\n\tself >= 0.0\n\t\tifTrue: [^(self + 0.5) truncated]\n\t\tifFalse: [^(self - 0.5) truncated]\n"
        },
        "printing": {
          "isLiteral": "isLiteral\n\t^true\n",
          "printOn:": "printOn: aStream\n\tself printOn: aStream digits: 6\n"
        },
        "copying": {
          "deepCopy": "deepCopy\n\t^self copy\n",
          "shallowCopy": "shallowCopy\n\t^self + 0.0\n"
        },
        "private": {
          "exponent": "exponent\n\t\"Consider the receiver to be represented as a power of two multiplied by a\n\tmantissa (between one and two).  Answer with the SmallInteger to whose power\n\ttwo is raised.  Optional.  See Object documentation whatIsAPrimitive.\"\n\n\t| positive |\n\t<primitive: 53>\n\tself >= 1.0 ifTrue: [^self floorLog: 2].\n\tself > 0.0\n\t\tifTrue:\n\t\t\t[positive _ (1.0 / self) exponent.\n\t\t\tself = (1.0 / (1.0 timesTwoPower: positive))\n\t\t\t\tifTrue: [^positive negated]\n\t\t\t\tifFalse: [^positive negated - 1]].\n\tself = 0.0 ifTrue: [^-1].\n\t^self negated exponent\n",
          "absPrintOn:digits:": "absPrintOn: aStream digits: digits\n\t\"Print me using digits significant figures.\"\n\n\t| fuzz x exp q i |\n\t\"x is myself normalized to [1.0, 10.0), exp is my exponent\"\n\texp _\n\t\tself < 1.0\n\t\t\tifTrue: [(10.0 / self floorLog: 10.0) negated]\n\t\t\tifFalse: [self floorLog: 10.0].\n\tx _ self / (10.0 raisedTo: exp).\n\tfuzz _ 10.0 raisedTo: 1 - digits.\n\t\"round the last digit to be printed\"\n\tx _ 0.5 * fuzz + x.\n\tx >= 10.0\n\t\tifTrue:\n\t\t\t[\"check if rounding has unnormalized x\"\n\t\t\tx _ x / 10.0.\n\t\t\texp _ exp + 1].\n\t(exp < 6 and: [exp > -4])\n\t\tifTrue:\n\t\t\t[\"decimal notation\"\n\t\t\tq _ 0.\n\t\t\texp < 0 ifTrue: [1 to: 1 - exp do: [:i | aStream nextPut: ('0.0000' at: i)]]]\n\t\tifFalse:\n\t\t\t[\"scientific notation\"\n\t\t\tq _ exp.\n\t\t\texp _ 0].\n\t[x >= fuzz]\n\t\twhileTrue:\n\t\t\t[\"use fuzz to track significance\"\n\t\t\ti _ x truncated.\n\t\t\taStream nextPut: (48 + i) asCharacter.\n\t\t\tx _ x - i * 10.0.\n\t\t\tfuzz _ fuzz * 10.0.\n\t\t\texp _ exp - 1.\n\t\t\texp = -1 ifTrue: [aStream nextPut: $.]].\n\t[exp >= -1]\n\t\twhileTrue:\n\t\t\t[aStream nextPut: $0.\n\t\t\texp _ exp - 1.\n\t\t\texp = -1 ifTrue: [aStream nextPut: $.]].\n\tq ~= 0\n\t\tifTrue:\n\t\t\t[aStream nextPut: $e.\n\t\t\tq printOn: aStream]\n",
          "mantissa:": "mantissa: nBits\n\t\"Answer as an integer the most significant nBits of the mantissa of the receiver.\"\n\n\t^(self abs timesTwoPower: nBits-self exponent-1) truncated\n",
          "timesTwoPower:": "timesTwoPower: anInteger\n\t\"Answer with the receiver mulitplied by 2.0 raised to the power of the argument.\n\tOptional.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 54>\n\t^self * (2.0 raisedToInteger: anInteger)\n",
          "printOn:digits:": "printOn: aStream digits: digits\n\t\"Print me using digits significant figures.\"\n\n\tself > 0.0\n\t\tifTrue: [self absPrintOn: aStream digits: digits]\n\t\tifFalse: [self = 0.0\n\t\t\t\t\tifTrue:\n\t\t\t\t\t\t[aStream nextPutAll: '0.0']\n\t\t\t\t\tifFalse:\n\t\t\t\t\t\t[aStream nextPutAll: '-'.\n\t\t\t\t\t\tself negated absPrintOn: aStream digits: digits]]\n"
        },
        "converting": {
          "asFraction": "asFraction\n\t\"Answer with a new Fraction representing the receiver.\n\tThis conversion uses the continued fraction method to approximate\n\ta floating point number.\"\n\n\t| num1 denom1 num2 denom2 int frac newD temp |\n\tnum1 _ self truncated.\t\"The first of two alternating numerators\"\n\tdenom1 _ 1.\t\t\"The first of two alternating denominators\"\n\tnum2 _ 1.\t\t\"The second numerator\"\n\tdenom2 _ 0.\t\t\"The second denominator--will update\"\n\tint _ num1.\t\t\"The integer part of self\"\n\tfrac _ self fractionPart.\t\t\"The fractional part of self\"\n\t[frac = 0]\n\t\twhileFalse:\n\t\t\t[\"repeat while the fractional part is not zero\"\n\t\t\tnewD _ 1.0 / frac.\t\t\t\"Take reciprocal of the fractional part\"\n\t\t\tint _ newD truncated.\t\t\"get the integer part of this\"\n\t\t\tfrac _ newD fractionPart.\t\"and save the fractional part for next time\"\n\t\t\ttemp _ num2.\t\t\t\t\"Get old numerator and save it\"\n\t\t\tnum2 _ num1.\t\t\t\t\"Set second numerator to first\"\n\t\t\tnum1 _ num1 * int + temp.\t\"Update first numerator\"\n\t\t\ttemp _ denom2.\t\t\t\t\"Get old denominator and save it\"\n\t\t\tdenom2 _ denom1.\t\t\t\"Set second denominator to first\"\n\t\t\tdenom1 _ int * denom1 + temp.\t\t\"Update first denominator\"\n\t\t\t10000.0 < denom1\n\t\t\t\tifTrue:\n\t\t\t\t\t[\"Is ratio past float precision?  If so, pick which\n\t\t\t\t\tof the two ratios to use\"\n\t\t\t\t\tnum2 = 0.0\n\t\t\t\t\t\tifTrue: [\"Is second denominator 0?\"\n\t\t\t\t\t\t\t\t^Fraction numerator: num1 denominator: denom1].\n\t\t\t\t\t^Fraction numerator: num2 denominator: denom2]].\n\t\"If fractional part is zero, return the first ratio\"\n\tdenom1 = 1\n\t\tifTrue: [\"Am i really an Integer?\"\n\t\t\t\t^num1\"Yes, return Integer result\"]\n\t\tifFalse: [\"Otherwise return Fraction result\"\n\t\t\t\t^Fraction numerator: num1 denominator: denom1]\n",
          "asFloat": "asFloat\n\t\"Answer with the receiver itself.\"\n\t^self\n",
          "radiansToDegrees": "radiansToDegrees\n\t^self / RadiansPerDegree\n",
          "degreesToRadians": "degreesToRadians\n\t^self * RadiansPerDegree\n"
        },
        "arithmetic": {
          "-": "- aNumber\n\t\"Subtract the argument from the receiver and return the result as a Float.  Fail if\n\tthe argument is not a Float.  Essential.  See Object documentation\n\twhatIsAPrimitive. \"\n\n\t<primitive: 42>\n\t^self retry: #- coercing: aNumber\n",
          "/": "/ aNumber\n\t\"Divide the receiver by the argument and return the exact result as a Float.  Fail\n\tif the argument is not a Float.  Essential.  See Object documentation\n\twhatIsAPrimitive. \"\n\n\t<primitive: 50>\n\taNumber = 0\n\t\tifTrue: [self error: 'attempt to divide by zero']\n\t\tifFalse: [^self retry: #/ coercing: aNumber]\n",
          "*": "* aNumber\n\t\"Multiply the receiver by the argument and return the result as a Float.  Fail if\n\tthe argument is not a Float.  Essential.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 49>\n\t^self retry: #* coercing: aNumber\n",
          "+": "+ aNumber\n\t\"Add the receiver to the argument and return the result as a Float.  Fail if the\n\targument is not a Float.  Essential.  See Object documentation\n\twhatIsAPrimitive. \"\n\n\t<primitive: 41>\n\t^self retry: #+ coercing: aNumber\n",
          "negated": "negated\n\t\"Answer a Number that is the negation of the receiver.\"\n\t^0.0 - self\n"
        },
        "mathematical functions": {
          "floorLog:": "floorLog: radix\n\t\"quick computation of (self log: radix) floor\"\n\n\t| x |\n\tself < radix ifTrue: [^0]. \t\"self assumed positive\"\n\tself < radix squared ifTrue: [^1].\n\tx _ 2 * (self floorLog: radix squared).\t\"binary recursion like ipow\"\n\t^x + (self / (radix raisedTo: x) floorLog: radix)\n",
          "arcSin": "arcSin\n\t\"Answers with the angle in radians\"\n\n\tself abs > 1.0 ifTrue: [self error: 'Value out of range'].\n\tself abs = 1.0\n\t\tifTrue: [^Halfpi]\n\t\tifFalse: [^(self / (1 - (self * self)) sqrt) arcTan]\n",
          "sin": "sin\n\t\"Answers with the sine of the receiver in radians.\"\n\n\t| x x2 sum |\n\t\t\"normalize to 0<=self<=(Pi/2)\"\n\tself < 0.0 ifTrue: [^self negated sin negated].\n\tself > Twopi ifTrue: [^(self \\\\ Twopi) sin].\n\tself > Pi ifTrue: [^(self - Pi) sin negated].\n\tself > Halfpi ifTrue: [^(Pi - self) sin].\n\tsum _ x _ self.\n\tx2 _ x * x.\n\tSinCoefficients do: [:const | sum _ const * (x _ x * x2) + sum].\n\t^sum\n",
          "exp": "exp\n\t\"see Computer Approximations, pp. 96-104, p. 205 (EXPB 1065)\"\n\n\t| a n1 x x2 P Q |\n\tself abs > 9212.0\n\t\tifTrue: [\"Float maxVal ln\"\n\t\t\t\"1.0 exp\"\n\t\t\tself error: 'exp overflow']\n\t\tifFalse:\n\t\t\t[x _ self / Ln2.\n\t\t\tn1 _ 2.0 raisedTo: x truncated.\n\t\t\t(x _ x - x truncated) >= 0.5\n\t\t\t\tifTrue:\n\t\t\t\t\t[n1 _ n1 * Sqrt2.\n\t\t\t\t\tx _ x - 0.5].\n\t\t\tx2 _ x * x.\n\t\t\t\"compute 2.0 power: x\"\n\t\t\tP _ Q _ 0.0.\n\t\t\tExpPCoefficients do: [:a | P _ P * x2 + a].\n\t\t\tExpQCoefficients do: [:a | Q _ Q * x2 + a].\n\t\t\t^n1 * (Q + (x * P) / (Q - (x * P)))]\n",
          "arcTan": "arcTan\n\t\"Answers with the angle in radians\"\n\n\t| theta term y eps i |\n\tself = 1.0 ifTrue: [^Fourthpi].\n\tself = -1.0 ifTrue: [^Fourthpi negated].\n\tself * self > 1.0\n\t\tifTrue:\n\t\t\t[theta _ Halfpi.\n\t\t\ty _ -1.0 / (self * self).\n\t\t\tterm _ -1.0 / self abs]\n\t\tifFalse:\n\t\t\t[theta _ 0.0.\n\t\t\ty _ 0.0 - (self * self).\n\t\t\tterm _ self abs].\n\ti _ 1.\n\teps _ 1.0e-4.\n\t[term abs > eps]\n\t\twhileTrue:\n\t\t\t[theta _ theta + term.\n\t\t\tterm _ term * y * i asFloat / (i + 2) asFloat.\n\t\t\ti _ i + 2].\n\t^self sign asFloat * theta\n",
          "arcCos": "arcCos\n\t\"Answers with the angle in radians.\"\n\n\t^Halfpi - self arcSin\n",
          "log": "log\n\t\"Base 10 logarithm\"\n\n\t^self ln / 10.0 ln\n",
          "sqrt": "sqrt\n\t| guess |\n\tself <= 0.0 ifTrue: [self = 0.0\n\t\t\tifTrue: [^0.0]\n\t\t\tifFalse: [^self error: 'sqrt invalid for x < 0']].\n\t\"copy and halve the exponent for first guess\"\n\tguess _ self timesTwoPower: 0 - (self exponent // 2).\n\t5 timesRepeat: [guess _ self - (guess * guess) / (guess * 2.0) + guess].\n\t^guess\n",
          "ln": "ln\n\t\"see Computer Approximations, pp. 105-111, p. 227 (LOGE 2663)\"\n\n\t| expt x x2 n P |\n\tself <= 0.0\n\t\tifTrue: [self error: 'ln not valid for ' , self printString]\n\t\tifFalse:\n\t\t\t[expt _ self exponent.\n\t\t\tn _ Ln2 * (expt - 0.5).\n\t\t\t\"mantissa between 0.5 and 1.0\"\n\t\t\tx _ self timesTwoPower: 0 - expt.\n\t\t\tx _ x * Sqrt2.\n\t\t\tx _ x - 1.0 / (x + 1.0).\n\t\t\tx2 _ x * x.\n\t\t\tP _ 0.0.\n\t\t\tLnCoefficients do: [:a | P _ P * x2 + a].\n\t\t\t^n + (x * P)]\n\n\"2.718284 ln 1.0\"\n",
          "cos": "cos\n\t\"Answers with the cosine of the receiver in radians.\"\n\n\tself < 0.0 ifTrue: [^(self + Halfpi) sin].\n\t^(Halfpi - self) sin\n",
          "tan": "tan\n\t\"Answer the ratio of the sine to cosine of the receiver in radians.\"\n\n\t| x x2 sum |\n\t\t\"normalize to 0<=self<=(Pi/4)\"\n\tself < 0.0 ifTrue: [^self negated tan negated].\n\tself > Pi ifTrue: [^(self \\\\ Pi) tan].\n\tself > Halfpi ifTrue: [^(Pi - self) tan negated].\n\tself > Fourthpi ifTrue: [^1.0 / (Halfpi - self) tan].\n\tsum _ x _ self.\n\tx2 _ x * x.\n\tTanCoefficients do: [:const | sum _ const * (x _ x * x2) + sum].\n\t^sum\n"
        }
      }
    },
    "Integer": {
      "comment": "I am a common abstract superclass for all Integer implementations.  My implementation subclasses are SmallInteger, LargePositiveInteger, and LargeNegativeInteger.\n",
      "class_name": "Integer",
      "superclass": "Number",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new:neg:": "new: length neg: neg\n\t\"Answer an instance of a large integer whose size is length.  neg is a flag determining\n\twhether the integer is negative or not.\"\n\n\tneg\n\t\tifTrue: [^LargeNegativeInteger new: length]\n\t\tifFalse: [^LargePositiveInteger new: length]\n",
          "readFrom:radix:": "readFrom: aStream radix: radix\n\t\"Answer an instance of one of my concrete subclasses. Initial minus sign accepted,\n\tand bases > 10 use letters A-Z. imbedded radix specifiers not allowed - use Integer\n\tclass readFrom: for that. Answer zero (not an error) if there are no digits.\"\n\n\t| digit value neg |\n\tneg _ aStream peekFor: $-.\n\tvalue _ 0.\n\t[aStream atEnd]\n\t\twhileFalse:\n\t\t\t[digit _ aStream next digitValue.\n\t\t\t(digit < 0 or: [digit >= radix])\n\t\t\t\tifTrue:\n\t\t\t\t\t[aStream skip: -1.\n\t\t\t\t\tneg ifTrue: [^value negated truncated\"catch 0 minVal\"].\n\t\t\t\t\t^value]\n\t\t\t\tifFalse: [value _ value * radix + digit]].\n\tneg ifTrue: [^value negated truncated\"catch 0 minVal\"].\n\t^value\n",
          "readFrom:": "readFrom: aStream\n\t\"Answer a new Integer as described on the stream, aStream.\"\n\n\t^self readFrom: aStream radix: 10\n"
        }
      },
      "instance_methods": {
        "comparing": {
          "hash": "hash\n\t^(self lastDigit bitShift: 8) + (self digitAt: 1)\n",
          ">": "> anInteger\n\t\"Compare the receiver with the argument and return true if the receiver is\n\tgreater than the argument. Otherwise return false.\"\n\n\tanInteger isInteger\n\t\tifTrue: [self negative == anInteger negative\n\t\t\t\t\tifTrue: [self negative\n\t\t\t\t\t\t\t\tifTrue: [^(self digitCompare: anInteger) < 0]\n\t\t\t\t\t\t\t\tifFalse: [^(self digitCompare: anInteger) > 0]]\n\t\t\t\t\tifFalse: [^anInteger negative]]\n\t\tifFalse: [^self retry: #> coercing: anInteger]\n",
          "<": "< anInteger\n\t\"Compare the receiver with the argument and return true if the receiver is\n\tless than the argument. Otherwise return false.\"\n\n\tanInteger isInteger\n\t\tifTrue: [self negative == anInteger negative\n\t\t\t\t\tifTrue: [self negative\n\t\t\t\t\t\t\t\tifTrue: [^(self digitCompare: anInteger) > 0]\n\t\t\t\t\t\t\t\tifFalse: [^(self digitCompare: anInteger) < 0]]\n\t\t\t\t\tifFalse: [^self negative]]\n\t\tifFalse: [^self retry: #< coercing: anInteger]\n",
          "=": "= anInteger\n\t\"Compare the receiver with the argument and return true if the receiver is\n\tequal to the argument. Otherwise return false.\"\n\n\tanInteger isInteger\n\t\tifTrue: [anInteger positive & self positive | (anInteger negative & self negative)\n\t\t\t\t\tifTrue: [^(self digitCompare: anInteger) = 0]\n\t\t\t\t\tifFalse: [^false]]\n\t\tifFalse: [^self retry: #= coercing: anInteger]\n",
          ">=": ">= anInteger\n\t\"Compare the receiver with the argument and return true if the receiver is\n\tgreater than or equal to the argument. Otherwise return false.\"\n\n\t^super >= anInteger\n",
          "~=": "~= anInteger\n\t\"Compare the receiver with the argument and return true if the receiver is\n\tnot equal to the argument. Otherwise answer false.\"\n\n\t^super ~= anInteger\n",
          "<=": "<= anInteger\n\t\"Compare the receiver with the argument and return true if the receiver is\n\tless than or equal to the argument. Otherwise return false.\"\n\n\t^super <= anInteger\n"
        },
        "coercing": {
          "coerce:": "coerce: aNumber\n\t^aNumber truncated\n",
          "generality": "generality\n\t^40\n"
        },
        "truncation and round off": {
          "truncated": "truncated\n",
          "rounded": "rounded\n",
          "ceiling": "ceiling\n",
          "floor": "floor\n"
        },
        "bit manipulation": {
          "bitShift:": "bitShift: anInteger\n\t\"Logical SHIFT the twos-complement representation of the receiver with the\n\ttwos-complement representation of the argument and return the result.\n\tShift left if the argument is positive, right if the argument is negative.\n\tZeros are shifted in from the right in left shifts.\n\tThe sign bit is extended in right shifts.\"\n\n\t| result abs |\n\tanInteger >= 0 ifTrue: [^(self\n\t\t\tdigitLshift: (anInteger bitAnd: 7)\n\t\t\tbytes: (anInteger bitShift: -3)\n\t\t\tlookfirst: true) truncated].\n\tabs _ 0 - anInteger.\n\tresult _ (self\n\t\t\t\tdigitRshift: (abs bitAnd: 7)\n\t\t\t\tbytes: (abs bitShift: -3)\n\t\t\t\tlookfirst: self digitLength) truncated.\n\t(self negative and: [self anyBitTo: abs])\n\t\tifTrue: [result _ result - 1].\n\t^result\n",
          "anyMask:": "anyMask: mask\n\t\"Treat the argument as a bit mask.  Answer true if any of the\n\tbits that are 1 in the argument are 1 in the receiver.\"\n\n\t^0 ~= (self bitAnd: mask)\n",
          "highBit": "highBit\n\t\"Answer with the index of the high order bit of the binary\n\trepresentation of the receiver.\"\n\n\tself subclassResponsibility\n",
          "bitInvert": "bitInvert\n\t\"Answer an integer whose bits are the complement of the receiver.\"\n\n\t^-1 - self\n",
          "bitAt:": "bitAt: i\n\t\"Answer the bit at the ith position.\"\n\n\t^(self bitAnd: (1 bitShift: i - 1)) = 0\n\t\tifTrue: [0]\n\t\tifFalse: [1]\n",
          "bitOr:": "bitOr: aNumber\n\t\"Logical OR the twos-complement representation of the receiver with the\n\ttwos-complement representation of the argument and return the result.\"\n\n\t| anInteger |\n\tanInteger _ aNumber truncated.\n\t^self\n\t\tdigitLogic: anInteger\n\t\top: #bitOr:\n\t\tlength: (self digitLength max: anInteger digitLength)\n",
          "bitXor:": "bitXor: aNumber\n\t\"Logical XOR the twos-complement representation of the receiver with the\n\ttwos-complement representation of the argument and return the result.\"\n\n\t| anInteger |\n\tanInteger _ aNumber truncated.\n\t^self\n\t\tdigitLogic: anInteger\n\t\top: #bitXor:\n\t\tlength: (self digitLength max: anInteger digitLength)\n",
          "noMask:": "noMask: mask\n\t\"Treat the argument as a bit mask.  Answer true if none of the bits\n\tthat are 1 in the argument are 1 in the receiver.\"\n\n\t^0 = (self bitAnd: mask)\n",
          "allMask:": "allMask: mask\n\t\"Treat the argument as a bit mask.  Answer true if all of the\n\tbits that are 1 in the argument are 1 in the receiver.\"\n\n\t^mask = (self bitAnd: mask)\n",
          "bitAnd:": "bitAnd: aNumber\n\t\"Logical AND the twos-complement representation of the receiver with the\n\ttwos-complement representation of the argument and return the result.\"\n\n\t| anInteger |\n\tanInteger _ aNumber truncated.\n\t^self\n\t\tdigitLogic: anInteger\n\t\top: #bitAnd:\n\t\tlength: (self digitLength max: anInteger digitLength)\n"
        },
        "printing": {
          "isLiteral": "isLiteral\n\t^true\n",
          "printOn:": "printOn: aStream\n\tself printOn: aStream base: 10\t\"default print radix\"\n",
          "printStringRadix:": "printStringRadix: radix\n\t\"Answer a String representing the receiver as a base radix integer.\"\n\n\t| aStream |\n\taStream _ WriteStream on: (String new: 16).\n\tself printOn: aStream base: radix.\n\t^aStream contents\n",
          "storeStringRadix:": "storeStringRadix: radix\n\t\"Answer a String representing the receiver as a base radix integer in Smalltalk syntax (e.g. 8r377).\"\n\n\t| aStream |\n\taStream _ WriteStream on: (String new: 16).\n\tradix ~= 10 ifTrue:\n\t\t[radix printOn: aStream.\n\t\taStream nextPutAll: 'r'].\n\tself printOn: aStream base: radix.\n\t^aStream contents\n",
          "printOn:base:": "printOn: aStream base: b\n\t\"Print a representation of the receiver on the stream, aStream, in\n\tbase b where 2<=b<=256.\"\n\n\t| digits source dest i j pos t rem |\n\ti _ self digitLength.\n\t\"Estimate size of result, conservatively\"\n\tdigits _ Array new: i * 8.\n\tpos _ 0.\n\tdest _\n\t\ti <= 1\n\t\t\tifTrue: [self]\n\t\t\tifFalse: [LargePositiveInteger new: i].\n\tsource _ self.\n\t[i > 1]\n\t\twhileTrue:\n\t\t\t[rem _ 0.\n\t\t\tj _ i.\n\t\t\t[j > 0]\n\t\t\t\twhileTrue:\n\t\t\t\t\t[t _ (rem bitShift: 8) + (source digitAt: j).\n\t\t\t\t\tdest digitAt: j put: t // b.\n\t\t\t\t\trem _ t \\\\ b.\n\t\t\t\t\tj _ j - 1].\n\t\t\tpos _ pos + 1.\n\t\t\tdigits at: pos put: rem.\n\t\t\tsource _ dest.\n\t\t\t(source digitAt: i) = 0 ifTrue: [i _ i - 1]].\n\t(dest digitAt: 1) printOn: aStream base: b.\n\t[pos > 0]\n\t\twhileTrue:\n\t\t\t[aStream nextPut: (Character digitValue: (digits at: pos)).\n\t\t\tpos _ pos - 1]\n"
        },
        "testing": {
          "even": "even\n\t^((self digitAt: 1) bitAnd: 1) = 0\n",
          "isInteger": "isInteger\n\t^true\n"
        },
        "private": {
          "denominator": "denominator\n\t^1\n",
          "digitAdd:": "digitAdd: arg\n\t| len arglen i accum sum |\n\taccum _ 0.\n\t(len _ self digitLength) < (arglen _ arg digitLength) ifTrue: [len _ arglen].\n\t\"Open code max: for speed\"\n\tsum _ Integer new: len neg: self negative.\n\ti _ 1.\n\t[i <= len]\n\t\twhileTrue:\n\t\t\t[accum _ (accum bitShift: -8) + (self digitAt: i) + (arg digitAt: i).\n\t\t\tsum digitAt: i put: (accum bitAnd: 255).\n\t\t\ti _ i + 1].\n\taccum > 255\n\t\tifTrue:\n\t\t\t[sum _ sum growby: 1.\n\t\t\tsum lastDigitGet: (accum bitShift: -8)].\n\t^sum\n",
          "anyBitTo:": "anyBitTo: pos\n\t\"Answer true if any bit from 1 to pos is non-zero, for testing for loss of significant\n\tbits when shifting right\"\n\n\t1 to: pos - 1 // 8 do:\n\t\t[:i | (self digitAt: i) ~= 0 ifTrue: [^true]].\n\t^(self digitAt: pos + 7 // 8) anyMask: (#(1 3 7 15 31 63 127 255) at: pos - 1 \\\\ 8 + 1)\n",
          "digitDiv:neg:": "digitDiv: arg neg: ng\n\t\"Answer with an array of (quotient, remainder)\"\n\n\t| quo rem ql d div dh dnh dl qhi qlo i j k l hi lo r3 a t |\n\tl _ self digitLength - arg digitLength + 1.\n\tl <= 0 ifTrue: [^Array with: 0 with: self].\n\td _ 8 - arg lastDigit highBit.\n\trem _\n\t\tself\tdigitLshift: d\n\t\t\tbytes: 0\n\t\t\tlookfirst: false.\n\t\"makes a copy and shifts\"\n\tdiv _\n\t\targ digitLshift: d\n\t\t\tbytes: 0\n\t\t\tlookfirst: false.\n\t\"shifts so high order word is >=128\"\n\tquo _ Integer new: l neg: ng.\n\tdl _ div digitLength - 1.\n\t\"Last actual byte of data\"\n\tql _ l.\n\tdh _ div digitAt: dl.\n\tdnh _\n\t\t dl = 1\n\t\t\tifTrue: [0]\n\t\t\tifFalse: [div digitAt: dl - 1].\n\t1 to: ql do:\n\t\t[:k |\n\t\t\"maintain quo*arg+rem=self\"\n\t\t\"Estimate rem/div by dividing the leading to bytes of rem by dh.\"\n\t\t\"The estimate is q = qhi*16+qlo, where qhi and qlo are nibbles.\"\n\t\tj _ rem digitLength + 1 - k.\n\t\t\"r1 _ rem digitAt: j.\"\n\t\t(rem digitAt: j) = dh\n\t\t\tifTrue: [qhi _ qlo _ 15\"i.e. q=255\"]\n\t\t\tifFalse:\n\t\t\t\t[\"Compute q = (r1,r2)//dh, t = (r1,r2)\\\\dh.\n\t\t\t\tNote that r1,r2 are bytes, not nibbles.\n\t\t\t\tBe careful not to generate intermediate results exceeding 13 bits.\"\n\t\t\t\t\"r2 _ (rem digitAt: j - 1).\"\n\t\t\t\tt _ ((rem digitAt: j) bitShift: 4) + ((rem digitAt: j - 1) bitShift: -4).\n\t\t\t\tqhi _ t // dh.\n\t\t\t\tt _ (t \\\\ dh bitShift: 4) + ((rem digitAt: j - 1) bitAnd: 15).\n\t\t\t\tqlo _ t // dh.\n\t\t\t\tt _ t \\\\ dh.\n\t\t\t\t\"Next compute (hi,lo) _ q*dnh\"\n\t\t\t\thi _ qhi * dnh.\n\t\t\t\tlo _ qlo * dnh + ((hi bitAnd: 15) bitShift: 4).\n\t\t\t\thi _ (hi bitShift: -4) + (lo bitShift: -8).\n\t\t\t\tlo _ lo bitAnd: 255.\n\t\t\t\t\"Correct overestimate of q.\n\t\t\t\tMax of 2 iterations through loop -- see Knuth vol. 2\"\n\t\t\t\tr3 _\n\t\t\t\t\tj < 3 ifTrue: [0]\n\t\t\t\t\t\t ifFalse: [rem digitAt: j - 2].\n\t\t\t\t[(t < hi or: [t = hi and: [r3 < lo]]) and:\n\t\t\t\t\t\t[\"i.e. (t,r3) < (hi,lo)\"\n\t\t\t\t\t\tqlo _ qlo - 1.\n\t\t\t\t\t\tlo _ lo - dnh.\n\t\t\t\t\t\tlo < 0\n\t\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t\t[hi _ hi - 1.\n\t\t\t\t\t\t\t\tlo _ lo + 256].\n\t\t\t\t\t\thi >= dh]]\n\t\t\t\t\twhileTrue: [hi _ hi - dh].\n\t\t\t\tqlo < 0\n\t\t\t\t\tifTrue:\n\t\t\t\t\t\t[qhi _ qhi - 1.\n\t\t\t\t\t\tqlo _ qlo + 16]].\n\t\t\"Subtract q*div from rem\"\n\t\tl _ j - dl.\n\t\ta _ 0.\n\t\t1 to: div digitLength do:\n\t\t\t[:i |\n\t\t\thi _ (div digitAt: i) * qhi.\n\t\t\tlo _\n\t\t\t\ta + (rem digitAt: l)\n\t\t\t\t\t- ((hi bitAnd: 15) bitShift: 4)\n\t\t\t\t\t- ((div digitAt: i) * qlo).\n\t\t\trem digitAt: l put: (lo bitAnd: 255).\n\t\t\ta _ (lo bitShift: -8) - (hi bitShift: -4).\n\t\t\tl _ l + 1].\n\t\ta < 0\n\t\t\tifTrue:\n\t\t\t\t[\"Add div back into rem, decrease q by 1\"\n\t\t\t\tqlo _ qlo - 1.\n\t\t\t\tl _ j - dl.\n\t\t\t\ta _ 0.\n\t\t\t\t1 to: div digitLength do:\n\t\t\t\t\t[:i |\n\t\t\t\t\ta _ (a bitShift: -8) + (rem digitAt: l) + (div digitAt: i).\n\t\t\t\t\trem digitAt: l put: (a bitAnd: 255).\n\t\t\t\t\tl _ l + 1]].\n\t\tquo digitAt: quo digitLength + 1 - k put: (qhi bitShift: 4) + qlo].\n\trem _\n\t\trem digitRshift: d\n\t\t\tbytes: 0\n\t\t\tlookfirst: dl.\n\t^Array with: quo with: rem\n",
          "copyto:": "copyto: x\n\t1 to: (self digitLength min: x digitLength)\n\t\tdo: [:i | x digitAt: i put: (self digitAt: i)].\n\t^x\n",
          "digitMultiply:neg:": "digitMultiply: arg neg: ng\n\t| prod pl carry digit i j k xh xl low high |\n\t((arg digitAt: 1) = 0 and: [arg digitLength = 1]) ifTrue: [^0].\n\tpl _ self digitLength + arg digitLength.\n\tprod _ Integer new: pl neg: ng.\n\t\"prod starts out all zero\"\n\t1 to: self digitLength do:\n\t\t[:i |\n\t\t(digit _ self digitAt: i) ~= 0\n\t\t\tifTrue:\n\t\t\t\t[k _ i.\n\t\t\t\tcarry _ 0.\n\t\t\t\txh _ digit bitShift: -4.\n\t\t\t\txl _ digit bitAnd: 15.\n\t\t\t\t\"Loop invariant: 0<=carry<=0377, k=i+j-1\"\n\t\t\t\t1 to: arg digitLength do:\n\t\t\t\t\t[:j |\n\t\t\t\t\thigh _ (arg digitAt: j) * xh.\n\t\t\t\t\t\"Do double-precision multiply in two parts.\n\t\t\t\t\tIntegers must be at least 13 bits for this to work.\"\n\t\t\t\t\tlow _ (arg digitAt: j)\n\t\t\t\t\t\t\t\t* xl + ((high bitAnd: 15)\n\t\t\t\t\t\t\t\t\tbitShift: 4) + carry + (prod digitAt: k).\n\t\t\t\t\tcarry _ (high bitShift: -4) + (low bitShift: -8).\n\t\t\t\t\tprod digitAt: k put: (low bitAnd: 255).\n\t\t\t\t\tk _ k + 1].\n\t\t\t\tprod digitAt: k put: carry]].\n\t(prod digitAt: pl) = 0 ifTrue: [^(prod growby: -1) truncated].\n\t^prod truncated\n",
          "growby:": "growby: n\n\t^self growto: self digitLength + n\n",
          "digitLshift:bytes:lookfirst:": "digitLshift: n bytes: b lookfirst: a\n\t| x f m len r digit |\n\t\"shift by 8*b+n bits, 0<=n<8.  a true means check for a leading zero byte in the\n\tresult \"\n\tx _ 0.\n\tf _ n - 8.\n\tm _ 255 bitShift: 0 - n.\n\tlen _ self digitLength + 1 + b.\n\t(a and: [(self lastDigit bitShift: f) = 0])\n\t\tifTrue: [len _ len - 1].\n\tr _ Integer new: len neg: self negative.\n\t1 to: b do: [:i | r digitAt: i put: 0].\n\t1 to: len - b do:\n\t\t[:i |\n\t\tdigit _ self digitAt: i.\n\t\tr\n\t\t\tdigitAt: i + b\n\t\t\tput: (((digit bitAnd: m) bitShift: n) bitOr: x).\n\t\t\"Avoid values > 8 bits\"\n\t\tx _ digit bitShift: f].\n\t^r\n",
          "growto:": "growto: n\n\t^self copyto: (self species new: n)\n",
          "digitRshift:bytes:lookfirst:": "digitRshift: anInteger bytes: b lookfirst: a\n\t \"shift right 8*b+anInteger bits, 0<=n<8.  Discard all digits beyond a,\n\tand all zeroes at or below a.\"\n\n\t| n x i r f m digit count|\n\tn _ 0 - anInteger.\n\tx _ 0.\n\tf _ n + 8.\n\ti _ a.\n\tm _ 255 bitShift: 0 - f.\n\tdigit _ self digitAt: i.\n\t[((digit bitShift: n) bitOr: x) = 0 and: [i ~= 1]] whileTrue:\n\t\t[x _ digit bitShift: f \"Can't exceed 8 bits\".\n\t\ti _ i - 1.\n\t\tdigit _ self digitAt: i].\n\ti <= b ifTrue: [^Integer new: 0 neg: self negative].  \"All bits lost\"\n\tr _ Integer new: i - b neg: self negative.\n\tcount _ i.\n\tx _ (self digitAt: b + 1) bitShift: n.\n\tb + 1 to: count do:\n\t\t[:i | digit _ self digitAt: i + 1.\n\t\tr digitAt: i - b put: (((digit bitAnd: m) bitShift: f) bitOr: x)\n\t\t\t\"Avoid values > 8 bits\".\n\t\tx _ digit bitShift: n].\n\t^r\n",
          "digitSubtract:": "digitSubtract: arg\n\t| smaller larger i z sum sl al ng lastdigit |\n\tsl _ self digitLength.\n\tal _ arg digitLength.\n\t(sl = al\n\t\tifTrue:\n\t\t\t[[(self digitAt: sl) = (arg digitAt: sl) and: [sl > 1]]\n\t\t\t\twhileTrue: [sl _ sl - 1].\n\t\t\tal _ sl.\n\t\t\t(self digitAt: sl) < (arg digitAt: sl)]\n\t\tifFalse: [sl < al])\n\t\tifTrue:\n\t\t\t[larger _ arg.\n\t\t\tsmaller _ self.\n\t\t\tng _ self negative == false.\n\t\t\tsl _ al]\n\t\tifFalse:\n\t\t\t[larger _ self.\n\t\t\tsmaller _ arg.\n\t\t\tng _ self negative].\n\tsum _ Integer new: sl neg: ng.\n\tlastdigit _ 1.\n\tz _ 0.\n\t\"Loop invariant is -1<=z<=1\"\n\ti _ 1.\n\t[i <= sl]\n\t\twhileTrue:\n\t\t\t[z _ z + (larger digitAt: i) - (smaller digitAt: i).\n\t\t\t(sum digitAt: i put: (z bitAnd: 255)) ~= 0 ifTrue: [lastdigit _ i].\n\t\t\tz _ z bitShift: -8.\n\t\t\ti _ i + 1].\n\tlastdigit = sl ifFalse: [sum _ sum growto: lastdigit].\n\t^sum truncated\n",
          "digitCompare:": "digitCompare: arg\n\t| len arglen t5 t6 |\n\tlen _ self digitLength.\n\t(arglen _ arg digitLength) ~= len\n\t\tifTrue: [arglen > len\n\t\t\t\t\tifTrue: [^-1]\n\t\t\t\t\tifFalse: [^1]].\n\t[len > 0]\n\t\twhileTrue:\n\t\t\t[(t5 _ arg digitAt: len) ~= (t6 _ self digitAt: len)\n\t\t\t\tifTrue: [t5 < t6\n\t\t\t\t\t\t\tifTrue: [^1]\n\t\t\t\t\t\t\tifFalse: [^-1]].\n\t\t\tlen _ len - 1].\n\t^0\n",
          "digitLogic:op:length:": "digitLogic: arg op: op length: len\n\t| result i neg1 neg2 rneg z1 z2 rz b1 b2 b rdigits |\n\tneg1 _ self negative.\n\tneg2 _ arg negative.\n\trneg _\n\t\t((neg1 ifTrue: [-1] ifFalse: [0])\n\t\t\tperform: op\n\t\t\twith: (neg2\n\t\t\t\t\tifTrue: [-1]\n\t\t\t\t\tifFalse: [0])) < 0.\n\tresult _ Integer new: len neg: rneg.\n\trz _ z1 _ z2 _ true.\n\trdigits _ 1.\n\t1 to: result digitLength do:\n\t\t[:i |\n\t\tb1 _ self digitAt: i.\n\t\tneg1\n\t\t\tifTrue: [b1 _ z1\n\t\t\t\t\t\tifTrue: [b1 = 0\n\t\t\t\t\t\t\t\t\tifTrue: [0]\n\t\t\t\t\t\t\t\t\tifFalse:\n\t\t\t\t\t\t\t\t\t\t[z1 _ false.\n\t\t\t\t\t\t\t\t\t\t256 - b1]]\n\t\t\t\t\t\tifFalse: [255 - b1]].\n\t\tb2 _ arg digitAt: i.\n\t\tneg2\n\t\t\tifTrue: [b2 _ z2\n\t\t\t\t\t\tifTrue: [b2 = 0\n\t\t\t\t\t\t\t\t\tifTrue: [0]\n\t\t\t\t\t\t\t\t\tifFalse:\n\t\t\t\t\t\t\t\t\t\t[z2 _ false.\n\t\t\t\t\t\t\t\t\t\t256 - b2]]\n\t\t\t\t\t\tifFalse: [255 - b2]].\n\t\tb _ b1 perform: op with: b2.\n\t\tb = 0\n\t\t\tifTrue:\n\t\t\t\t[result digitAt: i put: 0]\n\t\t\tifFalse:\n\t\t\t\t[rdigits _ i.\n\t\t\t\tresult\n\t\t\t\t\tdigitAt: i\n\t\t\t\t\tput: (rneg\n\t\t\t\t\t\t\tifTrue: [rz ifTrue:\n\t\t\t\t\t\t\t\t\t\t\t[rz _ false.\n\t\t\t\t\t\t\t\t\t\t\t256 - b]\n\t\t\t\t\t\t\t\t\t\tifFalse: [255 - b]]\n\t\t\t\t\t\tifFalse: [b])]].\n\trdigits ~= result digitLength ifTrue: [^(result growto: rdigits) truncated].\n\t^result truncated\n",
          "numerator": "numerator\n\t^self\n"
        },
        "converting": {
          "asCharacter": "asCharacter\n\t\"Answer the Character whose value is the receiver.\"\n\n\t^Character value: self\n",
          "asFraction": "asFraction\n\t\"Answer with a Fraction that represents the receiver.\"\n\n\t^Fraction numerator: self denominator: 1\n",
          "asFloat": "asFloat\n\t\"Answer with a Float that represents the receiver.\"\n\n\t| factor sum |\n\tsum _ 0.0.\n\tfactor _ self sign asFloat.\n\t1 to: self size do:\n\t\t[:i |\n\t\tsum _ (self digitAt: i) * factor + sum.\n\t\tfactor _ factor * 256.0].\n\t^sum\n",
          "asInteger": "asInteger\n\t\"Answer with the receiver itself.\"\n\n\t^self\n"
        },
        "enumerating": {
          "timesRepeat:": "timesRepeat: aBlock\n\t\"Evaluate the argument, aBlock, the number of times represented by\n\tthe receiver.\"\n\n\t| count |\n\tcount _ 1.\n\t[count <= self]\n\t\twhileTrue:\n\t\t\t[aBlock value.\n\t\t\tcount _ count + 1]\n"
        },
        "arithmetic": {
          "-": "- aNumber\n\t\"Subtract the argument from the receiver and answer with the result.\"\n\n\taNumber isInteger\n\t\tifTrue: [self negative == aNumber negative\n\t\t\t\t\tifTrue: [^self digitSubtract: aNumber]\n\t\t\t\t\tifFalse: [^self digitAdd: aNumber]]\n\t\tifFalse: [^self retry: #- coercing: aNumber]\n",
          "/": "/ aNumber\n\t\"Divide the receiver by the argument and answer with the result if the division\n\tis exact.\"\n\n\t| quoRem |\n\taNumber isInteger\n\t\tifTrue:\n\t\t\t[quoRem _ self digitDiv: aNumber neg: self negative ~~ aNumber negative.\n\t\t\t(quoRem at: 2) = 0\n\t\t\t\tifTrue: [^(quoRem at: 1) truncated]\n\t\t\t\tifFalse: [^(Fraction numerator: self denominator: aNumber) reduced]]\n\t\tifFalse: [^self retry: #/ coercing: aNumber]\n",
          "*": "* aNumber\n\t\"Multiply the receiver by the argument and answer with the result.\"\n\n\taNumber isInteger\n\t\tifTrue: [^(self\n\t\t\t\t\tdigitMultiply: aNumber\n\t\t\t\t\tneg: self negative ~~ aNumber negative) truncated]\n\t\tifFalse: [^self retry: #* coercing: aNumber]\n",
          "quo:": "quo: aNumber\n\t\"Divide the receiver by the argument and return the result.\n\tRound the result down towards zero to make it a whole integer.\"\n\n\t| ng quo |\n\taNumber isInteger\n\t\tifTrue:\n\t\t\t[ng _ self negative == aNumber negative == false.\n\t\t\tquo _ (self digitDiv: aNumber neg: ng) at: 1.\n\t\t\t(quo lastDigit = 0 and: [quo digitLength >= 2])\n\t\t\t\tifTrue: [^(quo growby: -1) truncated].\n\t\t\t^quo truncated]\n\t\tifFalse: [^self retry: #quo: coercing: aNumber]\n",
          "\\\\": "\\\\ aNumber\n\t\"Take the receiver modulo the argument and return the result.\n\tThe result is the remainder rounded towards negative infinity, of the receiver\n\tdivided by the argument. The remainder is defined in terms of //.\n\tThe result has the same sign as the argument:\n\t\te.g.  9\\\\4 = 1,  -9\\\\4 = 3,  9\\\\-4 =  -3,  -9\\\\-4 = -1 \"\n\n\t^self - (self // aNumber * aNumber)\n",
          "//": "// aNumber\n\t\"Divide the receiver by the argument and return the result.\n\tRound the result down towards negative infinity to make it a whole integer.\"\n\n\t| q |\n\taNumber = 0 ifTrue: [^self error: 'division by 0'].\n\tself = 0 ifTrue: [^0].\n\tq _ self quo: aNumber.\n\t(q negative\n\t\tifTrue: [q * aNumber ~= self]\n\t\tifFalse: [q = 0 and: [self negative ~= aNumber negative]])\n\t\tifTrue: [^q - 1\"Truncate towards minus infinity\"]\n\t\tifFalse: [^q]\n",
          "+": "+ aNumber\n\t\"Add the receiver to the argument and answer with the result.\"\n\n\taNumber isInteger\n\t\tifTrue: [self negative == aNumber negative\n\t\t\t\t\tifTrue: [^(self digitAdd: aNumber) truncated]\n\t\t\t\t\tifFalse: [^self digitSubtract: aNumber]]\n\t\tifFalse: [^self retry: #+ coercing: aNumber]\n"
        },
        "system primitives": {
          "lastDigit": "lastDigit\n\t\"Answer the last digit of the integer.\"\n\n\t^self digitAt: self digitLength\n",
          "lastDigitGet:": "lastDigitGet: digit\n\t\"Store the argument, digit, as the last digit of the integer.\"\n\n\t^self at: self digitLength put: digit\n"
        },
        "factorization and divisibility": {
          "lcm:": "lcm: n\n\t\"Answer the least common multiple of the receiver and n.\"\n\n\t^self // (self gcd: n) * n\n",
          "factorial": "factorial\n\t\"Answer the factorial of the receiver.  For example, 6 factorial == 6*5*4*3*2*1.\n\tSignal an error if the receiver is less than 0.\"\n\n\tself > 0\n\t\tifTrue: [^self * (self - 1) factorial].\n\tself = 0\n\t\tifTrue: [^1].\n\tself error: 'factorial invalid for: ' , self printString\n",
          "gcd:": "gcd: anInteger\n\t\"Answer the greatest common divisor of the receiver and anInteger.\n\tUses Roland Silver's algorithm\"\n\n\t| m n d t |\n\tm _ self abs max: anInteger abs.\n\tn _ self abs min: anInteger abs.\n\tm \\\\ n = 0 ifTrue: [^n].\n\t\"easy test, speeds up rest\"\n\td _ 0.\n\t[n even and: [m even]]\n\t\twhileTrue:\n\t\t\t[d _ d + 1.\n\t\t\tn _ n bitShift: -1.\n\t\t\tm _ m bitShift: -1].\n\t[n even]\n\t\twhileTrue: [n _ n bitShift: -1].\n\t[m even]\n\t\twhileTrue: [m _ m bitShift: -1].\n\t[m = n]\n\t\twhileFalse:\n\t\t\t[m > n\n\t\t\t\tifTrue:\n\t\t\t\t\t[m _ m - n]\n\t\t\t\tifFalse:\n\t\t\t\t\t[t _ m.\n\t\t\t\t\tm _ n - m.\n\t\t\t\t\tn _ t].\n\t\t\t\"Make sure larger gets replaced\"\n\t\t\t[m even]\n\t\t\t\twhileTrue: [m _ m bitShift: -1]].\n\td = 0 ifTrue: [^m].\n\t^m bitShift: d\n"
        }
      }
    },
    "Random": {
      "comment": "A simple random number generator.\n",
      "class_name": "Random",
      "superclass": "Stream",
      "instanceVariables": "seed",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t\"Answer a new random number generator.\"\n\t^self basicNew setSeed\n"
        }
      },
      "instance_methods": {
        "testing": {
          "atEnd": "atEnd\n\t^false\n"
        },
        "accessing": {
          "nextPut:": "nextPut: anObject\n\t^self shouldNotImplement\n",
          "next": "next\n\t\"Answer with the next random number.\"\n\n\t| temp |\n\t[seed _ 13849 + (27181 * seed) bitAnd: 65535.\n\t0 = (temp _ seed / 65536.0)] whileTrue.\n\t^temp\n",
          "contents": "contents\n\t^self shouldNotImplement\n"
        },
        "private": {
          "setSeed": "setSeed\n\tseed _ Time millisecondClockValue bitAnd: 65535\n\t\t\"Time millisecondClockValue gives a large integer;  I only want the lower 16 bits.\"\n"
        }
      }
    },
    "Fraction": {
      "comment": "I represent some rational number as a fraction.  All public arithmetic operations return reduced fractions.\n",
      "class_name": "Fraction",
      "superclass": "Number",
      "instanceVariables": "numerator denominator",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "numerator:denominator:": "numerator: numInteger denominator: denInteger\n\t\"Answer a new Fraction denInteger/numInteger.\"\n\n\t^self new setNumerator: numInteger denominator: denInteger\n"
        }
      },
      "instance_methods": {
        "comparing": {
          "hash": "hash\n\t\"Hash is reimplemented because = is implemented.\"\n\n\t^numerator bitXor: denominator\n",
          "<": "< aFraction\n\t(aFraction isMemberOf: Fraction)\n\t\tifTrue: [aFraction numerator = 0\n\t\t\t\tifTrue: [^numerator < 0]\n\t\t\t\tifFalse: [^self - aFraction < 0]]\n\t\tifFalse: [^self retry: #< coercing: aFraction]\n",
          "=": "= aFraction\n\t(aFraction isMemberOf: Fraction)\n\t\tifTrue: [aFraction numerator = 0\n\t\t\t\tifTrue: [^numerator = 0]\n\t\t\t\tifFalse: [^aFraction numerator = numerator\n\t\t\t\t\t\t\tand: [aFraction denominator = denominator]]]\n\t\tifFalse: [^self retry: #= coercing: aFraction]\n"
        },
        "coercing": {
          "coerce:": "coerce: aNumber\n\t^aNumber asFraction\n",
          "generality": "generality\n\t^60\n"
        },
        "truncation and round off": {
          "truncated": "truncated\n\t^numerator quo: denominator\n"
        },
        "printing": {
          "printOn:": "printOn: aStream\n\taStream nextPut: $(.\n\tnumerator printOn: aStream.\n\taStream nextPut: $/.\n\tdenominator printOn: aStream.\n\taStream nextPut: $)\n"
        },
        "private": {
          "denominator": "denominator\n\t^denominator\n",
          "reduced": "reduced\n\t| gcd numer denom |\n\tnumerator = 0 ifTrue: [^0].\n\tgcd _ numerator gcd: denominator.\n\tnumer _ numerator // gcd.\n\tdenom _ denominator // gcd.\n\tdenom = 1 ifTrue: [^numer].\n\t^Fraction numerator: numer denominator: denom\n",
          "setNumerator:denominator:": "setNumerator: n denominator: d\n\td = 0\n\t\tifTrue: [self error: 'denominator cannot be zero']\n\t\tifFalse:\n\t\t\t[numerator _ n truncated.\n\t\t\tdenominator _ d truncated abs. \"keep sign in numerator\"\n\t\t\td < 0 ifTrue: [numerator _ numerator negated]]\n",
          "numerator": "numerator\n\t^numerator\n"
        },
        "converting": {
          "asFraction": "asFraction\n\t\"Answer with the receiver itself.\"\n\t^self\n",
          "asFloat": "asFloat\n\t\"Answer with a new Float that represents the same value as does the receiver.\"\n\t^numerator asFloat / denominator asFloat\n"
        },
        "arithmetic": {
          "-": "- aFraction\n\t(aFraction isMemberOf: Fraction)\n\t\tifTrue: [^self + aFraction negated]\n\t\tifFalse: [^self retry: #- coercing: aFraction]\n",
          "reciprocal": "reciprocal\n\tnumerator = 0 ifTrue: [self error: '0 has no reciprocal'].\n\tnumerator = 1 ifTrue: [^denominator].\n\tnumerator = -1 ifTrue: [^denominator negated].\n\t^Fraction numerator: denominator denominator: numerator\n",
          "/": "/ aFraction\n\t(aFraction isMemberOf: Fraction)\n\t\tifTrue: [^self * aFraction reciprocal]\n\t\tifFalse: [^self retry: #/ coercing: aFraction]\n",
          "*": "* aFraction\n\t(aFraction isMemberOf: Fraction)\n\t\tifTrue: [^(Fraction\n\t\t\t\t\tnumerator: numerator * aFraction numerator\n\t\t\t\t\tdenominator: denominator * aFraction denominator)\n\t\t\t\t\treduced]\n\t\tifFalse: [^self retry: #* coercing: aFraction]\n",
          "+": "+ aFraction\n\t| commonDenominator newNumerator |\n\t(aFraction isMemberOf: Fraction)\n\t\tifTrue:\n\t\t\t[denominator = aFraction denominator\n\t\t\t\tifTrue: [^(Fraction\n\t\t\t\t\t\t\tnumerator: numerator + aFraction numerator\n\t\t\t\t\t\t\tdenominator: denominator) reduced].\n\t\t\tcommonDenominator _ denominator lcm: aFraction denominator.\n\t\t\tnewNumerator _ numerator\n\t\t\t\t\t\t\t\t* (commonDenominator / denominator)\n\t\t\t\t\t\t\t\t+ (aFraction numerator *\n\t\t\t\t\t\t\t\t\t(commonDenominator / aFraction denominator)).\n\t\t\t^(Fraction\n\t\t\t\tnumerator: newNumerator\n\t\t\t\tdenominator: commonDenominator) reduced]\n\t\tifFalse: [^self retry: #+ coercing: aFraction]\n",
          "negated": "negated\n\t^Fraction numerator: numerator negated denominator: denominator\n"
        }
      }
    }
  },
  "System-Changes": {
    "ClassCommentChange": {
      "comment": "I am a change to some part of a class comment.\n",
      "class_name": "ClassCommentChange",
      "superclass": "ClassOtherChange",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t^super new type: #comment\n"
        }
      },
      "instance_methods": {
        "accessing": {
          "text": "text\n\t^file == nil\n\t\tifTrue: [className, ' comment:\n', (Smalltalk at: className) comment printString]\n\t\tifFalse: [super text]\n"
        },
        "checking": {
          "checkWith:": "checkWith: aChecker\n\taChecker changesAt: className, '<', type, '>' add: self\n"
        }
      }
    },
    "Change": {
      "comment": "I represent a single change of some kind.  I have many subclasses for specific kinds of changes.  The text which represents me is a chunk of a file starting at a particular position.\n\nSince so many kinds of changes are related to classes, categories, and methods, there are dummy accessing methods for these parameters in class Change.\n\nInstance variables:\n\tfile <FileStream>\n\tposition <Integer>\n",
      "class_name": "Change",
      "superclass": "Object",
      "instanceVariables": "file position",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "file:position:": "file: f position: p\n\t^super new file: f position: p\n"
        }
      },
      "instance_methods": {
        "file accessing": {
          "file": "file\n\t^file\n",
          "fileName": "fileName\n\t(file isKindOf: FileStream)\n\t\tifTrue: [^file name]\n\t\tifFalse: [^'some local stream']\n"
        },
        "fileIn/Out": {
          "fileIn": "fileIn\n\t^Compiler evaluate: self text logged: true\n",
          "fileOutOn:": "fileOutOn: aStream\n\t\"Default, subclasses may do something different\"\n\taStream nextChunkPut: self text; cr; cr\n",
          "fileOutOn:previous:next:": "fileOutOn: aStream previous: previousChange next: nextChange\n\t\"Default, subclasses may be able to encode runs more compactly\"\n\tself fileOutOn: aStream\n"
        },
        "initialize": {
          "file:position:": "file: aFileStream position: anInteger\n\tfile _ aFileStream.\n\tposition _ anInteger\n"
        },
        "accessing": {
          "defaultName:": "defaultName: initialString\n\t\"The default name is the first few characters of the text.\"\n\t| text cr |\n\ttext _ WriteStream on: (String new: 50).\n\ttext nextPutAll: initialString.\n\tcr _ Character cr.\n\tself text do:\n\t\t[:char |\n\t\t(char = cr or: [text position >= 40]) ifTrue: [text nextPutAll: ' ...'.  ^text contents].\n\t\ttext nextPut: char].\n\t^text contents\n",
          "parameters": "parameters\n\t\"Return the parameters used for the 'same as' test\"\n\tself subclassResponsibility\n",
          "text": "text\n\tfile position: position.\n\t^file nextChunk\n",
          "name": "name\n\t\"Return the name which should appear in the list view.\"\n\tself subclassResponsibility\n",
          "classObject": "classObject\n\t\"Return the class in the present system referenced by my className\"\n\t^nil\n",
          "category": "category\n\t^''\n",
          "values": "values\n\t\"Return the value to be used for the 'same as' filter\"\n\t^Array with: self class with: self parameters\n",
          "selector": "selector\n\t^''\n",
          "className": "className\n\t^''\n",
          "text:": "text: aString\n\t| tempStream |\n\ttempStream _ ReadWriteStream on: (String new: aString size + 20).\n\ttempStream nextChunkPut: aString.\n\ttempStream position: 0.  \"Needed to set readLimit = writePosition\"\n\tfile _ ReadStream on: tempStream contents.\n\tposition _ 0\n"
        },
        "checking": {
          "checkWith:": "checkWith: aConflictChecker\n\t\"This is a default, most subclasses do something more intelligent.\"\n\taConflictChecker addDoIt: self\n"
        }
      }
    },
    "ClassRelatedChange": {
      "comment": "I am a change related in some way to a particular class.\n",
      "class_name": "ClassRelatedChange",
      "superclass": "Change",
      "instanceVariables": "className",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "accessing": {
          "parameters": "parameters\n\t^className\n",
          "getSource": "getSource\n\t\"Set me up to point to the version of this change which is currently installed in the system.\"\n\tself subclassResponsibility\n",
          "classObject": "classObject\n\t| class |\n\t^Smalltalk at: className ifAbsent:\n\t\t[(className size > 6 and: [(className copyFrom: className size - 5 to: className size) = ' class'])\n\t\t\tifTrue:\n\t\t\t\t[class _ Smalltalk at: (className copyFrom: 1 to: className size - 6) asSymbol ifAbsent: [^nil].\n\t\t\t\t(class isKindOf: Class) ifTrue: [class class] ifFalse: [nil]]\n\t\t\tifFalse:\n\t\t\t\t[nil]]\n",
          "className:": "className: aSymbol\n\tclassName _ aSymbol asSymbol\n",
          "className": "className\n\t^className\n"
        }
      }
    },
    "MethodDefinitionChange": {
      "comment": "I represent a change to the text of a method (as opposed to a category change or a removal).\n",
      "class_name": "MethodDefinitionChange",
      "superclass": "MethodChange",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "file accessing": {
          "fileName": "fileName\n\tfile isNil\n\t\tifTrue: [^'current system']\n\t\tifFalse: [^super fileName]\n"
        },
        "source code": {
          "getSource": "getSource\n\t\"Get the source code for this method from information currently in the system.\"\n\tself sourceFileAndPosition:\n\t\t[:aFile :aPosition |\n\t\tfile _ aFile.\n\t\tposition _ aPosition]\n",
          "sourceFileAndPosition:": "sourceFileAndPosition: aBlock\n\t\"Get the source code for this method from information currently in the system.\"\n\t| class method fileIndex pos |\n\t(class _ self classObject) isNil ifTrue: [^nil].\n\t(class includesSelector: selector) ifFalse: [^nil].\n\tmethod _ class compiledMethodAt: selector.\n\tSourceFiles isNil ifTrue: [^nil].\n\t(fileIndex _ method fileIndex) > SourceFiles size ifTrue: [^nil].\n\t\"The following code should be in CompiledMethod ...\"\n\tpos _ (method at: method size) bitAnd: 63.\n\tpos _ pos * 256 + (method at: method size - 1).\n\tpos _ pos * 256 + (method at: method size - 2).\n\tpos = 0 ifTrue: [^nil].\n\t^aBlock value: (SourceFiles at: method fileIndex) value: pos\n",
          "text": "text\n\t| aStream numArgs |\n\tfile == nil ifTrue:\n\t\t[aStream _ WriteStream on: (String new: 60).\n\t\t(numArgs _ selector numArgs) = 0\n\t\t\tifTrue: [aStream nextPutAll: selector]\n\t\t\tifFalse:\n\t\t\t\t[selector keywords with: (1 to: numArgs) do:\n\t\t\t\t\t[:word :i |\n\t\t\t\t\taStream nextPutAll: word; nextPutAll: ' t'; print: i; space]].\n\t\taStream cr; tab; nextPutAll: '\"Source code not available\"'.\n\t\t^aStream contents].\n\t^super text\n"
        },
        "fileIn/Out": {
          "fileOutHeaderOn:": "fileOutHeaderOn: aStream\n\taStream nextPut: $!;\n\t\tnextPutAll: className;\n\t\tnextPutAll: ' methodsFor: ';\n\t\tstore: category asString;\n\t\tnextPut: $!; cr; cr\n",
          "fileIn": "fileIn\n\t| class |\n\tclass _ self classObject.\n\tclass isNil\n\t\tifTrue: [self error: 'Class ', className, ' does not exist in this system']\n\t\tifFalse:\n\t\t\t[class compile: self text classified: category.\n\t\t\tTranscript show: className , '<' , category , '\n']\n",
          "fileOutOn:": "fileOutOn: aStream\n\tself fileOutHeaderOn: aStream.\n\taStream nextChunkPut: self text;\n\t\tspace; nextPut: $!; cr; cr\n",
          "fileOutOn:previous:next:": "fileOutOn: aStream previous: previousChange next: nextChange\n\t((previousChange isKindOf: MethodDefinitionChange) and: [previousChange className == className and: [previousChange category == category]])\n\t\tifFalse:\n\t\t\t[self fileOutHeaderOn: aStream].\n\taStream nextChunkPut: self text.\n\t((nextChange isKindOf: MethodDefinitionChange) and: [nextChange className == className and: [nextChange category == category]])\n\t\tifFalse:\n\t\t\t[aStream space; nextPut: $!].\n\taStream cr; cr\n"
        },
        "accessing": {
          "name": "name\n\t^className, ' ', selector\n",
          "accept:notifying:": "accept: newText notifying: requestor\n\t\"Check to make sure the current definition is valid\"\n\t| methodNode |\n\tmethodNode _ Compiler new\n\t\tcompile: newText\n\t\tin: (Smalltalk at: className ifAbsent: [^nil])\n\t\tnotifying: requestor\n\t\tifFail: [^nil].\n\tmethodNode generate: #(0 0 0).\n\t^self class new text: self text; className: className; selector: methodNode selector; category: category\n"
        },
        "checking": {
          "checkWith:": "checkWith: aChecker\n\t| systemVersion oldChanges |\n\taChecker changesAt: self name add: self.\n\taChecker checkSystem ifTrue:\n\t\t[self isInSystem ifFalse:\n\t\t\t[systemVersion _ self class new className: className; category: category; selector: selector.\n\t\t\tsystemVersion sourceFileAndPosition:\n\t\t\t\t[:aFile :aPosition |\n\t\t\t\tsystemVersion file: aFile position: aPosition.\n\t\t\t\t(aChecker equalWithoutComments: self text and: systemVersion text) ifFalse:\n\t\t\t\t\t[oldChanges _ aChecker changesAt: self name.\n\t\t\t\t\toldChanges size > 1 ifTrue:\n\t\t\t\t\t\t[oldChanges do: [:c | c isInSystem ifTrue: [^self]]].\n\t\t\t\t\taChecker changesAt: self name add: systemVersion]]]]\n",
          "isInSystem": "isInSystem\n\tself sourceFileAndPosition:\n\t\t[:aFile :aPosition |\n\t\t(file = aFile and: [position = aPosition])\n\t\t\tifTrue: [^true]].\n\t^false\n"
        }
      }
    },
    "ChangeSet": {
      "comment": "I keep track of the changes made to a system, so I can make an incremental fileOut.  I do not remember the order in which changes are made although this sometimes matters.\n\nInstance variables:\n\tclassChanges\t<Dictionary> {class name -> <Set>\n\t\t\t\t\t\t{add, change, comment, rename, reorganize, 'oldName: xxx'}}\n\tmethodChanges\t<Dictionary> {class name -> <IdentityDictionary>\n\t\t\t\t\t\t\t\t\t\t{selector -> add | change | remove}}\n\tclassRemoves\t<Set> {class name}\n\treorganizeSystem\t<Boolean> - indicates if SystemOrganization was changed.\n\tspecialDoIts\t\t<OrderedCollection> of Smalltalk expressions.\n",
      "class_name": "ChangeSet",
      "superclass": "Object",
      "instanceVariables": "classChanges methodChanges classRemoves reorganizeSystem specialDoIts",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "fileIn/Out": {
          "superclassOrder:": "superclassOrder: classes\n\t\"Arrange the classes in the collection, classes, in superclass order so the classes can be properly filed in.\"\n\n\t| aa bb na nb |\n\t^classes asSortedCollection: [:a :b |\n\t\t\"find lengths (na, nb) of superclass chains (a, b)\"\n\t\taa _ a. na _ 1.\tbb _ b. nb _ 1.\n\t\t[(aa _ aa superclass) notNil] whileTrue: [na _ na + 1].\n\t\t[(bb _ bb superclass) notNil] whileTrue: [nb _ nb + 1].\n\t\t\"follow longer chain to same depth as shorter\"\n\t\tna - nb timesRepeat: [a _ a superclass].\n\t\tnb - na timesRepeat: [b _ b superclass].\n\t\t\"trace back until the chains meet\"\n\t\t[(aa _ a superclass) ~~ (bb _ b superclass)]\n\t\t\twhileTrue: [a _ aa. b _ bb].\n\t\ta == b ifTrue: [na <= nb] \"chains overlap--one is sub*-class of other\"\n\t\t\tifFalse: [a name <= b name] \"alphabetize at the fork\" ]\n"
        },
        "instance creation": {
          "new": "new\n\t^super new initialize\n"
        }
      },
      "instance_methods": {
        "change management": {
          "changeClass:": "changeClass: class\n\t\"Include indication that a class definition has been changed.\"\n\tself atClass: class add: #change\n",
          "changedClasses": "changedClasses\n\t\"Answer a collection of the changed or edited classes, not including removed classes.\"\n\n\t| classes |\n\tclasses _ Set new.\n\tmethodChanges keys do: [:className | classes add: (self classNamed: className)].\n\tclassChanges keys do: [:className | classes add: (self classNamed: className)].\n\t^classes\n",
          "addClass:": "addClass: class\n\t\"Include indication that a new class was created.\"\n\tclassRemoves remove: class name ifAbsent: [].\n\tself atClass: class add: #add\n",
          "reorganizeClass:": "reorganizeClass: class\n\t\"Include indication that a class was reorganized.\"\n\tself atClass: class add: #reorganize\n",
          "removeClassChanges:": "removeClassChanges: class\n\t\"Remove all memory of changes associated with this class and its metaclass.\"\n\n\tclassChanges removeKey: class name ifAbsent: [].\n\tmethodChanges removeKey: class name ifAbsent: [].\n\tclassChanges removeKey: class class name ifAbsent: [].\n\tmethodChanges removeKey: class class name ifAbsent: [].\n\tclassRemoves remove: class name ifAbsent: [].\n",
          "removeClass:": "removeClass: class\n\t\"Include indication that a class has been forgotten.\"\n\n\t| name |\n\t(self isNew: class) ifTrue:\n\t\t[^self removeClassChanges: class]. \t\"only remember old classes\"\n\t(self atClass: class includes: #rename) \t\"remember as old name\"\n\t\tifTrue: [name _ self oldNameFor: class]\n\t\tifFalse: [name _ class name].\n\tself removeClassChanges: class.\n\tclassRemoves add: name\n",
          "addDoIt:": "addDoIt: smalltalkExpression\n\t\"When filing out changes, append this string to the file.\"\n\n\tspecialDoIts add: smalltalkExpression\n",
          "renameClass:as:": "renameClass: class as: newName\n\t\"Include indication that a class has been renamed.\"\n\n\t| value |\n\t(self atClass: class includes: #rename) ifFalse:\n\t\t[self atClass: class add: 'oldName: ', class name. \t\"only original name matters\"\n\t\tself atClass: class add: #rename].\n \t\"copy changes using new name (metaclass too)\"\n\t(Array with: classChanges with: methodChanges) do:\n\t\t[:changes |\n\t\t(value _ changes at: class name ifAbsent: [nil]) == nil ifFalse:\n\t\t\t[changes at: newName put: value.\n\t\t\tchanges removeKey: class name].\n\t\t(value _ changes at: class class name ifAbsent: [nil]) == nil ifFalse:\n\t\t\t[changes at: (newName, ' class') put: value.\n\t\t\tchanges removeKey: class class name]]\n",
          "reorganizeSystem": "reorganizeSystem\n\t\"Include indication that the system classes were reorganized.\"\n\n\treorganizeSystem _ true\n",
          "commentClass:": "commentClass: class\n\t\"Include indication that a class comment has been changed.\"\n\tself atClass: class add: #comment\n"
        },
        "fileIn/Out": {
          "fileOutChangesFor:on:": "fileOutChangesFor: class on: stream\n\t\"Write out all the changes the receiver knows about this class.\"\n\n\t| changes removes |\n\t\t\t\t\t\"first file out class changes\"\n\tself fileOutClassChanges: class on: stream.\n\t\t\t\t\t\"next file out changed methods\"\n\tremoves _ OrderedCollection new.\n\tchanges _ OrderedCollection new.\n\t(methodChanges at: class name ifAbsent: [^self]) associationsDo:\n\t\t[:mAssoc |\n\t\tmAssoc value = #remove\n\t\t\tifTrue: [removes add: mAssoc key]\n\t\t\tifFalse: [changes add: mAssoc key]].\n\tchanges isEmpty ifFalse:\n\t\t[class fileOutChangedMessages: changes on: stream.\n\t\tstream cr].\n\tremoves do:\n\t\t[:selector |\n\t\tstream nextChunkPut:\n\t\t\t\tclass name, ' removeSelector: ', selector storeString; cr].\n\t\"reintialize metaclass if necessary\"\n\t((class isMemberOf: Metaclass) and: [changes includes: #initialize]) ifTrue:\n\t\t[stream nextChunkPut: class soleInstance name, ' initialize'; cr].\n",
          "fileOutOn:": "fileOutOn: stream\n\t\"Write out all the changes the receiver knows about.\"\n\n\tself isEmpty ifTrue: [self notify: 'Warning: no changes to file out'].\n\n\t(ChangeSet superclassOrder: self changedClasses asOrderedCollection) do:\n\t\t[:class |\n\t\tself fileOutChangesFor: class on: stream].\n\tclassRemoves do:\n\t\t[:className |\n\t\tstream nextChunkPut: 'Smalltalk removeClassNamed: #', className; cr].\n\treorganizeSystem ifTrue:\n\t\t[stream cr; nextPut: $!; nextChunkPut: 'SystemOrganization'; cr.\n\t\tstream nextChunkPut: SystemOrganization printString; cr; cr].\n\tspecialDoIts do:\n\t\t[:expression |\n\t\tstream nextChunkPut: expression; cr].\n"
        },
        "method changes": {
          "changedMessageList": "changedMessageList\n\t\"Answer an array that identifies the methods that have been changed.\n\tEach entry is a String containing the class name and method selector.\"\n\n\t| messageList |\n\tmessageList _ SortedCollection new.\n\tmethodChanges associationsDo:\n\t\t[:clAssoc |\n\t\tclAssoc value associationsDo:\n\t\t\t[:mAssoc |\n\t\t\tmAssoc value = #remove ifFalse:\n\t\t\t\t[messageList add: clAssoc key asString, ' ' , mAssoc key]]].\n\t^messageList asArray\n",
          "changeSelector:class:": "changeSelector: selector class: class\n\t\"Include indication that a method has been edited.\"\n\n\t(self atSelector: selector class: class) = #add\n\t\tifFalse: [self atSelector: selector class: class put: #change]\n\t\t\t\"Don't forget a method is new just because it's been changed\"\n",
          "removeSelectorChanges:class:": "removeSelectorChanges: selector class: class\n\t\"Remove all memory of changes associated with the argument,\n\tselector, in this class.\"\n\n\t| dictionary |\n\tdictionary _ methodChanges at: class name ifAbsent: [^self].\n\tdictionary removeKey: selector ifAbsent: [].\n\tdictionary isEmpty ifTrue: [methodChanges removeKey: class name]\n",
          "removeSelector:class:": "removeSelector: selector class: class\n\t\"Include indication that a method has been forgotten.\"\n\n\t(self atSelector: selector class: class) = #add\n\t\tifTrue: [self removeSelectorChanges: selector\n\t\t\t\t\tclass: class]\t\t\t\t\t\"Forgot a new method, no-op\"\n\t\tifFalse: [self atSelector: selector\n\t\t\t\t\tclass: class\n\t\t\t\t\tput: #remove]\n",
          "addSelector:class:": "addSelector: selector class: class\n\t\"Include indication that a method has been added.\"\n\tself atSelector: selector class: class put: #add\n"
        },
        "testing": {
          "isEmpty": "isEmpty\n\t\"Answer whether the receiver contains any elements.\"\n\n\t^(((methodChanges isEmpty and: [classChanges isEmpty])\n\t\tand: [classRemoves isEmpty]) and: [reorganizeSystem not]) and: [specialDoIts isEmpty]\n"
        },
        "private": {
          "atSelector:class:put:": "atSelector: selector class: class put: changeType\n\t| name dict |\n\t(self isNew: class) ifTrue: [^self]. \t\"Don't keep method changes for new classes\"\n\tname _ class name.\n\t(methodChanges at: name\n\t\tifAbsent:\n\t\t\t[dict _ IdentityDictionary new.\n\t\t\tmethodChanges at: name put: dict.\n\t\t\tdict])\n\t\tat: selector put: changeType\n",
          "atClass:add:": "atClass: class add: changeType\n\t(self isNew: class) ifFalse: \t\"new classes don't matter\"\n\t\t[(classChanges at: class name\n\t\t\t\tifAbsent: [^classChanges at: class name put:\n\t\t\t\t\t(Set with: changeType)])\n\t\t\tadd: changeType]\n",
          "oldNameFor:": "oldNameFor: class\n\n\t| name |\n\tname _ (classChanges at: class name) asOrderedCollection detect:\n\t\t\t\t[:x | 'oldName: *' match: x].\n\t^(Scanner new scanTokens: name) last\n",
          "classNamed:": "classNamed: className\n\t\"className is either a class name or a class name followed by ' class'.  Answer the class or metaclass it names.\"\n\n\t| meta name class |\n\t(className size > 6\n\t\tand: [(className copyFrom: className size - 5 to: className size) = ' class'])\n\t\tifTrue:\n\t\t\t[meta _ true.\n\t\t\tname _ className copyFrom: 1 to: className size - 6]\n\t\tifFalse:\n\t\t\t[meta _ false.\n\t\t\tname _ className].\n\tclass _ Smalltalk at: name asSymbol.\n\tmeta\n\t\tifTrue: [^class class]\n\t\tifFalse: [^class]\n",
          "fileOutClassChanges:on:": "fileOutClassChanges: class on: stream\n\t\"Write out class changes.  i.e.  new class, definition, comment, renaming.\"\n\n\t(self atClass: class includes: #add) ifTrue:\n\t\t[stream cr.\n\t\tclass fileOutOn: stream.\n\t\tstream cr.\n\t\t^self atClass: class add: #add  \"fileOut clears this!\"].\n\n\t(self atClass: class includes: #rename) ifTrue:\n\t\t[stream nextChunkPut: (self oldNameFor: class), ' rename: #', class name; cr].\n\n\t(self atClass: class includes: #change) ifTrue:\n\t\t[stream emphasis: 5; nextChunkPut: class definition; cr; emphasis: 1].\n\n\t(self atClass: class includes: #comment) ifTrue:\n\t\t[class organization putCommentOnFile: stream\n\t\t\tnumbered: nil moveSource: false.\n\t\tstream cr].\n\n\t(self atClass: class includes: #reorganize) ifTrue:\n\t\t[class fileOutOrganizationOn: stream.\n\t\tstream cr]\n",
          "atSelector:class:": "atSelector: selector class: class\n\t^(methodChanges at: class name ifAbsent: [^#none])\n\t\tat: selector ifAbsent: [#none]\n",
          "isNew:": "isNew: class\n\t\"Answer whether this class was added since the ChangeSet was cleared.\"\n\n\tclass isMeta\n\t\tifTrue: [^self atClass: class soleInstance includes: #add \"check class\"]\n\t\tifFalse: [^self atClass: class includes: #add]\n",
          "atClass:includes:": "atClass: class includes: changeType\n\t^(classChanges at: class name ifAbsent: [^false])\n\t\tincludes: changeType\n"
        },
        "initialize-release": {
          "initialize": "initialize\n\t\"Reset the receiver to be empty.\"\n\n\tclassChanges _ Dictionary new.\n\tmethodChanges _ Dictionary new.\n\tclassRemoves _ Set new.\n\treorganizeSystem _ false.\n\tspecialDoIts _ OrderedCollection new.\n"
        },
        "converting": {
          "asSortedCollection": "asSortedCollection\n\t\"Answer a new instance of SortedCollection whose elements are Strings describing the changes represented by the receiver.\"\n\n\t| summary |\n\tsummary _ SortedCollection new.\n\tclassChanges associationsDo:\n\t\t[:clAssoc |\n\t\tclAssoc value do:\n\t\t\t[:changeType | summary add: clAssoc key, ' - ', changeType]].\n\tmethodChanges associationsDo:\n\t\t[:clAssoc |\n\t\tclAssoc value associationsDo:\n\t\t\t[:mAssoc | summary add: clAssoc key, ' ', mAssoc key, ' - ', mAssoc value]].\n\tclassRemoves do:\n\t\t[:name | summary add: name, ' - ', 'remove'].\n\treorganizeSystem ifTrue: [summary add: 'Reorganize System'].\n\tspecialDoIts isEmpty not ifTrue:\n\t\t[summary add: 'SpecialDoIts - (', specialDoIts size printString, ')'].\n\t^summary\n"
        }
      }
    },
    "ClassOtherChange": {
      "comment": "I represent a change to a class, other than a class definition.  Possible types are:\n\tcomment, initialize, inst vars for, rename, rename to\n",
      "class_name": "ClassOtherChange",
      "superclass": "ClassChange",
      "instanceVariables": "type",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "accessing": {
          "type:": "type: aSymbol\n\ttype _ aSymbol\n",
          "name": "name\n\t^'  ', type, ' ', className\n",
          "type": "type\n\t^type\n"
        },
        "checking": {
          "checkWith:": "checkWith: aChecker\n\taChecker changesAt: className add: self.\n\ttype == 'inst vars for' asSymbol ifFalse: [aChecker addDoIt: self]\n"
        }
      }
    },
    "ClassDefinitionChange": {
      "comment": "I am a change to some part of a class definition.\n",
      "class_name": "ClassDefinitionChange",
      "superclass": "ClassChange",
      "instanceVariables": "superclassName classType otherParameters",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "accessing": {
          "text": "text\n\t^file == nil\n\t\tifTrue: [(Smalltalk at: className) definition]\n\t\tifFalse: [super text]\n",
          "name": "name\n\t^'  define ', className\n",
          "superclassName:classType:otherParameters:": "superclassName: aSymbol classType: aSelector otherParameters: anArray\n\tsuperclassName _ aSymbol.\n\tclassType _ aSelector.\n\totherParameters _ anArray\n"
        },
        "checking": {
          "checkWith:": "checkWith: aChecker\n\t| class |\n\taChecker changesAt: className add: self.\n\taChecker checkSystem ifTrue:\n\t\t[class _ Smalltalk at: className ifAbsent: [^self].\n\t\tself text = class definition ifFalse:\n\t\t\t[aChecker changesAt: className add: (self class new className: className)]]\n"
        }
      }
    },
    "OtherChange": {
      "comment": "I represent a non-classifiable change, i.e. a doIt.  I cache my text to reduce disk accesses.\n",
      "class_name": "OtherChange",
      "superclass": "Change",
      "instanceVariables": "text",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "accessing": {
          "parameters": "parameters\n\t^self text\n",
          "text": "text\n\ttext == nil ifTrue: [text _ super text].\n\t^text\n",
          "name": "name\n\t^self defaultName: '  doIt '\n",
          "text:": "text: aString\n\ttext _ aString.\n\tfile _ nil\n"
        },
        "checking": {
          "checkWith:": "checkWith: aChecker\n\t\"Discard comments and 'From ...' messages if from the current system\"\n\t| myText aStream first |\n\tmyText _ self text.\n\tmyText isEmpty ifTrue: [^self].\n\taStream _ ReadStream on: myText.\n\tfirst _ aStream next.\n\tfirst = $\" ifTrue:\n\t\t[aStream skipTo: $\"; skipSeparators.\n\t\taStream atEnd ifTrue: [^self]].\n\tfirst = $' ifTrue:\n\t\t[first _ 'From ', Smalltalk version, ' on '.\n\t\tmyText size > first size ifTrue:\n\t\t\t[(aStream next: first size) = first ifTrue: [^self]]].\n\taChecker addDoIt: self\n"
        }
      }
    },
    "ClassChange": {
      "comment": "I am a change to some part of a class definition (actual definition, comment, name, ...) as opposed to a change to a method within a class.\n",
      "class_name": "ClassChange",
      "superclass": "ClassRelatedChange",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": ""
    },
    "ChangeScanner": {
      "comment": "I know how to parse a file into a collection of changes.\n",
      "class_name": "ChangeScanner",
      "superclass": "Scanner",
      "instanceVariables": "file chunkString",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t^super new initChangeScanner\n"
        }
      },
      "instance_methods": {
        "change set scanning": {
          "scanChangedMessages:do:": "scanChangedMessages: changedMessages do: aBlock\n\t| selector change className remoteSource class category |\n\tchangedMessages do:\n\t\t[:aString |\n\t\tsuper scan: (ReadStream on: aString).\n\t\t(className _ self nextClass) notNil ifTrue:\n\t\t\t[(selector _ self nextSelector) notNil ifTrue:\n\t\t\t\t[change _ MethodDefinitionChange new className: className; selector: selector.\n\t\t\t\t(className includes: Character space)\n\t\t\t\t\tifTrue: [class _ (Smalltalk at: (className copyUpTo: Character space) asSymbol) class]\n\t\t\t\t\tifFalse: [class _ Smalltalk at: className asSymbol].\n\t\t\t\tcategory _ class whichCategoryIncludesSelector: selector.\n\t\t\t\tcategory == nil ifTrue: [category _ 'As yet unclassified'].\n\t\t\t\tchange category: category.\n\t\t\t\tchange getSource.\n\t\t\t\taBlock value: change]]]\n"
        },
        "file scanning": {
          "scanMethodsClass:category:do:": "scanMethodsClass: class category: category do: aBlock\n\t| position method selector |\n\t[file skipSeparators.\n\tposition _ file position.\n\t(method _ self nextChunkStream) atEnd]\n\t\twhileFalse:\n\t\t\t[method _ method contents.\n\t\t\tselector _ Parser new parseSelector: method.\n\t\t\tselector notNil ifTrue:\n\t\t\t\t[aBlock value: ((MethodDefinitionChange file: file position: position) className: class; selector: selector; category: category)]]\n",
          "scanSpecialDo:": "scanSpecialDo: aBlock\n\t\"Scan a chunk of file beginning with a !.  For now, the only thing I understand is method definitions.\"\n\t| class category |\n\t(class _ self nextClass) notNil ifTrue:\n\t\t[(tokenType == #keyword and: [token = 'methodsFor:']) ifTrue:\n\t\t\t[self scanToken.\n\t\t\ttokenType == #string ifTrue:\n\t\t\t\t[category _ token.\n\t\t\t\tself scanToken.\n\t\t\t\ttokenType == #doIt ifTrue:\n\t\t\t\t\t[^self scanMethodsClass: class category: category asSymbol do: aBlock]]]].\n\t\"I don't understand what's on the file.  Scan for a blank chunk and hope for the best.\"\n\t[self nextChunkStream atEnd] whileFalse: []\n",
          "scanFile:do:": "scanFile: aFile do: aBlock\n\t\"Evaluate aBlock with each item on the file\"\n\t| position |\n\tfile _ aFile.\n\t[file skipSeparators.\n\tfile atEnd]\n\t\twhileFalse:\n\t\t\t[file peek = $!\n\t\t\t\tifTrue:\n\t\t\t\t\t[file next.\n\t\t\t\t\tsuper scan: self nextChunkStream.\n\t\t\t\t\tself scanSpecialDo: aBlock]\n\t\t\t\tifFalse:\n\t\t\t\t\t[position _ file position.\n\t\t\t\t\tself scanExpression: self nextChunkStream do:\n\t\t\t\t\t\t[:item | aBlock value: (item file: file position: position)]]]\n"
        },
        "initialize": {
          "initChangeScanner": "initChangeScanner\n\tchunkString _ String new: 200\n"
        },
        "expression scanning": {
          "scanClassDefinition:className:do:": "scanClassDefinition: classType className: superName do: aBlock\n\t\"Scan a presumed class definition.  The classType is the first keyword of the class defining message (subclass:, variableSubclass:, etc.)\"\n\t| newName parameters |\n\t(tokenType == #literal and: [token isKindOf: Symbol]) ifFalse: [^nil].\n\tnewName _ token.\n\tparameters _ #('instanceVariableNames:' 'classVariableNames:' 'poolDictionaries:' 'category:') collect:\n\t\t[:keyword |\n\t\tself scanToken.\n\t\t(tokenType == #keyword and: [token = keyword]) ifFalse: [^nil].\n\t\tself scanToken.\n\t\ttokenType == #string ifFalse: [^nil].\n\t\ttoken].\n\tself scanToken.\n\t^aBlock value: (ClassDefinitionChange new className: newName; superclassName: superName classType: classType otherParameters: parameters)\n",
          "scanClassExpression:do:": "scanClassExpression: class do: aBlock\n\t\"Scan an expression beginning with a class name.  This might be a class\n\tdefinition, a class removal, a class comment change, a class initialization,\n\ta method removal, or a doIt.\"\n\n\t| firstToken selector newName |\n\tfirstToken _ token.\n\tself scanToken.\n\tfirstToken = 'removeSelector:'\n\t\tifTrue:\n\t\t\t[(tokenType == #literal and: [token isKindOf: Symbol]) ifTrue:\n\t\t\t\t[selector _ token.\n\t\t\t\tself scanToken.\n\t\t\t\t^aBlock value: (MethodOtherChange new className: class; selector: selector; type: #remove)]].\n\tfirstToken = 'rename:'\n\t\tifTrue:\n\t\t\t[(tokenType == #literal and: [token isKindOf: Symbol]) ifTrue:\n\t\t\t\t[newName _ token.\n\t\t\t\tself scanToken.\n\t\t\t\taBlock value: (ClassOtherChange new className: class; type: #rename).\n\t\t\t\t^aBlock value: (ClassOtherChange new className: newName; type: 'rename to' asSymbol)]].\n\tfirstToken = 'comment:'\n\t\tifTrue:\n\t\t\t[tokenType == #string\n\t\t\t\tifTrue:\n\t\t\t\t\t[self scanToken.\n\t\t\t\t\t^aBlock value: (ClassCommentChange new className: class)]].\n\t(#('subclass:' 'variableSubclass:' 'variableByteSubclass:' 'variableWordSubclass:') includes: firstToken)\n\t\tifTrue:\n\t\t\t[^self scanClassDefinition: firstToken className: class do: aBlock].\n\tfirstToken = 'initialize'\n\t\tifTrue:\n\t\t\t[^aBlock value: (ClassOtherChange new className: class; type: #initialize)].\n\tfirstToken = 'removeFromSystem'\n\t\tifTrue:\n\t\t\t[^aBlock value: (ClassOtherChange new className: class; type: #remove)].\n\tfirstToken = 'instanceVariableNames:'\n\t\tifTrue:\n\t\t\t[tokenType == #string\n\t\t\t\tifTrue:\n\t\t\t\t\t[self scanToken.\n\t\t\t\t\t^aBlock value: (ClassOtherChange new className: class; type: 'inst vars for' asSymbol)]].\n\t^nil\n",
          "scanExpression:do:": "scanExpression: aStream do: aBlock\n\t\"Scan a chunk of file consisting of an expression.  This might be a class\n\tdefinition, a class removal, a class comment change, a method removal,\n\tor a doIt.\"\n\n\t| class item |\n\tsuper scan: aStream.\n\t((class _ self nextClass) notNil and: [tokenType == #keyword or: [tokenType == #word]])\n\t\tifTrue:\n\t\t\t[self scanClassExpression: class do:\n\t\t\t\t[:item | tokenType == #doIt ifTrue: [aBlock value: item]]].\n\titem == nil ifTrue: [aBlock value: OtherChange new]\n"
        },
        "private": {
          "nextClass": "nextClass\n\t| class |\n\ttokenType == #word ifTrue:\n\t\t[class _ token.\n\t\tself scanToken.\n\t\t(tokenType == #word and: [token = 'class'])\n\t\t\tifTrue:\n\t\t\t\t[class _ (class, ' ', token) asSymbol.\n\t\t\t\tself scanToken]\n\t\t\tifFalse:\n\t\t\t\t[class _ class asSymbol].\n\t\t^class].\n\t^nil\n",
          "nextSelector": "nextSelector\n\t| selector |\n\ttokenType == #keyword\n\t\tifTrue:\n\t\t\t[self scanLitWord].\n\t(tokenType == #word or: [tokenType == #keyword or: [tokenType == #binary]])\n\t\tifTrue:\n\t\t\t[selector _ token.\n\t\t\tself scanToken].\n\t^selector\n",
          "nextChunkStream": "nextChunkStream\n\t\"Return a read stream on the next chunk of the file.\"\n\n\t| chunkStream char terminator |\n\tterminator _ $!.\n\tfile skipSeparators.\n\tchunkStream _ ReadWriteStream on: chunkString.\n\t[file atEnd]\n\t\twhileFalse:\n\t\t\t[char _ file next.\n\t\t\tchar == terminator\n\t\t\t\tifTrue: [(file peekFor: terminator)\n\t\t\t\t\t\tifTrue: [\"doubled terminator\"\n\t\t\t\t\t\t\tchunkStream nextPut: char]\n\t\t\t\t\t\tifFalse: [chunkStream position: 0.  ^chunkStream]]\n\t\t\t\tifFalse: [chunkStream nextPut: char]].\n\tchunkStream position: 0.  \"Sets read limit to current position\"\n\t^chunkStream\n"
        }
      }
    },
    "MethodChange": {
      "comment": "Represents a change to a method (new definition or removal).\n",
      "class_name": "MethodChange",
      "superclass": "ClassRelatedChange",
      "instanceVariables": "selector category",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "accessing": {
          "category:": "category: aSymbol\n\tcategory _ aSymbol asSymbol\n",
          "parameters": "parameters\n\t^Array with: className with: selector\n",
          "selector:": "selector: aSymbol\n\tselector _ aSymbol asSymbol\n",
          "category": "category\n\t^category\n",
          "selector": "selector\n\t^selector\n"
        }
      }
    },
    "MethodOtherChange": {
      "comment": "Represents a change to a method other than new definition or removal.\n",
      "class_name": "MethodOtherChange",
      "superclass": "MethodChange",
      "instanceVariables": "type",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "accessing": {
          "type:": "type: aSymbol\n\ttype _ aSymbol\n",
          "name": "name\n\t^type, ' ', className, ' ', selector\n",
          "type": "type\n\t^type\n"
        },
        "checking": {
          "checkWith:": "checkWith: aChecker\n\taChecker changesAt: self name add: self.\n\taChecker addDoIt: self\n"
        }
      }
    }
  },
  "System-Compiler": {
    "BlockNode": {
      "comment": "I represent a bracketed block with 0 or more arguments and 1 or more statements.  If I am initialized with no statements, I create one.  I have a flag to tell whether my last statement returns a value from the enclosing method.  My last three fields remember data needed for code generation.\n\nI can emit for value in the usual way, in which case I create a literal method (actually a context remotely copied) to be evaluated by sending it value: at run time.  Or I can emit code to be evaluated in line; this only happens at the top level of a method and in conditionals and while-loops, none of which have arguments.\n",
      "class_name": "BlockNode",
      "superclass": "ParseNode",
      "instanceVariables": "arguments statements returns nArgsNode size remoteCopyNode sourceRange endPC",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "printing": {
          "printArgumentsOn:indent:": "printArgumentsOn: aStream indent: level\n\targuments size = 0\n\t\tifFalse:\n\t\t\t[arguments do:\n\t\t\t\t[:arg |\n\t\t\t\taStream nextPut: $:.\n\t\t\t\taStream nextPutAll: arg key.\n\t\t\t\taStream space].\n\t\t\taStream nextPutAll: '| '.\n\t\t\t\"If >0 args and >1 statement, put all statements on separate lines\"\n\t\t\tstatements size > 1 ifTrue: [aStream crtab: level]]\n",
          "printOn:indent:": "printOn: aStream indent: level\n\tstatements size <= 1 ifFalse: [aStream crtab: level].\n\taStream nextPut: $[.\n\tself printArgumentsOn: aStream indent: level.\n\tself printStatementsOn: aStream indent: level.\n\taStream nextPut: $]\n",
          "printStatementsOn:indent:": "printStatementsOn: aStream indent: level\n\t| len shown thisStatement |\n\tcomment == nil\n\t\tifFalse:\n\t\t\t[self printCommentOn: aStream indent: level.\n\t\t\taStream crtab: level].\n\tlen _ shown _ statements size.\n\t(level = 1 and: [statements last isReturnSelf])\n\t\tifTrue: [shown _ 1 max: shown - 1]\n\t\tifFalse: [(len = 1 and: [((statements at: 1) == NodeNil) & (arguments size = 0)])\n\t\t\t\t\tifTrue: [shown _ shown - 1]].\n\t1 to: shown do:\n\t\t[:i |\n\t\tthisStatement _ statements at: i.\n\t\tthisStatement == NodeSelf\n\t\t\tifFalse:\n\t\t\t\t[thisStatement printOn: aStream indent: level.\n\t\t\t\ti < shown ifTrue: [aStream nextPut: $.; crtab: level].\n\t\t\t\tthisStatement comment size > 0\n\t\t\t\t\tifTrue:\n\t\t\t\t\t\t[i = shown ifTrue: [aStream crtab: level].\n\t\t\t\t\t\tthisStatement printCommentOn: aStream indent: level.\n\t\t\t\t\t\ti < shown ifTrue: [aStream crtab: level]]]]\n"
        },
        "code generation": {
          "emitForEvaluatedEffect:on:": "emitForEvaluatedEffect: stack on: aStream\n\tself returns\n\t\tifTrue:\n\t\t\t[self emitForEvaluatedValue: stack on: aStream.\n\t\t\tstack pop: 1]\n\t\tifFalse:\n\t\t\t[self emitExceptLast: stack on: aStream.\n\t\t\tstatements last emitForEffect: stack on: aStream]\n",
          "sizeForValue:": "sizeForValue: encoder\n\tnArgsNode _ encoder encodeLiteral: arguments size.\n\tremoteCopyNode _ encoder encodeSelector: #blockCopy:.\n\tsize _ self sizeForEvaluatedValue: encoder.\n\tself returns\n\t\tifFalse: [size _ size+1.  \"end-block\"\n\t\t\t\tencoder noteSourceRange: sourceRange forNode: self].\n\targuments do: [:arg | size _ size + (arg sizeForStorePop: encoder)].\n\t^1 + (nArgsNode sizeForValue: encoder)\n\t\t+ (remoteCopyNode size: encoder) + 2 + size\n",
          "sizeForEvaluatedEffect:": "sizeForEvaluatedEffect: encoder\n\tself returns ifTrue: [^self sizeForEvaluatedValue: encoder].\n\t^(self sizeExceptLast: encoder)\n\t\t+ (statements last sizeForEffect: encoder)\n",
          "emitForValue:on:": "emitForValue: stack on: aStream\n\t| arg blockStack |\n\taStream nextPut: LdThisContext.\n\tstack push: 1.\n\tnArgsNode emitForValue: stack on: aStream.\n\tremoteCopyNode emit: stack args: 1 on: aStream.\n\t\"jmp-around must be 2 bytes\"\n\tself emitLongJump: size on: aStream.\n\n\t\"Block gets its own stack in blockContext\"\n\tblockStack _ ParseStack new init.\n\tblockStack push: arguments size.\n\targuments reverseDo: [:arg | arg emitStorePop: blockStack on: aStream].\n\tself emitForEvaluatedValue: blockStack on: aStream.\n\tendPC _ aStream position+1.\n\tself returns ifFalse: [aStream nextPut: EndRemote].\n\tblockStack pop: 1.\n\n\tstack max: blockStack size\n",
          "sizeExceptLast:": "sizeExceptLast: encoder\n\t| totalSize |\n\ttotalSize _ 0.\n\t1 to: statements size - 1 do:\n\t\t[:i | totalSize _ totalSize + ((statements at: i) sizeForEffect: encoder)].\n\t^totalSize\n",
          "pc": "pc\n\t^ endPC\n",
          "sizeForEvaluatedValue:": "sizeForEvaluatedValue: encoder\n\t^(self sizeExceptLast: encoder)\n\t\t+ (statements last sizeForValue: encoder)\n",
          "emitExceptLast:on:": "emitExceptLast: stack on: aStream\n\t1 to: statements size - 1 do:\n\t\t[:i | (statements at: i) emitForEffect: stack on: aStream]\n",
          "emitForEvaluatedValue:on:": "emitForEvaluatedValue: stack on: aStream\n\tself emitExceptLast: stack on: aStream.\n\tstatements last emitForValue: stack on: aStream\n",
          "code": "code\n\t^statements first code\n"
        },
        "testing": {
          "isJust:": "isJust: node\n\treturns ifTrue: [^false].\n\t^statements size = 1 and: [statements first == node]\n",
          "canBeSpecialArgument": "canBeSpecialArgument\n\t\"can I be an argument of (e.g.) ifTrue:?\"\n\n\t^arguments size = 0\n",
          "isQuick": "isQuick\n\t^statements size = 1 and: [statements first isVariableReference]\n",
          "isComplex": "isComplex\n\t^statements size > 1\n",
          "returns": "returns\n\t^returns or: [statements last isReturningIf]\n"
        },
        "accessing": {
          "returnSelfIfNoOther": "returnSelfIfNoOther\n\tself returns\n\t\tifFalse:\n\t\t\t[statements last == NodeSelf ifFalse: [statements add: NodeSelf].\n\t\t\tself returnLast]\n",
          "numberOfArguments": "numberOfArguments\n\t^arguments size\n",
          "returnLast": "returnLast\n\tself returns\n\t\tifFalse:\n\t\t\t[returns _ true.\n\t\t\tstatements at: statements size put: statements last asReturnNode]\n",
          "arguments:": "arguments: argNodes\n\t\"decompile\"\n\n\targuments _ argNodes\n"
        },
        "initialize-release": {
          "default": "default\n\t\"[] argument of missing kwyword in ifTrue: or ifFalse:\"\n\n\tstatements _ Array with: NodeNil.\n\targuments _ Array new: 0.\n\treturns _ false\n",
          "arguments:statements:returns:from:sourceEnd:": "arguments: argNodes statements: statementsCollection returns: returnBool from: encoder\n\tsourceEnd: sourceEnd\n\t\"compile\"\n\tsourceRange  _ sourceEnd to: sourceEnd.\n\targuments _ argNodes.\n\tstatements _ statementsCollection size > 0\n\t\t\t\tifTrue: [statementsCollection]\n\t\t\t\tifFalse: [argNodes size > 0\n\t\t\t\t\t\tifTrue: [statementsCollection copyWith: arguments last]\n\t\t\t\t\t\tifFalse: [Array with: NodeNil]].\n\treturns _ returnBool\n",
          "statements:returns:": "statements: statementsCollection returns: returnBool\n\t\"decompile\"\n\n\t| returnLast |\n\treturnLast _ returnBool.\n\treturns _ false.\n\tstatements _\n\t\t(statementsCollection size > 1\n\t\t\tand: [(statementsCollection at: statementsCollection size - 1)\n\t\t\t\t\tisReturningIf])\n\t\t\t\tifTrue:\n\t\t\t\t\t[returnLast _ false.\n\t\t\t\t\tstatementsCollection copyFrom: 1 to: statementsCollection size - 1]\n\t\t\t\tifFalse: [statementsCollection size = 0\n\t\t\t\t\t\tifTrue: [Array with: NodeNil]\n\t\t\t\t\t\tifFalse: [statementsCollection]].\n\targuments _ Array new: 0.\n\treturnLast ifTrue: [self returnLast]\n"
        }
      }
    },
    "ParseStack": {
      "comment": "I keep track of the current and high position of the stack that will be needed by code being compiled.  I am only used during the code generation pass of the compiler (MethodNode generate:)\n",
      "class_name": "ParseStack",
      "superclass": "Object",
      "instanceVariables": "position length",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "results": {
          "position": "position\n\t^position\n"
        },
        "accessing": {
          "max:": "max: otherSize\n\t\"Set my max length (size) to be the max of mine and otherSize\"\n\tlength _ length max: otherSize\n",
          "push:": "push: n\n\t(position _ position + n) > length\n\t\tifTrue: [length _ position]\n",
          "pop:": "pop: n\n\t(position _ position - n) < 0\n\t\tifTrue: [self error: 'Parse stack underflow']\n",
          "size": "size\n\t^length\n"
        },
        "initialize-release": {
          "init": "init\n\tlength _ position _ 0\n"
        }
      }
    },
    "DecompilerConstructor": {
      "comment": "I am used by the decompiler to construct parse tree nodes and other appropriate items corresponding to each unit identified by the decompiler.  This factoring allows the decompiler, in principle, to use other constructors for other purposes.\n",
      "class_name": "DecompilerConstructor",
      "superclass": "ParseNode",
      "instanceVariables": "method instVars nArgs literalValues tempVars",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "initialize-release": {
          "method:class:literals:": "method: aMethod class: aClass literals: literals\n\tmethod _ aMethod.\n\tinstVars _ aClass allInstVarNames.\n\tnArgs _ method numArgs.\n\tliteralValues _ literals\n"
        },
        "constructor": {
          "codeConstants": "codeConstants\n\t\"Answer with an array of the objects representing self, true, false, nil, -1, 0, 1, 2\"\n\n\t| i |\n\t^(Array with: NodeSelf with: NodeTrue with: NodeFalse with: NodeNil)\n\t\t, ((-1 to: 2) collect: [:i | LiteralNode new key: i code: LdMinus1 + i + 1])\n",
          "codeAnySelector:": "codeAnySelector: selector\n\t^SelectorNode new\n\t\tkey: selector\n\t\tindex: 0\n\t\ttype: SendType\n",
          "codeBlock:returns:": "codeBlock: statements returns: returns\n\t^BlockNode new statements: statements returns: returns\n",
          "codeThisContext": "codeThisContext\n\t^NodeThisContext\n",
          "codeAnyLitInd:": "codeAnyLitInd: association\n\t^VariableNode new\n\t\tname: association key\n\t\tkey: association\n\t\tindex: 0\n\t\ttype: LdLitIndType\n",
          "codeAnyLiteral:": "codeAnyLiteral: value\n\t^LiteralNode new\n\t\tkey: value\n\t\tindex: 0\n\t\ttype: LdLitType\n",
          "codeAssignTo:value:": "codeAssignTo: variable value: expression\n\t^AssignmentNode new variable: variable value: expression\n",
          "codeCascade:messages:": "codeCascade: receiver messages: messages\n\t^CascadeNode new receiver: receiver messages: messages\n",
          "codeCascadedMessage:arguments:": "codeCascadedMessage: selector arguments: arguments\n\t^self\n\t\tcodeMessage: nil\n\t\tselector: selector\n\t\targuments: arguments\n",
          "codeMessage:selector:arguments:": "codeMessage: receiver selector: selector arguments: arguments\n\t| symbol |\n\tsymbol _ selector key.\n\t^MessageNode new\n\t\treceiver: receiver\n\t\tselector: selector\n\t\targuments: arguments\n\t\tprecedence:\n\t\t\t(symbol isInfix\n\t\t\t\tifTrue: [2]\n\t\t\t\tifFalse: [symbol isKeyword ifTrue: [3] ifFalse: [1]])\n",
          "codeSelector:code:": "codeSelector: sel code: code\n\t^SelectorNode new key: sel code: code\n",
          "codeInst:": "codeInst: index\n\t^VariableNode new\n\t\tname: (instVars at: index + 1)\n\t\tindex: index\n\t\ttype: LdInstType\n",
          "codeSuper": "codeSuper\n\t^NodeSuper\n",
          "codeTemp:": "codeTemp: index\n\t^VariableNode new\n\t\tname: 't' , (index + 1) printString\n\t\tindex: index\n\t\ttype: LdTempType\n",
          "codeEmptyBlock": "codeEmptyBlock\n\t^BlockNode new default\n",
          "codeMethod:block:tempVars:primitive:class:": "codeMethod: selector block: block tempVars: vars primitive: primitive class: class\n\t| node precedence |\n\tnode _ self codeSelector: selector code: nil.\n\tprecedence _ selector isInfix\n\t\t\t\tifTrue: [2]\n\t\t\t\tifFalse: [selector isKeyword ifTrue: [3] ifFalse: [1]].\n\ttempVars _ vars.\n\t^MethodNode new\n\t\tselector: node\n\t\targuments: (tempVars copyFrom: 1 to: nArgs)\n\t\tprecedence: precedence\n\t\ttemporaries: (tempVars copyFrom: nArgs + 1 to: tempVars size)\n\t\tblock: block\n\t\tencoder: (Encoder new initScopeAndLiteralTables\n\t\t\t\t\tnTemps: tempVars size\n\t\t\t\t\tliterals: literalValues\n\t\t\t\t\tclass: class)\n\t\tprimitive: primitive\n",
          "codeArguments:block:": "codeArguments: args block: block\n\t^block arguments: args\n"
        }
      }
    },
    "Encoder": {
      "comment": "I encode names and literals into tree nodes with byte codes for the compiler.  Byte codes for literals are not assigned until the tree-sizing pass of the compiler, because only then is it known which literals are actually needed.  I also keep track of sourceCode ranges during parsing and code generation so I can provide an inverse map for the debugger.\n\nscopeTable is a dictionary of (names->nodes)\nnTemps is the count of temporaries used so far\nsupered is true if super has been used in this method\nrequestor is usually a parser\nclass is the class in which we are compiling - used to look up class and pool variables\nliteralStream accumulates the literals used in this method\nselectorSet is a dictionary of (selectors->nodes) predefined or used in this method\nlitIndSet is a dictionary of (poolVars->nodes) used in this method\nlitSet is a dictionary of (constants->nodes) used in this method\nsourceRanges is a dictionary of (node->source interval)s\n",
      "class_name": "Encoder",
      "superclass": "ParseNode",
      "instanceVariables": "scopeTable nTemps supered requestor class literalStream selectorSet litIndSet litSet sourceRanges lastTempPos",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "undeclared variables": {
          "declareCorrect:": "declareCorrect: name\n\t\"Attempt to correct the spelling of an undeclared variable.\"\n\n\t| old lc names score bestScore guess |\n\told _ name.\n\tlc _ old first asLowercase.\n\tnames _\n\t\t\t(scopeTable keys select: [:key | key first asLowercase = lc]).\n\tnames addAll:\n\t\t\t(class allVarNamesSelect: [:key | key first asLowercase = lc]).\n\n\tbestScore _ 0.\n\tnames do:\n\t\t[:name |\n\t\t(score _ name spellAgainst: old) > bestScore ifTrue:\n\t\t\t[bestScore _ score. guess _ name]].\n\n\tbestScore > 50 ifFalse: [^ self notify: 'Couldn''t correct'].\n\t(self confirm: 'Confirm correction to ' , guess)\n\t\tifTrue:\n\t\t\t[requestor replaceEditSelectionWith: guess.\n\t\t\t^ self encodeVariable: guess]\n\t\tifFalse:\n\t\t\t[^ self notify: 'Undeclared']\n",
          "declareClassVar:": "declareClassVar: name\n\t| sym |\n\tname first isUppercase ifFalse: [self notify: 'Capitalize globals or classVars'].\n\tsym _ name asSymbol.\n\tclass addClassVarName: sym.\n\tSmalltalk changes changeClass: class.\n\t^ self global: (class classPool associationAt: sym) name: sym\n",
          "declareGlobal:": "declareGlobal: name\n\t| sym |\n\tname first isUppercase ifFalse: [self notify: 'Capitalize globals or classVars'].\n\tsym _ name asSymbol.\n\tSmalltalk at: sym put: nil.\n\t^ self global: (Smalltalk associationAt: sym) name: sym\n",
          "undeclared:": "undeclared: name\n\t| message messageLoc messageBox saveBits menu index |\n\tCursor normal show.\n\trequestor selectVariable: name.\n\tindex _ (menu _ ActionMenu\n\t\t\tlabels: 'temp\\class var\\global\\undeclared\\correct it\\abort' withCRs\n\t\t\tlines: #(4)\n\t\t\tselectors: #(declareTemp: declareClassVar: declareGlobal: declareUndeclared: declareCorrect: declareFailed:))\n\t\t\t\tstartUp: #anyButton\n\t\t\t\twithHeading: ' declare ' asText , (name contractTo: 20) asText allBold , ' as ' asText.\n\tindex = 0 ifTrue: [^ self declareFailed: name].\n\t^ self perform: (menu selectorAt: index) with: name\n",
          "declareTemp:": "declareTemp: name\n\trequestor pasteTemp: name.\n\t^ self reallyBindTemp: name\n",
          "declareFailed:": "declareFailed: name\n\tself abort\n",
          "declareUndeclared:": "declareUndeclared: name\n\t| sym |\n\tsym _ name asSymbol.\n\t(Undeclared includesKey: name asSymbol) ifFalse:\n\t\t[Transcript show: ' (' , name , ' is Undeclared) '.\n\t\tUndeclared at: sym put: nil].\n\t^ self global: (Undeclared associationAt: sym) name: sym\n"
        },
        "encoding": {
          "cantStoreInto:": "cantStoreInto: varName\n\t^ StdVariables includesKey: varName\n",
          "encodeVariable:": "encodeVariable: name\n\t^scopeTable at: name\n\t\tifAbsent:\n\t\t\t[self lookupInPools: name\n\t\t\t\tifFound: [:assoc | ^ self global: assoc name: name].\n\t\t\trequestor editor notNil\n\t\t\t\tifTrue: [self undeclared: name]\n\t\t\t\tifFalse: [self declareUndeclared: name]]\n",
          "encodeSelector:": "encodeSelector: selector\n\t^self\n\t\tname: selector\n\t\tkey: selector\n\t\tclass: SelectorNode\n\t\ttype: SendType\n\t\tset: selectorSet\n",
          "encodeLiteral:": "encodeLiteral: object\n\t^self\n\t\tname: object\n\t\tkey: object\n\t\tclass: LiteralNode\n\t\ttype: LdLitType\n\t\tset: litSet\n",
          "litIndex:": "litIndex: literal\n\t| p |\n\tp _ literalStream position.\n\tp = 64 ifTrue:\n\t\t[self notify: 'More than 64 literals referenced.  You must split or otherwise simplify this method'. ^nil].\n\tliteralStream nextPut: literal.\n\t^p\n"
        },
        "results": {
          "literals:nArgs:": "literals: primitive nArgs: nArgs\n\t(primitive > 0 or: [nArgs > 4])\n\t\tifTrue:\n\t\t\t[self litIndex: nArgs * 256 + primitive.\n\t\t\tself litIndex: (self associationForClass)]\n\t\tifFalse:\n\t\t\t[supered ifTrue: [self litIndex: (self associationForClass)]].\n\t^literalStream contents\n",
          "tempNames": "tempNames\n\t| tempNodes |\n\ttempNodes _ (scopeTable values select: [:node | node isTemp])\n\t\tasSortedCollection: [:n1 :n2 | n1 code <= n2 code].\n\t^tempNodes collect: [:node | node key]\n",
          "supered": "supered\n\t^supered\n",
          "associationFor:": "associationFor: aClass\n\t| name |\n\tname _ Smalltalk keyAtValue: aClass ifAbsent: [^Association new value: aClass].\n\t^Smalltalk associationAt: name\n",
          "associationForClass": "associationForClass\n\t^self associationFor: class\n"
        },
        "private": {
          "global:name:": "global: ref name: name\n\t^self\n\t\tname: name\n\t\tkey: ref\n\t\tclass: VariableNode\n\t\ttype: LdLitIndType\n\t\tset: litIndSet\n",
          "lookupInPools:ifFound:": "lookupInPools: name ifFound: assocBlock\n\t| sym |\n\tSymbol\n\t\thasInterned: name\n\t\tifTrue: [:sym | ^class scopeHas: sym ifTrue: assocBlock].\n\t^false\n",
          "name:key:class:type:set:": "name: name key: key class: leafNodeClass type: type set: dict\n\t| node |\n\t^dict\n\t\tat: key\n\t\tifAbsent:\n\t\t\t[node _ leafNodeClass new\n\t\t\t\t\t\tname: name\n\t\t\t\t\t\tkey: key\n\t\t\t\t\t\tindex: nil\n\t\t\t\t\t\ttype: type.\n\t\t\tdict at: key put: node.\n\t\t\t^node]\n"
        },
        "initialize-release": {
          "fillDict:with:mapping:to:": "fillDict: dict with: nodeClass mapping: keys to: codeArray\n\t| codeStream key |\n\tcodeStream _ ReadStream on: codeArray.\n\tkeys do:\n\t\t[:key | dict\n\t\t\t\tat: key\n\t\t\t\tput:  (nodeClass new name: key key: key code: codeStream next)]\n",
          "initScopeAndLiteralTables": "initScopeAndLiteralTables\n\tscopeTable _ StdVariables copy.\n\tlitSet _ StdLiterals copy.\n\tselectorSet _ StdSelectors copy.\n\tlitIndSet _ Dictionary new: 16.\n\tliteralStream _ WriteStream on: (Array new: 32)\n",
          "init:context:notifying:": "init: aClass context: aContext notifying: req\n\t| variable node n homeNode indexNode |\n\trequestor _ req.\n\tclass _ aClass.\n\tnTemps _ 0.\n\tsupered _ false.\n\tself initScopeAndLiteralTables.\n\tn _ -1.\n\tclass allInstVarNames do:\n\t\t[:variable |\n\t\tnode _ VariableNode new\n\t\t\t\t\tname: variable\n\t\t\t\t\tindex: (n _ n + 1)\n\t\t\t\t\ttype: LdInstType.\n\t\tscopeTable at: variable put: node].\n\taContext == nil\n\t\tifFalse:\n\t\t\t[homeNode _ self bindTemp: 'homeContext'.\n\t\t\t\"first temp = aContext passed as arg\"\n\t\t\tn _ 0.\n\t\t\taContext tempNames do:\n\t\t\t\t[:variable |\n\t\t\t\tindexNode _ self encodeLiteral: (n _ n + 1).\n\t\t\t\tnode _ MessageNode new\n\t\t\t\t\t\t\treceiver: homeNode\n\t\t\t\t\t\t\tselector: #tempAt:\n\t\t\t\t\t\t\targuments: (Array with: indexNode)\n\t\t\t\t\t\t\tprecedence: 3\n\t\t\t\t\t\t\tfrom: self.\n\t\t\t\tscopeTable at: variable put: node]].\n\tsourceRanges _ Dictionary new: 32\n",
          "noteSuper": "noteSuper\n\tsupered _ true\n",
          "release": "release\n\trequestor _ nil\n",
          "nTemps:literals:class:": "nTemps: n literals: lits class: cl\n\t\"Decompile\"\n\n\tclass _ cl.\n\tnTemps _ n.\n\tliteralStream _ ReadStream on: lits.\n\tliteralStream position: lits size\n"
        },
        "error handling": {
          "notify:": "notify: string\n\t| req |\n\trequestor == nil\n\t\tifFalse:\n\t\t\t[req _ requestor.\n\t\t\tself release.\n\t\t\treq notify: string].\n\t^false\n",
          "abort": "abort\n\t| req |\n\trequestor == nil\n\t\tifFalse:\n\t\t\t[req _ requestor.\n\t\t\tself release.\n\t\t\treq abort].\n\t^false\n"
        },
        "temporaries": {
          "bindTemp:": "bindTemp: name\n\t\"Declare a temporary; error not if a field or class variable.\"\n\n\t(scopeTable includesKey: name)\n\t\tifTrue: [^self notify: 'Name is already defined'].\n\t^self reallyBindTemp: name\n",
          "newTemp:": "newTemp: name\n\tnTemps _ nTemps + 1.\n\t^VariableNode new\n\t\tname: name\n\t\tindex: nTemps - 1\n\t\ttype: LdTempType\n",
          "maxTemp": "maxTemp\n\t^nTemps\n",
          "reallyBindTemp:": "reallyBindTemp: name\n\t\"private;  assumes name not in scope yet\"\n\t| node |\n\tnode _ self newTemp: name.\n\tscopeTable at: name put: node.\n\t^node\n",
          "autoBind:": "autoBind: name\n\t\"Declare a block argument as a temp if not already declared\"\n\n\t| node assoc |\n\tnode _\n\t\tscopeTable\n\t\t\tat: name\n\t\t\tifAbsent:\n\t\t\t\t[(self lookupInPools: name ifFound: [:assoc | assoc])\n\t\t\t\t\tifTrue: [self notify: 'Name already used in a Pool or Global'].\n\t\t\t\t^self reallyBindTemp: name].\n\tnode isTemp ifFalse: [^self notify: 'Name already used in this class'].\n\t^node\n"
        },
        "source mapping": {
          "sourceMap:": "sourceMap: numLits\n\t\"Answer with a sorted set of associations (pc . range).  Delta is the difference\n\tbetween the parsed number of literals (startpc) and the generated number of\n\tliterals.\"\n\t| key delta |\n\tdelta _ (numLits - literalStream position) * 2.\n\t^(sourceRanges keys collect:\n\t\t[:key |  Association key: key pc + delta value: (sourceRanges at: key)])\n\t\t\tasSortedCollection\n",
          "noteSourceRange:forNode:": "noteSourceRange: range forNode: node\n\tsourceRanges at: node put: range\n"
        }
      }
    },
    "AssignmentNode": {
      "comment": "I represent a (var_expr) construct.\n",
      "class_name": "AssignmentNode",
      "superclass": "ParseNode",
      "instanceVariables": "variable value",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "printing": {
          "printOn:indent:": "printOn: aStream indent: level\n\tvariable printOn: aStream indent: level.\n\taStream nextPutAll: ' _ '.\n\tvalue printOn: aStream indent: level + 2\n",
          "printOn:indent:precedence:": "printOn: aStream indent: level precedence: p\n\tp < 4 ifTrue: [aStream nextPutAll: '('].\n\tself printOn: aStream indent: level.\n\tp < 4 ifTrue: [aStream nextPutAll: ')']\n"
        },
        "code generation": {
          "sizeForValue:": "sizeForValue: encoder\n\t^(value sizeForValue: encoder)\n\t\t+ (variable sizeForStore: encoder)\n",
          "emitForEffect:on:": "emitForEffect: stack on: aStream\n\tvalue emitForValue: stack on: aStream.\n\tvariable emitStorePop: stack on: aStream\n",
          "emitForValue:on:": "emitForValue: stack on: aStream\n\tvalue emitForValue: stack on: aStream.\n\tvariable emitStore: stack on: aStream\n",
          "sizeForEffect:": "sizeForEffect: encoder\n\t^(value sizeForValue: encoder)\n\t\t+ (variable sizeForStorePop: encoder)\n"
        },
        "initialize-release": {
          "variable:value:from:": "variable: aVariable value: expression from: encoder\n\t\"compile\"\n\n\t(aVariable isMemberOf: MessageNode)\n\t\tifTrue: [^aVariable store: expression from: encoder].\n\tvariable _ aVariable.\n\tvalue _ expression\n",
          "variable:value:": "variable: aVariable value: expression\n\tvariable _ aVariable.\n\tvalue _ expression\n"
        }
      }
    },
    "LeafNode": {
      "comment": "I represent a leaf node of the compiler parse tree.  I am abstract.\n Types (defined in class ParseNode):\n\t1 LdInstType (which uses class VariableNode)\n\t2 LdTempType (which uses class VariableNode)\n\t3 LdLitType (which uses class LiteralNode)\n\t4 LdLitIndType (which uses class VariableNode)\n\t5 SendType (which uses class SelectorNode)\n",
      "class_name": "LeafNode",
      "superclass": "ParseNode",
      "instanceVariables": "key code",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "code generation": {
          "sizeForValue:": "sizeForValue: encoder\n\tself reserve: encoder.\n\tcode < 256\n\t\tifTrue: [^1].\n\t^2\n",
          "size:": "size: encoder\n\t^self sizeForValue: encoder\n",
          "emitForEffect:on:": "emitForEffect: stack on: strm\n\t^self\n",
          "emitLong:on:": "emitLong: mode on: aStream\n\t\"emit extended variable access\"\n\n\t| type index |\n\tcode < 256\n\t\tifTrue: [code < 16\n\t\t\t\tifTrue:\n\t\t\t\t\t[type _ 0.\n\t\t\t\t\tindex _ code]\n\t\t\t\tifFalse:\n\t\t\t\t\t[code < 32\n\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t[type _ 1.\n\t\t\t\t\t\t\tindex _ code - 16]\n\t\t\t\t\t\tifFalse:\n\t\t\t\t\t\t\t[code < 96\n\t\t\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t\t\t[type _ code // 32 + 1.\n\t\t\t\t\t\t\t\t\tindex _ code \\\\ 32]\n\t\t\t\t\t\t\t\tifFalse: [self error:\n\t\t\t\t\t\t\t\t\t\t'Sends should be handled in SelectorNode']]]]\n\t\tifFalse:\n\t\t\t[index _ code \\\\ 256.\n\t\t\ttype _ code // 256 - 1].\n\taStream nextPut: mode.\n\taStream nextPut: type * 64 + index\n",
          "sizeForEffect:": "sizeForEffect: encoder\n\t^0\n",
          "reserve:": "reserve: encoder\n\t\"if this is a yet unused literal of type -code, reserve it\"\n\n\tcode < 0 ifTrue: [code _ self code: (encoder litIndex: key) type: 0 - code]\n",
          "code": "code\n\t^code\n"
        },
        "accessing": {
          "key": "key\n\t^key\n"
        },
        "private": {
          "code:type:": "code: index type: type\n\tindex isNil\n\t\tifTrue: [^type negated].\n\t(CodeLimits at: type) > index\n\t\tifTrue: [^(CodeBases at: type) + index].\n\t^type * 256 + index\n"
        },
        "initialize-release": {
          "key:code:": "key: object code: byte\n\tkey _ object.\n\tcode _ byte\n",
          "name:key:index:type:": "name: literal key: object index: i type: type\n\tself key: object\n\t\tindex: i\n\t\ttype: type\n",
          "name:key:code:": "name: ignored key: object code: byte\n\tkey _ object.\n\tcode _ byte\n",
          "key:index:type:": "key: object index: i type: type\n\tself key: object code: (self code: i type: type)\n"
        }
      }
    },
    "MessageNode": {
      "comment": "I represent a receiver and its message.\n\nPrecedence codes:\n\t1 unary\n\t2 binary\n\t3 keyword\n\t4 other\n\nIf special>0, I compile special code in-line instead of sending messages with literal methods as remotely copied contexts.\n",
      "class_name": "MessageNode",
      "superclass": "ParseNode",
      "instanceVariables": "receiver selector precedence special arguments sizes pc",
      "classInstanceVariables": "",
      "classVariables": "MacroEmitters MacroSelectors MacroSizers MacroTransformers ThenFlag",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"MessageNode initialize.\"\n\n\tMacroSelectors _\n\t\t#(ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:\n\t\t\tand: or: whileFalse: whileTrue: ).\n\tMacroTransformers _\n\t\t#(transformIfTrue: transformIfFalse: transformIfTrueIfFalse:\n\t\t\ttransformIfFalseIfTrue: transformAnd: transformOr:\n\t\t\ttransformWhile: transformWhile: ).\n\tMacroEmitters _\n\t\t#(emitIf:on:value: emitIf:on:value: emitIf:on:value: emitIf:on:value:\n\t\t\temitIf:on:value: emitIf:on:value: emitWhile:on:value: emitWhile:on:value: ).\n\tMacroSizers _\n\t\t#(sizeIf:value: sizeIf:value: sizeIf:value: sizeIf:value: sizeIf:value:\n\t\t\tsizeIf:value: sizeWhile:value: sizeWhile:value: )\n"
        }
      },
      "instance_methods": {
        "printing": {
          "printKeywords:arguments:on:indent:": "printKeywords: key arguments: args on: aStream indent: level\n\t| keywords part prev arg indent thisKey |\n\targs size = 0\n\t\tifTrue: [aStream space; nextPutAll: key. ^self].\n\tkeywords _ key keywords.\n\tprev _ receiver.\n\t1 to: args size do:\n\t\t[:part | arg _ args at: part.\n\t\tthisKey _ keywords at: part.\n\t\t(prev isMemberOf: BlockNode)\n\t\t | ((prev isMemberOf: MessageNode) and: [prev precedence >= 3])\n\t\t | ((arg isMemberOf: BlockNode) and: [arg isComplex and: [thisKey ~= #do:]])\n\t\t | (args size > 2)\n\t\t | (key = #ifTrue:ifFalse:)\n\t\t\tifTrue: [aStream crtab: level+1. indent _ 1] \"newline after big args\"\n\t\t\tifFalse: [aStream space. indent _ 0].\n\t\taStream nextPutAll: thisKey; space.\n\t\targ  printOn: aStream indent: level + 1 + indent\n\t\t\t precedence: (precedence = 2 ifTrue: [1] ifFalse: [precedence]).\n\t\tprev _ arg]\n",
          "precedence": "precedence\n\t^precedence\n",
          "printOn:indent:": "printOn: aStream indent: level\n\treceiver == nil\n\t\tifFalse: [receiver printOn: aStream indent: level precedence: precedence].\n\t(special between: 1 and: 6)\n\t\tifTrue:\n\t\t\t[self printIfOn: aStream indent: level]\n\t\tifFalse:\n\t\t\t[self\n\t\t\t\tprintKeywords: selector key\n\t\t\t\targuments: arguments\n\t\t\t\ton: aStream\n\t\t\t\tindent: level]\n",
          "printOn:indent:precedence:": "printOn: strm indent: level precedence: p\n\t| parenthesize |\n\tparenthesize _\n\t\tprecedence > p or: [p = 3 and: [precedence = 3 \"both keywords\"]].\n\tparenthesize ifTrue: [strm nextPutAll: '('].\n\tself printOn: strm indent: level.\n\tparenthesize ifTrue: [strm nextPutAll: ')']\n",
          "printIfOn:indent:": "printIfOn: aStream indent: level\n\t(arguments last isJust: NodeNil) ifTrue:\n\t\t[^self printKeywords: #ifTrue: arguments: (Array with: arguments first)\n\t\t\t\t\ton: aStream indent: level].\n\t(arguments last isJust: NodeFalse) ifTrue:\n\t\t[^self printKeywords: #and: arguments: (Array with: arguments first)\n\t\t\t\t\ton: aStream indent: level].\n\t(arguments first isJust: NodeNil) ifTrue:\n\t\t[^self printKeywords: #ifFalse: arguments: (Array with: arguments last)\n\t\t\t\t\ton: aStream indent: level].\n\t(arguments first isJust: NodeTrue) ifTrue:\n\t\t[^self printKeywords: #or: arguments: (Array with: arguments last)\n\t\t\t\t\ton: aStream indent: level].\n\tself printKeywords: #ifTrue:ifFalse: arguments: arguments\n\t\t\t\t\ton: aStream indent: level\n"
        },
        "expression types": {
          "cascadeReceiver": "cascadeReceiver\n\t\"nil out rcvr (to indicate cascade) and return what it had been\"\n\n\t| rcvr |\n\trcvr _ receiver.\n\treceiver _ nil.\n\t^rcvr\n"
        },
        "code generation": {
          "sizeForValue:": "sizeForValue: encoder\n\t| arg total argSize |\n\tspecial > 0\n\t\tifTrue: [^self perform: (MacroSizers at: special) with: encoder with: true].\n\treceiver == NodeSuper\n\t\tifTrue: [selector _ selector copy \"only necess for splOops\"].\n\ttotal _ selector size: encoder args: arguments size super: receiver == NodeSuper.\n\treceiver == nil\n\t\tifFalse: [total _ total + (receiver sizeForValue: encoder)].\n\tsizes _ arguments collect:\n\t\t\t\t\t[:arg |\n\t\t\t\t\targSize _ arg sizeForValue: encoder.\n\t\t\t\t\ttotal _ total + argSize.\n\t\t\t\t\targSize].\n\t^total\n",
          "emitForEffect:on:": "emitForEffect: stack on: strm\n\tspecial > 0\n\t\tifTrue:\n\t\t\t[self perform: (MacroEmitters at: special) with: stack with: strm with: false.\n\t\t\tpc _ 0]\n\t\tifFalse:\n\t\t\t[super emitForEffect: stack on: strm.\n\t\t\tpc _ strm position]\n",
          "emitWhile:on:value:": "emitWhile: stack on: strm value: forValue\n\t\"Size code for <A> whileTrue: <B>, or <A> whileFalse: <B>\"\n\t| stmt stmtSize loopSize |\n\tstmt _ arguments at: 1.\n\tstmtSize _ sizes at: 1.  \"Includes loop-back jump\"\n\tloopSize _ sizes at: 2.\n\treceiver emitForEvaluatedValue: stack on: strm.\n\tselector key == #whileTrue:\n\t\tifTrue: [self emitBranch: stmtSize pop: stack on: strm]\n\t\tifFalse: [self emitTrueBranch: stmtSize pop: stack on: strm].\n\tstmt emitForEvaluatedEffect: stack on: strm.\n\tself emitJump: 0 - loopSize on: strm.\n\tforValue ifTrue: [strm nextPut: LdNil. stack push: 1]\n",
          "sizeIf:value:": "sizeIf: encoder value: forValue\n\t\"Size code for <A> ifTrue: <B> ifFalse: <C>, with some optimizations\"\n\t| thenExpr thenSize elseExpr elseSize noElse noThen |\n\tthenExpr _ arguments at: 1.\n\telseExpr _ arguments at: 2.\n\tforValue\n\t\tifTrue:\n\t\t\t[\"Everything is straightforward for value:  <A> bfp-C <B> jmp-end <C>\"\n\t\t\telseSize _ elseExpr sizeForEvaluatedValue: encoder.\n\t\t\tthenSize _ (thenExpr sizeForEvaluatedValue: encoder)\n\t\t\t\t\t\t+ (thenExpr returns\n\t\t\t\t\t\t\t\tifTrue: [0]\n\t\t\t\t\t\t\t\tifFalse: [self sizeJump: elseSize])]\n\t\tifFalse:\n\t\t\t[\"If value not needed, check for possible shortcuts\"\n\t\t\t(noElse _ elseExpr isJust: NodeNil) | (noThen _ thenExpr isJust: NodeNil)\n\t\t\t\tifFalse:  \"If no shortcuts, then compile for value followed by pop\"\n\t\t\t\t\t[^ super sizeForEffect: encoder].\n\t\t\telseSize _ noElse\n\t\t\t\tifTrue: [0]\n\t\t\t\tifFalse: [elseExpr sizeForEvaluatedEffect: encoder].\n\t\t\tthenSize _ noThen\n\t\t\t\tifTrue: [0]\n\t\t\t\tifFalse:\t[thenExpr sizeForEvaluatedEffect: encoder]].\n\tsizes _ Array with: thenSize with: elseSize.\n\t(thenSize=0) & (elseSize=0)  \"null conditional\"\n\t\tifTrue: [^ receiver sizeForEffect: encoder].\n\t^ (receiver sizeForValue: encoder)\n\t\t\t+ (thenSize=0\n\t\t\t\tifTrue: [2 \"BTP is long\"]\n\t\t\t\tifFalse: [self sizeBranch: thenSize])\n\t\t\t+ thenSize + elseSize\n",
          "emitForValue:on:": "emitForValue: stack on: strm\n\t| argument |\n\tspecial > 0\n\t\tifTrue:\n\t\t\t[self perform: (MacroEmitters at: special) with: stack with: strm with: true.\n\t\t\tpc _ 0]\n\t\tifFalse:\n\t\t\t[receiver ~~ nil ifTrue: [receiver emitForValue: stack on: strm].\n\t\t\targuments do: [:argument | argument emitForValue: stack on: strm].\n\t\t\tselector\n\t\t\t\temit: stack\n\t\t\t\targs: arguments size\n\t\t\t\ton: strm\n\t\t\t\tsuper: receiver == NodeSuper.\n\t\t\tpc _ strm position]\n",
          "pc": "pc\n\t\"used by encoder source mapping\"\n\n\t^pc\n",
          "sizeForEffect:": "sizeForEffect: encoder\n\tspecial > 0\n\t\tifTrue: [^self perform: (MacroSizers at: special) with: encoder with: false].\n\t^super sizeForEffect: encoder\n",
          "emitIf:on:value:": "emitIf: stack on: strm value: forValue\n\t\"Emit code for <A> ifTrue: <B> ifFalse: <C>, with some optimizations\"\n\t| thenExpr thenSize elseExpr elseSize |\n\tthenSize _ sizes at: 1.\n\telseSize _ sizes at: 2.\n\tthenExpr _ arguments at: 1.\n\telseExpr _ arguments at: 2.\n\tforValue\n\t\tifTrue:\n\t\t\t[\"Everything is straightforward for value:  <A> bfp-C <B> jmp-end <C>\"\n\t\t\treceiver emitForValue: stack on: strm.\n\t\t\tself emitBranch: thenSize pop: stack on: strm.\n\t\t\tthenExpr emitForEvaluatedValue: stack on: strm.\n\t\t\tstack pop: 1.\n\t\t\tthenExpr returns ifFalse: [self emitJump: elseSize on: strm].\n\t\t\telseExpr emitForEvaluatedValue: stack on: strm]\n\t\tifFalse:\n\t\t\t[\"If value not needed, check for possible shortcuts\"\n\t\t\t(thenSize=0) & (elseSize=0)  \"null conditional\"\n\t\t\t\tifTrue: [^ receiver emitForEffect: stack on: strm].\n\t\t\t(elseSize = 0) | (thenSize = 0)\n\t\t\t\tifTrue:\n\t\t\t\t\t[receiver emitForValue: stack on: strm.\n\t\t\t\t\t(elseSize = 0)\n\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t[\"Shortcut for ifTrue: only:  <A> bfp-end <B>\"\n\t\t\t\t\t\t\tself emitBranch: thenSize pop: stack on: strm.\n\t\t\t\t\t\t\tthenExpr emitForEvaluatedEffect: stack on: strm]\n\t\t\t\t\t\tifFalse:\n\t\t\t\t\t\t\t[\"Shortcut for ifFalse: only  <A> btp-end <C>\"\n\t\t\t\t\t\t\tself emitTrueBranch: elseSize pop: stack on: strm.\n\t\t\t\t\t\t\telseExpr emitForEvaluatedEffect: stack on: strm]]\n\t\t\t\tifFalse:\n\t\t\t\t\t[\"If no shortcuts, then compile for value followed by pop\"\n\t\t\t\t\tsuper emitForEffect: stack on: strm]]\n",
          "sizeWhile:value:": "sizeWhile: encoder value: forValue\n\t\"Size code for <A> whileTrue: <B>, or <A> whileFalse: <B>\"\n\t| cond stmt branchSize stmtSize loopSize |\n\tstmt _ arguments at: 1.\n\tstmtSize _ (stmt sizeForEvaluatedEffect: encoder) + 2. \"loop jump is 2 bytes\"\n\tselector key == #whileTrue:\n\t\tifTrue: [branchSize _ self sizeBranch: stmtSize]\n\t\tifFalse: [branchSize _ 2 \"BTP is always 2 bytes\"].\n\tloopSize _ (receiver sizeForEvaluatedValue: encoder) + branchSize + stmtSize.\n\tsizes _ Array with: stmtSize with: loopSize.\n\t^ loopSize + (forValue ifTrue: [1] ifFalse: [0]) \"push nil (for value) takes 1 byte\"\n"
        },
        "testing": {
          "isReturningIf": "isReturningIf\n\t^(special between: 3 and: 4)\n\t\tand: [arguments first returns and: [arguments last returns]]\n",
          "canCascade": "canCascade\n\t^(receiver == NodeSuper or: [special > 0]) not\n"
        },
        "private": {
          "transformIfFalse:": "transformIfFalse: encoder\n\t(self transformBoolean: encoder)\n\t\tifTrue:\n\t\t\t[arguments _\n\t\t\t\tArray\n\t\t\t\t\twith: (BlockNode new\n\t\t\t\t\t\t\tstatements: (Array with: NodeNil)\n\t\t\t\t\t\t\treturns: false)\n\t\t\t\t\twith: (arguments at: 1).\n\t\t\t^true]\n\t\tifFalse:\n\t\t\t[^false]\n",
          "transformOr:": "transformOr: encoder\n\t(self transformBoolean: encoder)\n\t\tifTrue:\n\t\t\t[arguments _\n\t\t\t\tArray\n\t\t\t\t\twith: (BlockNode new\n\t\t\t\t\t\t\t\tstatements: (Array with: NodeTrue)\n\t\t\t\t\t\t\t\treturns: false)\n\t\t\t\t\twith: (arguments at: 1).\n\t\t\t^true]\n\t\tifFalse:\n\t\t\t[^false]\n",
          "transformAnd:": "transformAnd: encoder\n\t(self transformBoolean: encoder)\n\t\tifTrue:\n\t\t\t[arguments _\n\t\t\t\tArray\n\t\t\t\t\twith: (arguments at: 1)\n\t\t\t\t\twith: (BlockNode new\n\t\t\t\t\t\t\t\tstatements: (Array with: NodeFalse)\n\t\t\t\t\t\t\t\treturns: false).\n\t\t\t^true]\n\t\tifFalse:\n\t\t\t[^false]\n",
          "transformBoolean:": "transformBoolean: encoder\n\t^self\n\t\tcheckBlock: (arguments at: 1)\n\t\tas: 'argument'\n\t\tfrom: encoder\n",
          "transformIfFalseIfTrue:": "transformIfFalseIfTrue: encoder\n\t((self checkBlock: (arguments at: 1) as: 'False arg' from: encoder)\n\t\tand: [self checkBlock: (arguments at: 2) as: 'True arg' from: encoder])\n\t\tifTrue:\n\t\t\t[selector _ #ifTrue:ifFalse:.\n\t\t\targuments swap: 1 with: 2.\n\t\t\t^true]\n\t\tifFalse:\n\t\t\t[^false]\n",
          "transform:": "transform: encoder\n\tspecial = 0 ifTrue: [^false].\n\t(self perform: (MacroTransformers at: special) with: encoder)\n\t\tifTrue:\n\t\t\t[^true]\n\t\tifFalse:\n\t\t\t[special _ 0. ^false]\n",
          "transformIfTrueIfFalse:": "transformIfTrueIfFalse: encoder\n\t^(self checkBlock: (arguments at: 1) as: 'True arg' from: encoder)\n\t\tand: [self checkBlock: (arguments at: 2) as: 'False arg' from: encoder]\n",
          "transformWhile:": "transformWhile: encoder\n\t^(self transformBoolean: encoder)\n\t\tand: [self checkBlock: receiver as: 'receiver' from: encoder]\n",
          "receiver:arguments:precedence:": "receiver: rcvr arguments: args precedence: p\n\treceiver _ rcvr.\n\targuments _ args.\n\tsizes _ Array new: arguments size.\n\tprecedence _ p\n",
          "checkBlock:as:from:": "checkBlock: node as: nodeName from: encoder\n\tnode canBeSpecialArgument ifTrue: [^node isMemberOf: BlockNode].\n\t((node isKindOf: BlockNode) and: [node numberOfArguments > 0])\n\t\tifTrue:\t[^encoder notify: '<- ', nodeName , ' of ' ,\n\t\t\t\t\t(MacroSelectors at: special) , ' must be 0-argument block']\n\t\tifFalse: [^encoder notify: '<- ', nodeName , ' of ' ,\n\t\t\t\t\t(MacroSelectors at: special) , ' must be a block or variable']\n",
          "transformIfTrue:": "transformIfTrue: encoder\n\t(self transformBoolean: encoder)\n\t\tifTrue:\n\t\t\t[arguments _\n\t\t\t\tArray\n\t\t\t\t\twith: (arguments at: 1)\n\t\t\t\t\twith: (BlockNode new\n\t\t\t\t\t\t\t\tstatements: (Array with: NodeNil)\n\t\t\t\t\t\t\t\treturns: false).\n\t\t\t^true]\n\t\tifFalse:\n\t\t\t[^false]\n"
        },
        "initialize-release": {
          "receiver:selector:arguments:precedence:from:sourceRange:": "receiver: rcvr selector: selName arguments: args precedence: p from: encoder sourceRange: range\n\t\"compile\"\n\n\tencoder noteSourceRange: range forNode: self.\n\t^self\n\t\treceiver: rcvr\n\t\tselector: selName\n\t\targuments: args\n\t\tprecedence: p\n\t\tfrom: encoder\n",
          "receiver:selector:arguments:precedence:": "receiver: rcvr selector: selNode arguments: args precedence: p\n\t\"decompile\"\n\n\tself receiver: rcvr\n\t\targuments: args\n\t\tprecedence: p.\n\tspecial _ MacroSelectors indexOf: selNode key.\n\tselector _ selNode\n",
          "receiver:selector:arguments:precedence:from:": "receiver: rcvr selector: selName arguments: args precedence: p from: encoder\n\t\"compile\"\n\n\tself receiver: rcvr\n\t\targuments: args\n\t\tprecedence: p.\n\tspecial _  MacroSelectors indexOf: selName.\n\t(self transform: encoder)\n\t\tifTrue:\n\t\t\t[selector _ SelectorNode new\n\t\t\t\t\t\t\tkey: (MacroSelectors at: special)\n\t\t\t\t\t\t\tcode: #macro]\n\t\tifFalse:\n\t\t\t[selector _ encoder encodeSelector: selName.\n\t\t\trcvr == NodeSuper ifTrue: [encoder noteSuper]]\n"
        },
        "debugger temp access": {
          "store:from:": "store: expr from: encoder\n\t\"ctxt tempAt: n -> ctxt tempAt: n put: expr (see Assignment).\n\tFor assigning into temps of a context being debugged\"\n\tselector key ~= #tempAt:\n\t\tifTrue: [^self error: 'cant transform this message'].\n\t^MessageNode new\n\t\treceiver: receiver\n\t\tselector: #tempAt:put:\n\t\targuments: (arguments copyWith: expr)\n\t\tprecedence: precedence\n\t\tfrom: encoder\n",
          "isTemp": "isTemp\n\t\"Sorry, folks, for now you cant use remote temps in blocks\"\n\t\"This could be fixed by supporting store protocol for the case of assignment\n\tinto virtual fields in BlockNode sizeForValue and emitForValue\"\n\t^ false\n"
        }
      }
    },
    "ParseNode": {
      "comment": "This superclass of most compiler/decompiler classes declares common class variables, default messages, and the code emitters for jumps.  Some of the class variables are initialized here; the rest are initialized in class VariableNode, which is the last alphabetically.\n",
      "class_name": "ParseNode",
      "superclass": "Object",
      "instanceVariables": "comment",
      "classInstanceVariables": "",
      "classVariables": "Bfp CodeBases CodeLimits Dup EndMethod EndRemote Jmp JmpLimit JmpLong LdFalse LdInstLong LdInstType LdLitIndType LdLitType LdMinus1 LdNil LdSelf LdSuper LdTempType LdThisContext LdTrue NodeFalse NodeNil NodeSelf NodeSuper NodeThisContext NodeTrue Pop Send SendLimit SendLong SendPlus SendType ShortStoP StdLiterals StdSelectors StdVariables Store StorePop",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"ParseNode initialize.  VariableNode initialize.\"\n\n\tLdInstType _ 1.\n\tLdTempType _ 2.\n\tLdLitType _ 3.\n\tLdLitIndType _ 4.\n\tSendType _ 5.\n\tCodeBases _ #(0 16 32 64 208 ).\n\tCodeLimits _ #(16 16 32 32 16 ).\n\tLdSelf _ 112.\n\tLdTrue _ 113.\n\tLdFalse _ 114.\n\tLdNil _ 115.\n\tLdMinus1 _ 116.\n\tLdInstLong _ 128.\n\tStore _ 129.\n\tStorePop _ 130.\n\tShortStoP _ 96.\n\tSendLong _ 131.\n\tLdSuper _ 133.\n\tPop _ 135.\n\tDup _ 136.\n\tLdThisContext _ 137.\n\tEndMethod _ 124.\n\tEndRemote _ 125.\n\tJmp _ 144.\n\tBfp _ 152.\n\tJmpLimit _ 8.\n\tJmpLong _ 160.\n\tSendPlus _ 176.\n\tSend _ 208.\n\tSendLimit _ 16\n"
        }
      },
      "instance_methods": {
        "printing": {
          "printCommentOn:indent:": "printCommentOn: aStream indent: indent\n\t| thisComment |\n\tcomment == nil ifTrue: [^self].\n\t1 to: comment size do:\n\t\t[:index |\n\t\tindex > 1 ifTrue: [aStream crtab: indent].\n\t\taStream nextPut: $\".\n\t\tthisComment _ comment at: index.\n\t\tself printSingleComment: thisComment\n\t\t\ton: aStream\n\t\t\tindent: indent.\n\t\taStream nextPut: $\"].\n\tcomment _ nil\n",
          "printOn:": "printOn: aStream\n\taStream nextPutAll: '{'.\n\tself printOn: aStream indent: 0.\n\taStream nextPutAll: '}'\n",
          "printOn:indent:": "printOn: aStream indent: anInteger\n\t\"If control gets here, avoid recursion loop\"\n\n\tsuper printOn: aStream\n",
          "printOn:indent:precedence:": "printOn: aStream indent: level precedence: p\n\tself printOn: aStream indent: level\n"
        },
        "encoding": {
          "encodeSelector:": "encodeSelector: selector\n\t^nil\n"
        },
        "code generation": {
          "emitLongJump:on:": "emitLongJump: dist on: strm\n\t\"force a two byte jump\"\n\n\tself emitLong: dist code: JmpLong on: strm\n",
          "emitForReturn:on:": "emitForReturn: stack on: strm\n\tself emitForValue: stack on: strm.\n\tstrm nextPut: EndMethod\n",
          "emitShortOrLong:code:on:": "emitShortOrLong: dist code: shortCode on: strm\n\t(1 <= dist and: [dist <= JmpLimit])\n\t\tifTrue: [strm nextPut: shortCode + dist - 1]\n\t\tifFalse: [self emitLong: dist code: shortCode + 16 on: strm]\n",
          "emitForEffect:on:": "emitForEffect: stack on: strm\n\tself emitForValue: stack on: strm.\n\tstrm nextPut: Pop.\n\tstack pop: 1\n",
          "emitJump:on:": "emitJump: dist on: strm\n\tdist = 0 ifFalse: [self emitShortOrLong: dist code: Jmp on: strm]\n",
          "sizeJump:": "sizeJump: dist\n\tdist = 0 ifTrue: [^0].\n\t^self sizeShortOrLong: dist\n",
          "emitLong:code:on:": "emitLong: dist code: longCode on: aStream\n\t\"force a two-byte jump\"\n\n\t| code distance |\n\tcode _ longCode.\n\tdistance _ dist.\n\tdistance < 0\n\t\tifTrue:\n\t\t\t[distance _ distance + 1024]\n\t\tifFalse:\n\t\t\t[distance > 1023\n\t\t\t\tifTrue: [distance _ -1]\n\t\t\t\tifFalse: [code _ code + 4]].\n\tdistance < 0\n\t\tifTrue:\n\t\t\t[self error: 'A block compiles more than 1K bytes of code']\n\t\tifFalse:\n\t\t\t[aStream nextPut: distance // 256 + code.\n\t\t\taStream nextPut: distance \\\\ 256]\n",
          "sizeForReturn:": "sizeForReturn: encoder\n\t^(self sizeForValue: encoder) + 1\n",
          "sizeForEffect:": "sizeForEffect: encoder\n\t^(self sizeForValue: encoder) + 1\n",
          "emitTrueBranch:pop:on:": "emitTrueBranch: dist pop: stack on: strm\n\tstack pop: 1.\n\t\"offset for dist>0 adds another 4, so will begin at JmpLong+8\"\n\tself emitLong: dist code: JmpLong+4 on: strm\n",
          "sizeBranch:": "sizeBranch: dist\n\tdist = 0 ifTrue: [^1].\n\t^self sizeShortOrLong: dist\n",
          "sizeShortOrLong:": "sizeShortOrLong: dist\n\t(1 <= dist and: [dist <= JmpLimit])\n\t\tifTrue: [^1].\n\t^2\n",
          "emitBranch:pop:on:": "emitBranch: dist pop: stack on: strm\n\tstack pop: 1.\n\tdist = 0\n\t\tifTrue: [strm nextPut: Pop]\n\t\tifFalse: [self emitShortOrLong: dist code: Bfp on: strm]\n"
        },
        "testing": {
          "canBeSpecialArgument": "canBeSpecialArgument\n\t\"can I be an argument of (e.g.) ifTrue:?\"\n\n\t^false\n",
          "isReturnSelf": "isReturnSelf\n\t^false\n",
          "isReturningIf": "isReturningIf\n\t^false\n",
          "isArg": "isArg\n\t^false\n",
          "isVariableReference": "isVariableReference\n\t^false\n",
          "canCascade": "canCascade\n\t^false\n"
        },
        "accessing": {
          "comment:": "comment: newComment\n\t\"self halt.\"\n\n\tcomment _ newComment\n",
          "comment": "comment\n\t^comment\n"
        },
        "private": {
          "nextWordFrom:setCharacter:": "nextWordFrom: aStream setCharacter: aBlock\n\t| outStream char |\n\toutStream _ WriteStream on: (String new: 16).\n\t[aStream atEnd\n\t\tor:\n\t\t\t[char _ aStream next.\n\t\t\tchar = Character cr or: [char = Character space]]]\n\t\twhileFalse: [outStream nextPut: char].\n\taBlock value: char.\n\t^outStream contents\n",
          "printSingleComment:on:indent:": "printSingleComment: aString on: aStream indent: indent\n\t\"Print the comment string, assuming it has been indented indent tabs.\n\tBreak the string at word breaks, given the widths in the default font, at\n\t 450 points.\"\n\n\t| readStream word position lineBreak lastChar font wordWidth tabWidth spaceWidth |\n\treadStream _ ReadStream on: aString.\n\tfont _ TextStyle default defaultFont.\n\ttabWidth _ TextConstants at: #DefaultTab.\n\tspaceWidth _ font widthOf: Character space.\n\tposition _ indent * tabWidth.\n\tlineBreak _ 450.\n\t[readStream atEnd]\n\t\twhileFalse:\n\t\t\t[word _ self nextWordFrom: readStream setCharacter: [:lastChar | lastChar].\n\t\t\twordWidth _ 0.\n\t\t\tword do: [:char | wordWidth _ wordWidth + (font widthOf: char)].\n\t\t\tposition _ position + wordWidth.\n\t\t\tposition > lineBreak\n\t\t\t\tifTrue:\n\t\t\t\t\t[aStream crtab: indent.\n\t\t\t\t\tposition _ indent * tabWidth + wordWidth + spaceWidth.\n\t\t\t\t\tlastChar = Character cr\n\t\t\t\t\t\tifTrue: [[readStream peekFor: Character tab] whileTrue].\n\t\t\t\t\taStream nextPutAll: word; space]\n\t\t\t\tifFalse:\n\t\t\t\t\t[aStream nextPutAll: word.\n\t\t\t\t\treadStream atEnd\n\t\t\t\t\t\tifFalse:\n\t\t\t\t\t\t\t[position _ position + spaceWidth.\n\t\t\t\t\t\t\taStream space].\n\t\t\t\t\tlastChar = Character cr\n\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t[aStream crtab: indent.\n\t\t\t\t\t\t\tposition _ indent * tabWidth.\n\t\t\t\t\t\t\t[readStream peekFor: Character tab] whileTrue]]]\n"
        },
        "converting": {
          "asReturnNode": "asReturnNode\n\t^ReturnNode new expr: self\n"
        }
      }
    },
    "Parser": {
      "comment": "I parse Smalltalk syntax and create a parse tree.  I look one token ahead.\nInstance Variables:\n\there\t\t<Object> the current token\n\thereType\t<Symbol> the \"type\" of the current token (see initialize)\n\thereMark\t<Integer> position in source stream (mark) where this token began\n\tprevToken\t<Integer> size in chars of the previous token parsed\n\tprevMark\t<Integer> mark of previous token\n\tencoder\t\t<Encoder> which uses tables to decode tokens\n\trequestor\tobject from which parsing was invoked.  If not nil, this object\n\t\t\t\twill be sent -notify: prior to evaluating the failBlock\n\tparseNode\t<ParseNode> result of current (recursive descent) parse\n\tfailBlock\t<BlockContext> to be evaluated in case of parse errors\n\tlastTempMark <Integer> mark of last temp; points to vert bar,\n\t\t\t\tor last char of pattern if no temps declared\n\tcorrectionDelta\t<Integer> offset of corrected code relative to source stream\n\t\t\t\towing to interactive corrections so far\n",
      "class_name": "Parser",
      "superclass": "Scanner",
      "instanceVariables": "here hereType hereMark prevToken prevMark encoder requestor parseNode failBlock lastTempMark correctionDelta",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "comparing": {
          "matchToken:": "matchToken: thing\n\t\"matches the token, not its type\"\n\n\there = thing ifTrue: [self advance. ^true].\n\t^false\n",
          "match:": "match: type\n\t\"Answer with true if next tokens type matches\"\n\n\thereType == type\n\t\tifTrue:\n\t\t\t[self advance.\n\t\t\t^true].\n\t^false\n"
        },
        "scanning": {
          "startOfNextToken": "startOfNextToken\n\t\"return starting position in source of next token\"\n\n\thereType == #doIt ifTrue: [^source position + 1 + correctionDelta].\n\t^hereMark + correctionDelta\n",
          "advance": "advance\n\t| this |\n\tprevMark _ hereMark.\n\tprevToken _ \"Now means prev size\"\n\t\t(hereType == #number) | (hereType == #string)\n\t\t\tifTrue: [mark - prevMark]\n\t\t\tifFalse: [here size].\n\tthis _ here.\n\there _ token.\n\thereType _ tokenType.\n\thereMark _ mark.\n\tself scanToken.\n\t^this\n",
          "endOfLastToken": "endOfLastToken\n\thereType == #doIt ifTrue: [^ prevMark + prevToken + 1 + correctionDelta].\n\ttokenType == #doIt ifTrue: [^ prevMark + prevToken + correctionDelta].\n\t^ prevMark + prevToken - 1 + correctionDelta\n",
          "bareEndOfLastToken": "bareEndOfLastToken\n\t^ prevMark + prevToken - 1 + correctionDelta\n"
        },
        "expression types": {
          "statements:innerBlock:": "statements: argNodes innerBlock: inner\n\t| stmts returns start more blockComment |\n\tstmts _ OrderedCollection new.\n\t\"give initial comment to block, since others trail statements\"\n\tblockComment _ currentComment.\n\tcurrentComment _ nil.\n\treturns _ false.\n\tmore _ hereType ~~ #rightBracket.\n\t[more]\n\t\twhileTrue:\n\t\t\t[start _ self startOfNextToken.\n\t\t\t(returns _ self match: #upArrow)\n\t\t\t\tifTrue:\n\t\t\t\t\t[self expression\n\t\t\t\t\t\tifFalse: [^self expected: 'Expression to return'].\n\t\t\t\t\tself addComment.\n\t\t\t\t\tstmts addLast:\n\t\t\t\t\t\t(ReturnNode new\n\t\t\t\t\t\t\texpr: parseNode\n\t\t\t\t\t\t\tencoder: encoder\n\t\t\t\t\t\t\tsourceRange: (start to: self endOfLastToken))]\n\t\t\t\tifFalse:\n\t\t\t\t\t[self expression\n\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t[self addComment.\n\t\t\t\t\t\t\tstmts addLast: parseNode]\n\t\t\t\t\t\tifFalse:\n\t\t\t\t\t\t\t[self addComment.\n\t\t\t\t\t\t\tstmts size = 0\n\t\t\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t\t\t[stmts addLast:\n\t\t\t\t\t\t\t\t\t\t(encoder encodeVariable:\n\t\t\t\t\t\t\t\t\t\t\t(inner ifTrue: ['nil'] ifFalse: ['self']))]]].\n\t\t\treturns\n\t\t\t\tifTrue:\n\t\t\t\t\t[(hereType == #rightBracket or: [hereType == #doIt])\n\t\t\t\t\t\tifFalse: [^self expected: 'End of block']].\n\t\t\tmore _ returns not and: [self match: #period]].\n\tparseNode _ BlockNode new\n\t\t\t\t\targuments: argNodes\n\t\t\t\t\tstatements: stmts\n\t\t\t\t\treturns: returns\n\t\t\t\t\tfrom: encoder\n\t\t\t\t\tsourceEnd: self endOfLastToken+1.\n\tparseNode comment: blockComment.\n\t^true\n",
          "primitive": "primitive\n\t| n |\n\t(self matchToken: #<)\n\t\tifFalse: [^0].\n\t(self matchToken: 'primitive:')\n\t\tifFalse: [^self expected: 'primitive:'].\n\tn _ here.\n\t((self match: #number)\n\t\tand: [n isKindOf: Integer])\n\t\tifFalse: [^self expected: 'Integer'].\n\t(self matchToken: #>)\n\t\tifFalse: [^self expected: '>'].\n\t^n\n",
          "assignment": "assignment\n\t\"variable '_' expression => AssignmentNode\"\n\n\t| varName var |\n\tvarName _ self advance.\n\t(encoder cantStoreInto: varName)\n\t\tifTrue: [^self notify: 'Cannot store into'].\n\tvar _ encoder encodeVariable: varName.\n\tself advance.\n\tself expression ifFalse: [^self expected: 'Expression'].\n\tvar isArg ifTrue: [^self notify: 'Cannot store into argument'].\n\tparseNode _ AssignmentNode new\n\t\t\t\tvariable: var\n\t\t\t\tvalue: parseNode\n\t\t\t\tfrom: encoder\n",
          "temporaries": "temporaries\n\t\"[ '|' (variable) ]  (variable, ..., variable)* \"\n\n\t| vars |\n\t(self match: #verticalBar)\n\t\tifFalse: [lastTempMark _ self bareEndOfLastToken. ^#()].\t\"no temps\"\n\t(self match: #verticalBar)\n\t\tifTrue: [lastTempMark _ self endOfLastToken. ^#()].\t\"empty temps\"\n\tvars _ OrderedCollection new.\n\t[hereType == #word]\n\t\twhileTrue: [vars addLast: (encoder bindTemp: self advance)].\n\t(self match: #verticalBar)\n\t\tifTrue: [lastTempMark _ self endOfLastToken. ^vars].\n\t^self expected: 'Vertical bar'\n",
          "messagePart:repeat:": "messagePart: level repeat: repeat\n\t| start receiver selector args precedence |\n\n\t[receiver _ parseNode.\n\t(hereType == #keyword and: [level >= 3])\n\t\tifTrue:\n\t\t\t[start _ self startOfNextToken.\n\t\t\tselector _ WriteStream on: (String new: 32).\n\t\t\targs _ OrderedCollection new.\n\t\t\t[hereType == #keyword]\n\t\t\t\twhileTrue:\n\t\t\t\t\t[selector nextPutAll: self advance.\n\t\t\t\t\tself primaryExpression ifFalse: [^self expected: 'Argument'].\n\t\t\t\t\tself messagePart: 2 repeat: true.\n\t\t\t\t\targs addLast: parseNode].\n\t\t\tselector _ self makeNewSymbol: selector contents startingAt: start.\n\t\t\tprecedence _ 3]\n\t\tifFalse: [((hereType == #binary or: [hereType == #verticalBar])\n\t\t\t\tand: [level >= 2])\n\t\t\t\tifTrue:\n\t\t\t\t\t[start _ self startOfNextToken.\n\t\t\t\t\tselector _ self advance asSymbol.\n\t\t\t\t\tself primaryExpression ifFalse: [^self expected: 'Argument'].\n\t\t\t\t\tself messagePart: 1 repeat: true.\n\t\t\t\t\targs _ Array with: parseNode.\n\t\t\t\t\tprecedence _ 2]\n\t\t\t\tifFalse: [hereType == #word\n\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t[start _ self startOfNextToken.\n\t\t\t\t\t\t\tselector _ self makeNewSymbol: self advance startingAt: start.\n\t\t\t\t\t\t\targs _ #().\n\t\t\t\t\t\t\tprecedence _ 1]\n\t\t\t\t\t\tifFalse: [^args notNil]]].\n\tparseNode _ MessageNode new\n\t\t\t\treceiver: receiver\n\t\t\t\tselector: selector\n\t\t\t\targuments: args\n\t\t\t\tprecedence: precedence\n\t\t\t\tfrom: encoder\n\t\t\t\tsourceRange: (start to: self endOfLastToken).\n\trepeat]\n\t\twhileTrue: [].\n\t^true\n",
          "pattern:inContext:": "pattern: fromDoit inContext: ctxt\n\t\"unarySelector | binarySelector arg | keyword arg {keyword arg} =>\n\t{selector, arguments, precedence}\"\n\n\t| args selector |\n\tfromDoit\n\t\tifTrue:\n\t\t\t[ctxt == nil\n\t\t\t\tifTrue: [^Array with: #DoIt with: #() with: 1]\n\t\t\t\tifFalse: [^Array\n\t\t\t\t\t\t\twith: #DoItIn:\n\t\t\t\t\t\t\twith: (Array\n\t\t\t\t\t\t\t\t\twith: (encoder encodeVariable: 'homeContext'))\n\t\t\t\t\t\t\t\t\twith: 3]].\n\thereType == #word\n\t\tifTrue: [^Array with: self advance asSymbol with: #() with: 1].\n\t(hereType == #binary or: [hereType == #verticalBar])\n\t\tifTrue:\n\t\t\t[selector _ self advance asSymbol.\n\t\t\targs _ Array with: (encoder bindTemp: self argumentName).\n\t\t\t^Array with: selector with: args with: 2].\n\thereType == #keyword\n\t\tifTrue:\n\t\t\t[selector _ WriteStream on: (String new: 32).\n\t\t\targs _ OrderedCollection new.\n\t\t\t[hereType == #keyword]\n\t\t\t\twhileTrue:\n\t\t\t\t\t[selector nextPutAll: self advance.\n\t\t\t\t\targs addLast: (encoder bindTemp: self argumentName)].\n\t\t\t^Array with: selector contents asSymbol with: args with: 3].\n\t^self expected: 'Message pattern'\n",
          "argumentName": "argumentName\n\thereType == #word\n\t\tifFalse: [^self expected: 'Argument name'].\n\t^self advance\n",
          "cascade": "cascade\n\t\" {; message} => CascadeNode\"\n\n\t| rcvr msgs |\n\tparseNode canCascade\n\t\tifFalse: [^self expected: 'Cascading not'].\n\trcvr _ parseNode cascadeReceiver.\n\tmsgs _ OrderedCollection with: parseNode.\n\t[self match: #semicolon]\n\t\twhileTrue:\n\t\t\t[parseNode _ rcvr.\n\t\t\t(self messagePart: 3 repeat: false)\n\t\t\t\tifFalse: [^self expected: 'Cascade'].\n\t\t\tparseNode canCascade\n\t\t\t\tifFalse: [^self expected: '<- No special messages'].\n\t\t\tparseNode cascadeReceiver.\n\t\t\tmsgs addLast: parseNode].\n\tparseNode _ CascadeNode new receiver: rcvr messages: msgs\n",
          "expression": "expression\n\t(hereType == #word and: [tokenType == #leftArrow])\n\t\tifTrue: [self assignment.  ^true].\n\tself primaryExpression ifFalse: [^false].\n\t(self messagePart: 3 repeat: true)\n\t\tifTrue:\n\t\t\t[hereType == #semicolon ifTrue: [self cascade]].\n\t^true\n",
          "blockExpression": "blockExpression\n\t\"  [ {:var} ( | statements) ] => BlockNode\"\n\n\t| argNodes |\n\targNodes _ OrderedCollection new.\n\t[self match: #colon\n\t\"gather any arguments\"]\n\t\twhileTrue:\n\t\t\t[argNodes addLast: (encoder autoBind: self argumentName)].\n\t(argNodes size > 0 & (hereType ~~ #rightBracket) and: [(self match: #verticalBar) not])\n\t\tifTrue: [^self expected: 'Vertical bar'].\n\tself statements: argNodes innerBlock: true.\n\t(self match: #rightBracket)\n\t\tifFalse: [^self expected: 'Period or right bracket']\n",
          "primaryExpression": "primaryExpression\n\thereType == #word\n\t\tifTrue:\n\t\t\t[parseNode _ encoder encodeVariable: self advance.\n\t\t\t^true].\n\thereType == #leftBracket\n\t\tifTrue:\n\t\t\t[self advance.\n\t\t\tself blockExpression.\n\t\t\t^true].\n\thereType == #leftParenthesis\n\t\tifTrue:\n\t\t\t[self advance.\n\t\t\tself expression ifFalse: [^self expected: 'expression'].\n\t\t\t(self match: #rightParenthesis)\n\t\t\t\tifFalse: [^self expected: 'right parenthesis'].\n\t\t\t^true].\n\t(hereType == #string or: [hereType == #number or: [hereType == #literal]])\n\t\tifTrue:\n\t\t\t[parseNode _ encoder encodeLiteral: self advance.\n\t\t\t^true].\n\t(here == #- and: [tokenType == #number])\n\t\tifTrue:\n\t\t\t[self advance.\n\t\t\tparseNode _ encoder encodeLiteral: self advance negated.\n\t\t\t^true].\n\t^false\n",
          "method:context:": "method: doit context: ctxt\n\t\"pattern [ | temporaries ] block => MethodNode\"\n\n\t| sap blk prim temps messageComment methodNode |\n\tsap _ self pattern: doit inContext: ctxt.\n\t\"sap={selector, arguments, precedence}\"\n\t(sap at: 2) do: [:argNode | argNode isArg: true].\n\ttemps _ self temporaries.\n\tmessageComment _ currentComment.\n\tcurrentComment _ nil.\n\tprim _ doit ifTrue: [0] ifFalse: [self primitive].\n\tself statements: #() innerBlock: doit.\n\tblk _ parseNode.\n\tdoit\n\t\tifTrue: [blk returnLast]\n\t\tifFalse: [blk returnSelfIfNoOther].\n\thereType == #doIt ifFalse: [^self expected: 'Nothing more'].\n\tmethodNode _ MethodNode new comment: messageComment.\n\t^methodNode\n\t\tselector: (sap at: 1)\n\t\targuments: (sap at: 2)\n\t\tprecedence: (sap at: 3)\n\t\ttemporaries: temps\n\t\tblock: blk\n\t\tencoder: encoder\n\t\tprimitive: prim\n"
        },
        "private": {
          "initPattern:notifying:return:": "initPattern: aString notifying: req return: aBlock\n\t| result |\n\tself\n\t\tinit: (ReadStream on: aString asString)\n\t\tnotifying: req\n\t\tfailBlock: [^nil].\n\tencoder _ self.\n\tresult _ aBlock value: (self pattern: false inContext: nil).\n\tencoder _ failBlock _ nil.  \"break cycles\"\n\t^result\n",
          "makeNewSymbol:startingAt:": "makeNewSymbol: aString startingAt: start\n\t| editor index menu sym oldText newText oldStream oldKey |\n\tSymbol hasInterned: aString ifTrue: [:symbol | ^ symbol].\n\t(editor _ self editor) isNil ifTrue: [^ aString asSymbol].\n\teditor selectFrom: start to: self endOfLastToken.\n\tCursor normal show.\n\tindex _ (menu _ ActionMenu\n\t\t\tlabels: 'proceed as is\\correct it\\abort' withCRs\n\t\t\tselectors: #(proceed correct abort))\n\t\t\t\tstartUp: #anyButton\n\t\t\t\twithHeading: ' ' , (aString contractTo: 20) , ' is a new message '.\n\tindex = 0 ifTrue: [^ self notify: ''].\n\t(menu selectorAt: index) == #proceed ifTrue: [^ aString asSymbol].\n\t(menu selectorAt: index) == #correct ifTrue:\n\t\t[sym _ Symbol correctMessage: aString.\n\t\tsym == false ifTrue: [self notify: 'Couldn''t correct'. self abort].\n\t\tsym == nil ifTrue: [self abort].\n\t\toldText _ editor selection.\n\t\tsym isKeyword\n\t\t\tifTrue:\n\t\t\t\t[newText _ oldText.\n\t\t\t\toldStream _ ReadStream on: aString.\n\t\t\t\tsym keywords do:\n\t\t\t\t\t[:newKey | oldKey _ (oldStream upTo: $:) , ':'.\n\t\t\t\t\toldKey = newKey ifFalse:\n\t\t\t\t\t\t[newText _ newText copyReplaceAll: oldKey asText with: newKey asText]]]\n\t\t\tifFalse:\n\t\t\t\t[newText _ oldText copyReplaceAll: aString asText with: sym asText].\n\t\tself replaceEditSelectionWith: newText.\n\t\t^ sym].\n\tself abort\n",
          "addComment": "addComment\n\tparseNode ~~ nil\n\t\tifTrue:\n\t\t\t[parseNode comment: currentComment.\n\t\t\tcurrentComment _ nil]\n",
          "init:notifying:failBlock:": "init: sourceStream notifying: req failBlock: aBlock\n\trequestor _ req.\n\tfailBlock _ aBlock.\n\tcorrectionDelta _ 0.\n\tsuper scan: sourceStream.\n\tprevMark _ hereMark _ mark.\n\tself advance\n"
        },
        "public access": {
          "parse:class:noPattern:context:notifying:ifFail:": "parse: sourceStream class: class noPattern: noPattern context: ctxt\n\tnotifying: req ifFail: aBlock\n\t \"Answer with a parse tree.  noPattern is true for doIts (Compiler evaluate)\"\n\n\t | meth |\n\tself init: sourceStream notifying: req failBlock: [^aBlock value].\n\tencoder _ Encoder new init: class context: ctxt notifying: self.\n\tfailBlock_ aBlock.\n\tmeth _ self method: noPattern context: ctxt.\n\tencoder _ failBlock _ requestor _ parseNode _ nil. \"break cycles & mitigate refct overflow\"\n\t^meth\n",
          "parseSelector:": "parseSelector: aString\n\t\"Answer with the selector for this method string\"\n\n\t^self\n\t\tinitPattern: aString\n\t\tnotifying: nil\n\t\treturn: [:pattern | pattern at: 1]\n",
          "parseMethodComment:setPattern:": "parseMethodComment: aString setPattern: aBlock\n\t\"Answer with the method comment for this string\"\n\n\tself\n\t\tinitPattern: aString\n\t\tnotifying: nil\n\t\treturn: aBlock.\n\tcurrentComment == nil\n\t\tifTrue: [^OrderedCollection new]\n\t\tifFalse: [^currentComment]\n",
          "parseArgsAndTemps:notifying:": "parseArgsAndTemps: aString notifying: req\n\t\"(for debugger) parse the string and answer with a two-element Array containing Arrays of Strings (the arg and temp names)\"\n\n\taString == nil ifTrue: [^#()].\n\t^self\n\t\tinitPattern: aString\n\t\tnotifying: req\n\t\treturn: [:pattern | (pattern at: 2) , self temporaries]\n"
        },
        "error handling": {
          "expected:": "expected: aString\n\t\"Notify a problem at token 'here'\"\n\ttokenType == #doIt ifTrue: [hereMark _ hereMark + 1].\n\thereType == #doIt ifTrue: [hereMark _ hereMark + 1].\n\t^ self notify: aString , ' expected' at: hereMark\n",
          "offEnd:": "offEnd: aString\n\t\" notify a problem beyond 'here' (in lookAhead token).  Don't be offEnded!\"\n\t^ self notify: aString at: mark\n",
          "editor": "editor\n\t^ requestor editor\n",
          "notify:at:": "notify: string at: location\n\trequestor == nil ifFalse: [requestor notify: string , ' ->' at: location + correctionDelta].\n\tself abort\n",
          "notify:": "notify: aString\n\t\"Notify problem at token before 'here'\"\n\t^self notify: aString at: prevMark\n",
          "abort": "abort\n\t| exitBlock |\n\tencoder == nil\n\t\tifFalse: [encoder release. encoder _ nil]. \"break cycle\"\n\texitBlock _ failBlock.\n\tfailBlock _ nil.\n\t^exitBlock value\n"
        },
        "temporaries": {
          "bindTemp:": "bindTemp: name\n\t^name\n"
        },
        "code view interaction": {
          "pasteTemp:": "pasteTemp: name\n\t| editor |\n\teditor _ self editor.\n\t(lastTempMark > 0 and: [(editor text at: lastTempMark) = $|])\n\t\tifTrue:\t\t\"Paste in before vertical bar\"\n\t\t\t[editor selectAt: lastTempMark.\n\t\t\tself replaceEditSelectionWith: name , ' '.\n\t\t\tlastTempMark _ lastTempMark + name size + 1]\n\t\tifFalse:\t\t\"No temp declarations yet; have to insert whole line\"\n\t\t\t[editor selectAt: lastTempMark+1.\n\t\t\tself replaceEditSelectionWith: (String with: Character cr) , '\t| ' , name , ' | '.\n\t\t\tlastTempMark _ lastTempMark + name size + 6]\n",
          "selectVariable:": "selectVariable: name\n\tself editor selectFrom: self bareEndOfLastToken - name size + 1\n\t\t\t\t\tto: self bareEndOfLastToken\n",
          "replaceEditSelectionWith:": "replaceEditSelectionWith: aString\n\t| editor |\n\teditor _ self editor.\n\tcorrectionDelta _ correctionDelta + aString size - editor selection size.\n\teditor deselect; replaceSelectionWith: aString asText\n"
        }
      }
    },
    "VariableNode": {
      "comment": "I am a parse tree leaf representing a variable.  Note that my name and key are different for pool variables -- the key is the Object Reference.\n",
      "class_name": "VariableNode",
      "superclass": "LeafNode",
      "instanceVariables": "name isArg",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"VariableNode initialize. Decompiler initialize.\"\n\t| encoder |\n\tencoder _ Encoder new.\n\tStdVariables _ Dictionary new: 16.\n\tencoder\n\t\tfillDict: StdVariables\n\t\twith: VariableNode\n\t\tmapping: #('self' 'thisContext' 'super' 'nil' 'false' 'true' )\n\t\tto: (Array with: LdSelf with: LdThisContext with: LdSuper)\n\t\t\t\t, (Array with: LdNil with: LdFalse with: LdTrue).\n\tStdSelectors _ Dictionary new: 64.\n\tencoder\n\t\tfillDict: StdSelectors\n\t\twith: SelectorNode\n\t\tmapping: ((1 to: Smalltalk specialSelectorSize) collect:\n\t\t\t\t\t\t\t[:i | Smalltalk specialSelectorAt: i])\n\t\tto: (SendPlus to: SendPlus + 31).\n\tStdLiterals _ LiteralDictionary new: 16.\n\tencoder\n\t\tfillDict: StdLiterals\n\t\twith: LiteralNode\n\t\tmapping: #(-1 0 1 2 )\n\t\tto: (LdMinus1 to: LdMinus1 + 3).\n\tencoder initScopeAndLiteralTables.\n\tself initialize2: encoder\n",
          "initialize2:": "initialize2: encoder\n\t\"VariableNode initialize.\"\n\n\tNodeNil _ encoder encodeVariable: 'nil'.\n\tNodeTrue _ encoder encodeVariable: 'true'.\n\tNodeFalse _ encoder encodeVariable: 'false'.\n\tNodeSelf _ encoder encodeVariable: 'self'.\n\tNodeThisContext _ encoder encodeVariable: 'thisContext'.\n\tNodeSuper _ encoder encodeVariable: 'super'\n"
        }
      },
      "instance_methods": {
        "printing": {
          "printOn:indent:": "printOn: aStream indent: level\n\taStream nextPutAll: name\n"
        },
        "code generation": {
          "emitForReturn:on:": "emitForReturn: stack on: strm\n\t(code >= LdSelf and: [code <= LdNil])\n\t\tifTrue:\n\t\t\t[\"short returns\"\n\t\t\tstrm nextPut: EndMethod - 4 + (code - LdSelf).\n\t\t\tstack push: 1 \"doesnt seem right\"]\n\t\tifFalse:\n\t\t\t[super emitForReturn: stack on: strm]\n",
          "sizeForStore:": "sizeForStore: encoder\n\tself reserve: encoder.\n\t^2\n",
          "sizeForStorePop:": "sizeForStorePop: encoder\n\tself reserve: encoder.\n\t(code < 24 and: [code noMask: 8])\n\t\tifTrue: [^1].\n\t^2\n",
          "emitForValue:on:": "emitForValue: stack on: strm\n\tcode < 256\n\t\tifTrue:\n\t\t\t[strm nextPut: (code = LdSuper ifTrue: [LdSelf] ifFalse: [code]).\n\t\t\tstack push: 1]\n\t\tifFalse:\n\t\t\t[self emitLong: LdInstLong on: strm.\n\t\t\tstack push: 1]\n",
          "emitStore:on:": "emitStore: stack on: strm\n\tself emitLong: Store on: strm\n",
          "sizeForReturn:": "sizeForReturn: encoder\n\t(code >= LdSelf and: [code <= LdNil])\n\t\tifTrue: [\"short returns\" ^1].\n\t^super sizeForReturn: encoder\n",
          "emitStorePop:on:": "emitStorePop: stack on: strm\n\t(code between: 0 and: 7)\n\t\tifTrue:\n\t\t\t[strm nextPut: ShortStoP + code \"short stopop inst\"]\n\t\tifFalse:\n\t\t\t[(code between: 16 and: 23)\n\t\t\t\tifTrue: [strm nextPut: ShortStoP + 8 + code - 16 \"short stopop temp\"]\n\t\t\t\tifFalse: [self emitLong: StorePop on: strm]].\n\tstack pop: 1\n"
        },
        "testing": {
          "canBeSpecialArgument": "canBeSpecialArgument\n\t\"can I be an argument of (e.g.) ifTrue:?\"\n\n\t^code < LdNil\n",
          "isTemp": "isTemp\n\t\"Answer true if this describes a temporary variable\"\n\n\tcode < 0\n\t\tifTrue: [^code = LdTempType negated].\n\tcode > 255\n\t\tifTrue: [^code\n\t\t\t\t\tbetween: LdTempType * 256\n\t\t\t\t\tand: LdTempType * 256 + 255].\n\t^code\n\t\tbetween: (CodeBases at: 2)\n\t\tand: (CodeBases at: 2) + (CodeLimits at: 2) - 1\n",
          "isArg": "isArg\n\t^self isTemp and: [isArg==true]\n",
          "isVariableReference": "isVariableReference\n\t^true\n"
        },
        "initialize-release": {
          "name:index:type:": "name: varName index: i type: type\n\tself name: varName\n\t\tkey: varName\n\t\tindex: i\n\t\ttype: type\n",
          "name:key:index:type:": "name: varName key: objRef index: i type: type\n\tname _ varName.\n\tself key: objRef\n\t\tindex: i\n\t\ttype: type\n",
          "isArg:": "isArg: aBoolean\n\tisArg _ aBoolean\n",
          "name:key:code:": "name: string key: object code: byte\n\tname _ string.\n\tkey _ object.\n\tcode _ byte\n"
        }
      }
    },
    "Decompiler": {
      "comment": "I translate CompiledMethods into source code.\n",
      "class_name": "Decompiler",
      "superclass": "InstructionStream",
      "instanceVariables": "constructor method instVars tempVars constTable stack statements lastPc exit lastJumpPc lastReturnPc limit hasValue",
      "classInstanceVariables": "",
      "classVariables": "ArgumentFlag CascadeFlag",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"Decompiler initialize\"\n\tCascadeFlag _ 'cascade'.  \"A unique object\"\n\tArgumentFlag _ 'argument'.  \"Ditto\"\n"
        }
      },
      "instance_methods": {
        "instruction decoding": {
          "pushReceiver": "pushReceiver\n\tstack addLast: (constTable at: 1)\n",
          "methodReturnConstant:": "methodReturnConstant: value\n\tself pushConstant: value; methodReturnTop\n",
          "doPop": "doPop\n\tstatements addLast: stack removeLast\n",
          "pushLiteralVariable:": "pushLiteralVariable: assoc\n\tstack addLast: (constructor codeAnyLitInd: assoc)\n",
          "jump:": "jump: dist\n\texit _ pc + dist.\n\tlastJumpPc _ lastPc\n",
          "storeIntoLiteralVariable:": "storeIntoLiteralVariable: assoc\n\tself pushLiteralVariable: assoc; doStore: stack\n",
          "pushActiveContext": "pushActiveContext\n\tstack addLast: constructor codeThisContext\n",
          "popIntoReceiverVariable:": "popIntoReceiverVariable: offset\n\tself pushReceiverVariable: offset; doStore: statements\n",
          "blockReturnTop": "blockReturnTop\n\t\"No action needed\"\n",
          "jump:if:": "jump: dist if: condition\n\t| savePc elseDist sign elsePc elseStart end cond ifExpr thenBlock elseBlock thenJump elseJump condHasValue n b |\n\telsePc _ lastPc.\n\telseStart _ pc + dist.\n\tend _ limit.\n\t\"Check for bfp-jmp to invert condition.\n\tDon't be fooled by a loop with a null body.\"\n\tsign _ condition.\n\tsavePc _ pc.\n\t((elseDist _ self interpretJump) notNil and: [elseDist >= 0 and: [elseStart = pc]])\n\t\tifTrue: [sign _ sign not.  elseStart _ pc + elseDist]\n\t\tifFalse: [pc _ savePc].\n\tifExpr _ stack removeLast.\n\tthenBlock _ self blockTo: elseStart.\n\tcondHasValue _ hasValue.\n\t\"ensure jump is within block (in case thenExpr returns)\"\n\tthenJump _ exit <= end ifTrue: [exit] ifFalse: [elseStart].\n\t\"if jump goes back, then it's a loop\"\n\tthenJump < elseStart\n\t\tifTrue:\n\t\t\t[\"thenJump will jump to the beginning of the while expr.  In the case of\n\t\t\twhile's with a block in the condition, the while expr\n\t\t\tshould include more than just the last expression: find all the\n\t\t\tstatements needed by re-decompiling.\"\n\t\t\tpc _ thenJump.\n\t\t\tb _ self statementsTo: elsePc.\n\t\t\t\"discard unwanted statements from block\"\n\t\t\tb size - 1 timesRepeat: [statements removeLast].\n\t\t\tstatements addLast: (constructor\n\t\t\t\t\tcodeMessage: (constructor codeBlock: b returns: false)\n\t\t\t\t\tselector: (constructor codeSelector: (sign ifTrue: [#whileFalse:] ifFalse: [#whileTrue:]) code: #macro)\n\t\t\t\t\targuments: (Array with: thenBlock)).\n\t\t\tpc _ elseStart]\n\t\tifFalse:\n\t\t\t[elseBlock _ self blockTo: thenJump.\n\t\t\telseJump _ exit.\n\t\t\t\"if elseJump is backwards, it is not part of the elseExpr\"\n\t\t\telseJump < elsePc\n\t\t\t\tifTrue: [pc _ lastPc].\n\t\t\tcond _ constructor\n\t\t\t\t\t\tcodeMessage: ifExpr\n\t\t\t\t\t\tselector: (constructor codeSelector: #ifTrue:ifFalse: code: #macro)\n\t\t\t\t\t\targuments:\n\t\t\t\t\t\t\t(sign\n\t\t\t\t\t\t\t\tifTrue: [Array with: elseBlock with: thenBlock]\n\t\t\t\t\t\t\t\tifFalse: [Array with: thenBlock with: elseBlock]).\n\t\t\tcondHasValue\n\t\t\t\tifTrue: [stack addLast: cond]\n\t\t\t\tifFalse: [statements addLast: cond]]\n",
          "doStore:": "doStore: stackOrBlock\n\t\"Only called internally, not from InstructionStream.  StackOrBlock is\n\tstack for store, statements for storePop.\"\n\t| var expr |\n\tvar _ stack removeLast.\n\texpr _ stack removeLast.\n\tstackOrBlock addLast: (expr == ArgumentFlag\n\t\tifTrue: [var]\n\t\tifFalse: [constructor codeAssignTo: var value: expr])\n",
          "methodReturnReceiver": "methodReturnReceiver\n\tself pushReceiver; methodReturnTop\n",
          "pushReceiverVariable:": "pushReceiverVariable: offset\n\t| var |\n\t(var _ instVars at: offset + 1) == nil\n\t\tifTrue:\n\t\t\t[\"Not set up yet\"\n\t\t\tinstVars at: offset + 1 put: (var _ constructor codeInst: offset)].\n\tstack addLast: var\n",
          "storeIntoReceiverVariable:": "storeIntoReceiverVariable: offset\n\tself pushReceiverVariable: offset; doStore: stack\n",
          "send:super:numArgs:": "send: selector super: superFlag numArgs: numArgs\n\t| args rcvr selNode msgNode messages |\n\targs _ Array new: numArgs.\n\t(numArgs to: 1 by: -1) do:\n\t\t[:i | args at: i put: stack removeLast].\n\trcvr _ stack removeLast.\n\tsuperFlag ifTrue: [rcvr _ constructor codeSuper].\n\t(selector == #blockCopy: and: [self checkForBlock: rcvr])\n\t\tifFalse:\n\t\t\t[selNode _ constructor codeAnySelector: selector.\n\t\t\trcvr == CascadeFlag\n\t\t\t\tifTrue:\n\t\t\t\t\t[msgNode _ constructor\n\t\t\t\t\t\tcodeCascadedMessage: selNode\n\t\t\t\t\t\targuments: args.\n\t\t\t\t\tstack last == CascadeFlag\n\t\t\t\t\t\tifFalse:\n\t\t\t\t\t\t\t[\"Last message of a cascade\"\n\t\t\t\t\t\t\tstatements addLast: msgNode.\n\t\t\t\t\t\t\tmessages _ self popTo: stack removeLast.  \"Depth saved by first dup\"\n\t\t\t\t\t\t\tmsgNode _ constructor\n\t\t\t\t\t\t\t\tcodeCascade: stack removeLast\n\t\t\t\t\t\t\t\tmessages: messages]]\n\t\t\t\tifFalse:\n\t\t\t\t\t[msgNode _ constructor\n\t\t\t\t\t\tcodeMessage: rcvr\n\t\t\t\t\t\tselector: selNode\n\t\t\t\t\t\targuments: args].\n\t\t\tstack addLast: msgNode]\n",
          "popIntoLiteralVariable:": "popIntoLiteralVariable: value\n\tself pushLiteralVariable: value; doStore: statements\n",
          "storeIntoTemporaryVariable:": "storeIntoTemporaryVariable: offset\n\tself pushTemporaryVariable: offset; doStore: stack\n",
          "pushConstant:": "pushConstant: value\n\t| node |\n\tnode _ value == true ifTrue: [constTable at: 2]\n\t\tifFalse: [value == false ifTrue: [constTable at: 3]\n\t\tifFalse: [value == nil ifTrue: [constTable at: 4]\n\t\tifFalse: [constructor codeAnyLiteral: value]]].\n\tstack addLast: node\n",
          "pushTemporaryVariable:": "pushTemporaryVariable: offset\n\tstack addLast: (tempVars at: offset + 1)\n",
          "methodReturnTop": "methodReturnTop\n\texit _ method size + 1.\n\tlastJumpPc _ lastReturnPc _ lastPc.\n\tstatements addLast: stack removeLast\n",
          "doDup": "doDup\n\tstack last == CascadeFlag\n\t\tifFalse:\n\t\t\t[\"Save position and mark cascade\"\n\t\t\tstack addLast: statements size.\n\t\t\tstack addLast: CascadeFlag].\n\tstack addLast: CascadeFlag\n",
          "popIntoTemporaryVariable:": "popIntoTemporaryVariable: offset\n\tself pushTemporaryVariable: offset; doStore: statements\n"
        },
        "private": {
          "quickMethod": "quickMethod\n\t^method isReturnSelf\n\t\tifTrue: [constructor codeBlock:\n\t\t\t\t(Array with: (constTable at: 1 \"self\")) returns: true]\n\t\tifFalse: [method isReturnField\n\t\t\tifTrue: [constructor codeBlock:\n\t\t\t\t(Array with: (constructor codeInst: method returnField)) returns: true]\n\t\t\tifFalse: [self error: 'improper short method']]\n",
          "popTo:": "popTo: oldPos\n\t| t |\n\tt _ Array new: statements size - oldPos.\n\t(t size to: 1 by: -1) do:\n\t\t[:i | t at: i put: statements removeLast].\n\t^t\n",
          "decompile:in:method:using:": "decompile: aSelector in: aClass method: aMethod using: aConstructor\n\t| block |\n\tconstructor _ aConstructor.\n\tmethod _ aMethod.\n\tself initSymbols: aClass.  \"create symbol tables\"\n\tmethod isQuick\n\t\tifTrue: [block _ self quickMethod]\n\t\tifFalse:\n\t\t\t[stack _ OrderedCollection new: method frameSize.\n\t\t\tstatements _ OrderedCollection new: 20.\n\t\t\tsuper method: method pc: method initialPC.\n\t\t\tblock _ self blockTo: method endPC + 1.\n\t\t\tstack isEmpty ifFalse: [self error: 'stack not empty']].\n\t^constructor\n\t\tcodeMethod: aSelector\n\t\tblock: block\n\t\ttempVars: tempVars\n\t\tprimitive: method primitive\n\t\tclass: aClass\n"
        },
        "initialize-release": {
          "initSymbols:": "initSymbols: aClass\n\t|  nTemps |\n\tconstructor\n\t\tmethod: method\n\t\tclass: aClass\n\t\tliterals: method literals.\n\tconstTable _ constructor codeConstants.\n\tinstVars _ Array new: aClass instSize.\n\t\"parse the header\"\n\tnTemps _ method numTemps.\n\ttempVars _ Array new: nTemps.\n\t1 to: nTemps do: [:i | tempVars at: i put: (constructor codeTemp: i - 1)]\n"
        },
        "public access": {
          "decompile:in:": "decompile: aSelector in: aClass\n\t^self\n\t\tdecompile: aSelector\n\t\tin: aClass\n\t\tmethod: (aClass compiledMethodAt: aSelector)\n",
          "decompile:in:method:": "decompile: aSelector in: aClass method: aMethod\n\t\"answer with a parse tree (root is a MethodNode) for this method\"\n\t^self\n\t\tdecompile: aSelector\n\t\tin: aClass\n\t\tmethod: aMethod\n\t\tusing: DecompilerConstructor new\n"
        },
        "control": {
          "checkForBlock:": "checkForBlock: receiver\n\t\"We just saw a blockCopy: message.  Check for a following block.\"\n\t| savePc jump args argPos block |\n\treceiver == constructor codeThisContext ifFalse: [^false].\n\tsavePc _ pc.\n\t(jump _ self interpretJump) notNil\n\t\tifFalse:\n\t\t\t[pc _ savePc.  ^nil].\n\t\"Definitely a block\"\n\tjump _ jump + pc.\n\targPos _ statements size.\n\t[self willStorePop]\n\t\twhileTrue:\n\t\t\t[stack addLast: ArgumentFlag.  \"Flag for doStore:\"\n\t\t\tself interpretNextInstructionFor: self].\n\targs _ Array new: statements size - argPos.\n\t1 to: args size do: [:i | args at: i put: statements removeLast].  \"Retrieve args\"\n\tblock _ self blockTo: jump.\n\tstack addLast: (constructor codeArguments: args block: block).\n\t^true\n",
          "blockTo:": "blockTo: end\n\t| exprs block |\n\t\"Decompile a range of code as in statementsTo:, but return a block node\"\n\texprs _ self statementsTo: end.\n\tblock _ constructor codeBlock: exprs returns: lastReturnPc = lastPc.\n\tlastReturnPc _ -1.  \"So as not to mislead outer calls\"\n\t^block\n",
          "statementsTo:": "statementsTo: end\n\t| blockPos stackPos t |\n\t\"Decompile the method from pc up to end and return an array of\n\texpressions.  If at run time this block will leave a value on\n\tthe stack, set hasValue to true.  If the block ends with a jump or return,\n\tset exit to the destination of the jump, or the end of the method;\n\totherwise, set exit = end.  Leave pc = end.\"\n\tblockPos _ statements size.\n\tstackPos _ stack size.\n\t[pc < end]\n\t\twhileTrue:\n\t\t\t[lastPc _ pc.  limit _ end.  \"for performs\"\n\t\t\tself interpretNextInstructionFor: self].\n\t\"If there is an additional item on the stack, it will be the value\n\tof this block.\"\n\t(hasValue _ stack size > stackPos)\n\t\tifTrue:\n\t\t\t[statements addLast: stack removeLast].\n\tlastJumpPc = lastPc ifFalse: [exit _ pc].\n\t^self popTo: blockPos\n"
        }
      }
    },
    "LiteralNode": {
      "comment": "I am a parse tree leaf representing a literal string or number\n",
      "class_name": "LiteralNode",
      "superclass": "LeafNode",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "printing": {
          "printOn:indent:": "printOn: aStream indent: level\n\tkey storeOn: aStream\n"
        },
        "code generation": {
          "emitForValue:on:": "emitForValue: stack on: strm\n\tcode < 256\n\t\tifTrue: [strm nextPut: code]\n\t\tifFalse: [self emitLong: LdInstLong on: strm].\n\tstack push: 1\n"
        }
      }
    },
    "ReturnNode": {
      "comment": "I represent an expression of the form ^expr\n",
      "class_name": "ReturnNode",
      "superclass": "ParseNode",
      "instanceVariables": "expr pc",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "printing": {
          "printOn:indent:": "printOn: aStream indent: level\n\taStream nextPut: $^.\n\texpr printOn: aStream indent: level.\n\texpr printCommentOn: aStream indent: level\n"
        },
        "code generation": {
          "emitForReturn:on:": "emitForReturn: stack on: strm\n\texpr emitForReturn: stack on: strm.\n\tpc _ strm position\n",
          "sizeForValue:": "sizeForValue: encoder\n\t^expr sizeForReturn: encoder\n",
          "emitForValue:on:": "emitForValue: stack on: strm\n\texpr emitForReturn: stack on: strm.\n\tpc _ strm position\n",
          "pc": "pc\n\t\"used by encoder source mapping\"\n\tpc == nil\n\t\tifTrue: [^3].  \"quick returns never generate, so pc=nil\"\n\t^pc\n",
          "sizeForReturn:": "sizeForReturn: encoder\n\t^expr sizeForReturn: encoder\n",
          "code": "code\n\t^expr code\n"
        },
        "testing": {
          "isReturnSelf": "isReturnSelf\n\t^expr == NodeSelf\n",
          "isVariableReference": "isVariableReference\n\t^expr isVariableReference\n"
        },
        "initialize-release": {
          "expr:encoder:sourceRange:": "expr: e encoder: encoder sourceRange: range\n\texpr _ e.\n\tencoder noteSourceRange: range forNode: self\n",
          "expr:": "expr: e\n\texpr _ e\n"
        },
        "converting": {
          "asReturnNode": "asReturnNode\n"
        }
      }
    },
    "SelectorNode": {
      "comment": "I am a parse tree leaf representing a selector\n",
      "class_name": "SelectorNode",
      "superclass": "LeafNode",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "printing": {
          "printOn:indent:": "printOn: aStream indent: level\n\taStream nextPutAll: key\n"
        },
        "code generation": {
          "emit:args:on:": "emit: stack args: nArgs on: strm\n\tself emit: stack\n\t\targs: nArgs\n\t\ton: strm\n\t\tsuper: false\n",
          "size:args:super:": "size: encoder args: nArgs super: supered\n\t| index |\n\tself reserve: encoder.\n\t(supered not and: [code - Send < SendLimit and: [nArgs < 3]])\n\t\tifTrue: [^1]. \"short send\"\n\t(supered and: [code < Send])\n\t\tifTrue:\n\t\t\t[\"super special:\"\n\t\t\tcode _ self code: (encoder litIndex: key) type: 5].\n\tindex _ code < 256\n\t\t\t\tifTrue: [code - Send]\n\t\t\t\tifFalse: [code \\\\ 256].\n\t(index < 32 and: [nArgs <= 7])\n\t\tifTrue: [^2]. \"medium send\"\n\t^3 \"long send\"\n",
          "emit:args:on:super:": "emit: stack args: nArgs on: aStream super: supered\n\t| index |\n\tstack pop: nArgs.\n\t(supered not and: [code - Send < SendLimit and: [nArgs < 3]])\n\t\tifTrue:\n\t\t\t[\"short send\"\n\t\t\taStream nextPut:\n\t\t\t\t\t(code < Send\n\t\t\t\t\t\tifTrue: [code]\n\t\t\t\t\t\tifFalse: [\"special\" nArgs * 16 + code])]\n\t\tifFalse:\n\t\t\t[index _ code < 256 ifTrue: [code - Send] ifFalse: [code \\\\ 256].\n\t\t\t(index < 32 and: [nArgs <= 7])\n\t\t\t\tifTrue:\n\t\t\t\t\t[\"medium send\"\n\t\t\t\t\taStream nextPut: SendLong + (supered ifTrue: [2] ifFalse: [0]).\n\t\t\t\t\taStream nextPut: nArgs * 32 + index]\n\t\t\t\tifFalse:\n\t\t\t\t\t[\"long send\"\n\t\t\t\t\taStream nextPut: SendLong + 1 + (supered ifTrue: [2] ifFalse: [0]).\n\t\t\t\t\taStream nextPut: nArgs.\n\t\t\t\t\taStream nextPut: index]]\n"
        }
      }
    },
    "LiteralDictionary": {
      "comment": "LiteralDictionaries check not only for equality but also for same class of their keys.\nThis avoids the problem of 0 being considered = to 0.0 as in Dictionaries, and it\nalso avoids the problem of 1.3 not being == to 1.3 (necessarily), as in IdentityDictionaries.\n",
      "class_name": "LiteralDictionary",
      "superclass": "Dictionary",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "private": {
          "findKeyOrNil:": "findKeyOrNil: key\n\t| location length probe pass |\n\tlength _ self basicSize.\n\tpass _ 1.\n\tlocation _ key hash \\\\ length + 1.\n\t[(probe _ self basicAt: location) == nil or:\n\t\t\t[probe key class == key class and: [probe key = key]]]\n\t\twhileFalse:\n\t\t\t[(location _ location + 1) > length\n\t\t\t\tifTrue:\n\t\t\t\t\t[location _ 1.\n\t\t\t\t\tpass _ pass + 1.\n\t\t\t\t\tpass > 2 ifTrue: [^self grow findKeyOrNil: key]]].\n\t^location\n"
        }
      }
    },
    "Scanner": {
      "comment": "I scan a stream picking out Smalltalk syntactic tokens.  I look one character ahead.  I put each token found into token and its type (a Symbol) into tokenType.  At the end of stream or a doit symbol, I pretend to see an endless sequence of doits.\n",
      "class_name": "Scanner",
      "superclass": "Object",
      "instanceVariables": "source mark hereChar aheadChar token tokenType currentComment buffer typeTable",
      "classInstanceVariables": "",
      "classVariables": "EndChar TypeTable",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"Scanner initialize.\"\n\n\t| newTable |\n\tnewTable _ Array new: 256 withAll: #xBinary. \"default\"\n\tnewTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. \"tab lf ff cr space\"\n\tnewTable atAll: ($0 asciiValue to: $9 asciiValue) put: #xDigit.\n\tnewTable atAll: ($A asciiValue to: $Z asciiValue) put: #xLetter.\n\tnewTable atAll: ($a asciiValue to: $z asciiValue) put: #xLetter.\n\tnewTable at: 30 put: #doIt.\n\tnewTable at: $\" asciiValue put: #xDoubleQuote.\n\tnewTable at: $# asciiValue put: #xLitQuote.\n\tnewTable at: $$ asciiValue put: #xDollar.\n\tnewTable at: $' asciiValue put: #xSingleQuote.\n\tnewTable at: $( asciiValue put: #leftParenthesis.\n\tnewTable at: $) asciiValue put: #rightParenthesis.\n\tnewTable at: $. asciiValue put: #period.\n\tnewTable at: $: asciiValue put: #colon.\n\tnewTable at: $; asciiValue put: #semicolon.\n\tnewTable at: $[ asciiValue put: #leftBracket.\n\tnewTable at: $] asciiValue put: #rightBracket.\n\tnewTable at: $^ asciiValue put: #upArrow.\n\tnewTable at: $_ asciiValue put: #leftArrow.\n\tnewTable at: $| asciiValue put: #verticalBar.\n\tEndChar _ 30 asCharacter.\n\tTypeTable _ newTable \"bon voyage!\"\n"
        },
        "instance creation": {
          "new": "new\n\t^super new initScanner\n"
        },
        "testing": {
          "isLiteralSymbol:": "isLiteralSymbol: aSymbol\n\t\"Test whether a symbol can be stored as # followed by its characters.\n\tSymbols created internally with asSymbol may not have this property,\n\te.g. '3' asSymbol.\"\n\n\t| i ascii type |\n\ti _ aSymbol size.\n\ti = 0 ifTrue: [^false].\n\tascii _ (aSymbol at: 1) asciiValue.\n\t\"TypeTable should have been origined at 0 rather than 1 ...\"\n\tascii = 0 ifTrue: [^false].\n\ttype _ TypeTable at: ascii.\n\t(type == #colon or: [type == #verticalBar])\n\t\tifTrue: [^i = 1].\n\ttype == #xBinary\n\t\tifTrue:\n\t\t\t[[i > 1]\n\t\t\t\twhileTrue:\n\t\t\t\t\t[ascii _ (aSymbol at: i) asciiValue.\n\t\t\t\t\tascii = 0 ifTrue: [^false].\n\t\t\t\t\t(TypeTable at: ascii) == #xBinary ifFalse: [^false].\n\t\t\t\t\ti _ i - 1].\n\t\t\t^true].\n\ttype == #xLetter\n\t\tifTrue:\n\t\t\t[[i > 1]\n\t\t\t\twhileTrue:\n\t\t\t\t\t[ascii _ (aSymbol at: i) asciiValue.\n\t\t\t\t\tascii = 0 ifTrue: [^false].\n\t\t\t\t\ttype _ TypeTable at: ascii.\n\t\t\t\t\t(type == #xLetter or: [type == #xDigit or: [type == #colon]])\n\t\t\t\t\t\tifFalse: [^false].\n\t\t\t\t\ti _ i - 1].\n\t\t\t^true].\n\t^false\n"
        }
      },
      "instance_methods": {
        "multi-character scans": {
          "xSingleQuote": "xSingleQuote\n\t\"string\"\n\tself step.\n\tbuffer reset.\n\t[hereChar == $'\n\t\tand: [aheadChar == $'\n\t\t\t\tifTrue: [self step. false]\n\t\t\t\tifFalse: [true]]]\n\t\twhileFalse:\n\t\t\t[buffer nextPut: self step.\n\t\t\t(hereChar == EndChar and: [source atEnd])\n\t\t\t\tifTrue: [^self offEnd: 'Unmatched string quote']].\n\tself step.\n\ttoken _ buffer contents.\n\ttokenType _ #string\n",
          "xDoubleQuote": "xDoubleQuote\n\t\"collect comment\"\n\n\t| aStream |\n\taStream _ WriteStream on: (String new: 32).\n\tself step.\n\t[aStream nextPut: self step. hereChar == $\"]\n\t\twhileFalse:\n\t\t\t[(hereChar = EndChar and: [source atEnd])\n\t\t\t\tifTrue: [^self offEnd: 'Unmatched comment quote']].\n\tself step.\n\tcurrentComment == nil\n\t\tifTrue: [currentComment _ OrderedCollection with: aStream contents]\n\t\tifFalse: [currentComment add: aStream contents].\n\tself scanToken\n",
          "xBinary": "xBinary\n\ttokenType _ #binary.\n\ttoken _ Symbol internCharacter: self step.\n\t((typeTable at: hereChar asciiValue) = #xBinary and: [hereChar ~= $-])\n\t\tifTrue: [token _ (token , (String with: self step)) asSymbol]\n",
          "xDelimiter": "xDelimiter\n\t\"ignore blanks etc.\"\n\n\tself scanToken\n",
          "xDigit": "xDigit\n\t\"form a number\"\n\n\ttokenType _ #number.\n\t(aheadChar = EndChar and: [source atEnd\n\t\t\tand:  [source skip: -1. source next ~= EndChar]])\n\t\tifTrue: [source skip: -1 \"Read off the end last time\"]\n\t\tifFalse: [source skip: -2].\n\ttoken _ Number readFrom: source.\n\tself step; step\n",
          "xDollar": "xDollar\n\t\"form a Character literal\"\n\n\tself step. \"pass over $\"\n\ttoken _ self step.\n\ttokenType _ #number \"really should be Char, but rest of compiler doesn't know\"\n",
          "xLitQuote": "xLitQuote\n\t\"UniqueStrings and Vectors\"\n\t\" #(1 (4 5) 2 3) #ifTrue:ifFalse:\"\n\n\t| start |\n\tself step. \"litQuote\"\n\tself scanToken.\n\ttokenType = #leftParenthesis\n\t\tifTrue:\n\t\t\t[start _ mark.\n\t\t\tself scanToken; scanLitVec.\n\t\t\ttokenType == #doIt\n\t\t\t\tifTrue: [mark _ start.\n\t\t\t\t\t\tself offEnd: 'Unmatched parenthesis']]\n\t\tifFalse:\n\t\t\t[(#(word keyword colon) includes: tokenType)\n\t\t\t\tifTrue: [self scanLitWord]].\n\ttokenType _ #literal\n",
          "xLetter": "xLetter\n\t\"form a word or keyword\"\n\t| type prefix |\n\tbuffer reset.\n\t[type _ typeTable at: hereChar asciiValue.\n\ttype == #xLetter or: [type == #xDigit]]\n\t\twhileTrue:\n\t\t\t[\"open code step for speed\"\n\t\t\tbuffer nextPut: hereChar.\n\t\t\thereChar _ aheadChar.\n\t\t\tsource atEnd\n\t\t\t\tifTrue: [aheadChar _ EndChar \"doit\"]\n\t\t\t\tifFalse: [aheadChar _ source next]].\n\t(type == #period and:\n\t\t\t[tokenType _ typeTable at: aheadChar asciiValue.\n\t\t\t(tokenType == #xLetter) | (tokenType == #xBinary)])\n\t\tifTrue:  \"Allow embedded period in selectors\"\n\t\t\t[buffer nextPut: self step.\n\t\t\tprefix _ buffer contents.\n\t\t\tself perform: tokenType.\n\t\t\ttoken _ prefix , token.\n\t\t\ttokenType == #binary ifTrue: [token _ token asSymbol].\n\t\t\t^self].\n\ttype == #colon\n\t\tifTrue:\n\t\t\t[buffer nextPut: self step.\n\t\t\ttokenType _ #keyword]\n\t\tifFalse:\n\t\t\t[tokenType _ #word].\n\ttoken _ buffer contents\n"
        },
        "expression types": {
          "scanLitVec": "scanLitVec\n\t| s |\n\ts _ WriteStream on: (Array new: 16).\n\t[tokenType = #rightParenthesis or: [tokenType = #doIt]]\n\t\twhileFalse:\n\t\t\t[tokenType = #leftParenthesis\n\t\t\t\tifTrue:\n\t\t\t\t\t[self scanToken; scanLitVec]\n\t\t\t\tifFalse:\n\t\t\t\t\t[tokenType = #word | (tokenType = #keyword)\n\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t[self scanLitWord]\n\t\t\t\t\t\tifFalse:\n\t\t\t\t\t\t\t[(token == #-\n\t\t\t\t\t\t\t\t\tand: [(typeTable at: hereChar asciiValue) = #xDigit])\n\t\t\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t\t\t[self scanToken.\n\t\t\t\t\t\t\t\t\ttoken _ token negated]]].\n\t\t\ts nextPut: token.\n\t\t\tself scanToken].\n\ttoken _ s contents\n",
          "scanLitWord": "scanLitWord\n\t\"accumulate keywords and asSymbol the result\"\n\n\t| t |\n\t[(typeTable at: hereChar asciiValue) = #xLetter]\n\t\twhileTrue:\n\t\t\t[t _ token.\n\t\t\tself xLetter.\n\t\t\ttoken _ t , token].\n\ttoken _ token asSymbol\n",
          "step": "step\n\t| c |\n\tc _ hereChar.\n\thereChar _ aheadChar.\n\t(aheadChar _ source next) == nil\n\t\tifTrue: [aheadChar _ EndChar \"doit\"].\n\t^c\n",
          "scanToken": "scanToken\n\t[(tokenType _ typeTable at: hereChar asciiValue) == #xDelimiter]\n\t\twhileTrue: [self step].  \"Skip delimiters fast, there almost always is one.\"\n\tmark _ source position - 1.\n\t(tokenType at: 1) = $x \"x as first letter\"\n\t\tifTrue: [self perform: tokenType \"means perform to compute token & type\"]\n\t\tifFalse: [token _ self step asSymbol \"else just unique the first char\"].\n\t^token\n"
        },
        "initialize-release": {
          "on:": "on: inputStream\n\t\"Bind the input stream, fill the character buffers\"\n\tsource _ inputStream.\n\tself step.\n\tself step\n",
          "initScanner": "initScanner\n\tbuffer _ WriteStream on: (String new: 40).\n\ttypeTable _ TypeTable\n",
          "scan:": "scan: inputStream\n\t\"Bind the input stream, fill the character buffers and first token buffer\"\n\tself on: inputStream.\n\tself scanToken\n"
        },
        "public access": {
          "scanTokens:": "scanTokens: textOrString\n\t\"Answer with an Array which has been tokenized as though the input text\n\thad appeared between #( and ) in a Smalltalk literal expression.\"\n\n\tself scan: (ReadStream on: textOrString asString).\n\tself scanLitVec.\n\t^token\n\n\t\"Scanner new scanTokens:\n\t\t\t'identifier keyword: 8r31 ''string'' embedded.period key:word: .   '     \"\n",
          "scanFieldNames:": "scanFieldNames: stringOrArray\n\t\"Answer with an Array of strings which are the identifiers in the input string.\n\tIf passed an Array, just answer with that Array (it has already been scanned).\"\n\t| strm |\n\t(stringOrArray isMemberOf: Array)\n\t\tifTrue: [^stringOrArray].\n\tself scan: (ReadStream on: stringOrArray asString).\n\tstrm _ WriteStream on: (Array new: 10).\n\t[tokenType = #doIt]\n\t\twhileFalse:\n\t\t\t[tokenType = #word ifTrue: [strm nextPut: token].\n\t\t\tself scanToken].\n\t^strm contents\n\n\t\"Scanner new scanFieldNames: 'abc  def ghi' ('abc' 'def' 'ghi' )\"\n"
        },
        "error handling": {
          "offEnd:": "offEnd: aString\n\t\"Parser overrides this\"\n\n\t^self notify: aString\n",
          "notify:": "notify: string\n\tself error: string\n"
        }
      }
    },
    "Compiler": {
      "comment": "The compiler accepts Smalltalk source code from sourceStream, and compiles it in the context of a given class.  The debugger supplies a context as well, so that temporary variables are accessible.  If there is an error, the requestor (usually a CodeController) is sent the message notify:at:in:.  If not, then the result of compilation is a parse tree (made up of subinstances of ParseNode) whose root is a MethodNode.  The parse tree can then generate code in a CompiledMethod (for compile or evaluate), or prettyPrint the code (for format), or produce a map from object code back to source code (used by debugger pc selection).  See also Parser, Encoder, ParseNode.\n",
      "class_name": "Compiler",
      "superclass": "Object",
      "instanceVariables": "sourceStream requestor class context",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "evaluating": {
          "evaluate:for:notifying:logged:": "evaluate: textOrString for: anObject notifying: aController logged: logFlag \t\"Compile and execute the supplied text (see message to instance for details).\n\tIf both were successful then, if logFlag is true, log (write) the text onto\n\tthe changes file so that it can be replayed if necessary.\"\n\t| val |\n\tval _ self new\n\t\t\t\tevaluate: textOrString\n\t\t\t\tin: nil\n\t\t\t\tto: anObject\n\t\t\t\tnotifying: aController\n\t\t\t\tifFail: [^nil].\n\tlogFlag ifTrue: [Smalltalk logChange: textOrString].\n\t^val\n",
          "evaluate:": "evaluate: textOrString\n\t^self evaluate: textOrString for: nil logged: false\n",
          "evaluate:notifying:logged:": "evaluate: textOrString notifying: aController logged: logFlag\n\t^self evaluate: textOrString for: nil notifying: aController logged: logFlag\n",
          "evaluate:logged:": "evaluate: textOrString logged: logFlag\n\t^self evaluate: textOrString for: nil logged: logFlag\n",
          "evaluate:for:logged:": "evaluate: textOrString for: anObject logged: logFlag\n\t^ self evaluate: textOrString for: anObject notifying: nil logged: logFlag\n"
        },
        "accessing": {
          "preferredParserClass": "preferredParserClass\n\t\"Return a parser class which is appropriate for parsing methods compilable\n\t by this compiler class.  Should be overwritten by subclasses.\"\n\n\t^Parser\n"
        }
      },
      "instance_methods": {
        "private": {
          "format:noPattern:ifFail:": "format: aStream noPattern: noPattern ifFail: failBlock\n\t| tree |\n\ttree _\n\t\tclass parserClass new\n\t\t\tparse: aStream\n\t\t\tclass: class\n\t\t\tnoPattern: noPattern\n\t\t\tcontext: context\n\t\t\tnotifying: self\n\t\t\tifFail: [^failBlock value].\n\t^tree\n",
          "from:class:context:notifying:": "from: textOrStream class: aClass context: aContext notifying: req\n\t(textOrStream isKindOf: PositionableStream)\n\t\tifTrue: [sourceStream _ textOrStream]\n\t\tifFalse: [sourceStream _ ReadStream on: textOrStream asString].\n\tclass _ aClass.\n\tcontext _ aContext.\n\trequestor _ req\n",
          "translate:noPattern:ifFail:": "translate: aStream noPattern: noPattern ifFail: failBlock\n\t| tree |\n\ttree _\n\t\tclass parserClass new\n\t\t\tparse: aStream\n\t\t\tclass: class\n\t\t\tnoPattern: noPattern\n\t\t\tcontext: context\n\t\t\tnotifying: self\n\t\t\tifFail: [^failBlock value].\n\t^tree\n"
        },
        "public access": {
          "compile:in:notifying:ifFail:": "compile: textOrStream in: aClass notifying: aRequestor ifFail: failBlock\n\t\"Answer with a parse tree whose root is a MethodNode.\n\tThis can then be told to generate code as is done in the calls from Behavior\"\n\tself from: textOrStream\n\t\tclass: aClass\n\t\tcontext: nil\n\t\tnotifying: aRequestor.\n\t^self\n\t\ttranslate: sourceStream\n\t\tnoPattern: false\n\t\tifFail: failBlock\n",
          "evaluate:in:to:notifying:ifFail:": "evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock\n\t\"Compiles the sourceStream into a parse tree, then generates code into a method.\n\tThis method is then installed in the receiver's class so that it can be invoked.\n\tIn other words, if receiver is not nil, then the text can refer to instance variables\n\tof that receiver (the Inspector uses this).  If aContext is not nil, the text can refer to\n\ttemporaries in that context (the Debugger uses this).  If aRequestor is not nil, then\n\tit will receive a notify:at: message before the attempt to evaluate is aborted.\n\n\tFinally, the compiled method is invoked from here as DoIt or\n\t(in the case of evaluation in aContext) DoItIn:.\n\n\tThe method is subsequently removed from the class, but this will not get done\n\tif the invocation causes an error which is terminated.  Such garbage can be\n\tremoved by executing:\n\t\tSmalltalk allBehaviorsDo:\n\t\t\t[:cl | cl removeSelector: #DoIt; removeSelector: #DoItIn:].\"\n\n\t| methodNode method value |\n\tCursor execute show.\n\tclass _ (aContext == nil ifTrue: [receiver] ifFalse: [aContext receiver]) class.\n\tself from: textOrStream class: class context: aContext notifying: aRequestor.\n\tmethodNode _ self translate: sourceStream noPattern: true ifFail:\n\t\t[^failBlock value].\n\tmethod _ methodNode generate: #(0 0 0).\n\tcontext == nil\n\t\t\tifTrue: [class addSelector: #DoIt withMethod: method.\n\t\t\t\t\tvalue _ receiver DoIt.\n\t\t\t\t\tclass removeSelectorSimply: #DoIt.\n\t\t\t\t\tCursor normal show.\n\t\t\t\t\t^value]\n\t\t\tifFalse: [class addSelector: #DoItIn: withMethod: method.\n\t\t\t\t\tvalue _ receiver DoItIn: context.\n\t\t\t\t\tclass removeSelectorSimply: #DoItIn:.\n\t\t\t\t\tCursor normal show.\n\t\t\t\t\t^value]\n",
          "format:in:notifying:": "format: textOrStream in: aClass notifying: aRequestor\n\t\"Compile a parse tree from the incoming text, and then print the parse tree to yield the answer, a string containing the original code in standard format.\"\n\n\t| aNode |\n\tself from: textOrStream\n\t\tclass: aClass\n\t\tcontext: nil\n\t\tnotifying: aRequestor.\n\taNode _ self format: sourceStream noPattern: false ifFail: [^nil].\n\t^aNode decompileString\n",
          "parse:in:notifying:": "parse: textOrStream in: aClass notifying: req\n\t\"Compile the incoming text and answer with the resulting parse tree.\"\n\tself from: textOrStream class: aClass context: nil notifying: req.\n\t^self translate: sourceStream noPattern: false ifFail: []\n"
        },
        "error handling": {
          "editor": "editor\n\t^ requestor\n",
          "notify:at:": "notify: aString at: position\n\tCursor normal show.\n\trequestor == nil\n\t\tifTrue: [^SyntaxError\n\t\t\t\t\terrorInClass: class\n\t\t\t\t\twithCode:\n\t\t\t\t\t\t(sourceStream contents\n\t\t\t\t\t\t\tcopyReplaceFrom: position\n\t\t\t\t\t\t\tto: position - 1\n\t\t\t\t\t\t\twith: aString)\n\t\t\t\t\terrorString: aString]\n\t\tifFalse: [^ requestor insertAndSelect: aString at: (position max: 1)]\n"
        }
      }
    },
    "MethodNode": {
      "comment": "I am the root of the parse tree.\n",
      "class_name": "MethodNode",
      "superclass": "ParseNode",
      "instanceVariables": "selectorOrFalse precedence arguments block literals primitive encoder temporaries",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "printing": {
          "tempNames": "tempNames\n\t^encoder tempNames\n",
          "printOn:": "printOn: aStream\n\t| s args |\n\tprecedence = 1\n\t\tifTrue:\n\t\t\t[aStream nextPutAll: self selector]\n\t\tifFalse:\n\t\t\t[args _ ReadStream on: arguments.\n\t\t\tself selector keywords do:\n\t\t\t\t[:s |\n\t\t\t\taStream nextPutAll: s.\n\t\t\t\taStream space; nextPutAll: args next key.\n\t\t\t\taStream space]].\n\tcomment == nil\n\t\tifFalse:\n\t\t\t[aStream crtab: 1.\n\t\t\tself printCommentOn: aStream indent: 1.\n\t\t\taStream cr].\n\ttemporaries size > 0\n\t\tifTrue:\n\t\t\t[aStream crtab: 1.\n\t\t\taStream nextPutAll: '| '.\n\t\t\ttemporaries do:\n\t\t\t\t[:s | aStream nextPutAll: s key. aStream space].\n\t\t\taStream nextPut: $|].\n\tprimitive > 0\n\t\tifTrue:\n\t\t\t[aStream crtab: 1.\n\t\t\taStream nextPutAll: '<primitive: '; print: primitive; nextPutAll: '>'].\n\taStream crtab: 1.\n\t^block printStatementsOn: aStream indent: 1\n"
        },
        "code generation": {
          "generate:": "generate: trailer\n\t\"I am the root of a parse tree; answer with an instance of CompiledMethod.\"\n\t| blkSize method nLits lit stack strm nArgs i |\n\tself generateIfQuick:\n\t\t[:method |\n\t\t1 to: 3 do: [:i | method at: method size - 3 + i put: (trailer at: i)].\n\t\tmethod cacheTempNames: self tempNames.\n\t\t^method].\n\tnArgs _ arguments size.\n\tblkSize _ block sizeForEvaluatedValue: encoder.\n\tliterals _ encoder literals: primitive nArgs: nArgs.\n\tencoder maxTemp > 31\n\t\tifTrue: [^self error: 'Too many temporary variables'].\n\t(nLits _ literals size) > 63\n\t\tifTrue: [^self error: 'Too many literals referenced'].\n\tmethod _ CompiledMethod\t\"Dummy to allocate right size\"\n\t\t\t\tnewBytes: blkSize\n\t\t\t\tflags: ((nArgs <= 4 and: [primitive = 0]) ifTrue: [nArgs] ifFalse: [7])\n\t\t\t\tnTemps: encoder maxTemp\n\t\t\t\tnStack: 0\n\t\t\t\tnLits: nLits.\n\tstrm _ ReadWriteStream with: method.\n\tstrm position: method initialPC - 1.\n\tstack _ ParseStack new init.\n\tblock emitForEvaluatedValue: stack on: strm.\n\tstack position ~= 1 ifTrue: [^self error: 'Compiler stack discrepancy'].\n\tstrm position ~= (method size - 3)\n\t\tifTrue: [^self error: 'Compiler code size discrepancy'].\n\t1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].\n\tmethod needsStack: stack size encoder: encoder.\n\t1 to: 3 do: [:i | method at: method size - 3 + i put: (trailer at: i)].\n\tmethod cacheTempNames: self tempNames.\n\t^method\n",
          "sourceMap": "sourceMap\n\t\"I am the root of a parse tree; answer with a sorted collection of associations\n\tof the form: pc (byte offset in me) -> sourceRange (an Interval) in source text.\n\tBecause the number of my literals may grow during generation and therefore\n\tthe pc's may be off, I must pass my generated number of literals to the encoder.\"\n\t| numLits |\n\tnumLits _ (self generate: #(0 0 0 )) numLiterals.\n\t^encoder sourceMap: numLits\n",
          "generateNoQuick": "generateNoQuick\n\t\"Assumes would have been quick.  Forces numArgs > 0 so will compile real code.\n\tThe debugger needs this to look simulate a quick return\"\n\n\targuments _ Array new: 1.\n\t^ self generate: #(0 0 0)\n",
          "selector": "selector\n\t(selectorOrFalse isMemberOf: Symbol)\n\t\tifTrue: [^selectorOrFalse].\n\t^selectorOrFalse key\n",
          "generateIfQuick:": "generateIfQuick: methodBlock\n\t| v |\n\t(primitive = 0 and: [arguments size = 0 and: [block isQuick]])\n\t\tifTrue:\n\t\t\t[v _ block code.\n\t\t\tv < 0\n\t\t\t\tifTrue: [^self].\n\t\t\tv = LdSelf\n\t\t\t\tifTrue: [^methodBlock value: CompiledMethod toReturnSelf].\n\t\t\tv < ((CodeBases at: LdInstType) + (CodeLimits at: LdInstType))\n\t\t\t\tifTrue: [^methodBlock value: (CompiledMethod toReturnField: v)].\n\t\t\t(v // 256 = 1 and: [v \\\\ 256 < 32])\n\t\t\t\tifTrue:\n\t\t\t\t\t[^methodBlock value: (CompiledMethod toReturnField: v \\\\ 256)]]\n"
        },
        "initialize-release": {
          "selector:arguments:precedence:temporaries:block:encoder:primitive:": "selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim\n\tencoder _ anEncoder.\n\tselectorOrFalse _ selOrFalse.\n\tprecedence _ p.\n\targuments _ args.\n\ttemporaries _ temps.\n\tblock _ blk.\n\tprimitive _ prim\n"
        },
        "converting": {
          "decompileString": "decompileString\n\t| aStream |\n\taStream _ WriteStream on: (String new: 1000).\n\tself printOn: aStream.\n\t^aStream contents\n"
        }
      }
    },
    "CascadeNode": {
      "comment": "The first message has the common receiver, the rest have receiver == nil, which signifies cascading.\n",
      "class_name": "CascadeNode",
      "superclass": "ParseNode",
      "instanceVariables": "receiver messages",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "instance_methods": {
        "printing": {
          "printOn:indent:": "printOn: aStream indent: level\n\treceiver printOn: aStream indent: level precedence: 0.\n\t1 to: messages size do:\n\t\t[:i |\n\t\t(messages at: i) printOn: aStream indent: level.\n\t\ti < messages size ifTrue: [aStream nextPut: $;]]\n"
        },
        "code generation": {
          "sizeForValue:": "sizeForValue: encoder\n\t| size |\n\tsize _ (receiver sizeForValue: encoder) + (messages size - 1 * 2).\n\tmessages do: [:aMessage | size _ size + (aMessage sizeForValue: encoder)].\n\t^size\n",
          "emitForValue:on:": "emitForValue: stack on: aStream\n\treceiver emitForValue: stack on: aStream.\n\t1 to: messages size - 1 do:\n\t\t[:i |\n\t\taStream nextPut: Dup.\n\t\tstack push: 1.\n\t\t(messages at: i) emitForValue: stack on: aStream.\n\t\taStream nextPut: Pop.\n\t\tstack pop: 1].\n\tmessages last emitForValue: stack on: aStream\n"
        },
        "initialize-release": {
          "receiver:messages:": "receiver: receivingObject messages: msgs\n\t\"user show: 'abc'; tab; show: 'abc'; cr\"\n\n\treceiver _ receivingObject.\n\tmessages _ msgs\n"
        }
      }
    }
  },
  "System-Releasing": {
    "Checker": {
      "comment": "I contain a collection of checks to run for system consistency.\n",
      "class_name": "Checker",
      "superclass": "Object",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "browsing": {
          "browseAllUnimplementedCalls": "browseAllUnimplementedCalls\n\t\"Create and schedule a message browser on each method that includes a message\n\tthat is not implemented in any object in the system.\n\t\tSmalltalk browseAllUnimplementedCalls \"\n\n\tBrowserView\n\t\topenListBrowserOn: self allUnimplementedCalls\n\t\tlabel: 'Unimplemented calls'\n"
        },
        "static checks": {
          "checkOrganizations": "checkOrganizations\n\t\"Check for organization/messagedict inconsistencies.  Print the result in the\n\tSystem Transcript.\n\n\tSmalltalk checkOrganizations.\n\tSmalltalk allClassesDo:\n\t\t\t[:cl | cl removeSelector: #DoIt; removeSelector: #DoItIn:]. \"\n\n\t| className class cat sel set |\n\tSmalltalk classNames do:\n\t\t[:className |\n\t\t(Array with: (Smalltalk at: className) with: (Smalltalk at: className) class) do:\n\t\t\t[:class |\n\t\t\tset _ Set new.\n\t\t\tclass organization categories do:\n\t\t\t\t[:cat | (class organization listAtCategoryNamed: cat) do:\n\t\t\t\t\t\t[:sel |\n\t\t\t\t\t\t(set includes: sel)\n\t\t\t\t\t\t\tifTrue: [Transcript show: class name , ' multiple: ' , sel; cr].\n\t\t\t\t\t\tset add: sel]].\n\t\t\tclass selectors do:\n\t\t\t\t[:sel | (set includes: sel)\n\t\t\t\t\tifTrue: [set remove: sel]\n\t\t\t\t\tifFalse: [Transcript show: class name , ' missing: ' , sel; cr]].\n\t\t\t\tset do: [:sel | Transcript show: class name , ' spurious: ' , sel; cr]]].\n\tTranscript show: 'Done checking.'; cr\n",
          "obsoleteClassReferences": "obsoleteClassReferences\n\t\"Answer a collection of all the methods that reference obsolete classes.\"\n\n\t| methods |\n\tmethods _ SortedCollection new.\n\tself obsoleteAssociations do: [:assoc | methods addAll: (self allCallsOn: assoc)].\n\t^methods\n\n\t\"BrowserView\n\t\topenListBrowserOn: Smalltalk obsoleteClassReferences\n\t\tlabel: 'References to Obsolete Classes' \"\n",
          "allUnimplementedCalls": "allUnimplementedCalls\n\t\"Answer an Array of each message that is sent by an expression in a method\n\tbut is not implemented by any object in the system.\"\n\n\t| aStream secondStream all  |\n\tall _ self allImplementedMessages.\n\taStream _ WriteStream on: (Array new: 50).\n\tCursor execute showWhile:\n\t\t[self allBehaviorsDo:\n\t\t\t[:cl |\n\t\t\t cl selectors do:\n\t\t\t\t[:sel |\n\t\t\t\t secondStream _ WriteStream on: (String new: 5).\n\t\t\t\t(cl compiledMethodAt: sel) messages do:\n\t\t\t\t\t[:m | (all includes: m) ifFalse: [secondStream nextPutAll: m; space]].\n\t\t\t\tsecondStream position = 0 ifFalse:\n\t\t\t\t\t[aStream nextPut: cl name , ' ' , sel , ' calls: ', secondStream contents]]]].\n\t^aStream contents\n",
          "browseAllNonAsciiMessages": "browseAllNonAsciiMessages\n\t\"Bring up a Message Set Window with methods containing bad characters\"\n\n\t| char cr ff tab aStream badCharacter |\n\tcr _ Character cr asciiValue.\n\tff _ Character newPage asciiValue.\n\ttab _ Character tab asciiValue.\n\tSmalltalk\n\t\tbrowseAllSelect:\n\t\t\t[:method |\n\t\t\tbadCharacter _ false.\n\t\t\taStream _ ReadStream on: method getSource.\n\t\t\t[aStream atEnd or: [badCharacter]]\n\t\t\t\twhileFalse:\n\t\t\t\t\t[char _ aStream next asciiValue.\n\t\t\t\t\t(char > 127\n\t\t\t\t\t\tor: [char < 32\n\t\t\t\t\t\t\t\tand: [char ~= cr & (char ~= ff) & (char ~= tab)]])\n\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t[Transcript show: '*'.\n\t\t\t\t\t\t\tbadCharacter _ true]].\n\t\t\tbadCharacter]\n\t\"Smalltalk browseAllNonAsciiMessages.\"\n",
          "onlyReturnSelves": "onlyReturnSelves\n\t\"Return message names for messages that are ^self only (i.e. no implementation)\n\tSmalltalk onlyReturnSelves.\"\n\n\t| aStream |\n\taStream _ WriteStream on: (Array new: 50).\n\tSmalltalk allBehaviorsDo:\n\t\t[:class |\n\t\tclass selectors do:\n\t\t\t[:selector |\n\t\t\t(class compiledMethodAt: selector) isReturnSelf\n\t\t\t\tifTrue: [aStream nextPut: class name, ' ', selector]]].\n\t^aStream contents\n",
          "obsoleteClasses": "obsoleteClasses\n\t\"Return a collection of all obsolete classes.\n\tSmalltalk obsoleteClasses \"\n\n\t^(Metaclass allInstances select: [:metaclass | metaclass isObsolete])\n\t\tcollect: [:metaclass | metaclass someInstance]\n",
          "obsoleteInstanceCounts": "obsoleteInstanceCounts\n\t\"Compute the number of instances of each obsolete class.\n\tSmalltalk obsoleteInstanceCounts \"\n\n\t| obsolete count |\n\tobsolete _ Dictionary new.\n\tself obsoleteClasses do:\n\t\t[:class |\n\t\tcount _ class instanceCount.\n\t\tcount > 0 ifTrue: [obsolete at: class put: count]].\n\t^obsolete\n",
          "whichClassesHaveCategory:": "whichClassesHaveCategory: categoryName\n\t\"Return the names of all the classes with the category.\n\tSmalltalk whichClassesHaveCategory: 'accessing'.\"\n\n\t| aStream |\n\taStream _ WriteStream on: (Array new: 500).\n\tSmalltalk allBehaviorsDo:\n\t\t[:class |\n\t\t(class organization categories includes: categoryName asSymbol)\n\t\t\tifTrue: [aStream nextPut: class name]].\n\t^aStream contents asSortedCollection\n",
          "unaryCategoryNames": "unaryCategoryNames\n\t\"Return the names of all the categories with only one message in them\"\n\n\t| aSet |\n\taSet _ Set new: 1000.\n\tSmalltalk allBehaviorsDo:\n\t\t[:class | class organization categories do:\n\t\t\t[:catName |\n\t\t\t(class organization listAtCategoryNamed: catName) size = 1\n\t\t\t\tifTrue: [aSet add: class name, ' >> ',  catName]]].\n\t^aSet asSortedCollection\n",
          "findSharedPoolVariables": "findSharedPoolVariables\n\t\"Smalltalk findSharedPoolVariables.\"\n\n\t| aSet duplicates |\n\tduplicates _ OrderedCollection new.\n\tSmalltalk allClassesDo:\n\t[:class |\n\tclass subclasses isEmpty\n\t\tifTrue:\n\t\t\t[aSet _ Set new.\n\t\t\tclass allSharedPools do:\n\t\t\t\t[:pool |\n\t\t\t\tpool keys do:\n\t\t\t\t\t[:key |\n\t\t\t\t\t(aSet includes: key)\n\t\t\t\t\t\tifTrue: [duplicates add: (Association key: key value: class)].\n\t\t\t\t\taSet add: key]]]].\n\t^duplicates\n",
          "allCategoryNames": "allCategoryNames\n\t\"Answer a SortedCollection of the names of all the categories (sorted alphabetically).\"\n\n\t| aSet |\n\taSet _ Set new: 1000.\n\tSmalltalk allBehaviorsDo:\n\t\t[:class | class organization categories do: [:catName | aSet add: catName]].\n\t^aSet asSortedCollection\n",
          "unResponsives": "unResponsives\n\t\"Smalltalk unResponsives\"\n\n\t| aStream aCollection satisfiedSet workingSet aSubclass special |\n\taStream _ WriteStream on: (Array new: 50).\n\tspecial _ self hasSpecialSelector: #subclassResponsibility ifTrueSetByte: [:byte ].\n\tSmalltalk allBehaviorsDo:\n\t\t[:class |\n\t\taCollection _ class whichSelectorsReferTo: #subclassResponsibility special: special byte: byte.\n\t\taCollection size > 0\n\t\t\tifTrue:\n\t\t\t\t[aCollection do:\n\t\t\t\t\t[:selector |\n\t\t\t\t\tworkingSet _ class subclasses asOrderedCollection.\n\t\t\t\t\tsatisfiedSet _ Set new.\n\t\t\t\t\t[workingSet isEmpty] whileFalse:\n\t\t\t\t\t\t[aSubclass _ workingSet removeFirst.\n\t\t\t\t\t\t(aSubclass includesSelector: selector)\n\t\t\t\t\t\t\tifFalse:\n\t\t\t\t\t\t\t\t[satisfiedSet add: aSubclass.\n\t\t\t\t\t\t\t\tworkingSet addAll: aSubclass subclasses]].\n\t\t\t\t\t satisfiedSet do:\n\t\t\t\t\t\t[:subclass |\n\t\t\t\t\t\taStream nextPut: class name, ' ', selector, '\n\t', subclass name]]]].\n\t^aStream contents\n",
          "categoriesSelect:": "categoriesSelect: aBlock\n\t\"Smalltalk categoriesSelect: [:catName | catName first = $A]\"\n\n\t| aDictionary aStream |\n\taDictionary _ IdentityDictionary new: 512.\n\taStream _ WriteStream on: (Array new: 500).\n\tSmalltalk allBehaviorsDo:\n\t\t[:class | class organization categories do:\n\t\t\t[:catName |\n\t\t\t(aBlock value: catName)\n\t\t\t\tifTrue: [aStream nextPut: class name, ' >> ',catName]]].\n\t^aStream contents asSortedCollection\n",
          "findAllNonAsciiSources": "findAllNonAsciiSources\n\t\"Collect chunks from the source files containing bad characters\"\n\n\t| char cr ff tab aStream badCharacter aFileStream aChunk badStream|\n\tcr _ Character cr asciiValue.\n\tff _ Character newPage asciiValue.\n\ttab _ Character tab asciiValue.\n\tbadStream _ WriteStream on: (Array new: 10).\n\tCursor execute show.\n\t1 to: 2 do:\n\t\t[:i |\n\t\taFileStream _ (SourceFiles at: i) copy.\n\t\taFileStream reset.\n\t\t[aFileStream atEnd]\n\t\t\twhileFalse:\n\t\t\t\t[aChunk _ aFileStream nextChunk.\n\t\t\t\taStream _ ReadStream on: aChunk.\n\t\t\t\tbadCharacter _ false.\n\t\t\t\t[aStream atEnd or: [badCharacter]]\n\t\t\t\twhileFalse:\n\t\t\t\t\t[char _ aStream next asciiValue.\n\t\t\t\t\t(char > 127\n\t\t\t\t\t\tor: [char < 32\n\t\t\t\t\t\t\tand: [char ~= cr & (char ~= ff) & (char ~= tab)]])\n\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t[Transcript show: '*'.\n\t\t\t\t\t\tbadCharacter _ true]].\n\t\t\t\tbadCharacter ifTrue: [badStream nextPut: aChunk]].\n\t\taFileStream close].\n\tCursor normal show.\n\t^badStream contents\n\t\"Smalltalk findAllNonAsciiSources inspect.\"\n",
          "instanceCountsAndSpaceDo:": "instanceCountsAndSpaceDo: aBlock\n\t\"Evaluate aBlock value: class value: instanceCount value: totalSpace\n\tfor every class in the system.\"\n\n\t| nwords isBytes n |\n\tSmalltalk\n\t\tallClassesDo:\n\t\t\t[:class |\n\t\t\tnwords _ 0.\n\t\t\tclass isVariable\n\t\t\t\tifTrue:\n\t\t\t\t\t[n _ 0.\n\t\t\t\t\tisBytes _ class isBytes.\n\t\t\t\t\tclass\n\t\t\t\t\t\tallInstancesDo:\n\t\t\t\t\t\t\t[:inst |\n\t\t\t\t\t\t\tn _ n + 1.\n\t\t\t\t\t\t\tnwords _ nwords + (isBytes\n\t\t\t\t\t\t\t\t\t\t\tifTrue: [inst basicSize + 1 // 2]\n\t\t\t\t\t\t\t\t\t\t\tifFalse: [inst basicSize])]]\n\t\t\t\tifFalse: [n _ class instanceCount].\n\t\t\tnwords _ nwords + (class instSize + 2 * n).  \"+2 for header\"\n\t\t\taBlock\n\t\t\t\tvalue: class\n\t\t\t\tvalue: n\n\t\t\t\tvalue: nwords]\n",
          "obsoleteAssociations": "obsoleteAssociations\n\t\"Return a collection of all associations containing obsolete classes.\n\tSmalltalk obsoleteAssociations \"\n\n\t| class |\n\t^Association allInstances select:\n\t\t[:assoc |\n\t\tclass _ assoc value class.\n\t\tclass isMeta and: [class isObsolete]]\n",
          "allUnSentMessages": "allUnSentMessages\n\t\"Answer an Array of each message that is implemented by some object in the\n\tsystem but is not sent by any.\"\n\n\n\t| all anArray |\n\tall _ self allImplementedMessages.\n\tanArray _ Array new: 0.\n\tCursor execute\n\t\tshowWhile:\n\t\t\t[self allBehaviorsDo:\n\t\t\t\t[:cl |\n\t\t\t\t cl selectors do:\n\t\t\t\t\t[:sel |\n\t\t\t\t\t(cl compiledMethodAt: sel) literals do:\n\t\t\t\t\t\t[:m | all remove: m ifAbsent: []]]].\n\t\t\t1 to: self specialSelectorSize do:\n\t\t\t\t[:index |\n\t\t\t\tall remove: (self specialSelectorAt: index) ifAbsent: []].\n\t\t\tTranscript show: all size printString.\n\t\t\tall do: [:sel | anArray _ anArray , (self allImplementorsOf: sel)]].\n\t^anArray\n",
          "removeEmptyCategories": "removeEmptyCategories\n\t\"Remove all empty class and method categories.\n\tSmalltalk removeEmptyCategories \"\n\n\tSystemOrganization removeEmptyCategories.\n\tClassOrganizer allInstancesDo: [:organizer | organizer removeEmptyCategories].\n",
          "whichClassesIncludeCategory:": "whichClassesIncludeCategory: categoryName\n\t\"Answer an Array of each class that includes the name, categoryName, as\n\tone of its message categories.\"\n\n\t| aStream cat |\n\taStream _ WriteStream on: (Array new: 10).\n\tcat _ categoryName asSymbol.\n\tself allClassesDo:\n\t\t[:class |\n\t\t(class organization categories includes: cat)\n\t\t\tifTrue: [aStream nextPut: class].\n\t\t(class class organization categories includes: cat)\n\t\t\tifTrue: [aStream nextPut: class class]].\n\t^aStream contents\n\n\t\"Smalltalk whichClassesIncludeCategory: #comparison.\"\n",
          "singleClassCategoryNames": "singleClassCategoryNames\n\t\"Return the names of all the categories defined in only one class, alphabetic\n\tSmalltalk singleClassCategoryNames.\"\n\n\t| aDictionary aStream |\n\taDictionary _ IdentityDictionary new: 512.\n\tSmalltalk allBehaviorsDo:\n\t\t[:class | class organization categories do:\n\t\t\t[:catName |\n\t\t\t(aDictionary includesKey: catName)\n\t\t\t\tifTrue: [(aDictionary at: catName) = nil\n\t\t\t\t\t\t\tifFalse: [aDictionary at: catName put: nil]]\n\t\t\t\tifFalse: [aDictionary at: catName put: class name]]].\n\taStream _ WriteStream on: (Array new: 500).\n\taDictionary associationsDo:\n\t\t[:assn |\n\t\tassn value == nil\n\t\t\tifFalse: [aStream nextPut: assn value, ' >> ',assn key]].\n\t^aStream contents asSortedCollection\n",
          "multipleCategoryMessageNames": "multipleCategoryMessageNames\n\t\"Return the names of all the messages defined in more then one category,\n\talong with the category names.\"\n\n\t| aDictionary class catName selector |\n\taDictionary _ IdentityDictionary new: 1024.\n\tSmalltalk allBehaviorsDo:\n\t\t[:class |\n\t\tclass organization categories do:\n\t\t\t[:catName |\n\t\t\t(class organization listAtCategoryNamed: catName) do:\n\t\t\t\t[:selector |\n\t\t\t\t(aDictionary includesKey: selector)\n\t\t\t\t\tifTrue:\n\t\t\t\t\t\t[(aDictionary at: selector) add: catName]\n\t\t\t\t\tifFalse: [aDictionary\n\t\t\t\t\t\t\t\tat: selector\n\t\t\t\t\t\t\t\tput: (Set with: catName)]]]].\n\t^aDictionary keys select: [:selector | (aDictionary at: selector) size > 1]\n",
          "rehashBadSets": "rehashBadSets\n\t\"Checker rehashBadSets\"\n\n\t| badSets checkSet |\n\tbadSets _ Set new.\n\tcheckSet _ [:set |\n\t\t(set isKindOf: Dictionary)\n\t\t\tifTrue: [set keysDo:\n\t\t\t\t[:x | (set includesKey: x) ifFalse: [badSets add: set]]]\n\t\t\tifFalse: [set do:\n\t\t\t\t[:x | (set includes: x) ifFalse: [badSets add: set]]]].\n\n\tSet allInstances do: checkSet.\n\tSet allSubInstancesDo: checkSet.\n\tbadSets do: [:bad | bad rehash].\n\tTranscript cr; print: badSets size; show: ' bad sets/dictionaries rehashed'.\n\t^badSets\n",
          "instanceVariablesNotReferenced": "instanceVariablesNotReferenced\n\t\"Return a list of classes and instance variables defined in, but not used in that class\n\tSmalltalk instanceVariablesNotReferenced\"\n\n\t| aStream |\n\taStream _ WriteStream on: (Array new: 50).\n\tSmalltalk allBehaviorsDo:\n\t\t[:class |\n\t\tclass instVarNames do:\n\t\t\t[:instVarName |\n\t\t\t(class whichSelectorsAccess: instVarName) size = 0\n\t\t\t\tifTrue: [aStream nextPut: class name, ' ', instVarName]]].\n\t^aStream contents\n"
        },
        "printing checks": {
          "printMultipleCategoryMessageNamesOn:": "printMultipleCategoryMessageNamesOn: aFileStream\n\t\"Print the names of all the messages defined in more than one category.\"\n\n\t| aCollection |\n\taCollection _ self multipleCategoryMessageNames asSortedCollection.\n\taCollection do:\n\t\t[:selector |\n\t\taFileStream cr; nextPutAll: selector.\n\t\tSmalltalk allBehaviorsDo:\n\t\t\t[:class |\n\t\t\t(class includesSelector: selector)\n\t\t\t\tifTrue:\n\t\t\t\t\t[ aFileStream crtab: 1; nextPutAll: class name.\n\t\t\t\t\taFileStream nextPutAll: '>'.\n\t\t\t\t\taFileStream\n\t\t\t\t\t\tnextPutAll: (class whichCategoryIncludesSelector: selector)]]].\n\taFileStream close\n\t\"Checker printMultipleCategoryMessageNamesOn:\n\t\t(Disk file: 'Smalltalk.multcats').\"\n",
          "printAllMessagesOn:": "printAllMessagesOn: aFileStream\n\t\"Smalltalks printAllMessagesOn: (Disk file: 'smalltalk.allMessages').\"\n\n\t| class selectorStream |\n\tselectorStream _ WriteStream on: (String new: 100).\n\tSystemOrganization categories do:\n\t\t[:sysCat |\n\t\tTranscript show: sysCat; cr.\n\t\t\"form feed between categories of classes\"\n\t\taFileStream nextPut: 12 asCharacter; cr; nextPutAll: sysCat.\n\t\t(SystemOrganization listAtCategoryNamed: sysCat) do:\n\t\t\t[:className |\n\t\t\tclass _ self at: className.\n\t\t\taFileStream crtab: 1; nextPutAll: className.\n\t\t\tclass organization categories do:\n\t\t\t\t[:classCat |\n\t\t\t\taFileStream crtab: 2; nextPutAll: classCat; crtab: 3.\n\t\t\t\tselectorStream reset.\n\t\t\t\t(class organization listAtCategoryNamed: classCat) do:\n\t\t\t\t\t[:selector |\n\t\t\t\t\t(selectorStream position + selector size) > 70\n\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t[aFileStream nextPutAll: selectorStream contents.\n\t\t\t\t\t\t\taFileStream crtab: 4.\n\t\t\t\t\t\t\tselectorStream reset].\n\t\t\t\t\tselectorStream space; nextPutAll: selector.\n\t\t\t\t\taFileStream nextPutAll: selectorStream contents.]].\n\t\t\taFileStream crtab: 1; nextPutAll: class class name.\n\t\t\tclass class organization categories\n\t\t\t  do:\n\t\t\t\t[:classCat |\n\t\t\t\taFileStream crtab: 2; nextPutAll: classCat; crtab: 3.\n\t\t\t\tselectorStream reset.\n\t\t\t\t(class class organization listAtCategoryNamed: classCat) do:\n\t\t\t\t\t[:selector |\n\t\t\t\t\t(selectorStream position + selector size) > 70\n\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t[aFileStream nextPutAll: selectorStream contents.\n\t\t\t\t\t\t\taFileStream crtab: 4.\n\t\t\t\t\t\t\tselectorStream reset].\n\t\t\t\t\tselectorStream space; nextPutAll: selector.\n\t\t\t\t\taFileStream nextPutAll: selectorStream contents.]].\n\t\t\t]\n\t\t].\n\taFileStream close.\n",
          "printReceivedButNotSentOn:": "printReceivedButNotSentOn: aFileStream\n\t\"Print a list of messages implemented but not sent anywhere (could be sent\n\tby performs).\n\n\tSmalltalk printReceivedButNotSentOn: (Disk file: 'smalltalk.receivedButNotSent')\"\n\n\tself allUnSentMessages do:\n\t\t[:aString | aFileStream nextPutAll: aString; cr].\n\taFileStream close\n",
          "printUnaryCategoryNamesOn:": "printUnaryCategoryNamesOn: aFileStream\n\t\"Print the names of all the categories with only one message.\n\n\tSmalltalk printUnaryCategoryNamesOn: (Disk file: 'Smalltalk.unaries').\"\n\n\tself unaryCategoryNames do:\n\t\t[:catName | aFileStream nextPutAll: catName; cr].\n\taFileStream close\n",
          "printCategoryNamesOn:": "printCategoryNamesOn: aFileStream\n\t\"Print the names of all the categories, alphabetically, in the file aFileStream.\"\n\n\tself allCategoryNames do: [:catName | aFileStream nextPutAll: catName; cr].\n\taFileStream close\n\t\"Smalltalk printCategoryNamesOn: (Disk file: 'Smalltalk.categories').\"\n",
          "printSentButNotReceivedOn:": "printSentButNotReceivedOn: aFileStream\n\t\"Print a list of messages sent but not implemented anywhere.\n\n\tSmalltalk printSentButNotReceivedOn:\n\t\t(Disk file: 'smalltalk.sentButNotReceived') \"\n\n\tself allUnimplementedCalls do: [:aString | aFileStream nextPutAll: aString; cr].\n\taFileStream close\n",
          "printSingleClassCategoryNamesOn:": "printSingleClassCategoryNamesOn: aFileStream\n\t\"Print the names of all the categories defined in only one class.\n\n\tSmalltalk printSingleClassCategoryNamesOn:\n\t\t(Disk file: 'Smalltalk.singles'). \"\n\n\tself singleClassCategoryNames do: [:catName | aFileStream nextPutAll: catName; cr].\n\taFileStream close\n",
          "printOnlyReturnSelvesOn:": "printOnlyReturnSelvesOn: aFileStream\n\t\"Print a list of messages that are only ^self (unimplemented).\n\n\tSmalltalk printOnlyReturnSelvesOn:\n\t\t(Disk file: 'smalltalk.unimplementeds') \"\n\n\tself onlyReturnSelves do: [:aString | aFileStream nextPutAll: aString; cr].\n\taFileStream close\n",
          "printMessageUsage": "printMessageUsage\n\t\"Smalltalk printMessageUsage.\"\n\t| dict file set |\n\tdict _ IdentityDictionary new: 1024.\n\tCursor execute showWhile:\n\t[CompiledMethod allInstancesDo:\n\t\t[:meth |\n\t\tset _ meth messages.\n\t\tset do:\n\t\t\t[:sel | dict at: sel put: (dict at: sel ifAbsent: [0]) + 1]\n\t\t]\n\t].\n\tCursor write showWhile:\n\t[file _ Disk file: 'message.counts'.\n\tdict associationsDo:\n\t\t[:assn |\n\t\tassn value > 10\n\t\t\tifTrue: [file cr; nextPutAll: assn key; tab; nextPutAll: assn value printString]].\n\tfile close]\n",
          "printInstanceVariablesNotReferencedOn:": "printInstanceVariablesNotReferencedOn: aFileStream\n\t\"Print a list of classes and instance variables defined in, but not used in that\n\tclass\n\n\tSmalltalk printInstanceVariablesNotReferencedOn:\n\t\t(Disk file: 'smalltalk.unrefedIvars') \"\n\n\tself instanceVariablesNotReferenced do: [:ivar | aFileStream nextPutAll: ivar; cr].\n\taFileStream close\n",
          "printInstanceCounts": "printInstanceCounts\n\t\"Smalltalk printInstanceCounts. (Disk file: 'Instance.counts') edit.\"\n\n\t| file |\n\tfile _ Disk file: 'Instance.counts'.\n\tSmalltalk timeStamp: file.\n\tSmalltalk\n\t\tinstanceCountsAndSpaceDo:\n\t\t\t[:class :count :nwords |\n\t\t\tfile cr; nextPutAll: class name.\n\t\t\t(25 - class name size) timesRepeat: [file space].\n\t\t\tfile print: count; tab; print: nwords].\n\tfile close\n",
          "printUnresponsivesOn:": "printUnresponsivesOn: aFileStream\n\t\"Print a list of unimplemented subclassResponsibilities.\n\n\tSmalltalk printUnresponsivesOn: (Disk file: 'smalltalk.subclassUnimps')\"\n\n\tself unResponsives do:\n\t\t[:aString | aFileStream nextPutAll: aString; cr].\n\taFileStream close\n"
        }
      }
    },
    "SystemTracer": {
      "comment": "Instance Variables:\n\t\tmap\t\t<Array> of new oops indexed by old oops\n\t\trefcts\t<ByteArray> encoding refcts and clamping\n\t\tfile\t\t<FileStream> for writing vmem image\n\t\tholder\t<Stream> of objects created just for the new image\n\t\twriteDict\t<Dictionary> of writing selectors for each class\n\t\tmaxOop\t\t<Integer> number of objects written in clone\n\t\tspecialObjects\t<Array> of objects to get first N oops in clone\n\t\tinitialProcess\t<Process> to resume at startup\n\t\tot\t\t<FileStream> for writing OT\n\t\tbank\t<Integer> high bits of object offest in image\n\t\taddr\t<Integer> low bits\n\nThe system Tracer is the secret weapon of Smalltalk developers.  Some people think it is an overnight garbage collector.  It is; in fact on a decent machine (heh, heh), it is a coffee-break garbage collector.  But the real value of the tracer is that it allows fundamental changes to be made to the system from within.\n\nBasically, the tracer runs through the system tracing every accessible object, and writing a copy of each object onto a disk image.  It does this carefully enough that the resulting clone can be started up and run, just like a snapshot.  Some care is taken so that objects appear in the same order in the data space as they do in the object table.\n\nThe tracer has built-in support for clamping unwanted (or unneeded) classes out of the system.  Use the message writeCloneWithout: for this.  A considerably more powerful clamping mechanism is the message winnowing feature.  It will cull out all unreferenced messages, and then based on THOSE deletions, cull out more and so on.  See the comment in winnow.\n\nExamples of things we have done with the SystemTracer include changing the instruction set of Smalltalk.  For this we define a subclass called Junta which defines a special method for writing CompiledMethods out in the new format.  Then we change the virtual machine and fire up the clone.  Another example is changing the format of FloatingPoint numbers\n",
      "class_name": "SystemTracer",
      "superclass": "Object",
      "instanceVariables": "map refcts file holder writeDict maxOop specialObjects initialProcess ot bank addr",
      "classInstanceVariables": "",
      "classVariables": "Clamped MT NewNil NoRefs ODD OVref PTRS",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"SystemTracer initialize.\"\n\n\tODD _ 128.\n\tPTRS _ 64.\n\tMT _ 32.\n\tNoRefs _ 0.\n\tOVref _ 128.\n\tClamped _ 255.\n\tNewNil _ 1\n"
        },
        "cloning": {
          "writeCloneWithout:": "writeCloneWithout: aSet\n\t\"This message creates and runs a SystemTracer without the sets named:\n\t\tSystemTracer writeCloneWithout:\n\t\t\t(Set with: AltoFilePage with: AltoFile with: AltoFileDirectory).\n\tIf all goes well, it will produce a file called clone.im which is a valid image file\"\n\n\t| tracer |\n\ttracer_ self new.\n\ttracer doitWithout: aSet.\n\ttracer == nil\n\t\tifTrue:\n\t\t\t[Smalltalk install.\n\t\t\tScheduledControllers restore.\n\t\t\tDisk == nil ifFalse: [Disk release]]\n\t\"\n\tBelow are checks for things which might cause the Tracer to run amock:\n\n\tChecker rehashBadSets\n\n\tSmalltalk obsoleteClasses do: [:class | class obsolete]\n\n\tBrowserView\n\t\topenListBrowserOn: Smalltalk obsoleteClassReferences\n\t\tlabel: 'References to Obsolete Classes'\n\n\tSmalltalk classNames select:\n\t\t[:x | (Smalltalk at: x) superclass class ~~ (Smalltalk at: x) \tclass superclass]\n\t\"\n",
          "writeClone": "writeClone\n\t\"This message creates and runs a SystemTracer:\n\t\tSystemTracer writeClone.\n\tIf all goes well, it will produce a file called clone.im which is a valid image file\"\n\n\tself writeCloneWithout: Set new\n"
        }
      },
      "instance_methods": {
        "tracing and writing": {
          "writeProcess:": "writeProcess: obj\n\t\"Substitute new initialProcess for current\"\n\n\t| length newObj |\n\tnewObj _\n\t\tobj == Processor activeProcess\n\t\t\tifTrue: [initialProcess]\n\t\t\tifFalse: [obj].\n\tself new: obj\n\t\tclass: newObj class\n\t\tlength: (length _ self sizeInWordsOf: newObj)\n\t\ttrace: [1 to: length do: [:i | self trace: (newObj instVarAt: i)]]\n\t\twrite: [1 to: length do: [:i | self writePointerField: (newObj instVarAt: i)]]\n",
          "writePointers:": "writePointers: obj\n\t| length |\n\tself new: obj\n\t\tclass: obj class\n\t\tlength: (length _ self sizeInWordsOf: obj)\n\t\ttrace: [1 to: length do: [:i | self trace: (obj instVarAt: i)]]\n\t\twrite: [1 to: length do: [:i | self writePointerField: (obj instVarAt: i)]]\n",
          "writeIdentityDictionary:": "writeIdentityDictionary: obj\n\t\"Elements of an IdentityDict need to be reOrdered owing to new oops\"\n\t\"Here we also support removal of entries for clamped values\"\n\t| i perm fixPart length objCopy |\n\tobjCopy _ obj copy.\n\tobjCopy keys do:\n\t\t[:key |\n\t\t(self hasClamped: (objCopy at: key)) ifTrue: [objCopy removeKey: key]].\n\tholder nextPut: objCopy.\n\tfixPart _ objCopy class instSize.\n\tself new: obj\n\t\tclass: objCopy class\n\t\tlength: (length _ self sizeInWordsOf: objCopy)\n\t\ttrace:\n\t\t\t[\"map the keys first\"\n\t\t\t3 to: length do: [:i | self trace: (objCopy instVarAt: i)].\n\t\t\tperm _\n\t\t\t\tself permutation:\n\t\t\t\t\t[:key |  \"IdentityDicts hash by asOop, not hash\"\n\t\t\t\t\tkey class == SmallInteger\n\t\t\t\t\t\tifTrue: [self newSmallIntegerHash: key]\n\t\t\t\t\t\tifFalse: [self newHashFor: key asOop]]\n\t\t\t\tfor: objCopy.\n\t\t\tself permute: (objCopy instVarAt: 2) by: perm.\n\t\t\t\"and permute the new value vector\"\n\t\t\t1 to: 2 do: [:i | self trace: (objCopy instVarAt: i)]]\n\t\twrite:\n\t\t\t[1 to: fixPart do: [:i | self writePointerField: (objCopy instVarAt: i)].\n\t\t\t1 to: objCopy basicSize do: [:i | self writePointerField: ((perm at: i)\n\t\t\t\t\t\t== nil ifFalse: [objCopy instVarAt: (perm at: i)\n\t\t\t\t\t\t\t\t+ fixPart])]]\n",
          "writeWords:": "writeWords: obj\n\t| length |\n\tself new: obj\n\t\tclass: obj class\n\t\tlength: (length _ self sizeInWordsOf: obj)\n\t\ttrace: []\n\t\twrite: [1 to: length do: [:i | self writeBitField: (obj instVarAt: i)]]\n",
          "writeSet:": "writeSet: obj\n\t\"Elements of a Set need to be reOrdered owing to new oops\"\n\t| perm length assoc |\n\tself new: obj\n\t\tclass: obj class\n\t\tlength: (length _ self sizeInWordsOf: obj)\n\t\ttrace:\n\t\t\t[1 to: length do: [:i | self trace: (obj instVarAt: i)].\n\t\t\t\"map the elements first\"\n\t\t\tperm _ self permutation: [:key | key hashMappedBy: self] for: obj]\n\t\twrite:\n\t\t\t[1 to: obj class instSize do:\n\t\t\t\t[:i | self writePointerField: (obj instVarAt: i)].\n\t\t\t1 to: obj basicSize do:\n\t\t\t\t[:i |\n\t\t\t\tself writePointerField:\n\t\t\t\t\t((perm at: i) == nil ifFalse: [obj basicAt: (perm at: i)])]]\n",
          "writeBytes:": "writeBytes: obj\n\tself new: obj\n\t\tclass: obj class\n\t\tlength: (self sizeInWordsOf: obj)\n\t\ttrace: []\n\t\twrite:\n\t\t\t[1 to: obj size do: [:i | file nextPut: (obj at: i) asInteger].\n\t\t\tfile padToNextWordPut: 0]\n",
          "writePointerField:": "writePointerField: obj\n\t| oop |\n\t(obj isMemberOf: SmallInteger)\n\t\t\tifTrue:\n\t\t\t\t[file nextPut: ((obj bitShift: -7) bitAnd: 255).\n\t\t\t\tfile nextPut: (obj bitAnd: 127) * 2 + 1]\n\t\t\tifFalse:\n\t\t\t\t[oop _ map at: (self oopOf: obj).\n\t\t\t\toop = 0 ifTrue: [oop _ NewNil].\n\t\t\t\tfile nextPut: ((oop bitShift: -7) bitAnd: 255).\n\t\t\t\tfile nextPut: (oop bitAnd: 127) * 2 + 0]\n",
          "trace:": "trace: obj\n\t| oop refct |\n\t(obj isMemberOf: SmallInteger) ifTrue: [^self].\n\toop _ self oopOf: obj.\n\trefct _ refcts at: oop.\n\trefct >= OVref ifTrue: [^self].\n\trefct > NoRefs\n\t\tifTrue:\n\t\t\t[refcts at: oop put: refct + 1.\n\t\t\t^self].\n\tself perform: (writeDict at: obj class)\n\t\twith: obj\n",
          "writeMethod:": "writeMethod: obj\n\t| nptrs |\n\tnptrs _ obj numLiterals + 1.\n\tself new: obj\n\t\tclass: obj class\n\t\tlength: (self sizeInWordsOf: obj)\n\t\ttrace: [1 to: nptrs do: [:i | self trace: (obj objectAt: i)]]\n\t\twrite:\n\t\t\t[1 to: nptrs do: [:i | self writePointerField: (obj objectAt: i)].\n\t\t\tnptrs * 2 + 1 to: obj size do: [:i | file nextPut: (obj at: i)].\n\t\t\tfile padToNextWordPut: 0]\n",
          "writeClamped:": "writeClamped: obj\n\t\"Take no action\"\n",
          "writeBitField:": "writeBitField: bits\n\tbits class == SmallInteger\n\t\tifTrue:\n\t\t\t[file nextPut: (bits bitShift: -8).\n\t\t\tfile nextPut: (bits bitAnd: 255)]\n\t\tifFalse:\n\t\t\t[file nextPut: (bits at: 2).\n\t\t\tfile nextPut: (bits at: 1)]\n"
        },
        "image": {
          "writeSpecial1": "writeSpecial1\n\t| obj |\n\tspecialObjects _\n\t\t \"1:\" (Array with: nil with: false with: true with: (Smalltalk associationAt: #Processor))\n\t\t, \"5:\" (Array with: Symbol table with: SmallInteger with: String with: Array)\n\t\t, \"9:\" (Array with: (Smalltalk associationAt: #Smalltalk) with: Float\n\t\t\t\t\twith: MethodContext with: BlockContext)\n\t\t, \"13:\" (Array with: Point with: LargePositiveInteger with: DisplayBitmap with: Message)\n\t\t, \"17:\" (Array with: CompiledMethod with: #unusedOop18 with: Semaphore with: Character)\n\t\t, \"21:\" (Array with: #doesNotUnderstand: with: #cannotReturn:\n\t\t\t\t\twith: #monitor: with: Smalltalk specialSelectors)\n\t\t, \"25:\" (Array with: Character characterTable with: #mustBeBoolean).\n\tspecialObjects size = 26 ifFalse: [self error: 'try again!'].\n\tspecialObjects do:  \"create OT entries\"\n\t\t[:obj |\n\t\tself new: obj\n\t\t\tclass: obj class\n\t\t\tlength: (self sizeInWordsOf: obj)\n\t\t\ttrace: nil\n\t\t\twrite: [].\n\t\trefcts at: (self oopOf: obj) put: OVref \"jam refcts of special objects\"].\n\tself trace: #Smalltalk; trace: #Processor \"need to get mapped now\"\n",
          "writeImage:": "writeImage: roots\n\t| datalen otlen root oop i |\n\tot readWrite.\n\tfile readWrite.\n\tfile position: 512.\n\t\"Skip header page\"\n\tot position: 0.\n\taddr _ bank _ 0.\n\tself writeSpecial1.\n\troots do: [:root | self trace: root].\n\tself writeSpecial2.\n\tdatalen _ file position - 512 // 2.\n\tot shorten.\n\totlen _ ot position // 5 + 1 * 2.\n\tfile padTo: 512 put: 0.\n\tot position: 0.\n\tfile nextWordPut: MT.\n\tfile nextWordPut: 0.\n\t\"oop zero\"\n\t1 to: maxOop do:\n\t\t[:i |\n\t\t\"append the OT, rectifying reference counts\"\n\t\toop _ ot nextWord.\n\t\tfile nextPut: (refcts at: oop).\n\t\tfile nextPut: ot next.\n\t\tfile nextPut: ot next.\n\t\tfile nextPut: ot next].\n\tfile shorten.\n\t\"info in header page\"\n\tfile position: 0.\n\tfile nextWordPut: datalen // 65536.\n\tfile nextWordPut: datalen \\\\ 65536.\n\tfile nextWordPut: otlen // 65536.\n\tfile nextWordPut: otlen \\\\ 65536.\n\tfile nextWordPut: 0.\n\tfile padTo: 512 put: 0.\n\t\"Pad header page\"\n\tot close.\n\tfile close.\n\t^Array with: otlen // 2 with: datalen\n",
          "writeSpecial2": "writeSpecial2\n\t| obj pos max oldTable |\n\tspecialObjects do:\n\t\t[:obj |\n\t\t\"make sure parts are written (will cause extra ref)\"\n\t\tself trace: obj class.\n\t\tobj == Symbol table | obj class isBits\n\t\t\tifFalse: [1 to: (self sizeInWordsOf: obj) do:\n\t\t\t\t\t\t[:i | self trace: (obj instVarAt: i)]]].\n\toldTable _ Symbol table copy.\n\t\"trim Symbol table to only those UStrings used\"\n\t1 to: Symbol table size do:\n\t\t[:i |\n\t\tSymbol table\n\t\t\tat: i\n\t\t\tput: ((Symbol table at: i)\n\t\t\t\t\tselect: [:obj | (refcts at: (self oopOf: obj)) > NoRefs])].\n\t1 to: (self sizeInWordsOf: Symbol table) do:\n\t\t[:i | self trace: (Symbol table instVarAt: i)].\n\tpos _ file position.\n\tfile position: 512.\n\tmax _ maxOop.\n\tspecialObjects do:\n\t\t[:obj | \"go back and write data after tracing\"\n\t\tself perform: (writeDict at: obj class) with: obj].\n\tmax ~= maxOop ifTrue: [self error: 'bug in tracer'].\n\tfile position: pos.\n\tspecialObjects do:\n\t\t[:obj | \"undo the extra refs due to specialObjects\"\n\t\tself unref: obj class.\n\t\tobj class isBits ifFalse:\n\t\t\t[1 to: (self sizeInWordsOf: obj) do: [:i | self unref: (obj instVarAt: i)]]].\n\tSymbol table: oldTable.\n\tself unref: #Smalltalk; unref: #Processor\n"
        },
        "static checks": {
          "allCallsOn:clampedBy:": "allCallsOn: aLiteral clampedBy: nameSet\n\t\"Specialized version of the SystemDictionary allCallsOn:,\n\twhich doesnt include calls from clamped classes.\"\n\t| aSortedCollection classNames class name special |\n\taSortedCollection _ SortedCollection new.\n\tspecial _ Smalltalk hasSpecialSelector: aLiteral ifTrueSetByte: [:byte ].\n\tclassNames _ Smalltalk classNames.\n\tnameSet do: [:name | classNames remove: name ifAbsent: []].\n\tCursor execute showWhile:\n\t\t[classNames do:\n\t\t\t[:name | class _ Smalltalk at: name.\n\t\t\t(class whichSelectorsReferTo: aLiteral special: special byte: byte) do:\n\t\t\t\t[:sel | sel ~~ #DoIt\n\t\t\t\t\tifTrue: [aSortedCollection add: class name , ' ' , sel]].\n\t\t\tclass _ class class.\n\t\t\t(class whichSelectorsReferTo: aLiteral special: special byte: byte) do:\n\t\t\t\t[:sel | sel ~~ #DoIt\n\t\t\t\t\tifTrue: [aSortedCollection add: class name , ' ' , sel]]]].\n\t^aSortedCollection\n",
          "printDanglingRefs": "printDanglingRefs   \"SystemTracer new printDanglingRefs.\"\n\t\"Use this method to locate calls on classes and other global objects\n\twhich are to be clamped from the system\"\n\t| class x clamped f dangling |\n\tclamped _ Set new.\n\t\"clamp entire categories of classes: \"\n\t(SystemOrganization categories select: [:x | 'ClampThis*' match: x]) do:\n\t\t[:str |\n\t\t(SystemOrganization superclassOrder: str) do:\n\t\t\t[:class | clamped add: class name]].\n\t\"clamp individual classes and other Globals: \"\n\t(Array with: #AltoFile with: #AltoFileDirectory with: #AltoFilePage) do:\n\t\t[:x | clamped add: x].\n\tSmalltalk allBehaviorsDo:\n\t\t[:class |\n\t\t(class organization categories select:\n\t\t\t\t[:name | ('clampme*' match: name)]) do:\n\t\t\t[:name | Transcript print: class; space; nextPutAll: name; cr; endEntry.\n\t\t\tclass removeCategory: name].\n\t\t].\n\tf_ Disk file: 'dangling.st'.\n\tclamped do:\n\t\t[:name |\n\t\tdangling _ self allCallsOn: (Smalltalk associationAt: name) clampedBy: clamped.\n\t\tdangling isEmpty ifFalse:\n\t\t\t[f cr; nextPutAll: name; cr.\n\t\t\tdangling do:\n\t\t\t\t[:x | f tab; nextPutAll: x; cr]]].\n\tf close\n"
        },
        "private": {
          "permute:by:": "permute: vec by: perm\n\t| copy j len inverse |\n\t(perm isMemberOf: Interval) ifTrue: [^perm\"no-op for 1~n identity\"].\n\tlen _ vec size.\n\tcopy _ Array new: len.\n\tinverse _ Array new: len.\n\t1 to: len do:\n\t\t[:i |\n\t\t(j _ perm at: i) == nil\n\t\t\tifFalse:\n\t\t\t\t[copy at: i put: (vec at: j).\n\t\t\t\tinverse at: j put: i]].\n\t1 to: len do: [:i | vec at: i put: (copy at: i)].\n\t^inverse\n",
          "oopOf:": "oopOf: obj\n\t\"Returns an OT index, also suitable for indexing map and refcts.\n\tobj must not be a SmallInteger.\"\n\n\t^ self asOopToIndex: obj asOop\n",
          "permutation:for:": "permutation: permutationBlock for: array\n\t| len perm key hash |\n\t\"Return an inverse permutation for an array to permute it according to\n\tthe mapped oop values.  The keys in array MUST have been mapped.\"\n\n\tlen _ array basicSize.\n\tperm _ Array new: len.\n\t1 to: len do:\n\t\t[:i | key _ array basicAt: i.\n\t\t(key == nil or: [self hasClamped: key])\n\t\t  ifFalse:\n\t\t\t[hash _ permutationBlock value: key.\n\t\t\thash _ hash \\\\ len + 1.\n\t\t\t[(perm at: hash) == nil]\n\t\t\t\twhileFalse:\n\t\t\t\t[hash _ (hash = len ifTrue: [1] ifFalse: [hash + 1])].\n\t\t\tperm at: hash put: i]].\n\t^perm\n",
          "sizeInWordsOf:": "sizeInWordsOf: anObject\n\t| class |\n\tclass_ anObject class.\n\tclass isBytes ifTrue: [^anObject size+1//2].\n\tclass isVariable ifTrue: [^class instSize+anObject basicSize].\n\t^class instSize\n",
          "unref:": "unref: obj\n\t| oop refct |\n\t(obj isMemberOf: SmallInteger) ifTrue: [^self].\n\toop _ self oopOf: obj.\n\t(refct _ refcts at: oop) = OVref ifTrue: [^self].\n\trefct = 1 ifTrue: [self error: 'deleting last ref'].\n\trefcts at: oop put: refct - 1\n",
          "asOopToIndex:": "asOopToIndex: oop\n\t\"Unscramble asOop values to return OT index in range 1 to 32767.\"\n\toop < 0\n\t\tifTrue: [^ oop + 32768]\n\t\tifFalse: [^ oop]\n",
          "newHashFor:": "newHashFor: asOop\n\t\"This is what asOop will return in the cloned system.\n\tasOop is what asOop returns in the current system\"\n\n\t^ self asOopFromIndex: (map at: (self asOopToIndex: asOop))\n",
          "clamp:": "clamp: obj\n\trefcts at: (self oopOf: obj) put: Clamped.\n\t(obj isKindOf: Behavior)\n\t\tifTrue:\n\t\t\t[writeDict at: obj put: #writeClamped:.\n\t\t\tSmalltalk removeKey: obj name.\n\t\t\tSystemOrganization removeElement: obj name]\n",
          "newSmallIntegerHash:": "newSmallIntegerHash: anInteger\n\t^ anInteger asOop\n",
          "refctOf:": "refctOf: obj\n\t(obj isMemberOf: SmallInteger) ifTrue: [^0].\n\t^refcts at: (self oopOf: obj)\n",
          "hasClamped:": "hasClamped: obj\n\tobj class == SmallInteger ifTrue: [^false].\n\t^(refcts at: (self oopOf: obj)) = Clamped\n",
          "asOopFromIndex:": "asOopFromIndex: oop\n\t\"Convert from OT index to values returned by asOop\"\n\toop <= 16383\n\t\tifTrue: [^ oop]\n\t\tifFalse: [^ oop - 32768]\n"
        },
        "initialize-release": {
          "init:": "init: aContext\n\tinitialProcess _ Process forContext: aContext priority: Processor activePriority.\n\trefcts _ ByteArray new: 49152.\n\tmap _ WordArray new: 49152.\n\tfile _ Disk file: 'clone.im'.\n\tfile binary.\n\tot _ Disk file: 'ot.scratch'.\n\tot binary.\n\tholder _ ReadWriteStream on: (Array new: 100).\n\tmaxOop _ 0.\n\tself clamp: self.\n\tself initDict\n",
          "doitWithout:": "doitWithout: classSet\n\t| time1 time2 ctxt n |\n\tctxt _ thisContext sender.\n\tctxt push: nil.\n\tself init: ctxt.\n\tself initClampedClasses: classSet.\n\tFileDirectory initializeExternalReferences.\n\tSmalltalk shutdown.\n\t\"Make sure the system is stable underneath us.\"\n\tTranscript show: 'Tracing . . . '.\n\ttime1 _ Time now asSeconds.\n\tn _ self writeImage: (Array with: Smalltalk).\n\ttime2 _ Time now asSeconds.\n\tTranscript print: n; show: ' objects, words, '; print: time2 - time1; show: ' sec.'; cr.\n\tSmalltalk install.\n\t\"Allow things to change again.\"\n\tctxt pop\n\t\"So we can resume\"\n",
          "winnow:": "winnow: nPasses\n\t\"This method will clamp message out of the cloning process.  First it calls preserve:\n\tto establish a root set of messages which must not be deleted.  Then it makes a pass\n\tthrough the system figuring out which messages are not called from anywhere\n\texcept in classes which have already been clamped.  Then it makes another pass,\n\tpicking up those which are now unreferenced due to the preceding deletions.\n\tAnd so on;  usually 6 iterations gets most everything.\n\n\tIt is advisable to run just the winnow phase of the trace (2 passes, say)\n\t\tExportTracer new init: thisContext; winnow: 2\n\tand then read the file chaff.st to see what got zapped, before doing a full trace.\n\tChances are, you will have forgotten to include several messages in preserve: (qv).\"\n\n\t| f refs class sel lit method first |\n\tf _ Disk file: 'chaff.st'.\n\t\" 6 iterations gets most everything\"\n\t1 to: nPasses do:\n\t\t[:i |\n\t\tTranscript show: 'Winnow pass ' , i printString; cr; endEntry.\n\t\trefs _ Set new: 4096.\n\t\tself preserve: refs.\n\t\tSmalltalk allBehaviorsDo: [:class | \"collect all refs\"\n\t\t\t(self hasClamped: class)\n\t\t\t\tifFalse: [class selectors do:\n\t\t\t\t\t\t[:sel |\n\t\t\t\t\t\tmethod _ class compiledMethodAt: sel.\n\t\t\t\t\t\t(self hasClamped: method)\n\t\t\t\t\t\t\tifFalse: [method literals do: [:lit | (lit isMemberOf: Symbol)\n\t\t\t\t\t\t\t\t\t\tifTrue: [refs add: lit]]]]]].\n\t\tSmalltalk allBehaviorsDo: [:class | \"collect all unrefs\"\n\t\t\t(self hasClamped: class)\n\t\t\t\tifFalse:\n\t\t\t\t\t[first _ true.\n\t\t\t\t\tclass selectors do: [:sel | (refs includes: sel)\n\t\t\t\t\t\t\tifFalse:\n\t\t\t\t\t\t\t\t[method _ class compiledMethodAt: sel.\n\t\t\t\t\t\t\t\t(self hasClamped: method)\n\t\t\t\t\t\t\t\t\tifFalse:\n\t\t\t\t\t\t\t\t\t\t[first ifTrue:\n\t\t\t\t\t\t\t\t\t\t\t[first _ false.\n\t\t\t\t\t\t\t\t\t\t\tf cr; cr; nextPutAll: class name; space].\n\t\t\t\t\t\t\t\t\t\tself clamp: (class compiledMethodAt: sel).\n\t\t\t\t\t\t\t\t\t\tclass organization removeElement: sel.\n\t\t\t\t\t\t\t\t\t\tf nextPutAll: sel; space]]]]].\n\t\tf cr; nextPutAll: '------------'; cr].\n\tf close\n",
          "initDict": "initDict\n\twriteDict _ Dictionary new: 256.\n\tSmalltalk\n\t\tallBehaviorsDo:\n\t\t\t[:class |\n\t\t\twriteDict at: class put: #writePointers:.\n\t\t\tclass isBits\n\t\t\t\tifTrue:\n\t\t\t\t\t[writeDict at: class put: (class isBytes\n\t\t\t\t\t\t\t\t\t\t\tifTrue: [#writeBytes:]\n\t\t\t\t\t\t\t\t\t\t\tifFalse: [#writeWords:])]\n\t\t\t\tifFalse:\n\t\t\t\t\t[(class inheritsFrom: Set) | (class == Set) ifTrue:\n\t\t\t\t\t\t[writeDict at: class put: #writeSet:].\n\t\t\t\t\t(class inheritsFrom: IdentityDictionary) | (class == IdentityDictionary) ifTrue:\n\t\t\t\t\t\t[writeDict at: class put: #writeIdentityDictionary:]]].\n\twriteDict at: SmallInteger put: #writeClamped:.\n\twriteDict at: CompiledMethod put: #writeMethod:.\n\twriteDict at: Process put: #writeProcess:\n",
          "new:class:length:trace:write:": "new: obj class: class length: length trace: traceBlock write: writeBlock\n\t| oop objpos endpos |\n\toop_ self oopOf: obj.\n\t(refcts at: oop)=NoRefs ifTrue: \"create a new ot entry\"\n\t\t[map at: oop put: (maxOop_ maxOop+1).\n\t\trefcts at: oop put: 1.\n\t\tot nextWordPut: oop.  \"save oop; fill in refct in pass2\"\n\t\tot nextPut: bank +\n\t\t\t(class  isBits\n\t\t\tifTrue: [(class isBytes and: [obj size even == false])\n\t\t\t\t\t\tifTrue: [ODD]  ifFalse: [0]]\n\t\t\tifFalse: [PTRS]).\n\t\tot nextWordPut: addr.\n\t\taddr _ addr + length+2.\n\t\taddr >= 65536\n\t\t\tifTrue:\n\t\t\t\t[addr _ (addr - 65536) truncated.\n\t\t\t\tbank _ bank + 1]]\n\t\t\tifFalse:\n\t\t\t\t[(map at: oop)>specialObjects size\n\t\t\t\t\tifTrue: [self error: 'double write!']].\n\tobjpos_ file position.\n\tfile skip: length+2*2.\n\ttraceBlock notNil ifTrue: [self trace: class.  traceBlock value].\n\tendpos_ file position.  file position: objpos.\n\tself writeBitField: length+2.  self writePointerField: class.  writeBlock value.\n\tfile position: endpos\n",
          "initClampedClasses:": "initClampedClasses: classSet\n\t| x |\n\tclassSet isEmpty\n\t\tifTrue: [^self].\n\tclassSet do:\n\t\t[:class |\n\t\tself clamp: class].\n\tSmalltalk allBehaviorsDo:\n\t\t[:class |\n\t\tclass superclass == nil &\n\t\t\t((writeDict at: class) ~= #writeClamped:)\n\t\tifTrue: [class == Object\n\t\t\t\t\tifFalse: [self error: class name , 'superclass is clamped!!!!']]].\n\tSystemOrganization removeEmptyCategories.\n\tSmalltalk newClassNames; noChanges.\n\tBrowser allInstancesDo: [:x | x updateCategories].\n\tSmalltalk newSourceFile: 'Smalltalk80' without: classSet\n",
          "preserve:": "preserve: refs\n\t\"This message should puts into the set 'refs' all the messages considered as\n\troots in the system to be winnowed.  Those given below are a minimal set.\n\tSee the comment in winnow:\"\n\n\t1 to: Smalltalk specialSelectorSize do:  \"these at least\"\n\t\t[:i | refs add: (Smalltalk specialSelectorAt: i)].\n\trefs addAll: #(doesNotUnderstand: cannotReturn: monitor: unusedOop51).\n\trefs addAll: #()  \"Lots more here for a real trace\"\n"
        }
      }
    }
  },
  "System-Support": {
    "Benchmark": {
      "comment": "Class Benchmark contains facilities for timing the performance of your system and reporting the results.\n\nThere are built-in methods for timing certain activities that occur frequently in using Smalltalk-80.  There are also facilities for timing the execution of most byte codes.\n\nIt is intended that comparison of timing information between implementations and over time will allow implementors to discover where their systems could stand improvement and to gauge the value of intended performance enhancements.\n\nThe main interface to these facilities is through sending the messsage\n\tBenchmark new test: aBlock labeled: aLabel repeated: howManyTimes.\nThis will cause howManyTimes executions of aBlock and report the results, using aLabel for ease of identification.\n\nThe results can be reported in several different ways.  The default is to print a fairly verbose report in the Transcript.  But the reporting mode can be altered by sending the Benchmark which is going to perform a given test the message setOutputParameters.  This gives you the option of directing the report to a file or an internal stream and also of shortening the feedback in the Transcript.  The system automatically invites you to respecify the output parameters (e.g. naming a new output report file) whenever you test more than one thing at a time, using the message testList: (as in testStandardTests below).\n\nTry an example.  To time your system's performance of simple addition, say\n\tBenchmark new test3plus4\nor to time pushing an instance variable onto the stack, say\n\tBenchmark new testLoadInstVar.\n\nIf you had wished to print the results on a file or internal stream, you could have said\n\tBenchmark new setOutputParameters testLoadInstVar.\n\nIf you look at the code for these methods (e.g. testLoadInstVar), you will notice that it does a few things that you didn't want to time, such as sending the message ==, or popping things off the stack.  This is to make the compiler happy or to keep the stack from overflowing.  So you may want to subtract this stuff out.  (Use systems of equations.  Be clever!)\n\nThe message category \"macro operations\" contains methods for timing more involved activities such as compiling, decompiling, editing text, formatting text, etc.\n\nThere is a message to class Benchmark which will invoke all the built-in benchmarks sequentially.  Say\n\tBenchmark testStandardTests.\n\nThere are also facilities for examining or automatically comparing the output files or streams generated by testing a bunch of benchmarks sequentially.  See the \"output\" category.  Be sure to read the comment to the streamsRatherThanFiles code.\n\nHave fun and share your results with a friend.\n",
      "class_name": "Benchmark",
      "superclass": "Object",
      "instanceVariables": "dummy verboseTranscript reporting reportStream fromList",
      "classInstanceVariables": "",
      "classVariables": "Outputs StandardTests",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "new": "new\n\t^super new defaultOutputParameters\n\n\t\"Benchmark new inspect\"\n"
        },
        "standard tests": {
          "testStandardTests": "testStandardTests\n\t\"This message allows you to test the default series of benchmarks and record all the\n\tresults according to how you answer the interactive prompts.\"\n\n\tself setStandardTests.\n\tself new testList: StandardTests\n\n\t\"Benchmark testStandardTests\"\n",
          "setStandardTests": "setStandardTests\n\t\"These are all the built-in benchmarks.\n\tFeel free to change if you add more or think some of these are useless.\n\tTo just execute a few, use testList: directly.\"\n\n\tStandardTests _\n\t\t\t#(testLoadInstVar testLoadTempNRef testLoadTempRef\n\t\t\ttestLoadQuickConstant testLoadLiteralNRef testLoadLiteralIndirect\n\t\t\ttestPopStoreInstVar testPopStoreTemp\n\t\t\ttest3plus4 test3lessThan4 test3times4 test3div4 test16bitArith testLargeIntArith\n\t\t\ttestActivationReturn testShortBranch testWhileLoop\n\t\t\ttestArrayAt testArrayAtPut testStringAt testStringAtPut testSize\n\t\t\ttestPointCreation testStreamNext testStreamNextPut testEQ testClass\n\t\t\ttestBlockCopy testValue testCreation testPointX\n\t\t\ttestLoadThisContext\n\t\t\ttestBasicAt testBasicAtPut testPerform testStringReplace\n\t\t\ttestAsFloat testFloatingPointAddition testBitBLT testTextScanning\n\t\t\ttestClassOrganizer testPrintDefinition testPrintHierarchy\n \t\t\ttestAllCallsOn testAllImplementors testInspect\n\t\t\ttestCompiler testDecompiler\n\t\t\ttestKeyboardLookAhead testKeyboardSingle\n\t\t\ttestTextDisplay testTextFormatting testTextEditing )\n",
          "testStandardToFile:": "testStandardToFile: aFileStream\n\t\"This message allows you to test the default series of benchmarks and record all the\n\tresults on the specified file or stream.\"\n\n\tself setStandardTests.\n\tself new testList: StandardTests toFile: aFileStream\n\n\t\"Benchmark testStandardToFile: (FileStream fileNamed: 'Smalltalk.timing')\"\n"
        }
      },
      "instance_methods": {
        "primitive methods": {
          "testFloatingPointAddition": "testFloatingPointAddition\n\t| a b |\n\ta _ 3.1.\n\tb _ 4.1.\n\tself test: [a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b.\n\t\t\t  a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b. nil]\n\t\tlabeled: 'add 3.1 plus 4.1, 20 times' repeated: 100\n\n\t\"Benchmark new testFloatingPointAddition\"\n",
          "testPerform": "testPerform\n\tself test: [3 perform: #+ with: 4. 3 perform: #+ with: 4.\n\t\t\t  3 perform: #+ with: 4. 3 perform: #+ with: 4.\n\t\t\t  3 perform: #+ with: 4. 3 perform: #+ with: 4.\n\t\t\t  3 perform: #+ with: 4. 3 perform: #+ with: 4.\n\t\t\t  3 perform: #+ with: 4. 3 perform: #+ with: 4.\n\t\t\t  3 perform: #+ with: 4. 3 perform: #+ with: 4.\n\t\t\t  3 perform: #+ with: 4. 3 perform: #+ with: 4.\n\t\t\t  3 perform: #+ with: 4. 3 perform: #+ with: 4.\n\t\t\t  3 perform: #+ with: 4. 3 perform: #+ with: 4.\n\t\t\t  3 perform: #+ with: 4. 3 perform: #+ with: 4. nil]\n\t\tlabeled: '3 perform: #+ with: 4, 20 times' repeated: 1000\n\n\t\"Benchmark new testPerform\"\n",
          "testAsFloat": "testAsFloat\n\tself test: [1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat.\n\t\t\t  1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat.\n\t\t\t  1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat.\n\t\t\t  1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat. nil]\n\t\tlabeled: 'convert 1 to floating point, 20 times' repeated: 100\n\n\t\"Benchmark new testAsFloat\"\n",
          "testStringReplace": "testStringReplace\n\t| source sink size |\n\tsource _ self longishString copy.\n\tsink _ source copy.\n\tsize _ sink size.\n\tself test:\n\t\t\t[sink replaceFrom: 1 to: size with: source startingAt: 1. nil]\n\t\tlabeled: 'replace characters in a string' repeated: 100\n\n\t\"Benchmark new testStringReplace\"\n",
          "testBasicAtPut": "testBasicAtPut\n\t| coll index element |\n\tcoll _ Set new: 16.\n\tindex _ 5.\n\telement _ 17.\n\tself test:\n\t\t\t[coll basicAt: index put: element. coll basicAt: index put: element.\n\t\t\t coll basicAt: index put: element. coll basicAt: index put: element.\n\t\t\t coll basicAt: index put: element. coll basicAt: index put: element.\n\t\t\t coll basicAt: index put: element. coll basicAt: index put: element.\n\t\t\t coll basicAt: index put: element. coll basicAt: index put: element.\n\t\t\t coll basicAt: index put: element. coll basicAt: index put: element.\n\t\t\t coll basicAt: index put: element. coll basicAt: index put: element.\n\t\t\t coll basicAt: index put: element. coll basicAt: index put: element.\n\t\t\t coll basicAt: index put: element. coll basicAt: index put: element.\n\t\t\t coll basicAt: index put: element. coll basicAt: index put: element. nil]\n\t\tlabeled: 'send #basicAtPut: 20 times (to a set)' repeated: 1000\n\n\t\"Benchmark new testBasicAtPut\"\n",
          "testBasicAt": "testBasicAt\n\t| coll index |\n\tcoll _ Set new: 16.\n\tindex _ 5.\n\tself test:\n\t\t\t[coll basicAt: index. coll basicAt: index. coll basicAt: index. coll basicAt: index.\n\t\t\t coll basicAt: index. coll basicAt: index. coll basicAt: index. coll basicAt: index.\n\t\t\t coll basicAt: index. coll basicAt: index. coll basicAt: index. coll basicAt: index.\n\t\t\t coll basicAt: index. coll basicAt: index. coll basicAt: index. coll basicAt: index.\n\t\t\t coll basicAt: index. coll basicAt: index. coll basicAt: index. coll basicAt: index. nil]\n\t\tlabeled: 'send #basicAt: 20 times (to a set)' repeated: 1000\n\n\t\"Benchmark new testBasicAt\"\n",
          "testTextScanning": "testTextScanning\n\t| clipRect para range scanner stops |\n\tclipRect _ Display boundingBox.\n\tpara _ Paragraph withText: 'Hi there, folks' asText.\n\trange _ 1 to: para numberOfLines.\n\tscanner _ DisplayScanner new.\n\tscanner displayLines: range in: para clippedBy: clipRect.\n\tstops _ scanner instVarAt: 17.\n\tself test:\n\t\t[scanner destX: 0.\n\t\t scanner\n\t\t\tscanCharactersFrom: 1\n\t\t\tto: 16\n\t\t\tin: 'Hi there, folks!'\n\t\t\trightX: 400\n\t\t\tstopConditions: stops\n\t\t\tdisplaying: true]\n\t\tlabeled: 'scan characters (primitive text display)' repeated: 100\n\n\t\"Benchmark new testTextScanning\"\n",
          "testBitBLT": "testBitBLT\n\t| bLTer |\n\tbLTer _ self sampleBitBLT.\n\tself test:\n\t\t\t[bLTer copyBits. bLTer copyBits.\n\t\t\t bLTer copyBits. bLTer copyBits.\n\t\t\t bLTer copyBits. bLTer copyBits.\n\t\t\t bLTer copyBits. bLTer copyBits.\n\t\t\t bLTer copyBits. bLTer copyBits. nil]\n\t\tlabeled: 'call bitBLT 10 times' repeated: 10\n\n\t\"Benchmark new testBitBLT\"\n"
        },
        "arrays and strings": {
          "testArrayAt": "testArrayAt\n\t| array index |\n\tarray _ #(1 2 3 4 5 6).\n\tindex _ 4.\n\tself test:\n\t\t\t[array at: index. array at: index. array at: index. array at: index.\n\t\t\t array at: index. array at: index. array at: index. array at: index.\n\t\t\t array at: index. array at: index. array at: index. array at: index.\n\t\t\t array at: index. array at: index. array at: index. array at: index.\n\t\t\t array at: index. array at: index. array at: index. array at: index. nil]\n\t\tlabeled: 'send #at: 20 times (to an array)' repeated: 1000\n\n\t\"Benchmark new testArrayAt\"\n",
          "testSize": "testSize\n\t| string |\n\tstring _ 'abcde'.\n\tself test:\n\t\t\t[string size. string size. string size. string size. string size.\n\t\t\t string size. string size. string size. string size. string size.\n\t\t\t string size. string size. string size. string size. string size.\n\t\t\t string size. string size. string size. string size. string size. nil]\n\t\tlabeled: 'send #size 20 times (to a string)' repeated: 1000\n\n\t\"Benchmark new testSize\"\n",
          "testStringAtPut": "testStringAtPut\n\t| string index char |\n\tstring _ 'abcdefg'.\n\tindex _ 4.\n\tchar _ $q.\n\tself test:\n\t\t\t[string at: index put: char. string at: index put: char.\n\t\t\t string at: index put: char. string at: index put: char.\n\t\t\t string at: index put: char. string at: index put: char.\n\t\t\t string at: index put: char. string at: index put: char.\n\t\t\t string at: index put: char. string at: index put: char.\n\t\t\t string at: index put: char. string at: index put: char.\n\t\t\t string at: index put: char. string at: index put: char.\n\t\t\t string at: index put: char. string at: index put: char.\n\t\t\t string at: index put: char. string at: index put: char.\n\t\t\t string at: index put: char. string at: index put: char. nil]\n\t\tlabeled: 'send #at:put: 20 times (to a string)' repeated: 1000\n\n\t\"Benchmark new testStringAtPut\"\n",
          "testStringAt": "testStringAt\n\t| string index |\n\tstring _ 'abcdefg'.\n\tindex _ 4.\n\tself test:\n\t\t\t[string at: index. string at: index. string at: index. string at: index.\n\t\t\t string at: index. string at: index. string at: index. string at: index.\n\t\t\t string at: index. string at: index. string at: index. string at: index.\n\t\t\t string at: index. string at: index. string at: index. string at: index.\n\t\t\t string at: index. string at: index. string at: index. string at: index. nil]\n\t\tlabeled: 'send #at: 20 times (to a string)' repeated: 1000\n\n\t\"Benchmark new testStringAt\"\n",
          "testArrayAtPut": "testArrayAtPut\n\t| array index element |\n\tarray _ #(1 2 3 4 5 6).\n\tindex _ 4.\n\telement _ 17.\n\tself test:\n\t\t\t[array at: index put: element. array at: index put: element.\n\t\t\t array at: index put: element. array at: index put: element.\n\t\t\t array at: index put: element. array at: index put: element.\n\t\t\t array at: index put: element. array at: index put: element.\n\t\t\t array at: index put: element. array at: index put: element.\n\t\t\t array at: index put: element. array at: index put: element.\n\t\t\t array at: index put: element. array at: index put: element.\n\t\t\t array at: index put: element. array at: index put: element.\n\t\t\t array at: index put: element. array at: index put: element.\n\t\t\t array at: index put: element. array at: index put: element. nil]\n\t\tlabeled: 'send #at:put: 20 times (to an array)' repeated: 1000\n\n\t\"Benchmark new testArrayAtPut\"\n"
        },
        "output": {
          "clearOutputs": "clearOutputs\n\t\"This allows you to get rid of your old accumulated output streams.\"\n\n\tOutputs _ nil\n\n\t\"Benchmark new clearOutputs\"\n",
          "report:timedAt:repeated:": "report: label timedAt: time repeated: numberOfTimes\n\t\"Do all the reporting, both in the Transcript and on the output file or stream.\"\n\n\t| reportString |\n\treportString _ self reportStringFor: label\n\t\t\t\t\t\ttimedAt: time\n\t\t\t\t\t\trepeated: numberOfTimes.\n\tverboseTranscript\n\t\t\tifTrue: [Transcript show: reportString]\n\t\t\tifFalse: [Transcript show: '\n[', label, ']'].\n\treporting ifTrue:\n\t\t[reportStream nextPutAll: reportString.\n\t\t fromList ifFalse: [self closeOutput: reportStream]]\n",
          "compareOldTimes:toNewTimes:outputTo:": "compareOldTimes: oldName toNewTimes: newName outputTo: outName\n\t\"Compare two sets of benchmark ouput reports.\"\n\n\t| oldDict newDict labels compareStream oldTime newTime |\n\toldDict _ Dictionary new. newDict _ Dictionary new. labels _ OrderedCollection new.\n\tself readOutput: (self outputNamed: oldName) intoDict: oldDict andCollection: nil.\n\tself readOutput: (self outputNamed: newName) intoDict: newDict andCollection: labels.\n\tcompareStream _ self makeOutputNamed: outName.\n\tlabels do:\n\t\t[:label | (oldDict includesKey: label) ifTrue:\n\t\t\t[compareStream nextPutAll: label; cr; tab;\n\t\t\t\tnextPutAll: 'old time: ', (oldTime _ oldDict at: label) printString; tab;\n\t\t\t\tnextPutAll: 'new time: ', (newTime _ newDict at: label) printString; tab;\n\t\t\t\tnextPutAll: 'percent change: ', (newTime - oldTime * 100.0 / oldTime) printString; cr; cr]].\n\tself closeOutput: compareStream\n\n\t\"Benchmark new\n\t\tcompareOldTimes: 'test1.timing'\n\t\ttoNewTimes: 'test2.timing'\n\t\toutputTo: 'compare1-2.timing'\"\n\n\t\"Benchmark new displayOutputNamed: 'compare1-2.timing'\"\n",
          "makeOutputNamed:": "makeOutputNamed: name\n\t\"Create a new output file or stream of the given name.\"\n\n\tself streamsRatherThanFiles\n\t\tifTrue: [Outputs == nil ifTrue: [Outputs _ Dictionary new].\n\t\t\t\tOutputs at: name put:\n\t\t\t\t\t(ReadWriteStream on: (String new: 1000))].\n\t^self outputNamed: name\n",
          "reportStringFor:timedAt:repeated:": "reportStringFor: label timedAt: time repeated: numberOfTimes\n\t\"Generate the parsible string to represent the measurement of a benchmark.\"\n\n\t| nTimes unitTime seconds aStream|\n\taStream _ WriteStream on: (String new: 200).\n\tnTimes _ numberOfTimes <= 1000\n\t\t\t\tifTrue: [numberOfTimes]\n\t\t\t\tifFalse: [numberOfTimes // 1000 * 1000].\n\tseconds _ time asFloat / 1000.\n\taStream cr; nextPutAll: 'Testing:  [' , label , ']'; cr.\n\taStream tab; print: nTimes; nextPutAll: ' repetition(s) in'; cr;\n\t\ttab; print: seconds; nextPutAll: ' seconds'; cr.\n\tnTimes ~= 1\n\t\tifTrue:\n\t\t\t[unitTime _ (time * 1000) asFloat / nTimes.\n\t\t\taStream tab; print: unitTime;\n\t\t\t\tnextPutAll: ' microseconds per repetition'; cr].\n\t^aStream contents\n",
          "closeOutput:": "closeOutput: aStream\n\tself streamsRatherThanFiles\n\t\tifTrue: [aStream reset]\n\t\tifFalse: [aStream close]\n",
          "readOutput:intoDict:andCollection:": "readOutput: aStream intoDict: aDict andCollection: aColl\n\t\"Parse the output file or stream, aStream, putting labels and times in aDict.\n\tIf aColl is non-nil (but rather an ordered collection), also add the labels to it\n\tin order.\"\n\n\t| leftBracket rightBracket tab space label value |\n\tleftBracket _ $[.\n\trightBracket _ $].\n\ttab _ $\t.\n\tspace _ $ .\n\taStream upTo: leftBracket.\n\t[aStream atEnd] whileFalse:\n\t\t[label _ aStream upTo: rightBracket.\n\t\t aColl notNil ifTrue: [aColl add: label].\n\t\t aStream next: 2; upTo: tab.\n\t\t value _ Number readFrom: (ReadStream on: (aStream upTo: space)).\n\t\t aDict at: label put: value.\n\t\t aStream upTo: leftBracket].\n\tself closeOutput: aStream\n",
          "displayOutputNamed:": "displayOutputNamed: name\n\t\"Create a window on the display to view the contents of the named output.\n\tDoes not allow editing of the output file or stream.\"\n\n\t| output contents |\n\toutput _ self outputNamed: name.\n\tcontents _ self streamsRatherThanFiles\n\t\t\t\t\tifTrue: [output contents]\n\t\t\t\t\tifFalse: [output contentsOfEntireFile].\n\tStringHolderView\n\t\topen: (StringHolder new contents: contents)\n\t\tlabel: name\n",
          "streamsRatherThanFiles": "streamsRatherThanFiles\n\t\"Should the named outputs be (internal Smalltalk-80) streams rather than disk files?\n\tThey should if there is no file system.\n\tFeel free to change this method if you have a file system but want streams anyway.\"\n\n\t^Disk == nil\n",
          "outputNamed:": "outputNamed: name\n\t\"Answer with the output file or stream of the given name.\"\n\n\tself streamsRatherThanFiles\n\t\tifTrue: [^Outputs at: name]\n\t\tifFalse: [^Disk file: name]\n"
        },
        "load and popStore": {
          "testLoadQuickConstant": "testLoadQuickConstant\n\tself test: [1 == 1. 1 == 1. 1 == 1. 1 == 1. 1 == 1.\n\t\t\t  1 == 1. 1 == 1. 1 == 1. 1 == 1. 1 == 1.\n\t\t\t  1 == 1. 1 == 1. 1 == 1. 1 == 1. 1 == 1.\n\t\t\t  1 == 1. 1 == 1. 1 == 1. 1 == 1. 1 == 1. nil]\n\t\tlabeled: 'load 1, 40 times; send ==, 20 times' repeated: 10000\n\n\t\"Benchmark new testLoadQuickConstant\"\n",
          "testLoadInstVar": "testLoadInstVar\n\tdummy _ 1.\n\tself test: [dummy == dummy. dummy == dummy.\n\t\t\t  dummy == dummy. dummy == dummy.\n\t\t\t  dummy == dummy. dummy == dummy.\n\t\t\t  dummy == dummy. dummy == dummy.\n\t\t\t  dummy == dummy. dummy == dummy. nil]\n\t\tlabeled: 'load an instance variable, 20 times' repeated: 10000\n\n\t\"Benchmark new testLoadInstVar\"\n",
          "testPopStoreInstVar": "testPopStoreInstVar\n\tself test: [dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1.\n\t\t\t  dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1.\n\t\t\t  dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1.\n\t\t\t  dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1. nil]\n\t\tlabeled: 'store into an instance variable, 20 times' repeated: 10000\n\n\t\"Benchmark new testPopStoreInstVar\"\n",
          "testPopStoreTemp": "testPopStoreTemp\n\t| temp |\n\tself test: [temp _ 1. temp _ 1. temp _ 1. temp _ 1. temp _ 1.\n\t\t\t  temp _ 1. temp _ 1. temp _ 1. temp _ 1. temp _ 1.\n\t\t\t  temp _ 1. temp _ 1. temp _ 1. temp _ 1. temp _ 1.\n\t\t\t  temp _ 1. temp _ 1. temp _ 1. temp _ 1. temp _ 1. nil]\n\t\tlabeled: 'store into a temp, 20 times' repeated: 10000\n\n\t\"Benchmark new testPopStoreTemp\"\n",
          "testLoadTempNRef": "testLoadTempNRef\n\t| temp |\n\ttemp _ 1.\n\tself test: [temp == temp. temp == temp.\n\t\t\t  temp == temp. temp == temp.\n\t\t\t  temp == temp. temp == temp.\n\t\t\t  temp == temp. temp == temp.\n\t\t\t  temp == temp. temp == temp. nil]\n\t\tlabeled: 'load 1 as a temp, 20 times' repeated: 10000\n\n\t\"Benchmark new testLoadTempNRef\"\n",
          "testLoadLiteralNRef": "testLoadLiteralNRef\n\tself test: [3 == 3. 3 == 3. 3 == 3. 3 == 3. 3 == 3.\n\t\t\t  3 == 3. 3 == 3. 3 == 3. 3 == 3. 3 == 3. nil]\n\t\tlabeled: 'load nonRefcounted literal, 20 times' repeated: 10000\n\n\t\"Benchmark new testLoadLiteralNRef\"\n",
          "testLoadLiteralIndirect": "testLoadLiteralIndirect\n\tself test: [Point == Point. Point == Point.\n\t\t\t  Point == Point. Point == Point.\n\t\t\t  Point == Point. Point == Point.\n\t\t\t  Point == Point. Point == Point.\n\t\t\t  Point == Point. Point == Point. nil]\n\t\tlabeled: 'load literal indirect (overflow refct), 20 times' repeated: 10000\n\n\t\"Benchmark new testLoadLiteralIndirect\"\n",
          "testLoadTempRef": "testLoadTempRef\n\t| temp |\n\ttemp _ 0@0.\n\tself test: [temp == temp. temp == temp.\n\t\t\t  temp == temp. temp == temp.\n\t\t\t  temp == temp. temp == temp.\n\t\t\t  temp == temp. temp == temp.\n\t\t\t  temp == temp. temp == temp. nil]\n\t\tlabeled: 'load 0@0, 20 times' repeated: 10000\n\n\t\"Benchmark new testLoadTempRef\"\n"
        },
        "primitive byte codes": {
          "testPointX": "testPointX\n\t| pt |\n\tpt _ 0@0.\n\tself test: [pt x. pt x. pt x. pt x. pt x. pt x. pt x. pt x. pt x. pt x. nil]\n\t\tlabeled: 'execute aPoint x, 10 times' repeated: 10000\n\n\t\"Benchmark new testPointX\"\n",
          "testStreamNext": "testStreamNext\n\t| strm |\n\tstrm _ ReadStream on: 'abcdefghijklmnopqrstuvwxyz'.\n\tself test: [strm position: 0.\n\t\t\t  strm next. strm next. strm next. strm next.\n\t\t\t  strm next. strm next. strm next. strm next.\n\t\t\t  strm next. strm next. strm next. strm next.\n\t\t\t  strm next. strm next. strm next. strm next.\n\t\t\t  strm next. strm next. strm next. strm next. nil]\n\t\tlabeled: 'execute ReadStream next, 20 times' repeated: 1000\n\n\t\"Benchmark new testStreamNext\"\n",
          "testEQ": "testEQ\n\t| temp |\n\ttemp _ 1.\n\tself test: [temp == temp == temp == temp == temp ==\n\t\t\t  temp == temp == temp == temp == temp ==\n\t\t\t  temp == temp == temp == temp == temp ==\n\t\t\t  temp == temp == temp == temp == temp. nil]\n\t\tlabeled: 'send ==, 20 times' repeated: 10000\n\n\t\"Benchmark new testEQ\"\n",
          "testLoadThisContext": "testLoadThisContext\n\tself test: [thisContext == thisContext. thisContext == thisContext.\n\t\t\t  thisContext == thisContext. thisContext == thisContext.\n\t\t\t  thisContext == thisContext. thisContext == thisContext.\n\t\t\t  thisContext == thisContext. thisContext == thisContext.\n\t\t\t  thisContext == thisContext. thisContext == thisContext. nil]\n\t\tlabeled: 'load thisContext, 20 times' repeated: 10000\n\n\t\"Benchmark new testLoadThisContext\"\n",
          "testValue": "testValue\n\t| block |\n\tblock _ [3+4].\n\tself test: [block value. block value. block value. block value.\n\t\t\t  block value. block value. block value. block value.\n\t\t\t  block value. block value. block value. block value.\n\t\t\t  block value. block value. block value. block value.\n\t\t\t  block value. block value. block value. block value. nil]\n\t\tlabeled: 'evaluate the block: (3+4), 20 times' repeated: 1000\n\n\t\"Benchmark new testValue\"\n",
          "testCreation": "testCreation\n\tself test:\n\t\t\t[Point new. Point new. Point new. Point new. Point new.\n\t\t\t  Point new. Point new. Point new. Point new. Point new.\n\t\t\t  Point new. Point new. Point new. Point new. Point new.\n\t\t\t  Point new. Point new. Point new. Point new. Point new. nil]\n\t\tlabeled: 'create 20 uninitialized points' repeated: 1000\n\n\t\"Benchmark new testCreation\"\n",
          "testBlockCopy": "testBlockCopy\n\t| tC |\n\ttC _ thisContext.\n\tself test: [tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0.\n\t\t\t  tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0.\n\t\t\t  tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0.\n\t\t\t  tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0.\n\t\t\t  tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0. nil]\n\t\tlabeled: 'execute blockCopy: 0, 20 times' repeated: 1000\n\n\t\"Benchmark new testBlockCopy\"\n",
          "testClass": "testClass\n\t| pt |\n\tpt _ 0@0.\n\tself test:\n\t\t\t[pt class. pt class. pt class. pt class. pt class.\n\t\t\t pt class. pt class. pt class. pt class. pt class.\n\t\t\t pt class. pt class. pt class. pt class. pt class.\n\t\t\t pt class. pt class. pt class. pt class. pt class. nil]\n\t\tlabeled: 'send #class 20 times (to a point)' repeated: 1000\n\n\t\"Benchmark new testClass\"\n",
          "testStreamNextPut": "testStreamNextPut\n\t| strm ch |\n\tstrm _ ReadWriteStream on: 'abcdefghijklmnopqrstuvwxyz'.\n\tch _ $q.\n\tself test: [strm position: 0.\n\t\t\t  strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. strm nextPut: ch.\n\t\t\t  strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. strm nextPut: ch.\n\t\t\t  strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. strm nextPut: ch.\n\t\t\t  strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. strm nextPut: ch.\n\t\t\t  strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. nil]\n\t\tlabeled: 'execute ReadWriteStream nextPut:, 20 times' repeated: 1000\n\n\t\"Benchmark new testStreamNextPut\"\n",
          "testPointCreation": "testPointCreation\n\tself test: [3@4. 3@4. 3@4. 3@4. 3@4. 3@4. 3@4. 3@4. 3@4. 3@4. nil]\n\t\tlabeled: 'create 3@4, 10 times' repeated: 1000\n\n\t\"Benchmark new testPointCreation\"\n"
        },
        "testing": {
          "testList:toFile:": "testList: selectorList toFile: aFileStream\n\t\"This message allows you to test a series of benchmarks and record all the results on\n\ta file or stream.\"\n\n\tfromList _ true.\n\tself fileOutputParameters: aFileStream.\n\tselectorList do:\n\t\t[:selector | self perform: selector.\n\t\t verboseTranscript ifTrue:\n\t\t\t[Transcript show: 'press any mouse button to continue'.\n\t\t\t Sensor waitButton.\n\t\t\t Transcript clear; refresh]].\n\treporting ifTrue: [self closeOutput: reportStream].\n\tfromList _ false.\n\n\t\"Benchmark new testList: #(testLoadInstVar testLoadLiteralIndirect testLoadLiteralNRef testLoadQuickConstant testLoadTempNRef) toFile: (FileStream fileNamed: 'Smalltalk.timing')\"\n",
          "test:labeled:repeated:": "test: aBlock labeled: label repeated: nTimes\n\t\"This is the main message to a Benchmark. aBlock is repeated nTimes, and the\n\tresults are reported.\"\n\n\t| time |\n\ttime _ self time: aBlock repeated: nTimes.\n\tself\n\t\treport: label\n\t\ttimedAt: time\n\t\trepeated: nTimes\n",
          "testList:": "testList: selectorList\n\t\"This message allows you to test a series of benchmarks and record all the results on\n\ta file or stream.\"\n\n\tfromList _ true.\n\tself setOutputParameters.\n\tselectorList do:\n\t\t[:selector | self perform: selector.\n\t\t verboseTranscript ifTrue:\n\t\t\t[Transcript show: 'press any mouse button to continue'.\n\t\t\t Sensor waitButton.\n\t\t\t Transcript clear; refresh]].\n\treporting ifTrue: [self closeOutput: reportStream].\n\tfromList _ false.\n\n\t\"Benchmark new testList: #(testLoadInstVar testLoadLiteralIndirect testLoadLiteralNRef testLoadQuickConstant testLoadTempNRef)\"\n",
          "time:repeated:": "time: aBlock repeated: nTimes\n\t\"Answer how many milliseconds it takes to repeat aBlock nTimes, corrected for the\n\ttime to repeat an empty block.\"\n\n\t| i emptyBlock emptyTime blockTime iBox |\n\tnTimes > 10000 ifTrue: [^self time: aBlock repeated10K: nTimes // 10000].\n\temptyBlock _ [].\n\temptyTime _ Time millisecondsToRun:\n\t\t\t\t\t\t\t[i _ 0.\n\t\t\t\t\t\t\t [(i _ i + 1) <= nTimes] whileTrue: [emptyBlock value]].\n\tblockTime _ Time millisecondsToRun:\n\t\t\t\t\t\t\t[i _ 0.\n\t\t\t\t\t\t\t [(i _ i + 1) <= nTimes] whileTrue: [aBlock value]].\n\t^blockTime - emptyTime\n",
          "time:repeated10K:": "time: aBlock repeated10K: tenKTimes\n\t| i emptyBlock emptyTime blockTime |\n\ttenKTimes > 10000 ifTrue: [^self error: 'one hundred million repetitions is my limit'].\n\temptyBlock _ [].\n\temptyTime _\n\t\t\tTime millisecondsToRun:\n\t\t\t\t\t[1 to: tenKTimes do:\n\t\t\t\t\t\t[:j |\n\t\t\t\t\t\ti _ 0.\n\t\t\t\t\t\t[(i _ i + 1) <= 10000]\n\t\t\t\t\t\t\twhileTrue: [emptyBlock value]]].\n\tblockTime _\n\t\t\tTime millisecondsToRun:\n\t\t\t\t\t[1 to: tenKTimes do:\n\t\t\t\t\t\t[:j |\n\t\t\t\t\t\ti _ 0.\n\t\t\t\t\t\t[(i _ i + 1) <= 10000]\n\t\t\t\t\t\t\twhileTrue: [aBlock value]]].\n\t^blockTime - emptyTime\n"
        },
        "instance initialization": {
          "fileOutputParameters:": "fileOutputParameters: aFileStream\n\treporting _ true.\n\treportStream _ aFileStream.\n\tverboseTranscript _ false\n",
          "defaultOutputParameters": "defaultOutputParameters\n\treporting _ false.\n\tverboseTranscript _ true.\n\tfromList _ false\n",
          "setOutputParameters": "setOutputParameters\n\tBinaryChoice\n\t\tmessage: 'Would you like the transcript to just show labels, rather than full reports?'\n\t\tdisplayAt: Sensor mousePoint\n\t\tcentered: true\n\t\tifTrue: [verboseTranscript _ false]\n\t\tifFalse: [verboseTranscript _ true].\n\tBinaryChoice\n\t\tmessage: 'Should the full reports to be output (saved on a file or stream)?'\n\t\tdisplayAt: Sensor mousePoint\n\t\tcentered: true\n\t\tifTrue: [reporting _ true]\n\t\tifFalse: [reporting _ false].\n\treporting ifTrue:\n\t\t[FillInTheBlank\n\t\t\trequest: 'Please supply desired output name'\n\t\t\tdisplayAt: Sensor mousePoint\n\t\t\tcentered: true\n\t\t\taction: [:answer | reportStream _ self makeOutputNamed: answer]\n\t\t\tinitialAnswer: '.timing']\n"
        },
        "private": {
          "sampleBitBLT": "sampleBitBLT\n\t^BitBlt\n\t\tdestForm: Display\n\t\tsourceForm: nil\n\t\thalftoneForm: Form black\n\t\tcombinationRule: Form reverse\n\t\tdestOrigin: 0@0\n\t\tsourceOrigin: 0@0\n\t\textent: 400@400\n\t\tclipRect: Display boundingBox\n",
          "favoriteStringHolderView": "favoriteStringHolderView\n\t| aStringHolderView message |\n\tmessage _ self longishString.\n\taStringHolderView _ StringHolderView container: (StringHolder new contents: message).\n\taStringHolderView window: (0@0 extent: 300@200).\n\taStringHolderView translateBy: 100@250.\n\taStringHolderView display.\n\t^aStringHolderView\n",
          "recur:": "recur: exp\n\t\"Invokes a recursion involving ((2 raisedTo: exp+1) - 1) activations and\n\treturns.\"\n\n\texp = 0 ifTrue: [^self].\n\tself recur: exp - 1.\n\t^self recur: exp - 1\n",
          "textForDisplay": "textForDisplay\n\t^self stringForDisplay asText\n",
          "longishString": "longishString\n\t^ 'Now is the time for all good people to come to the aid of the cause of world peace.  It is just fine, even desirable, to love your country, if that means wanting it to play a beneficial role in the course of world events and be the best possible example of a good society.  But if it means wanting dominion over the rest of the world, it is not love but defensiveness or self-glorification, and will lead only to oblivion.'\n",
          "stringForDisplay": "stringForDisplay\n\t^'testTextDisplay\n\t| clipRect para range scanner |\n\tclipRect _ Display boundingBox.\n\tpara _ Paragraph withText: self textForDisplay.\n\trange _ 1 to: para numberOfLines.\n\tscanner _ DisplayScanner new.\n\tself test: [scanner\n\t\t\t\tdisplayLines: range\n\t\t\t\tin: para\n\t\t\t\tclippedBy: clipRect]\n\t\tlabeled: ''displaying text'' repeated: 10\n\n\t\"Benchmark new testTextDisplay\"'\n"
        },
        "arithmetic": {
          "test3div4": "test3div4\n\tself test: [3//4. 3//4. 3//4. 3//4. 3//4. 3//4. 3//4. 3//4. 3//4. 3//4. nil]\n\t\tlabeled: 'divide 3 by 4, 10 times' repeated: 1000\n\n\t\"Benchmark new test3div4\"\n",
          "test16bitArith": "test16bitArith\n\t| twentyK |\n\ttwentyK _ 20000.\n\tself test: [twentyK+twentyK. twentyK+twentyK.\n\t\t\t  twentyK+twentyK. twentyK+twentyK.\n\t\t\t  twentyK+twentyK. twentyK+twentyK.\n\t\t\t  twentyK+twentyK. twentyK+twentyK.\n\t\t\t  twentyK+twentyK. twentyK+twentyK. nil]\n\t\tlabeled: 'add 20000 + 20000, 10 times' repeated: 1000\n\n\t\"Benchmark new test16bitArith\"\n",
          "test3plus4": "test3plus4\n\tself test: [3+4. 3+4. 3+4. 3+4. 3+4. 3+4. 3+4. 3+4. 3+4. 3+4. nil]\n\t\tlabeled: 'add 3 + 4, 10 times' repeated: 10000\n\n\t\"Benchmark new test3plus4\"\n",
          "test3times4": "test3times4\n\tself test: [3*4. 3*4. 3*4. 3*4. 3*4. 3*4. 3*4. 3*4. 3*4. 3*4. nil]\n\t\tlabeled: 'multiply 3 * 4, 10 times' repeated: 10000\n\n\t\"Benchmark new test3times4\"\n",
          "test3lessThan4": "test3lessThan4\n\tself test: [3<4. 3<4. 3<4. 3<4. 3<4. 3<4. 3<4. 3<4. 3<4. 3<4. nil]\n\t\tlabeled: 'test 3 < 4, 10 times' repeated: 10000\n\n\t\"Benchmark new test3lessThan4\"\n",
          "testLargeIntArith": "testLargeIntArith\n\t| eightyK |\n\teightyK _ 80000.\n\tself test: [eightyK+eightyK. eightyK+eightyK.\n\t\t\t  eightyK+eightyK. eightyK+eightyK.\n\t\t\t  eightyK+eightyK. eightyK+eightyK.\n\t\t\t  eightyK+eightyK. eightyK+eightyK.\n\t\t\t  eightyK+eightyK. eightyK+eightyK. nil]\n\t\tlabeled: 'add 80000 + 80000, 10 times' repeated: 100\n\n\t\"Benchmark new testLargeIntArith\"\n"
        },
        "macro operations": {
          "testPrintDefinition": "testPrintDefinition\n\t| class |\n\tclass _ Compiler.\n\tself test:\n\t\t\t[class definition]\n\t\tlabeled: 'print a class definition' repeated: 20\n\n\t\"Benchmark new testPrintDefinition\"\n",
          "testInspect": "testInspect\n\t| window |\n\tself test:\n\t\t\t[window _ InspectorView buildScheduledView:\n\t\t\t\t\t\t\t(Inspector inspect: Compiler new).\n\t\t\t  window release]\n\t\tlabeled: 'create an inspector view' repeated: 10\n\n\t\"Benchmark new testInspect\"\n",
          "testTextFormatting": "testTextFormatting\n\t| aString aView contents |\n\taString _ self stringForDisplay.\n\taView _ StringHolderView container: StringHolder new.\n\taView window: Display boundingBox viewport: (100@100 extent: 200@200).\n\tself test:\n\t\t\t[aView editString: (aString asText makeSelectorBoldIn: Benchmark) asParagraph]\n\t\tlabeled: 'format a bunch of text' repeated: 5.\n\taView release\n\n\t\"Benchmark new testTextFormatting\"\n",
          "testClassOrganizer": "testClassOrganizer\n\t| class |\n\tclass _ Benchmark.\n\tself test:\n\t\t\t[class organization changeFromString: class organization printString]\n\t\tlabeled: 'read and write class organization' repeated: 1\n\n\t\"Benchmark new testClassOrganizer\"\n",
          "testCompiler": "testCompiler\n\tself test:\n\t\t\t[Benchmark compile:\n'dummy: aBlock repeated: nTimes | i emptyBlock emptyTime blockTime |\n\tnTimes > 1000 ifTrue: [^self time: aBlock repeatedK: nTimes // 1000].\n\temptyBlock _ [].\n\temptyTime _ Time millisecondsToRun:\n\t\t\t\t\t[i _ 0.\n\t\t\t\t\t [(i _ i + 1) <= nTimes] whileTrue: [emptyBlock value]].\n\tblockTime _ Time millisecondsToRun:\n\t\t\t\t\t[i _ 0.\n\t\t\t\t\t [(i _ i + 1) <= nTimes] whileTrue: [aBlock value]].\n\t^blockTime - emptyTime'\n\t\t\t\tnotifying: nil trailer: #(0 0 0)]\n\t\tlabeled: 'compile dummy method' repeated: 5.\n\tBenchmark removeSelector: #dummy:repeated:\n\n\t\"Benchmark new testCompiler\"\n",
          "testPrintHierarchy": "testPrintHierarchy\n\t| class |\n\tclass _ InstructionStream.\n\tself test:\n\t\t\t[class printHierarchy]\n\t\tlabeled: 'print a class hierarchy' repeated: 10\n\n\t\"Benchmark new testPrintHierarchy\"\n",
          "testAllImplementors": "testAllImplementors\n\tself test:\n\t\t\t[Smalltalk allImplementorsOf: #next]\n\t\tlabeled: 'find all implementors of #next' repeated: 1\n\n\t\"Benchmark new testAllImplementors\"\n",
          "testKeyboardSingle": "testKeyboardSingle\n\t| aStringHolderView insert inputter editor |\n\taStringHolderView _ self favoriteStringHolderView.\n\teditor _ aStringHolderView controller.\n\teditor selectAt: 5.\n\tinputter _ editor sensor class classPool at: #CurrentInputState.\n\tSensor flushKeyboard.\n\tself test:\n\t\t\t['Now! ' do:\n\t\t\t\t[:char |\n\t\t\t\t inputter keyAt: char asciiValue put: 1.\n\t\t\t\t editor readKeyboard]]\n\t\tlabeled: 'text keyboard response for single keystroke' repeated: 3.\n\taStringHolderView release\n\n\t\"Benchmark new testKeyboardSingle\"\n",
          "testTextEditing": "testTextEditing\n\t| aStringHolderView editor selectPoint |\n\taStringHolderView _ self favoriteStringHolderView.\n\teditor _ aStringHolderView controller.\n\tselectPoint _ 0.\n\tself test:\n\t\t\t[editor selectAt: (selectPoint _ selectPoint + 5).\n\t\t\t editor replaceSelectionWith: 'Now! ' asText]\n\t\tlabeled: 'text replacement and redisplay' repeated: 20.\n\taStringHolderView release\n\n\t\"Benchmark new testTextEditing\"\n",
          "testDecompiler": "testDecompiler\n\t| class |\n\tclass _ InputSensor.\n\tself\n\t\ttest: [class selectors do:\n\t\t\t\t[:sel | (Decompiler new\n\t\t\t\t\t\tdecompile: sel\n\t\t\t\t\t\tin: class\n\t\t\t\t\t\tmethod: (class compiledMethodAt: sel)) decompileString]]\n\t\tlabeled: 'decompile class InputSensor' repeated: 1\n\n\t\"Benchmark new testDecompiler\"\n",
          "testAllCallsOn": "testAllCallsOn\n\tself test:\n\t\t\t[Smalltalk allCallsOn: #printStringRadix:]\n\t\tlabeled: 'find all calls on #printStringRadix:' repeated: 1\n\n\t\"Benchmark new testAllCallsOn\"\n",
          "testTextDisplay": "testTextDisplay\n\t| para |\n\tpara _ Paragraph withText: self textForDisplay.\n\tpara displayAt: 200@200.\n\tself test: [para displayAt: 200@200]\n\t\tlabeled: 'display text' repeated: 10\n\n\t\"Benchmark new testTextDisplay\"\n",
          "testKeyboardLookAhead": "testKeyboardLookAhead\n\t| aStringHolderView insert inputter editor |\n\taStringHolderView _ self favoriteStringHolderView.\n\teditor _ aStringHolderView controller.\n\teditor selectAt: 5.\n\tinputter _ editor sensor class classPool at: #CurrentInputState.\n\tSensor flushKeyboard.\n\tself test:\n\t\t\t['Now! ' do:\n\t\t\t\t[:char |\n\t\t\t\t inputter keyAt: char asciiValue put: 1].\n\t\t\t\t editor readKeyboard]\n\t\tlabeled: 'text keyboard response using lookahead buffer' repeated: 3.\n\taStringHolderView release\n\n\t\"Benchmark new testKeyboardLookAhead\"\n"
        },
        "control": {
          "testActivationReturn": "testActivationReturn\n\tself test:\n\t\t\t[self recur: 14]\n\t\tlabeled: 'activate and return, 32K times' repeated: 1\n\n\t\"Benchmark new testActivationReturn\"\n",
          "testShortBranch": "testShortBranch\n\tself test: [false ifTrue: [1] ifFalse: [2].\n\t\t\t  false ifTrue: [1] ifFalse: [2].\n\t\t\t  false ifTrue: [1] ifFalse: [2].\n\t\t\t  false ifTrue: [1] ifFalse: [2].\n\t\t\t  false ifTrue: [1] ifFalse: [2].\n\t\t\t  false ifTrue: [1] ifFalse: [2].\n\t\t\t  false ifTrue: [1] ifFalse: [2].\n\t\t\t  false ifTrue: [1] ifFalse: [2].\n\t\t\t  false ifTrue: [1] ifFalse: [2].\n\t\t\t  false ifTrue: [1] ifFalse: [2]. nil]\n\t\tlabeled: 'short branch on false, 10 times' repeated: 10000\n\n\t\"Benchmark new testShortBranch\"\n",
          "testWhileLoop": "testWhileLoop\n\t| temp |\n\tself test: [temp _ 10000.\n\t\t\t  [temp > 0] whileTrue: [temp _ temp - 1].\n\t\t\t  nil]\n\t\tlabeled: 'simple whileLoop, 10000 times through' repeated: 10\n\n\t\"Benchmark new testWhileLoop\"\n"
        }
      }
    },
    "InputSensor": {
      "comment": "I represent an interface to the user input devices.  There is at least one instance of me named Sensor in the system.\n\n\tkeyboardMap  - <String> indexed by (256 * meta key state + ASCII code + 1)\n",
      "class_name": "InputSensor",
      "superclass": "Object",
      "instanceVariables": "keyboardMap",
      "classInstanceVariables": "",
      "classVariables": "CurrentCursor CurrentInputState DefaultKeyboardMap",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "install": "install\n\t\"Create an instance of InputState for accessing the hardware, and save it\n\tin the class variable CurrentInputState.\"\n\n\tCurrentInputState _ InputState new.\n\tCurrentInputState install\n",
          "initialize": "initialize\n\t| map base array |\n\tmap _ String new: 256*5.\n\t1 to: map size do: [:i | map at: i put: 255 asCharacter].  \"Unassigned\"\n\t#(\n\t  \"Unshifted characters\"\n\t  (0 8 (8 9 30 255 255 13 255 255\n\t\t255 255 255 255 255 255 255 255 255 255 255 160))\n\t  (0 32 ' !\"#$%&''()*+,-./0123456789:;<=>?')\n\t  (0 64 '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_')\n\t  (0 96 '`abcdefghijklmnopqrstuvwxyz{|}~')\n\t  (0 127 (173))\n\t  (0 140 (158 29 25 174 187 190))\n\t  \"Shift\"\n\t  (256 8 (8 9 30 255 255 13 255 255\n\t\t255 255 255 255 255 255 255 255 255 255 255 160))\n\t  (256 32 ' ')\n\t  (256 $' '\"')\n\t  (256 $, '<')\n\t  (256 $- (21))\n\t  (256 $. '>?')\n\t  (256 $0 ')!@#$%~&*(')\n\t  (256 $; ':')\n\t  (256 $= '+')\n\t  (256 $[ '{|}')\n\t  (256 $_ '^')\n\t  (256 $a 'ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n\t  (256 127 (173))\n\t  (256 140 (22 29 25 238 253 254))\n\t  \"Control\"\n\t  (512 8 (8 9 30 255 255 141 255 255\n\t\t255 255 255 255 255 255 255 255 255 255 255 160))\n\t  (512 32\n\t\t(32 255 255 255 255 255 255 15 255 255 255 255 1 137 18 27\n\t\t135 159 144 143 128 127 129 131 180 149 255 3 255 6 255 255))\n\t  (512 $[ (7 14 23 255 17))\n\t  (512 $a \"through $z\"\n\t\t(1 166 3 132 130 12 231 179 150 165 136 153 182 14 15\n\t\t138 17 18 19 11 21 134 145 151 178 167))\n\t  (512 127 (173))\n\t  (512 140 (222 229 225 174 187 190))\n\t  \"Shift+control\"\n\t  (768 8 (8 9 30 255 255 13 255 255\n\t\t255 255 255 255 255 255 255 255 255 255 255 160))\n\t  (768 32\n\t\t(32 255 255 255 255 255 255 219 255 255 255 255 218 201 233 203\n\t\t199 223 208 207 192 191 193 195 244 213 255 3 255 14 255 255))\n\t  (768 $[ (249 204 220 255 236))\n\t  (768 $a \"through $z\"\n\t\t(212 230 228 196 194 226 241 243 214 229 200 217 246 245 216\n\t\t202 210 239 211 240 197 198 209 215 242 231))\n\t  (768 127 (173))\n\t  (768 140 (22 24 25 238 253 254))\n\t  \"Upper case lock\"\n\t  (1024 8 (8 9 30 255 255 13 255 255\n\t\t255 255 255 255 255 255 255 255 255 255 255 160))\n\t  (1024 32 ' !\"#$%&''()*+,-./0123456789:;<=>?')\n\t  (1024 64 '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_')\n\t  (1024 96 '`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~')\n\t  (1024 127 (173))\n\t  (1024 140 (158 29 25 174 187 190))\n\t ) do:\n\t  [:part |\n\t\tbase _ (part at: 1) + (part at: 2) asInteger.\n\t\tarray _ part at: 3.\n\t\t1 to: array size do:\n\t\t  [:i | map at: base + i put: (array at: i) asCharacter]].\n\tDefaultKeyboardMap _ map\n\n\t\"InputSensor initialize; install.\n\tSensor initMap.\"\n"
        },
        "constants": {
          "default": "default\n\t\"Answer the default system InputSensor, Sensor.\"\n\t^Sensor\n",
          "initSensor": "initSensor\n\t\"Create the default system InputSensor, Sensor.\"\n\tSensor _ InputSensor new\n"
        },
        "instance creation": {
          "new": "new\n\t^super new initMap\n"
        }
      },
      "instance_methods": {
        "mouse": {
          "anyButtonPressed": "anyButtonPressed\n\t\"Answer whether a mouse button is being pressed.\"\n\t^self buttons > 0\n",
          "waitClickButton": "waitClickButton\n\t\"Wait for the user to click (press and then release) any mouse button and then\n\tanswer with the current location of the cursor.\"\n\tself waitButton.\n\t^self waitNoButton\n",
          "noButtonPressed": "noButtonPressed\n\t\"Answer whether any mouse button is not being pressed.\"\n\t^self anyButtonPressed == false\n",
          "mousePointNext": "mousePointNext\n\t\"Answer the next mouse point if red button or tablet is down; false otherwise.\"\n\tself redButtonPressed ifTrue: [^self mousePoint].\n\t^false\n",
          "waitButton": "waitButton\n\t\"Wait for the user to press any mouse button and then answer with the\n\tcurrent location of the cursor.\"\n\t[self anyButtonPressed] whileFalse.\n\t^self cursorPoint\n",
          "yellowButtonPressed": "yellowButtonPressed\n\t\"Answer whether only the yellow mouse button is being pressed.\"\n\t^self buttons = 2\n",
          "mousePoint": "mousePoint\n\t\"Answer a Point indicating the coordinates of the current mouse location.\"\n\t^self primMousePt\n",
          "waitNoButton": "waitNoButton\n\t\"Wait for the user to release any mouse button and then answer with the\n\tcurrent location of the cursor.\"\n\t[self anyButtonPressed] whileTrue.\n\t^self cursorPoint\n",
          "blueButtonPressed": "blueButtonPressed\n\t\"Answer whether only the blue mouse button is being pressed.\"\n\t^self buttons = 1\n",
          "redButtonPressed": "redButtonPressed\n\t\"Answer whether only the red mouse button is being pressed.\"\n\t^self buttons = 4\n"
        },
        "private": {
          "primLeftShiftDown": "primLeftShiftDown\n\t^CurrentInputState leftShiftDown\n",
          "primMousePt": "primMousePt\n\t\"Poll the mouse to find out its position. Return a Point. Fail if event-driven\n\ttracking is used instead of polling. Optional. See Object documentation\n\twhatIsAPrimitive. \"\n\n\t<primitive: 90>\n\t^CurrentInputState mousePoint\n",
          "buttons": "buttons\n\t^self primMouseButtons\n",
          "primCursorLocPut:": "primCursorLocPut: pt\n\tCurrentInputState cursorPoint: pt\n",
          "initMap": "initMap\n\t\"Initialize a new instance with the default keyboard map\"\n\n\tkeyboardMap _ DefaultKeyboardMap\n",
          "primMouseButtons": "primMouseButtons\n\t^CurrentInputState mouseButtons\n",
          "primKbdNext": "primKbdNext\n\t^CurrentInputState keyboardNext\n",
          "primKbdPeek": "primKbdPeek\n\t^CurrentInputState keyboardPeek\n"
        },
        "current cursor": {
          "currentCursor": "currentCursor\n\t\"Answer the instance of Cursor currently displayed.\"\n\t^CurrentCursor\n",
          "cursorPoint:": "cursorPoint: aPoint\n\t\"Set aPoint to be the current cursor location.\"\n\t^self primCursorLocPut: aPoint + CurrentCursor offset\n",
          "currentCursor:": "currentCursor: newCursor\n\t\"Set newCursor to be the displayed Cursor form.\"\n\tCurrentCursor offset = newCursor offset\n\t\tifFalse: [self primCursorLocPut: self cursorPoint + newCursor offset].\n\tCurrentCursor _ newCursor.\n\tCursor currentCursor: CurrentCursor\n",
          "cursorPoint": "cursorPoint\n\t\"Answer a Point indicating the cursor location.\"\n\t^self mousePoint - CurrentCursor offset\n"
        },
        "keyboard": {
          "mapKeyboardEvent:": "mapKeyboardEvent: aKeyboardEvent\n\t\"Answer the character corresponding to the character in aKeyboardEvent\"\n\n\t| meta |\n\tmeta _ aKeyboardEvent hasShift\n\t\t\t\tifTrue: [256]\n\t\t\t\tifFalse: [0].\n\taKeyboardEvent hasCtrl ifTrue: [meta _ meta + 512].\n\tmeta = 0 ifTrue: [aKeyboardEvent hasLock ifTrue: [meta _ 1024]].\n\t^keyboardMap at: aKeyboardEvent keyCharacter asciiValue + meta + 1\n",
          "keyboard": "keyboard\n\t\"Answer the next character from the keyboard buffer as a fully decoded\n\t(ASCII) character.\"\n\n\t^self mapKeyboardEvent: self primKbdNext\n",
          "keyboardEvent": "keyboardEvent\n\t\"Answer the next character from the keyboard buffer as a KeyboardEvent.\"\n\n\t^self primKbdNext\n",
          "flushKeyboard": "flushKeyboard\n\t\"Remove all characters from the keyboard buffer.\"\n\n\t[self keyboardPressed]\n\t\twhileTrue: [self keyboard]\n",
          "leftShiftDown": "leftShiftDown\n\t\"Answer true if the left shift key on the keyboard is being held down.\"\n\n\t^self primLeftShiftDown\n",
          "keyboardPeek": "keyboardPeek\n\t\"Answer the next character in the keyboard buffer or false if it is empty.\n\tself keyboardPressed must be true, else an error is created.\"\n\n\tself keyboardPressed ifTrue: [^self mapKeyboardEvent: self primKbdPeek].\n\tself error: 'Cant peek when nothing there'\n",
          "keyboardPressed": "keyboardPressed\n\t\"Answer false if the keyboard buffer is empty, else true.\"\n\n\t^self primKbdPeek notNil\t\"The keyboard queue only contains real keystrokes, so\n\t\t\t\t\t\t\t\tjust test if it is non-empty.\"\n"
        }
      }
    },
    "KeyboardEvent": {
      "comment": "I represent a keyboard event consisting of a non-meta key being struck plus the state of the meta keys at that moment.  Only InputState creates instances of me.\n\nInstance Variables:\n\t\tkeyCharacter \"<Integer> non-meta key character\"\n\t\tmetaState \"<Integer> combined state of meta keys\"\n",
      "class_name": "KeyboardEvent",
      "superclass": "Object",
      "instanceVariables": "keyCharacter metaState",
      "classInstanceVariables": "",
      "classVariables": "",
      "poolDictionaries": "",
      "class_methods": {
        "instance creation": {
          "code:meta:": "code: code meta: meta\n\t\"Answer an instance of me, with code the regular key and meta the special\n\tkeys--ctrl, shift, lock.\"\n\t^self new key: code meta: meta\n"
        }
      },
      "instance_methods": {
        "testing": {
          "hasLock": "hasLock\n\t\"Answer whether the shift key is locked.\"\n\t^metaState anyMask: 4\n",
          "hasShift": "hasShift\n\t\"Answer whether a shift key was pressed.\"\n\t^metaState anyMask: 1\n",
          "hasCtrl": "hasCtrl\n\t\"Answer whether a control key was pressed.\"\n\t^metaState anyMask: 2\n"
        },
        "accessing": {
          "metaState": "metaState\n\t\"Answer the state of the special keyboard characters--control, shift, lock.\"\n\t^metaState\n",
          "keyCharacter": "keyCharacter\n\t\"Answer the keyboard character of the receiver.\"\n\t^keyCharacter\n"
        },
        "private": {
          "key:meta:": "key: anInteger meta: meta\n\tkeyCharacter _ anInteger asCharacter.\n\tmetaState _ meta\n"
        }
      }
    },
    "MessageTally": {
      "comment": "See the comment for spyOn: in MessageTally class for an example of how to use the spy.\n\nMessageTallies represent nodes in a tree which gathers statistics on the time spent in various parts of the system.  Specifically, each node represents a message being sent.  During the evaluation of an expression, a timer periodically interrupts the execution of the various methods involved, and tallies these probes in the tree of MessageTallies which it constructs.  When evaluation of the expression is complete, a detailed report is produced indicating where in the system most of the time was spent.\n\nInstance variables:\n\tclass\t\t<Behavior> the class of the receiver of the message\n\tmethod\t\t<CompiledMethod> which was running when probe occurred\n\ttally\t\t<Integer> number of probes which hit this method or others\n\t\t\t\tcalled by it\n\treceivers\t<Collection of MessageTally> sons of this node in the tree,\n\t\t\t\trepresenting tallies of methods called from this one.\n\t\t\t\tIf this field is nil, it indicates tallies due to in-line primitives\n\nMessageTallies may be taken on only one block at a time.  Spying on two blocks at once does not work.  The block upon which the MessageTally is spying can be stopped and started.  See spyEvery:on:.\n",
      "class_name": "MessageTally",
      "superclass": "Magnitude",
      "instanceVariables": "class method tally receivers",
      "classInstanceVariables": "",
      "classVariables": "HowOften ObservedProcess TargetBlock Timer",
      "poolDictionaries": "",
      "class_methods": {
        "spying": {
          "spyOn:to:": "spyOn: aBlock to: fileName\n\t\"Spy on the evaluation of aBlock.  Write the data collected on a file named fileName.\n\tThe value of the block is returned as the value of this method.  For example:\n\t\tMessageTally spyOn: [Smalltalk asSortedCollection] to: 'spy.results'.\n\t\t(FileStream oldFileNamed: 'spy.results') edit.\n\t\"\n\t| spy val aFileStream |\n\tspy _ self new.\n\t\"Set up the block\"\n\tspy spyEvery: spy defaultInterval on: aBlock.\n\t\t\"Run the block and take the tallies\"\n\tval _ spy continueSpying.\n\t\t\"Report it\"\n\taFileStream _ FileStream fileNamed: fileName.\n\taFileStream timeStamp; nextPutAll: fileName; space.\n\tspy reportOn: aFileStream; close.\n\taFileStream close.\n\t^val\n",
          "spyOn:": "spyOn: aBlock\n\t\"An execution profile of the execution of aBlock is obtained.  For example:\n\t\tMessageTally spyOn: [Pen example].\n\tThe execution profile is presented in a workspace (user is prompted for area).\n\tNo value is returned\"\n\t| spy val reportStream |\n\tspy _ self new.\n\t\"Set up the block\"\n\tspy spyEvery: spy defaultInterval on: aBlock.\n\t\"Run the block and take the tallies\"\n\tval _ spy continueSpying.\n\t\"Report it\"\n\treportStream _ WriteStream on: (String new: 5000).\n\tspy reportOn: reportStream; close.\n\tStringHolderView\n\t\topen: (StringHolder new contents: reportStream contents)\n\t\tlabel: 'Spy Results'.\n\t^val  \"Never gets returned due to window scheduling\"\n"
        }
      },
      "instance_methods": {
        "comparing": {
          "hash": "hash\n\t^method asOop\n",
          ">": "> aMessageTally\n\t^tally < aMessageTally tally\n",
          "<": "< aMessageTally\n\t^tally > aMessageTally tally\n",
          "=": "= aMessageTally\n\t^aMessageTally method == method\n",
          "sonsOver:": "sonsOver: threshold\n\t| hereTally last sons |\n\t(receivers == nil or: [receivers size = 0]) ifTrue: [^#()].\n\thereTally _ tally.\n\tsons _ receivers select:  \"subtract subNode tallies for primitive hits here\"\n\t\t[:son |\n\t\thereTally _ hereTally - son tally.\n\t\tson tally > threshold].\n\thereTally > threshold\n\t\tifTrue:\n\t\t\t[last _ MessageTally new class: class method: method.\n\t\t\t^sons copyWith: (last primitives: hereTally)].\n\t^sons\n"
        },
        "collecting leaves": {
          "into:": "into: aDictionary\n\t| aMessageTally index |\n\tindex _\n\t\taDictionary\n\t\t\tfind: self\n\t\t\tifAbsent:\n\t\t\t\t[aDictionary add:\n\t\t\t\t\t(aMessageTally _ MessageTally new class: class method: method).\n\t\t\t\t^aMessageTally bump: tally].\n\t(aDictionary basicAt: index) bump: tally\n",
          "bump:": "bump: anInteger\n\ttally _ tally + anInteger\n",
          "leaves:": "leaves: leafDictionary\n\t| aBreakDown |\n\taBreakDown _ self sonsOver: 0.\n\taBreakDown size = 0\n\t\tifTrue:\n\t\t\t[self into: leafDictionary]\n\t\tifFalse:\n\t\t\t[aBreakDown do: [:aMessageTally | aMessageTally leaves: leafDictionary]]\n"
        },
        "printing": {
          "treePrintOn:tabs:thisTab:total:over:": "treePrintOn: aStream tabs: tabs thisTab: myTab total: total over: threshold\n\t| sons sonTab |\n\ttabs do: [:tab | aStream nextPutAll: tab].\n\ttabs size > 0 ifTrue: [self printOn: aStream total: total].\n\tsons _ self sonsOver: threshold.\n\tsons isEmpty ifFalse:\n\t\t[tabs addLast: myTab.\n\t\tsons _ sons asSortedCollection.\n\t\t(1 to: sons size) do:\n\t\t\t[:i |\n\t\t\tsonTab _ i < sons size ifTrue: ['  |'] ifFalse: ['  '].\n\t\t\t(sons at: i)\n\t\t\t\ttreePrintOn: aStream tabs: tabs thisTab: sonTab total: total over: threshold].\n\t\ttabs removeLast]\n",
          "fullPrintOn:cutoff:": "fullPrintOn: aStream cutoff: perCent\n\t| threshold |\n\tthreshold _ (perCent asFloat / 100 * tally) rounded.\n\taStream nextPutAll: '**Tree**'; cr.\n\tself treePrintOn: aStream\n\t\ttabs: OrderedCollection new\n\t\tthisTab: ''\n\t\ttotal: tally\n\t\tover: threshold.\n\taStream nextPut: Character newPage; cr.\n\taStream nextPutAll: '**Leaves**'; cr.\n\tself leavesPrintOn: aStream\n\t\tover: threshold.\n",
          "printOn:total:": "printOn: aStream total: total\n\t| aSelector aClass |\n\taStream print: (tally asFloat / total * 100.0 roundTo: 0.1); space.\n\treceivers == nil\n\t\tifTrue: [aStream nextPutAll: 'primitives']\n\t\tifFalse:\n\t\t\t[aSelector _ class selectorAtMethod: method setClass: [:aClass].\n\t\t\taStream nextPutAll: aClass name; space; nextPutAll: aSelector].\n\taStream cr\n",
          "leavesPrintOn:over:": "leavesPrintOn: aStream over: threshold\n\t| aSet |\n\taSet _ Set new: 128.\n\tself leaves: aSet.\n\t(aSet asOrderedCollection select: [:node | node tally > threshold])\n\t\tasSortedCollection do:\n\t\t[:node | node printOn: aStream total: tally]\n"
        },
        "private": {
          "method": "method\n\t^method\n",
          "class:method:": "class: aClass method: aMethod\n\tclass _ aClass.\n\tmethod _ aMethod.\n\ttally _ 0.\n\treceivers _ Array new: 0\n",
          "primitives:": "primitives: anInteger\n\ttally _ anInteger.\n\treceivers _ nil\n",
          "tally": "tally\n\t^tally\n"
        },
        "initialize-release": {
          "spyOn:to:": "spyOn: aBlock to: fileName\n\t\"Spy on the evaluation of aBlock.  Write the data collected on a file named fileName.\"\n\t| val aFileStream |\n\t\t\"Set up the block\"\n\tself spyEvery: self defaultInterval on: aBlock.\n\t\t\"Run the block and take the tallies\"\n\tval _ self continueSpying.\n\t\t\"Report it\"\n\taFileStream _ FileStream fileNamed: fileName.\n\taFileStream timeStamp; nextPutAll: fileName; space.\n\tself reportOn: aFileStream.\n\tself close.\n\taFileStream close.\n\t^val\n",
          "defaultInterval": "defaultInterval\n\t\"Answer the number of ticks between sampling.\"\n\n\tSmalltalk frills ifTrue: [^16] ifFalse: [^60]\n",
          "spyEvery:on:": "spyEvery: millisecs on: aBlock\n\t\"Create a spy on the given block at the specified rate.  Don't run it yet\"\n\t(aBlock isMemberOf: BlockContext)\n\t\tifFalse: [self error: 'spy needs a block here'].\n\tself class: aBlock receiver class method: aBlock method.\n\t\t\"set up the probe\"\n\tObservedProcess _ Processor activeProcess.\n\tHowOften _ millisecs.\n\tTargetBlock _ aBlock\n\n\"Set a block up for spying, and accumulate the tallies from several executions\n\t| spy |\n\tspy _ MessageTally new.\n\tspy spyEvery: spy defaultInterval on:\n\t\t['this block contains your code'. 30 factorial].\n\t10 timesRepeat: [spy continueSpying].\n\tspy report: 'spy.results'.  spy close.\n\t(Disk file: 'spy.results') edit.\n\nIf there are no tallies reported, the block executes faster than the delay\"\n",
          "continueSpying": "continueSpying\n\t| myDelay value active |\n\tmyDelay _ Delay forMilliseconds: HowOften.\n\tactive _ true.\n\tTimer _\n\t\t[[active] whileTrue:\n\t\t\t[myDelay wait.\n\t\t\tactive ifTrue: [self tally: ObservedProcess suspendedContext]].\n\t\tnil] newProcess.\n\tTimer priority: Processor userInterruptPriority.\n\t\t\"activate the probe and evaluate the block\"\n\tTimer resume.\n\tvalue _ TargetBlock value.\n\tactive _ false.\n\t\t\"Timer will fire once more, not tally, and terminate itself\"\n\t^value  \"return the block's value\"\n",
          "reportOn:": "reportOn: aStream\n\t\"Default cutoff percentage is 2%.\"\n\tself reportOn: aStream cutoff: 2\n",
          "spyOn:": "spyOn: aBlock\n\t\"Spy on the evaluation of aBlock.  Browse the results in a workspace.\"\n\t| val reportStream |\n\t\"Set up the block\"\n\tself spyEvery: self defaultInterval on: aBlock.\n\t\"Run the block and take the tallies\"\n\tval _ self continueSpying.\n\t\"Report it\"\n\treportStream _ WriteStream on: (String new: 5000).\n\tself reportOn: reportStream.\n\tself close.\n\tStringHolderView\n\t\topen: (StringHolder new contents: reportStream contents)\n\t\tlabel: 'Spy Results'.\n\t^val  \"Never gets returned due to window scheduling\"\n",
          "close": "close\n\t(Timer isMemberOf: Process) ifTrue: [Timer terminate].\n\tTimer _ ObservedProcess _ nil.\n\tclass _ method _ tally _ receivers _ nil\n",
          "reportOn:cutoff:": "reportOn: aStream cutoff: perCent\n\t\"Print a report on the stream. perCent should be a number like 2 or 3\"\n\ttally = 0\n\t\tifTrue:\n\t\t\t[aStream nextPutAll: ' - no tallies obtained']\n\t\tifFalse:\n\t\t\t[aStream nextPutAll: ' - '; print: tally; nextPutAll: ' tallies.'; cr; cr.\n\t\t\tself fullPrintOn: aStream cutoff: perCent]\n"
        },
        "tallying": {
          "tallyPath:": "tallyPath: context\n\t| aMethod path |\n\taMethod _ context method.\n\treceivers do:\n\t\t[:aMessageTally |\n\t\taMessageTally method == aMethod ifTrue: [path _ aMessageTally]].\n\tpath == nil\n\t\tifTrue:\n\t\t\t[path _ MessageTally new class: context receiver class method: aMethod.\n\t\t\treceivers _ receivers copyWith: path].\n\t^path bump\n",
          "bump": "bump\n\ttally _ tally + 1\n",
          "tally:": "tally: context\n\t\"Explicitly tally the specified context and its stack.\"\n\n\t| root |\n\tcontext method == method ifTrue: [^self bump].\n\t(root _ context home sender) == nil ifTrue: [^self bump tallyPath: context].\n\t^(self tally: root) tallyPath: context\n"
        }
      }
    },
    "SystemDictionary": {
      "comment": "I am a special dictionary that supports protocol for asking questions about the structure of the system.  My only instance is Smalltalk.\n",
      "class_name": "SystemDictionary",
      "superclass": "Dictionary",
      "instanceVariables": "",
      "classInstanceVariables": "",
      "classVariables": "CachedClassNames Frills LowSpaceProcess LowSpaceSemaphore OopsLeftLimit SpecialSelectors SystemChanges WordsLeftLimit",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\tProject current noChanges\n\t\"SystemDictionary initialize\"\n"
        }
      },
      "instance_methods": {
        "change management": {
          "removeClassNamed:": "removeClassNamed: className\n\t\"Remove the class with the name className, and all of its subclasses, from the system, and note the removal in the system ChangeSet.\"\n\n\t| class |\n\tclass _ self at: className asSymbol ifAbsent: [^self].\n\tclass subclasses do:\n\t\t[:subclass | self removeClassNamed: subclass name]. \t\"remove subclasses first\"\n\tSystemChanges removeClass: class.\n\tSystemOrganization removeElement: className.\n\tself removeKey: className asSymbol.\n\tself flushClassNameCache.\n\tclass obsolete.\n",
          "newChanges:": "newChanges: aChangeSet\n\t\"Set the system ChangeSet to be aChangeSet.\"\n\tSystemChanges _ aChangeSet\n",
          "recover:": "recover: nCharacters\n\t\"Schedule an editable text view on the last n characters of changes.\"\n\n\t| changes |\n\tchanges _ SourceFiles at: 2.\n\tchanges setToEnd; skip: nCharacters negated.\n\t(Disk file: 'st80.recent') nextPutAll: changes; close; edit\n",
          "changes": "changes\n\t\"Answer the current system ChangeSet.\"\n\t^SystemChanges\n",
          "renameClass:as:": "renameClass: aClass as: newName\n\t\"Rename the class, aClass, to have the title newName.\"\n\n\t| oldref |\n\tSystemOrganization classify: newName under: aClass category.\n\tSystemOrganization removeElement: aClass name.\n\tSystemChanges renameClass: aClass as: newName.\n\toldref _ self removeKey: aClass name.\n\toldref key: newName.\n\t(Undeclared includesKey: newName)\n\t\tifTrue: [self at: newName put: aClass]\n\t\tifFalse: [self add: oldref \"Preserve old reference\"].\n\tself flushClassNameCache\n",
          "noChanges": "noChanges\n\t\"Initialize the system ChangeSet.\"\n\n\tSystemChanges initialize\n",
          "logChange:": "logChange: aStringOrText\n\t\"Write the argument, a String or Text, onto the changes file.\"\n\t| aFileStream aString |\n\tSourceFiles == nil\n\t\tifTrue: [^self].\n\t(aString isMemberOf: Text)\n\t\tifTrue: [aString _ aStringOrText string]\n\t\tifFalse: [aString _ aStringOrText].\n\t(aString isMemberOf: String)\n\t\tifFalse: [self error: 'cant log this change'].\n\t(aString findFirst: [:char | char isSeparator not]) = 0\n\t\tifTrue: [^self].  \"null doits confuse replay\"\n\taFileStream _ SourceFiles at: 2.\n\taFileStream setToEnd; readWrite.\n\taFileStream cr; cr; nextChunkPut: aString.\n\taFileStream readOnly\n"
        },
        "compiling": {
          "recompileAllFrom:": "recompileAllFrom: firstName\n\t\"Recompile all classes, starting with given name.\"\n\n\t| class |\n\tSmalltalk forgetDoIts.\n\tself allClassesDo:\n\t\t[:class | class name >= firstName\n\t\t\tifTrue:\n\t\t\t\t[Transcript show: class name; cr.\n\t\t\t\tclass compileAll]]\n\n\t\"Smalltalk recompileAllFrom: 'Aardvark'.\"\n",
          "recompileMethodsForWhich:": "recompileMethodsForWhich: aBlock\n\t\"Recompile all methods in the system for which aBlock evaluates to true.\n\tFor example,\n\t\tSmalltalk recompileMethodsForWhich: [:meth | meth size=6]\"\n\n\tCursor execute showWhile:\n\t\t[self allBehaviorsDo:\n\t\t\t[:class | class selectors do:\n\t\t\t\t[:sel | (aBlock value: (class compiledMethodAt: sel))\n\t\t\t\t\tifTrue:\n\t\t\t\t\t\t[Transcript show: class name , ' ' , sel; cr.\n\t\t\t\t\t\tclass recompile: sel]]]]\n",
          "recompileCallsOn:": "recompileCallsOn: aLiteral\n\t\"Recompile every message in the system that refers to aLiteral.\"\n\n\t| special |\n\tspecial _ self hasSpecialSelector: aLiteral ifTrueSetByte: [:byte ].\n\tCursor execute showWhile:\n\t\t[self allBehaviorsDo:\n\t\t\t[:class | (class whichSelectorsReferTo: aLiteral special: special byte: byte)\n\t\t\t\tdo: [:sel | sel ~~ #DoIt ifTrue: [class recompile: sel]]]]\n"
        },
        "system compression": {
          "newSourceFile:without:": "newSourceFile: vers without: setOfClasses\n\t\"Make a new source file omitting references to any classes in the set, setOfClasses.\n\n\t\tSmalltalk newSourceFile: Smalltalk versionName without: (Array new).\n\n\tMake sure versionName is updated.\n\tThen rename the image similarly, and delete the old sources and changes.\"\n\n\t| oldFile newFile class |\n\toldFile _ SourceFiles at: 1.\n\tnewFile _ Disk file: vers , '.sources'.\n\tnewFile timeStamp.\n\tSmalltalk classNames do:\n\t\t[:className |\n\t\tclass _ Smalltalk at: className.\n\t\t(setOfClasses includes: class)\n\t\t\tifFalse:\n\t\t\t\t[class\n\t\t\t\t\tfileOutOn: newFile\n\t\t\t\t\tmoveSource: true\n\t\t\t\t\ttoFile: 1.\n\t\t\t\tnewFile nextPut: 12 asCharacter]].\n\tnewFile shorten; readOnly.\n\tSourceFiles at: 1 put: newFile.\n\tSourceFiles at: 2 put: (Disk file: vers , '.changes').\n\t(SourceFiles at: 2) shorten; readOnly\n",
          "renameSystemFiles:": "renameSystemFiles: newVersion\n\t\"Rename the sources and changes and image files.\n\n\t\tSmalltalk renameSystemFiles: Smalltalk versionName.\n\n\tThen rename the relevant .run and .syms files manually.\"\n\n\t| oldFile oldName oldVersion file |\n\toldFile _ SourceFiles at: 1.\n\toldName _ oldFile name.\n\toldVersion _ oldName copyFrom: 1 to: (oldName indexOf: $.)\n\t\t\t\t\t- 1.\n\t(SourceFiles at: 1) close.\n\tSourceFiles at: 1 put: nil.\n\t(SourceFiles at: 2) close.\n\tSourceFiles at: 2 put: nil.\n\t#('.sources' '.changes' '.im' ) do:\n\t\t[:ext | (Disk file: oldVersion , ext) file rename: newVersion , ext].\n\t1 to: 2 do:\n\t\t[:i |\n\t\tfile _ Disk file: newVersion , (#('.sources' '.changes' ) at: i).\n\t\tfile readOnly.\n\t\tSourceFiles at: i put: file]\n",
          "forgetDoIts": "forgetDoIts\n\t\"get rid of old DoIt methods\"\n\n\tSmalltalk allBehaviorsDo:\n\t\t[:class |\n\t\tclass removeSelectorSimply: #DoIt;\n\t\tremoveSelectorSimply: #DoItIn:]\n\n\t\"Smalltalk forgetDoIts\"\n",
          "condenseChanges": "condenseChanges\n\t\"Move all the changes onto a compacted sources file.\n\t\tSmalltalk condenseChanges.\"\n\n\t| f fileName |\n\tf _ Disk file: 'ST80.temp'.\n\tf timeStamp.\n\tSmalltalk allBehaviorsDo: [:class | class moveChangesTo: f].\n\tf close.\n\tf readOnly.\n\tfileName _ (SourceFiles at: 2) name.\n\t(SourceFiles at: 2) close.\n\tSourceFiles at: 2 put: f.\n\tDisk removeKey: fileName.\n\tf file rename: fileName\n"
        },
        "memory space": {
          "resetSpaceLimits": "resetSpaceLimits\n\t\"Reset the threashold on the number of oops and the core space at which\n\tpoint the user should be notified.\"\n\n\tOopsLeftLimit _ self oopsLeft // 4.\n\tWordsLeftLimit _ self coreLeft // 4.\n\tself resetLowSpaceSignal\n",
          "oopsLeftLimit": "oopsLeftLimit\n\t\"Answer the threashold at which the user is to be notified\n\tthat the system is low in number of oops.\"\n\n\t^OopsLeftLimit\n",
          "frills:": "frills: aBoolean\n\t\"Set to true for more functionality on fast machines -\n\tbut on slow machines, you may want to set Smalltalk frills: false.\"\n\n\t^Frills _ aBoolean\n",
          "frills": "frills\n\t\"Answer whether the current Smalltalk is willing to work harder -\n\ton slow machines, you may want to set Smalltalk frills: false\"\n\n\t^Frills\n",
          "resetLowSpaceSignal": "resetLowSpaceSignal\n\t\"The threasholds for notifying the user the space is low have changed so\n\tupdate the system.\"\n\tself signal: LowSpaceSemaphore\n\t\tatOopsLeft: OopsLeftLimit\n\t\twordsLeft: WordsLeftLimit\n",
          "oopsLeft": "oopsLeft\n\t\"Answer the number of unallocated object pointers in the object\n\ttable.  Equal to the net number of objects which can be created before the\n\tobject table is full.  Essential.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 115>\n\tself primitiveFailed\n",
          "coreLeftLimit:": "coreLeftLimit: newLimit\n\t\"Set newLimit to be the threashold at which the user is to be notified\n\tthat the system is low in core space.\"\n\n\tWordsLeftLimit _ newLimit.\n\tself resetLowSpaceSignal.\n\t^newLimit\n",
          "coreLeft": "coreLeft\n\t\"Answer the number of unallocated words in the object space.  Essential.\n\tSee Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 112>\n\tself primitiveFailed\n",
          "signal:atOopsLeft:wordsLeft:": "signal: aSemaphore atOopsLeft: numOops wordsLeft: numWords\n\t\"Tell the object memory to signal the Semaphore when either the number\n\t of object pointers remaining drops below numOops, or the number of\n\twords in the object space remaining drops below numWords.  Fail if the\n\tfrist argument is neither a Semaphore nor nil.  Fail if numOops is not a\n\t16-bit Integer, or if numWords is not a 32-bit LargePositiveInteger.\n\tEssential.  See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 116>\n\tself primitiveFailed\n",
          "oopsLeftLimit:": "oopsLeftLimit: newLimit\n\t\"Set newLimit to be the threashold at which the user is to be notified\n\tthat the system is low in nubmer of oops.\"\n\n\tOopsLeftLimit _ newLimit.\n\tself resetLowSpaceSignal.\n\t^newLimit\n",
          "coreLeftLimit": "coreLeftLimit\n\t\"Answer the threashold at which the user is to be notified\n\tthat the system is low in core space.\"\n\n\t^WordsLeftLimit\n",
          "core": "core\n\t\"Answer an Array containing the number of objects in the system and the number\n\tof words they occupy.\n\t\t\tSmalltalk core\"\n\n\t| n nobjects nwords isBytes name |\n\tnobjects _ nwords _ 0.\n\tSmalltalk allBehaviorsDo:\n\t\t[:class |\n\t\tclass isVariable\n\t\t\tifTrue:\n\t\t\t\t[n _ 0.\n\t\t\t\tisBytes _ class isBytes.\n\t\t\t\tclass allInstancesDo:\n\t\t\t\t\t[:inst |\n\t\t\t\t\tn _ n + 1.\n\t\t\t\t\tnwords _\n\t\t\t\t\t\tnwords + (isBytes\n\t\t\t\t\t\t\t\t\tifTrue: [inst basicSize + 1 // 2]\n\t\t\t\t\t\t\t\t\tifFalse: [inst basicSize])]]\n\t\t\tifFalse:\n\t\t\t\t[n _ class isMeta\n\t\t\t\t\t\tifTrue: [\"quicker\" 1]\n\t\t\t\t\t\tifFalse: [class instanceCount]].\n\t\tnobjects _ nobjects + n.\n\t\tnwords _ nwords + (class instSize + 2 * n) \"+2 for header\"].\n\t^Array with: nobjects with: nwords\n"
        },
        "browsing": {
          "browseAllCallsOn:and:": "browseAllCallsOn: literal1 and: literal2\n\t\"Create and schedule a message browser on each method that calls on the\n\ttwo Symbols, literal1 and literal2.\n\tFor example,\n\t\tSmalltalk browseAllCallsOn: #at: and: #at:pt:.\t\"\n\n\tBrowserView\n\t\topenListBrowserOn: (self allCallsOn: literal1 and: literal2)\n\t\tlabel: literal1 printString , literal2 printString\n",
          "browseAllImplementorsOf:": "browseAllImplementorsOf: selector\n\t\"Create and schedule a message browser on each method that implements the\n\tmessage whose selector is the argument, selector.\n\tFor example,\n\t\tSmalltalk browseAllImplementorsOf: #at:put:.\t\"\n\n\tBrowserView\n\t\topenListBrowserOn: (self allImplementorsOf: selector)\n\t\tlabel: 'Implementors of ' , selector\n",
          "browseAllCallsOn:": "browseAllCallsOn: aSymbol\n\t\"Create and schedule a message browser on each method that calls on\n\taSymbol. For example,\n\tSmalltalk browseAllCallsOn: #open:label:.\t\"\n\n\t| label key |\n\t(aSymbol isMemberOf: Association)\n\t\tifTrue: [key _ aSymbol key. \tlabel _ 'Users of ' , key]\n\t\tifFalse: [key _ aSymbol. \t\tlabel _ 'Senders of ', key].\n\n\t^ BrowserView\n\t\topenListBrowserOn: (self allCallsOn: aSymbol)\n\t\tlabel: label\n\t\tinitialSelection: key asSymbol keywords first\n",
          "browseAllSelect:": "browseAllSelect: aBlock\n\t\"Create and schedule a message browser on each method that, when used as the\n\tblock argument to aBlock gives a true result.\n\tFor example,\n\t\tSmalltalk browseAllSelect:\n\t\t\t[:method |\n\t\t\tmethod numLiterals > 10]\n\t\"\n\n\tBrowserView openListBrowserOn: (self allSelect: aBlock) label: 'selected messages'\n",
          "showMenuThenBrowse:": "showMenuThenBrowse: selectorCollection\n\t\"Show a menu of the given selectors, abbreviated to 20 characters.\n\tCreate and schedule a message set browser of all implementors of the\n\tmessage chosen.  Do nothing if no message is chosen.\"\n\t| aStream menu index |\n\tselectorCollection isEmpty ifTrue: [^Transcript cr; show: 'No messages sent.'].\n\taStream _ WriteStream on: (String new: 200).\n\tselectorCollection do:\n\t\t[:sel |\n\t\taStream nextPutAll: (sel contractTo: 20); cr].\n\taStream skip: -1.\n\tindex _ (PopUpMenu labels: aStream contents) startUp.\n\tindex > 0 ifTrue: [Smalltalk browseAllImplementorsOf: (selectorCollection at: index)]\n",
          "browseChangedMessages": "browseChangedMessages\n\t\"Smalltalk browseChangedMessages\"\n\tBrowserView\n\t\topenListBrowserOn: SystemChanges changedMessageList\n\t\tlabel: 'Changed Messages'\n"
        },
        "printing": {
          "printOn:": "printOn: aStream\n\t\"Intercepted to avoid infinite recursion when #Smalltalk is reached.\"\n\t| tooMany |\n\ttooMany _ aStream position + self maxPrint.\n\taStream nextPutAll: self class name, ' keys ('.\n\tself keysDo:\n\t\t[:key |\n\t\taStream position > tooMany ifTrue: [aStream nextPutAll: '...etc...)'. ^self].\n\t\tkey printOn: aStream.\n\t\taStream space].\n\taStream nextPut: $)\n"
        },
        "special selectors": {
          "specialSelectorSize": "specialSelectorSize\n\t\"Answer the number of special selectors in the system.\"\n\t^SpecialSelectors size // 2\n",
          "hasSpecialSelector:ifTrueSetByte:": "hasSpecialSelector: aLiteral ifTrueSetByte: aBlock\n\t1 to: self specialSelectorSize do:\n\t\t[:index |\n\t\t(self specialSelectorAt: index) == aLiteral\n\t\t\tifTrue: [aBlock value: index + 16rAF. ^true]].\n\t^false\n",
          "specialNargsAt:": "specialNargsAt: anInteger\n\t\"Answer the number of arguments for the special selector at: anInteger\"\n\n\t^SpecialSelectors at: anInteger * 2\n",
          "specialSelectorAt:": "specialSelectorAt: anInteger\n\t\"Answer the special message selector stored at location anInteger in the\n\tsystem dictionary.\"\n\t^SpecialSelectors at: anInteger * 2 - 1\n"
        },
        "accessing": {
          "at:put:": "at: aKey put: anObject\n\t\"Override from Dictionary so that can check Undeclared and fix up\n\treferences of undeclared variables.\"\n\n\t| index element |\n\tindex _ self findKeyOrNil: aKey.\n\telement _ self basicAt: index.\n\telement == nil\n\t\tifTrue:\n\t\t\t[self\n\t\t\t\tvalueAtNewKey: aKey\n\t\t\t\tput: anObject\n\t\t\t\tatIndex: index\n\t\t\t\tdeclareFrom: Undeclared]\n\t\tifFalse:\n\t\t\t[element value: anObject].\n\t^anObject\n",
          "valueAtNewKey:put:atIndex:declareFrom:": "valueAtNewKey: aKey put: anObject atIndex: index declareFrom: aDictionary\n\t\"Handle overriding atKey:put: from Dictionary so that adding\n\tsomething new to a system dictionary such as Smalltalk checks\n\tUndeclared and fixes up all references to the undeclared variable\"\n\n\t(aDictionary includesKey: aKey)\n\t\tifTrue:\n\t\t\t[self atNewIndex: index\n\t\t\t\tput: ((aDictionary associationAt: aKey) value: anObject).\n\t\t\taDictionary removeKey: aKey]\n\t\tifFalse:\n\t\t\t[self atNewIndex: index put: (Association key: aKey value: anObject)].\n\tself flushClassNameCache\n"
        },
        "private": {
          "quitPrimitive": "quitPrimitive\n\t\"Exit to another operating system on the host machine, if one exists.  All\n\tstate changes in the object space since the last snapshot are lost.  Essential.\n\tSee Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 113>\n\tself primitiveFailed\n",
          "lowSpaceNotificationLoop": "lowSpaceNotificationLoop\n\t[true]\n\t\twhileTrue:\n\t\t\t[LowSpaceSemaphore wait.\n\t\t\tScheduledControllers interruptName: 'Space is Low'.\n\t\t\tself resetSpaceLimits]\n",
          "specialSelectors": "specialSelectors\n\t\"Used by SystemTracer only\"\n\n\t^SpecialSelectors\n",
          "snapshotPrimitive": "snapshotPrimitive\n\t\"Write the current state of the object memory on a file in the same format as\n\tthe Smalltalk-80 release.  The file can later be resumed, returning you to\n\tthis exact state.  Return normally after writing the file.  Essential.  See\n\tObject documentation whatIsAPrimitive.\"\n\n\t<primitive: 97>\n\tself primitiveFailed\n",
          "exitToDebugger": "exitToDebugger\n\t\"Enter the machine language debugger, if one exists.  Essential.  See Object\n\tdocumentation whatIsAPrimitive. \"\n\n\t<primitive: 114>\n\tself primitiveFailed\n",
          "releaseExternalViews": "releaseExternalViews\n\tSourceFiles==nil\n\t\tifFalse: [SourceFiles do: [:t | t==nil ifFalse: [t close]]].\n\tDisk==nil ifFalse: [Disk close].\n\tFileDirectory releaseExternalReferences\n"
        },
        "initialize-release": {
          "install": "install\n\t\"Get connected back up to the hardware after a snapshot or quit.\"\n\n\t\"Call the initialization code that depends on system parameters,\n\tin case we are coming up on a system different from the one\n\tthat we quit or snapshot on.\"\n\tCompiledMethod initialize.\n\tSmallInteger initialize.\n\tLargePositiveInteger initialize.\n\tLargeNegativeInteger initialize.\n\n\tDisplayScreen currentDisplay: Display.\n\tCursor currentCursor: Cursor currentCursor.\n\tInputSensor install.\n\tLowSpaceProcess == nil ifFalse: [LowSpaceProcess terminate].\n\tLowSpaceSemaphore _ Semaphore new.\n\tLowSpaceProcess _ [self lowSpaceNotificationLoop] newProcess.\n\tLowSpaceProcess priority: Processor lowIOPriority.\n\tLowSpaceProcess resume.\n\tself resetSpaceLimits.\n"
        },
        "time/versions": {
          "timeStamp:": "timeStamp: aStream\n\t\"Writes system version and current time on stream aStream.\"\n\n\t| dateTime |\n\tdateTime _ Time dateAndTimeNow.\n\taStream nextPutAll: 'From ', Smalltalk version, ' on ', (dateTime at: 1) printString,\n\t\t\t\t\t\t' at ', (dateTime at: 2) printString\n",
          "versionName": "versionName\n\t\"Answer the version identification, e.g. Smalltalk-80\"\n\n\t^'Smalltalk-80'\n",
          "version": "version\n\t\"Answer the version of this Smalltalk release.\"\n\n\t^'Smalltalk-80, version 2, of April 1, 1983'\n",
          "copyright": "copyright\n\t\"The Smalltalk copyright.\n\t\t\tCopyright (c) 1983 Xerox Corp.  All rights reserved.\n\t\"\n\n\t^'Copyright (c) 1983 Xerox Corp.  All rights reserved.'\n"
        },
        "enumerating": {
          "pointersTo:do:": "pointersTo: anObject do: aBlock\n\t\"Evaluate the argument aBlock for each pointer to anObject in the system.\"\n\n\t| me class obj method i fixedSize |\n\tme _ thisContext.\n\tSmalltalk allBehaviorsDo:\n\t\t[:class | class isBits\n\t\t\tifTrue:\n\t\t\t\t[\"Might be CompiledMethod\"\n\t\t\t\tclass == CompiledMethod\n\t\t\t\t\tifTrue:\n\t\t\t\t\t\t[class allInstancesDo:\n\t\t\t\t\t\t\t[:method |\n\t\t\t\t\t\t\t1 to: method numLiterals + 1 do:\n\t\t\t\t\t\t\t\t[:i |\n\t\t\t\t\t\t\t\t(method objectAt: i) == anObject\n\t\t\t\t\t\t\t\t\tifTrue: [aBlock value: method]]]]]\n\t\t\tifFalse:\n\t\t\t\t[fixedSize _ class instSize.\n\t\t\t\tclass allInstancesDo:\n\t\t\t\t\t[:obj |\n\t\t\t\t\t1 to: (fixedSize + obj basicSize) do:\n\t\t\t\t\t\t[:i |\n\t\t\t\t\t\t((obj instVarAt: i) == anObject and: [obj ~~ me])\n\t\t\t\t\t\t\tifTrue: [aBlock value: obj]]]]].\n\tme _ nil \"Break cycle\"\n",
          "allBehaviorsDo:": "allBehaviorsDo: aBlock\n\t\"Evaluate the argument, aBlock, for each kind of Behavior in the system\n\t(that is, Object and its subclasses).\"\n\taBlock value: Object.\n\tObject allSubclassesDo: aBlock\n",
          "allClassesDo:": "allClassesDo: aBlock\n\t\"Evaluate the argument, aBlock, for each class in the system.\"\n\t(self classNames collect: [:name | Smalltalk at: name]) do: aBlock\n"
        },
        "retrieving": {
          "allSelect:": "allSelect: aBlock\n\t\"Answer a SortedCollection of each method that, when used as the\n\tblock argument to aBlock, gives a true result.\"\n\n\t| aCollection |\n\taCollection _ SortedCollection new.\n\tCursor execute showWhile:\n\t\t[self allBehaviorsDo:\n\t\t\t[:class | class selectors do:\n\t\t\t\t[:sel | (aBlock value: (class compiledMethodAt: sel))\n\t\t\t\t\tifTrue: [aCollection add: class name , ' ' , sel]]]].\n\t^aCollection\n",
          "allImplementorsOf:": "allImplementorsOf: aSelector\n\t\"Answer a SortedCollection of all the methods that implement the message aSelector.\"\n\n\t| aCollection |\n\taCollection _ SortedCollection new.\n\tCursor execute showWhile:\n\t\t[self allBehaviorsDo:\n\t\t\t[:class |\n\t\t\t(class includesSelector: aSelector)\n\t\t\t\tifTrue: [aCollection add: class name, ' ', aSelector]]].\n\t^aCollection\n",
          "allClassesImplementing:": "allClassesImplementing: aSelector\n\t\"Answer an Array of all classes that implement the message aSelector.\"\n\n\t| aCollection |\n\taCollection _ ReadWriteStream on: Array new.\n\tself allBehaviorsDo:\n\t\t[:class | (class includesSelector: aSelector)\n\t\t\tifTrue: [aCollection nextPut: class]].\n\t^ aCollection contents\n",
          "allCallsOn:and:": "allCallsOn: firstLiteral and: secondLiteral\n\t\"Answer a SortedCollection of all the methods that call on both aLiteral and\n\tsecondLiteral.\"\n\n\t| aCollection secondArray firstSpecial secondSpecial |\n\taCollection _ SortedCollection new.\n\tfirstSpecial _ self hasSpecialSelector: firstLiteral ifTrueSetByte: [:firstByte].\n\tsecondSpecial _ self hasSpecialSelector: secondLiteral ifTrueSetByte: [:secondByte].\n\tCursor execute showWhile:\n\t\t[self allBehaviorsDo:\n\t\t\t[:class |\n\t\t\tsecondArray _ class whichSelectorsReferTo: secondLiteral special: secondSpecial byte: secondByte.\n\t\t\t((class whichSelectorsReferTo: firstLiteral special: firstSpecial byte: firstByte) select:\n\t\t\t\t[:aSel | (secondArray includes: aSel)]) do:\n\t\t\t\t\t\t[:sel | aCollection add: class name , ' ' , sel]]].\n\t^aCollection\n",
          "allImplementedMessages": "allImplementedMessages\n\t\"Answer a Set of all the messages that are sent by a method in the\n\tsystem but are not implemented.\"\n\n\t| aSet |\n\taSet _ Set new: (Symbol instanceCount * 1.5) truncated.\n\tCursor execute showWhile:\n\t\t[self allBehaviorsDo: [:cl | cl selectors do: [:aSelector | aSet add: aSelector]]].\n\t^aSet\n",
          "collectPointersTo:": "collectPointersTo: anObject\n\t\"Answer an Array of all occurrences in the system of pointers to the argument\n\tanObject.\"\n\n\t| some me |\n\tsome _ OrderedCollection new.\n\tme _ thisContext.\n\tself pointersTo: anObject do:\n\t\t[:obj | (obj ~~ me) & (obj ~~ some) ifTrue: [some add: obj]].\n\tme _ nil. \"to avoid circularity\"\n\t^some asArray\n\n\t\"(Smalltalk collectPointersTo: Browser) inspect.\"\n",
          "allCallsOn:": "allCallsOn: aLiteral\n\t\"Answer a SortedCollection of all the methods that call on aLiteral.\"\n\n\t| aSortedCollection special |\n\taSortedCollection _ SortedCollection new.\n\tspecial _ self hasSpecialSelector: aLiteral ifTrueSetByte: [:byte ].\n\tCursor execute showWhile:\n\t\t[self allBehaviorsDo:\n\t\t\t[:class |\n\t\t\t (class whichSelectorsReferTo: aLiteral special: special byte: byte) do:\n\t\t\t\t[:sel | sel ~~ #DoIt\n\t\t\t\t\tifTrue: [aSortedCollection add: class name , ' ' , sel]]]].\n\t^aSortedCollection\n"
        },
        "class names": {
          "flushClassNameCache": "flushClassNameCache\n\t\"Invalidate cached copy of classnames (see classNames)\"\n\tCachedClassNames _ nil\n",
          "classNames": "classNames\n\t\"Answer a SortedCollection of all class names.  Use cached copy if available.\"\n\n\tCachedClassNames == nil ifTrue: [^self newClassNames].\n\t^CachedClassNames\n",
          "newClassNames": "newClassNames\n\t\"Compute a sorted collection of class names and cache it for efficiency.\"\n\t| names |\n\tnames _ OrderedCollection new: self size.\n\tself do:\n\t\t[:cl | (cl isKindOf: Class) ifTrue: [names add: cl name]].\n\t^CachedClassNames _ names asSortedCollection\n"
        },
        "system backup/out": {
          "saveAs:thenQuit:": "saveAs: imagePrefix thenQuit: quitIfTrue\n\t\"Copy the changes file to the new name if necessary, then create a matching image file.  Answer true if the image file was just created.\"\n\n\tDisk == nil\n\t\tifFalse:\n\t\t\t[(imagePrefix sameAs: 'snapshot')\n\t\t\t\t\tifFalse: [self copyChangesTo: imagePrefix, '.changes']].\n\t^self snapshotAs: imagePrefix thenQuit: quitIfTrue\n",
          "getImagePrefix": "getImagePrefix\n\t\"Prompt the user for a snapshot file name.  Persist until a legal name is supplied.\"\n\n\t| default newPrefix prompt |\n\tSourceFiles == nil\n\t\tifTrue: [^'snapshot'].\n\tprompt _\n'Enter name for image file:'.\n\tdefault _ 'snapshot'.\n\tnewPrefix _ ''.\n\tFillInTheBlank\n\t\trequest: prompt\n\t\tdisplayAt: Sensor cursorPoint\n\t\tcentered: true\n\t\taction: [:newPrefix | ]\n\t\tinitialAnswer: default.\n\n\t[newPrefix isEmpty or:\n\t\t\t[(Disk isLegalFileName: newPrefix, '.changes') not]] whileTrue:\n\t\t[newPrefix isEmpty ifTrue: [^newPrefix].\n\t\tFillInTheBlank\n\t\t\trequest: prompt\n\t\t\tdisplayAt: Sensor cursorPoint\n\t\t\tcentered: true\n\t\t\taction: [:newPrefix | ]\n\t\t\tinitialAnswer: default.\n\t\t(newPrefix size > 2 and:\n\t\t\t[(newPrefix copyFrom: newPrefix size-2 to: newPrefix size) sameAs: '.im'])\n\t\t\t\tifTrue: [newPrefix _ newPrefix copyFrom: 1 to: newPrefix size-3].\n\t\tprompt _\n'Illegal file name: ', newPrefix, '\nEnter name for image file:'.\n\t\tdefault _ Disk checkName: newPrefix, '.changes' fixErrors: true.\n\t\tdefault _ default copyFrom: 1 to: default size - 8].\n\n\t^newPrefix\n",
          "snapshot": "snapshot\n\t\"Write the OT and Data of this Smalltalk out on the external file snapshot.im.\"\n\n\tself snapshotAs: 'snapshot' thenQuit: false\n",
          "snapshotAs:thenQuit:": "snapshotAs: imageFilePrefix thenQuit: quitIfTrue\n\t\"Write the OT and Data of this Smalltalk out on an external file.  Answer true if the snapshot was just created.\"\n\n\t| height justSnapped |\n\tCursor execute show.\n\tself logChange: '''----SNAPSHOT----'''.\n\tDisk == nil\n\t\tifFalse:\t\"install as snapshot file and update creation time\"\n\t\t\t[(FileStream fileNamed: imageFilePrefix, '.im') beSnapshotFile; readWrite; close].\n\tself releaseExternalViews.\n\tTranscript cr; show: 'Snapshot at: ', Time dateAndTimeNow printString.\n\theight _ Display height.\n\tDisplayScreen displayHeight: (height min: 100).  \"Minimize display space on snapshot\"\n\tDelay preSnapshot.\n\tCursor wait show.\n\tjustSnapped _ self snapshotPrimitive isNil.\n\tjustSnapped & quitIfTrue\n\t\tifTrue:\n\t\t\t[self quitPrimitive]\n\t\tifFalse:\n\t\t\t[Delay postSnapshot.\n\t\t\tDisplayScreen displayHeight: height.\n\t\t\tself install].\n\tCursor normal show.\n\t^justSnapped\n",
          "copyChangesTo:": "copyChangesTo: newFileName\n\t\"If the file name supplied is different than the current changes file name, copy the changes file and install the new copy as the changes file.\"\n\n\t| oldName newFile |\n\tSourceFiles == nil ifTrue: [^self].\n\toldName _ (SourceFiles at: 2) name.\n\toldName last = $. ifTrue: [oldName _ oldName copyFrom: 1 to: oldName size-1].\n\t(newFileName sameAs: oldName) ifFalse:\n\t\t[Transcript cr; show: 'Copying ', oldName,\n\t\t\t' to ', newFileName, '...'.\n\t\t(SourceFiles at: 2) close; readOnly; reset.\n\t\tnewFile _ FileStream fileNamed: newFileName.\n\t\tCursor write showWhile:\n\t\t\t[newFile nextPutAll: (SourceFiles at: 2)].\n\t\tnewFile readOnly.\n\t\tSourceFiles at: 2 put: newFile.\n\t\tTranscript show: ' done'; cr]\n",
          "quit": "quit\n\t\"Close open files then exit to another operating system on the host machine,\n\tif one exists.  All state changes in the object space since the last snapshot are lost.\"\n\n\tself releaseExternalViews.\n\tself quitPrimitive\n",
          "shutdown": "shutdown\n\t\"Shut off the low space signal so that the Vmem writer can be sure the\n\tsystem is stable while it is tracing.\"\n\n\tself coreLeftLimit: 0.\n\tself oopsLeftLimit: 0\n"
        }
      }
    },
    "InputState": {
      "comment": "I represent the state of the user input devices.\n\nInstance Variables:\n\t\tx  <Integer> mouse X location\n\t\ty  <Integer> mouse Y location\n\t\tbitState  <Integer> mouse button and keyset state\n\t\tlshiftState  <1 or 0> state of left shift key\n\t\trshiftState  <1 or 0> state of right shift key\n\t\tctrlState  <2 or 0> state of ctrl key\n\t\tlockState  <4 or 0> state of shift-lock key\n\t\tmetaState  <Integer> combined state of the meta keys\n\t\tkeyboardQueue  <SharedQueue> of keyboard characters\n\t\tdeltaTime  <Integer> sampling ticks since last setting of baseTime\n\t\tbaseTime  <Integer> millisecond timer at last resync\n",
      "class_name": "InputState",
      "superclass": "Object",
      "instanceVariables": "x y bitState lshiftState rshiftState ctrlState lockState metaState keyboardQueue deltaTime baseTime timeProtect",
      "classInstanceVariables": "",
      "classVariables": "BitMax BitMin CtrlKey InputProcess InputSemaphore LockKey LshiftKey RshiftKey",
      "poolDictionaries": "",
      "class_methods": {
        "class initialization": {
          "initialize": "initialize\n\t\"Define parameters\"\n\n\tBitMin _ 8r200.  \"Min mouse/keyset bit code\"\n\tBitMax _ 8r207.  \"Max mouse/keyset bit code\"\n\tLshiftKey _ 8r210.\n\tRshiftKey _ 8r211.\n\tCtrlKey _ 8r212.\n\tLockKey _ 8r213\n"
        }
      },
      "instance_methods": {
        "cursor": {
          "cursorPoint:": "cursorPoint: aPoint\n\t\"Set the current cursor position to be aPoint.\"\n\tself primCursorLocPut: aPoint.\n\tx _ aPoint x.\n\ty _ aPoint y\n"
        },
        "time": {
          "currentTime": "currentTime\n\t\"Answer the time on the system clock in milliseconds since midnight.\"\n\ttimeProtect critical:\n\t\t[deltaTime = 0\n\t\t\tifFalse: [baseTime _ baseTime + (deltaTime * 1000 // 60).\n\t\t \t\t\t deltaTime _ 0]].\n\t^baseTime\n"
        },
        "mouse": {
          "mouseButtons": "mouseButtons\n\t\"Answer the status of the mouse buttons--an Integer between 0 and 7.\"\n\t^bitState bitAnd: 7\n",
          "mousePoint": "mousePoint\n\t\"Answer the coordinates of the mouse location.\"\n\t^self primMousePt\n"
        },
        "private": {
          "primMousePt": "primMousePt\n\t\"Poll the mouse to find out its position.  Return a Point.  Fail if event-driven\n\ttracking is used instead of polling.  Optional.  See Object documentation\n\twhatIsAPrimitive. \"\n\n\t<primitive: 90>\n\t^x @ y\n",
          "keyAt:put:": "keyAt: index put: value\n\t| mask |\n\tindex < 8r200\n\t  ifTrue:  \"Not a potential special character\"\n\t\t[value ~= 0 ifTrue:\n\t\t\t[(index = $c asciiValue and: [ctrlState ~= 0])\n\t\t\t\tifTrue: [lshiftState ~= 0\n\t\t\t\t\t\t\tifTrue: [self forkEmergencyEvaluatorAt: Processor userInterruptPriority]\n\t\t\t\t\t\t\tifFalse: [[ScheduledControllers interruptName: 'User Interrupt'] fork]]\n\t\t\t\tifFalse: [^keyboardQueue nextPut:\n\t\t\t\t\t\t\t\t(KeyboardEvent code: index\n\t\t\t\t\t\t\t\t\t\t\t\t meta: metaState)]]]\n\t  ifFalse:\n\t\t[index = CtrlKey\n\t\t  ifTrue: [ctrlState _ value bitShift: 1]\n\t\t  ifFalse:\n\t\t\t[index = LshiftKey\n\t\t\t  ifTrue: [lshiftState _ value]\n\t\t\t  ifFalse:\n\t\t\t\t[index = RshiftKey\n\t\t\t\t  ifTrue: [rshiftState _ value]\n\t\t\t\t  ifFalse:\n\t\t\t\t\t[index = LockKey\n\t\t\t\t\t  ifTrue: [lockState _ value bitShift: 2]\n\t\t\t\t\t  ifFalse:\n\t\t\t\t\t\t[(index >= BitMin and: [index <= BitMax])\n\t\t\t\t\t\t  ifTrue:\n\t\t\t\t\t\t\t[mask _ 1 bitShift: index - BitMin.\n\t\t\t\t\t\t\tvalue = 1\n\t\t\t\t\t\t\t  ifTrue: [bitState _ bitState bitOr: mask]\n\t\t\t\t\t\t\t  ifFalse: [bitState _ bitState bitAnd: -1 - mask]]\n\t\t\t\t\t\t  ifFalse:\n\t\t\t\t\t\t\t[value ~= 0 ifTrue:\n\t\t\t\t\t\t\t\t[keyboardQueue nextPut:\n\t\t\t\t\t\t\t\t\t(KeyboardEvent code: index meta: metaState)]]]]]].\n\t\tmetaState _ (ctrlState bitOr: (lshiftState bitOr: rshiftState)) bitOr: lockState]\n",
          "primCursorLocPutAgain:": "primCursorLocPutAgain: aPoint\n\t\"By this time, aPoint better be an integer or get out of here\"\n\n\t<primitive: 91>\n\t^self primitiveFailed\n",
          "primCursorLocPut:": "primCursorLocPut: aPoint\n\t\"Move the cursor to the screen location specified by the argument. Fail if\n\tthe argument is not a Point. Essential. See Object documentation\n\twhatIsAPrimitive. \"\n\n\t<primitive: 91>\n\t^self primCursorLocPutAgain: aPoint rounded\n",
          "primInputSemaphore:": "primInputSemaphore: aSemaphore\n\t\"Install the argument (a Semaphore) as the object to be signalled whenever\n\tan input event occurs. The semaphore will be signaled once for every\n\tword placed in the input buffer by an I/O device. Fail if the argument is\n\tneither a Semaphore nor nil. Essential. See Object whatIsAPrimitive.\"\n\n\t<primitive: 93>\n\t^self primitiveFailed\n",
          "nextEvent:with:": "nextEvent: type with: param\n\t\"Process a single input event, aside from mouse X/Y\"\n\n\t| highTime lowTime |\n\ttype = 0  \"Delta time\"\n\t\tifTrue:\n\t\t\t[timeProtect critical: [deltaTime _ deltaTime + param]]\n\t\tifFalse:\n\t\t\t[type = 3\t\"Key down\"\n\t\t\t\tifTrue: [self keyAt: param put: 1]\n\t\t\t\tifFalse:\n\t\t\t\t\t[type = 4\t\"Key up\"\n\t\t\t\t\t\tifTrue: [self keyAt: param put: 0]\n\t\t\t\t\t\tifFalse:\n\t\t\t\t\t\t\t[type = 5\t\"Reset time\"\n\t\t\t\t\t\t\t\tifTrue:\n\t\t\t\t\t\t\t\t\t[InputSemaphore wait.\n\t\t\t\t\t\t\t\t\thighTime _ self primInputWord.\n\t\t\t\t\t\t\t\t\tInputSemaphore wait.\n\t\t\t\t\t\t\t\t\tlowTime _ self primInputWord.\n\t\t\t\t\t\t\t\t\ttimeProtect critical:\n\t\t\t\t\t\t\t\t\t\t[baseTime _ (highTime bitShift: 16) + lowTime.\n\t\t\t\t\t\t\t\t\t\t deltaTime _ 0]]\n\t\t\t\t\t\t\t\tifFalse: [self error: 'Bad event type']]]]\n",
          "run": "run\n\t\"This is the loop that actually processes input events.\"\n\n\t| word type param |\n\t[true]\n\t\twhileTrue:\n\t\t\t[InputSemaphore wait.\n\t\t\t\"Test for mouse X/Y events here to avoid an activation.\"\n\t\t\tword _ self primInputWord.\n\t\t\ttype _ word bitShift: -12.\n\t\t\tparam _ word bitAnd: 4095.\n\t\t\ttype = 1\n\t\t\t\tifTrue:\n\t\t\t\t\t[x _ param \"Mouse X\"]\n\t\t\t\tifFalse:\n\t\t\t\t\t[type = 2\n\t\t\t\t\t\tifTrue: [y _ param \"Mouse Y\"]\n\t\t\t\t\t\tifFalse: [self nextEvent: type with: param]]]\n",
          "initState": "initState\n\ttimeProtect _ Semaphore forMutualExclusion.\n\ttimeProtect critical: [deltaTime _ baseTime _ 0].\n\tx _ y _ 0.\n\tkeyboardQueue _ SharedQueue new: 50.\n\tctrlState _ lshiftState _ rshiftState _ lockState _ metaState _ 0.\n\tbitState _ 0\n",
          "primSampleInterval:": "primSampleInterval: anInteger\n\t\"Set the minimum time span between event driven mouse position\n\tsamples.  The argument is a number of milliseconds.  Fail if the argument\n\tis not a SmallInteger.  Essential.  See Object documentation\n\twhatIsAPrimitive. \"\n\n\t<primitive: 94>\n\t^self primitiveFailed\n",
          "primInputWord": "primInputWord\n\t\"Return the next word from the input buffer and remove the word from the\n\tbuffer. This message should be sent just after the input semaphore\n\tfinished a wait (was sent a signal by an I/O device). Fail of the input\n\tbuffer is empty. Essential. See Object documentation whatIsAPrimitive.\"\n\n\t<primitive: 95>\n\t^self primitiveFailed\n"
        },
        "initialize-release": {
          "install": "install\n\t\"Initialize and connect the receiver to the hardware.  Terminate the old input\n\tprocess if any.\"\n\n\tInputProcess == nil ifFalse: [InputProcess terminate].\n\tself initState.\n\tInputSemaphore _ Semaphore new.\n\tInputProcess _ [self run] newProcess.\n\tInputProcess priority: Processor lowIOPriority.\n\tInputProcess resume.\n\tself primInputSemaphore: InputSemaphore\n"
        },
        "keyboard": {
          "keyboardNext": "keyboardNext\n\t\"Remove and answer the next key in the keyboard buffer.\"\n\t^keyboardQueue next\n",
          "leftShiftDown": "leftShiftDown\n\t\"Answer whether the left shift key is down.\"\n\t^lshiftState ~= 0\n",
          "keyboardPeek": "keyboardPeek\n\t\"Answer the next key in the keyboard buffer but do not remove it.\"\n\t^keyboardQueue peek\n"
        }
      }
    }
  }
}
