Object subclass: #Benchmark
  instanceVariableNames: 'dummy verboseTranscript reporting reportStream fromList'
  classVariableNames: 'Outputs StandardTests'
  poolDictionaries: ''
  category: 'System-Support'!
Benchmark class
  instanceVariableNames: ''!
"-----------------------------------"!
Benchmark comment:
'Class Benchmark contains facilities for timing the performance of your system and reporting the results.

There are built-in methods for timing certain activities that occur frequently in using Smalltalk-80.  There are also facilities for timing the execution of most byte codes.

It is intended that comparison of timing information between implementations and over time will allow implementors to discover where their systems could stand improvement and to gauge the value of intended performance enhancements.

The main interface to these facilities is through sending the messsage
	Benchmark new test: aBlock labeled: aLabel repeated: howManyTimes.
This will cause howManyTimes executions of aBlock and report the results, using aLabel for ease of identification.

The results can be reported in several different ways.  The default is to print a fairly verbose report in the Transcript.  But the reporting mode can be altered by sending the Benchmark which is going to perform a given test the message setOutputParameters.  This gives you the option of directing the report to a file or an internal stream and also of shortening the feedback in the Transcript.  The system automatically invites you to respecify the output parameters (e.g. naming a new output report file) whenever you test more than one thing at a time, using the message testList: (as in testStandardTests below).

Try an example.  To time your system''s performance of simple addition, say
	Benchmark new test3plus4
or to time pushing an instance variable onto the stack, say
	Benchmark new testLoadInstVar.

If you had wished to print the results on a file or internal stream, you could have said
	Benchmark new setOutputParameters testLoadInstVar.

If you look at the code for these methods (e.g. testLoadInstVar), you will notice that it does a few things that you didn''t want to time, such as sending the message ==, or popping things off the stack.  This is to make the compiler happy or to keep the stack from overflowing.  So you may want to subtract this stuff out.  (Use systems of equations.  Be clever!!)

The message category "macro operations" contains methods for timing more involved activities such as compiling, decompiling, editing text, formatting text, etc.

There is a message to class Benchmark which will invoke all the built-in benchmarks sequentially.  Say
	Benchmark testStandardTests.

There are also facilities for examining or automatically comparing the output files or streams generated by testing a bunch of benchmarks sequentially.  See the "output" category.  Be sure to read the comment to the streamsRatherThanFiles code.

Have fun and share your results with a friend.'!
"-----------------------------------"!
!Benchmark class methodsFor: 'instance creation'!
new
	^super new defaultOutputParameters

	"Benchmark new inspect"!
"-----------------------------------"!
!Benchmark class methodsFor: 'standard tests'!
setStandardTests
	"These are all the built-in benchmarks.
	Feel free to change if you add more or think some of these are useless.
	To just execute a few, use testList: directly."

	StandardTests _
			#(testLoadInstVar testLoadTempNRef testLoadTempRef
			testLoadQuickConstant testLoadLiteralNRef testLoadLiteralIndirect
			testPopStoreInstVar testPopStoreTemp
			test3plus4 test3lessThan4 test3times4 test3div4 test16bitArith testLargeIntArith
			testActivationReturn testShortBranch testWhileLoop
			testArrayAt testArrayAtPut testStringAt testStringAtPut testSize
			testPointCreation testStreamNext testStreamNextPut testEQ testClass
			testBlockCopy testValue testCreation testPointX
			testLoadThisContext
			testBasicAt testBasicAtPut testPerform testStringReplace
			testAsFloat testFloatingPointAddition testBitBLT testTextScanning
			testClassOrganizer testPrintDefinition testPrintHierarchy
 			testAllCallsOn testAllImplementors testInspect
			testCompiler testDecompiler
			testKeyboardLookAhead testKeyboardSingle
			testTextDisplay testTextFormatting testTextEditing )!
testStandardTests
	"This message allows you to test the default series of benchmarks and record all the
	results according to how you answer the interactive prompts."

	self setStandardTests.
	self new testList: StandardTests

	"Benchmark testStandardTests"!
testStandardToFile: aFileStream
	"This message allows you to test the default series of benchmarks and record all the
	results on the specified file or stream."

	self setStandardTests.
	self new testList: StandardTests toFile: aFileStream

	"Benchmark testStandardToFile: (FileStream fileNamed: 'Smalltalk.timing')"!
"-----------------------------------"!
!Benchmark methodsFor: 'arithmetic'!
test16bitArith
	| twentyK |
	twentyK _ 20000.
	self test: [twentyK+twentyK. twentyK+twentyK.
			  twentyK+twentyK. twentyK+twentyK.
			  twentyK+twentyK. twentyK+twentyK.
			  twentyK+twentyK. twentyK+twentyK.
			  twentyK+twentyK. twentyK+twentyK. nil]
		labeled: 'add 20000 + 20000, 10 times' repeated: 1000

	"Benchmark new test16bitArith"!
test3div4
	self test: [3//4. 3//4. 3//4. 3//4. 3//4. 3//4. 3//4. 3//4. 3//4. 3//4. nil]
		labeled: 'divide 3 by 4, 10 times' repeated: 1000

	"Benchmark new test3div4"!
test3lessThan4
	self test: [3<4. 3<4. 3<4. 3<4. 3<4. 3<4. 3<4. 3<4. 3<4. 3<4. nil]
		labeled: 'test 3 < 4, 10 times' repeated: 10000

	"Benchmark new test3lessThan4"!
test3plus4
	self test: [3+4. 3+4. 3+4. 3+4. 3+4. 3+4. 3+4. 3+4. 3+4. 3+4. nil]
		labeled: 'add 3 + 4, 10 times' repeated: 10000

	"Benchmark new test3plus4"!
test3times4
	self test: [3*4. 3*4. 3*4. 3*4. 3*4. 3*4. 3*4. 3*4. 3*4. 3*4. nil]
		labeled: 'multiply 3 * 4, 10 times' repeated: 10000

	"Benchmark new test3times4"!
testLargeIntArith
	| eightyK |
	eightyK _ 80000.
	self test: [eightyK+eightyK. eightyK+eightyK.
			  eightyK+eightyK. eightyK+eightyK.
			  eightyK+eightyK. eightyK+eightyK.
			  eightyK+eightyK. eightyK+eightyK.
			  eightyK+eightyK. eightyK+eightyK. nil]
		labeled: 'add 80000 + 80000, 10 times' repeated: 100

	"Benchmark new testLargeIntArith"!
"-----------------------------------"!
!Benchmark methodsFor: 'arrays and strings'!
testArrayAt
	| array index |
	array _ #(1 2 3 4 5 6).
	index _ 4.
	self test:
			[array at: index. array at: index. array at: index. array at: index.
			 array at: index. array at: index. array at: index. array at: index.
			 array at: index. array at: index. array at: index. array at: index.
			 array at: index. array at: index. array at: index. array at: index.
			 array at: index. array at: index. array at: index. array at: index. nil]
		labeled: 'send #at: 20 times (to an array)' repeated: 1000

	"Benchmark new testArrayAt"!
testArrayAtPut
	| array index element |
	array _ #(1 2 3 4 5 6).
	index _ 4.
	element _ 17.
	self test:
			[array at: index put: element. array at: index put: element.
			 array at: index put: element. array at: index put: element.
			 array at: index put: element. array at: index put: element.
			 array at: index put: element. array at: index put: element.
			 array at: index put: element. array at: index put: element.
			 array at: index put: element. array at: index put: element.
			 array at: index put: element. array at: index put: element.
			 array at: index put: element. array at: index put: element.
			 array at: index put: element. array at: index put: element.
			 array at: index put: element. array at: index put: element. nil]
		labeled: 'send #at:put: 20 times (to an array)' repeated: 1000

	"Benchmark new testArrayAtPut"!
testSize
	| string |
	string _ 'abcde'.
	self test:
			[string size. string size. string size. string size. string size.
			 string size. string size. string size. string size. string size.
			 string size. string size. string size. string size. string size.
			 string size. string size. string size. string size. string size. nil]
		labeled: 'send #size 20 times (to a string)' repeated: 1000

	"Benchmark new testSize"!
testStringAt
	| string index |
	string _ 'abcdefg'.
	index _ 4.
	self test:
			[string at: index. string at: index. string at: index. string at: index.
			 string at: index. string at: index. string at: index. string at: index.
			 string at: index. string at: index. string at: index. string at: index.
			 string at: index. string at: index. string at: index. string at: index.
			 string at: index. string at: index. string at: index. string at: index. nil]
		labeled: 'send #at: 20 times (to a string)' repeated: 1000

	"Benchmark new testStringAt"!
testStringAtPut
	| string index char |
	string _ 'abcdefg'.
	index _ 4.
	char _ $q.
	self test:
			[string at: index put: char. string at: index put: char.
			 string at: index put: char. string at: index put: char.
			 string at: index put: char. string at: index put: char.
			 string at: index put: char. string at: index put: char.
			 string at: index put: char. string at: index put: char.
			 string at: index put: char. string at: index put: char.
			 string at: index put: char. string at: index put: char.
			 string at: index put: char. string at: index put: char.
			 string at: index put: char. string at: index put: char.
			 string at: index put: char. string at: index put: char. nil]
		labeled: 'send #at:put: 20 times (to a string)' repeated: 1000

	"Benchmark new testStringAtPut"!
"-----------------------------------"!
!Benchmark methodsFor: 'control'!
testActivationReturn
	self test:
			[self recur: 14]
		labeled: 'activate and return, 32K times' repeated: 1

	"Benchmark new testActivationReturn"!
testShortBranch
	self test: [false ifTrue: [1] ifFalse: [2].
			  false ifTrue: [1] ifFalse: [2].
			  false ifTrue: [1] ifFalse: [2].
			  false ifTrue: [1] ifFalse: [2].
			  false ifTrue: [1] ifFalse: [2].
			  false ifTrue: [1] ifFalse: [2].
			  false ifTrue: [1] ifFalse: [2].
			  false ifTrue: [1] ifFalse: [2].
			  false ifTrue: [1] ifFalse: [2].
			  false ifTrue: [1] ifFalse: [2]. nil]
		labeled: 'short branch on false, 10 times' repeated: 10000

	"Benchmark new testShortBranch"!
testWhileLoop
	| temp |
	self test: [temp _ 10000.
			  [temp > 0] whileTrue: [temp _ temp - 1].
			  nil]
		labeled: 'simple whileLoop, 10000 times through' repeated: 10

	"Benchmark new testWhileLoop"!
"-----------------------------------"!
!Benchmark methodsFor: 'instance initialization'!
defaultOutputParameters
	reporting _ false.
	verboseTranscript _ true.
	fromList _ false!
fileOutputParameters: aFileStream
	reporting _ true.
	reportStream _ aFileStream.
	verboseTranscript _ false!
setOutputParameters
	BinaryChoice
		message: 'Would you like the transcript to just show labels, rather than full reports?'
		displayAt: Sensor mousePoint
		centered: true
		ifTrue: [verboseTranscript _ false]
		ifFalse: [verboseTranscript _ true].
	BinaryChoice
		message: 'Should the full reports to be output (saved on a file or stream)?'
		displayAt: Sensor mousePoint
		centered: true
		ifTrue: [reporting _ true]
		ifFalse: [reporting _ false].
	reporting ifTrue:
		[FillInTheBlank
			request: 'Please supply desired output name'
			displayAt: Sensor mousePoint
			centered: true
			action: [:answer | reportStream _ self makeOutputNamed: answer]
			initialAnswer: '.timing']!
"-----------------------------------"!
!Benchmark methodsFor: 'load and popStore'!
testLoadInstVar
	dummy _ 1.
	self test: [dummy == dummy. dummy == dummy.
			  dummy == dummy. dummy == dummy.
			  dummy == dummy. dummy == dummy.
			  dummy == dummy. dummy == dummy.
			  dummy == dummy. dummy == dummy. nil]
		labeled: 'load an instance variable, 20 times' repeated: 10000

	"Benchmark new testLoadInstVar"!
testLoadLiteralIndirect
	self test: [Point == Point. Point == Point.
			  Point == Point. Point == Point.
			  Point == Point. Point == Point.
			  Point == Point. Point == Point.
			  Point == Point. Point == Point. nil]
		labeled: 'load literal indirect (overflow refct), 20 times' repeated: 10000

	"Benchmark new testLoadLiteralIndirect"!
testLoadLiteralNRef
	self test: [3 == 3. 3 == 3. 3 == 3. 3 == 3. 3 == 3.
			  3 == 3. 3 == 3. 3 == 3. 3 == 3. 3 == 3. nil]
		labeled: 'load nonRefcounted literal, 20 times' repeated: 10000

	"Benchmark new testLoadLiteralNRef"!
testLoadQuickConstant
	self test: [1 == 1. 1 == 1. 1 == 1. 1 == 1. 1 == 1.
			  1 == 1. 1 == 1. 1 == 1. 1 == 1. 1 == 1.
			  1 == 1. 1 == 1. 1 == 1. 1 == 1. 1 == 1.
			  1 == 1. 1 == 1. 1 == 1. 1 == 1. 1 == 1. nil]
		labeled: 'load 1, 40 times; send ==, 20 times' repeated: 10000

	"Benchmark new testLoadQuickConstant"!
testLoadTempNRef
	| temp |
	temp _ 1.
	self test: [temp == temp. temp == temp.
			  temp == temp. temp == temp.
			  temp == temp. temp == temp.
			  temp == temp. temp == temp.
			  temp == temp. temp == temp. nil]
		labeled: 'load 1 as a temp, 20 times' repeated: 10000

	"Benchmark new testLoadTempNRef"!
testLoadTempRef
	| temp |
	temp _ 0@0.
	self test: [temp == temp. temp == temp.
			  temp == temp. temp == temp.
			  temp == temp. temp == temp.
			  temp == temp. temp == temp.
			  temp == temp. temp == temp. nil]
		labeled: 'load 0@0, 20 times' repeated: 10000

	"Benchmark new testLoadTempRef"!
testPopStoreInstVar
	self test: [dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1.
			  dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1.
			  dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1.
			  dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1. nil]
		labeled: 'store into an instance variable, 20 times' repeated: 10000

	"Benchmark new testPopStoreInstVar"!
testPopStoreTemp
	| temp |
	self test: [temp _ 1. temp _ 1. temp _ 1. temp _ 1. temp _ 1.
			  temp _ 1. temp _ 1. temp _ 1. temp _ 1. temp _ 1.
			  temp _ 1. temp _ 1. temp _ 1. temp _ 1. temp _ 1.
			  temp _ 1. temp _ 1. temp _ 1. temp _ 1. temp _ 1. nil]
		labeled: 'store into a temp, 20 times' repeated: 10000

	"Benchmark new testPopStoreTemp"!
"-----------------------------------"!
!Benchmark methodsFor: 'macro operations'!
testAllCallsOn
	self test:
			[Smalltalk allCallsOn: #printStringRadix:]
		labeled: 'find all calls on #printStringRadix:' repeated: 1

	"Benchmark new testAllCallsOn"!
testAllImplementors
	self test:
			[Smalltalk allImplementorsOf: #next]
		labeled: 'find all implementors of #next' repeated: 1

	"Benchmark new testAllImplementors"!
testClassOrganizer
	| class |
	class _ Benchmark.
	self test:
			[class organization changeFromString: class organization printString]
		labeled: 'read and write class organization' repeated: 1

	"Benchmark new testClassOrganizer"!
testCompiler
	self test:
			[Benchmark compile:
'dummy: aBlock repeated: nTimes | i emptyBlock emptyTime blockTime |
	nTimes > 1000 ifTrue: [^self time: aBlock repeatedK: nTimes // 1000].
	emptyBlock _ [].
	emptyTime _ Time millisecondsToRun:
					[i _ 0.
					 [(i _ i + 1) <= nTimes] whileTrue: [emptyBlock value]].
	blockTime _ Time millisecondsToRun:
					[i _ 0.
					 [(i _ i + 1) <= nTimes] whileTrue: [aBlock value]].
	^blockTime - emptyTime'
				notifying: nil trailer: #(0 0 0)]
		labeled: 'compile dummy method' repeated: 5.
	Benchmark removeSelector: #dummy:repeated:

	"Benchmark new testCompiler"!
testDecompiler
	| class |
	class _ InputSensor.
	self
		test: [class selectors do:
				[:sel | (Decompiler new
						decompile: sel
						in: class
						method: (class compiledMethodAt: sel)) decompileString]]
		labeled: 'decompile class InputSensor' repeated: 1

	"Benchmark new testDecompiler"!
testInspect
	| window |
	self test:
			[window _ InspectorView buildScheduledView:
							(Inspector inspect: Compiler new).
			  window release]
		labeled: 'create an inspector view' repeated: 10

	"Benchmark new testInspect"!
testKeyboardLookAhead
	| aStringHolderView insert inputter editor |
	aStringHolderView _ self favoriteStringHolderView.
	editor _ aStringHolderView controller.
	editor selectAt: 5.
	inputter _ editor sensor class classPool at: #CurrentInputState.
	Sensor flushKeyboard.
	self test:
			['Now!! ' do:
				[:char |
				 inputter keyAt: char asciiValue put: 1].
				 editor readKeyboard]
		labeled: 'text keyboard response using lookahead buffer' repeated: 3.
	aStringHolderView release

	"Benchmark new testKeyboardLookAhead"!
testKeyboardSingle
	| aStringHolderView insert inputter editor |
	aStringHolderView _ self favoriteStringHolderView.
	editor _ aStringHolderView controller.
	editor selectAt: 5.
	inputter _ editor sensor class classPool at: #CurrentInputState.
	Sensor flushKeyboard.
	self test:
			['Now!! ' do:
				[:char |
				 inputter keyAt: char asciiValue put: 1.
				 editor readKeyboard]]
		labeled: 'text keyboard response for single keystroke' repeated: 3.
	aStringHolderView release

	"Benchmark new testKeyboardSingle"!
testPrintDefinition
	| class |
	class _ Compiler.
	self test:
			[class definition]
		labeled: 'print a class definition' repeated: 20

	"Benchmark new testPrintDefinition"!
testPrintHierarchy
	| class |
	class _ InstructionStream.
	self test:
			[class printHierarchy]
		labeled: 'print a class hierarchy' repeated: 10

	"Benchmark new testPrintHierarchy"!
testTextDisplay
	| para |
	para _ Paragraph withText: self textForDisplay.
	para displayAt: 200@200.
	self test: [para displayAt: 200@200]
		labeled: 'display text' repeated: 10

	"Benchmark new testTextDisplay"!
testTextEditing
	| aStringHolderView editor selectPoint |
	aStringHolderView _ self favoriteStringHolderView.
	editor _ aStringHolderView controller.
	selectPoint _ 0.
	self test:
			[editor selectAt: (selectPoint _ selectPoint + 5).
			 editor replaceSelectionWith: 'Now!! ' asText]
		labeled: 'text replacement and redisplay' repeated: 20.
	aStringHolderView release

	"Benchmark new testTextEditing"!
testTextFormatting
	| aString aView contents |
	aString _ self stringForDisplay.
	aView _ StringHolderView container: StringHolder new.
	aView window: Display boundingBox viewport: (100@100 extent: 200@200).
	self test:
			[aView editString: (aString asText makeSelectorBoldIn: Benchmark) asParagraph]
		labeled: 'format a bunch of text' repeated: 5.
	aView release

	"Benchmark new testTextFormatting"!
"-----------------------------------"!
!Benchmark methodsFor: 'output'!
clearOutputs
	"This allows you to get rid of your old accumulated output streams."

	Outputs _ nil

	"Benchmark new clearOutputs"!
closeOutput: aStream
	self streamsRatherThanFiles
		ifTrue: [aStream reset]
		ifFalse: [aStream close]!
compareOldTimes: oldName toNewTimes: newName outputTo: outName
	"Compare two sets of benchmark ouput reports."

	| oldDict newDict labels compareStream oldTime newTime |
	oldDict _ Dictionary new. newDict _ Dictionary new. labels _ OrderedCollection new.
	self readOutput: (self outputNamed: oldName) intoDict: oldDict andCollection: nil.
	self readOutput: (self outputNamed: newName) intoDict: newDict andCollection: labels.
	compareStream _ self makeOutputNamed: outName.
	labels do:
		[:label | (oldDict includesKey: label) ifTrue:
			[compareStream nextPutAll: label; cr; tab;
				nextPutAll: 'old time: ', (oldTime _ oldDict at: label) printString; tab;
				nextPutAll: 'new time: ', (newTime _ newDict at: label) printString; tab;
				nextPutAll: 'percent change: ', (newTime - oldTime * 100.0 / oldTime) printString; cr; cr]].
	self closeOutput: compareStream

	"Benchmark new
		compareOldTimes: 'test1.timing'
		toNewTimes: 'test2.timing'
		outputTo: 'compare1-2.timing'"

	"Benchmark new displayOutputNamed: 'compare1-2.timing'"!
displayOutputNamed: name
	"Create a window on the display to view the contents of the named output.
	Does not allow editing of the output file or stream."

	| output contents |
	output _ self outputNamed: name.
	contents _ self streamsRatherThanFiles
					ifTrue: [output contents]
					ifFalse: [output contentsOfEntireFile].
	StringHolderView
		open: (StringHolder new contents: contents)
		label: name!
makeOutputNamed: name
	"Create a new output file or stream of the given name."

	self streamsRatherThanFiles
		ifTrue: [Outputs == nil ifTrue: [Outputs _ Dictionary new].
				Outputs at: name put:
					(ReadWriteStream on: (String new: 1000))].
	^self outputNamed: name!
outputNamed: name
	"Answer with the output file or stream of the given name."

	self streamsRatherThanFiles
		ifTrue: [^Outputs at: name]
		ifFalse: [^Disk file: name]!
readOutput: aStream intoDict: aDict andCollection: aColl
	"Parse the output file or stream, aStream, putting labels and times in aDict.
	If aColl is non-nil (but rather an ordered collection), also add the labels to it
	in order."

	| leftBracket rightBracket tab space label value |
	leftBracket _ $[.
	rightBracket _ $].
	tab _ $	.
	space _ $ .
	aStream upTo: leftBracket.
	[aStream atEnd] whileFalse:
		[label _ aStream upTo: rightBracket.
		 aColl notNil ifTrue: [aColl add: label].
		 aStream next: 2; upTo: tab.
		 value _ Number readFrom: (ReadStream on: (aStream upTo: space)).
		 aDict at: label put: value.
		 aStream upTo: leftBracket].
	self closeOutput: aStream!
report: label timedAt: time repeated: numberOfTimes
	"Do all the reporting, both in the Transcript and on the output file or stream."

	| reportString |
	reportString _ self reportStringFor: label
						timedAt: time
						repeated: numberOfTimes.
	verboseTranscript
			ifTrue: [Transcript show: reportString]
			ifFalse: [Transcript show: '
[', label, ']'].
	reporting ifTrue:
		[reportStream nextPutAll: reportString.
		 fromList ifFalse: [self closeOutput: reportStream]]!
reportStringFor: label timedAt: time repeated: numberOfTimes
	"Generate the parsible string to represent the measurement of a benchmark."

	| nTimes unitTime seconds aStream|
	aStream _ WriteStream on: (String new: 200).
	nTimes _ numberOfTimes <= 1000
				ifTrue: [numberOfTimes]
				ifFalse: [numberOfTimes // 1000 * 1000].
	seconds _ time asFloat / 1000.
	aStream cr; nextPutAll: 'Testing:  [' , label , ']'; cr.
	aStream tab; print: nTimes; nextPutAll: ' repetition(s) in'; cr;
		tab; print: seconds; nextPutAll: ' seconds'; cr.
	nTimes ~= 1
		ifTrue:
			[unitTime _ (time * 1000) asFloat / nTimes.
			aStream tab; print: unitTime;
				nextPutAll: ' microseconds per repetition'; cr].
	^aStream contents!
streamsRatherThanFiles
	"Should the named outputs be (internal Smalltalk-80) streams rather than disk files?
	They should if there is no file system.
	Feel free to change this method if you have a file system but want streams anyway."

	^Disk == nil!
"-----------------------------------"!
!Benchmark methodsFor: 'primitive byte codes'!
testBlockCopy
	| tC |
	tC _ thisContext.
	self test: [tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0.
			  tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0.
			  tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0.
			  tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0.
			  tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0. nil]
		labeled: 'execute blockCopy: 0, 20 times' repeated: 1000

	"Benchmark new testBlockCopy"!
testClass
	| pt |
	pt _ 0@0.
	self test:
			[pt class. pt class. pt class. pt class. pt class.
			 pt class. pt class. pt class. pt class. pt class.
			 pt class. pt class. pt class. pt class. pt class.
			 pt class. pt class. pt class. pt class. pt class. nil]
		labeled: 'send #class 20 times (to a point)' repeated: 1000

	"Benchmark new testClass"!
testCreation
	self test:
			[Point new. Point new. Point new. Point new. Point new.
			  Point new. Point new. Point new. Point new. Point new.
			  Point new. Point new. Point new. Point new. Point new.
			  Point new. Point new. Point new. Point new. Point new. nil]
		labeled: 'create 20 uninitialized points' repeated: 1000

	"Benchmark new testCreation"!
testEQ
	| temp |
	temp _ 1.
	self test: [temp == temp == temp == temp == temp ==
			  temp == temp == temp == temp == temp ==
			  temp == temp == temp == temp == temp ==
			  temp == temp == temp == temp == temp. nil]
		labeled: 'send ==, 20 times' repeated: 10000

	"Benchmark new testEQ"!
testLoadThisContext
	self test: [thisContext == thisContext. thisContext == thisContext.
			  thisContext == thisContext. thisContext == thisContext.
			  thisContext == thisContext. thisContext == thisContext.
			  thisContext == thisContext. thisContext == thisContext.
			  thisContext == thisContext. thisContext == thisContext. nil]
		labeled: 'load thisContext, 20 times' repeated: 10000

	"Benchmark new testLoadThisContext"!
testPointCreation
	self test: [3@4. 3@4. 3@4. 3@4. 3@4. 3@4. 3@4. 3@4. 3@4. 3@4. nil]
		labeled: 'create 3@4, 10 times' repeated: 1000

	"Benchmark new testPointCreation"!
testPointX
	| pt |
	pt _ 0@0.
	self test: [pt x. pt x. pt x. pt x. pt x. pt x. pt x. pt x. pt x. pt x. nil]
		labeled: 'execute aPoint x, 10 times' repeated: 10000

	"Benchmark new testPointX"!
testStreamNext
	| strm |
	strm _ ReadStream on: 'abcdefghijklmnopqrstuvwxyz'.
	self test: [strm position: 0.
			  strm next. strm next. strm next. strm next.
			  strm next. strm next. strm next. strm next.
			  strm next. strm next. strm next. strm next.
			  strm next. strm next. strm next. strm next.
			  strm next. strm next. strm next. strm next. nil]
		labeled: 'execute ReadStream next, 20 times' repeated: 1000

	"Benchmark new testStreamNext"!
testStreamNextPut
	| strm ch |
	strm _ ReadWriteStream on: 'abcdefghijklmnopqrstuvwxyz'.
	ch _ $q.
	self test: [strm position: 0.
			  strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. strm nextPut: ch.
			  strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. strm nextPut: ch.
			  strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. strm nextPut: ch.
			  strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. strm nextPut: ch.
			  strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. nil]
		labeled: 'execute ReadWriteStream nextPut:, 20 times' repeated: 1000

	"Benchmark new testStreamNextPut"!
testValue
	| block |
	block _ [3+4].
	self test: [block value. block value. block value. block value.
			  block value. block value. block value. block value.
			  block value. block value. block value. block value.
			  block value. block value. block value. block value.
			  block value. block value. block value. block value. nil]
		labeled: 'evaluate the block: (3+4), 20 times' repeated: 1000

	"Benchmark new testValue"!
"-----------------------------------"!
!Benchmark methodsFor: 'primitive methods'!
testAsFloat
	self test: [1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat.
			  1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat.
			  1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat.
			  1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat. nil]
		labeled: 'convert 1 to floating point, 20 times' repeated: 100

	"Benchmark new testAsFloat"!
testBasicAt
	| coll index |
	coll _ Set new: 16.
	index _ 5.
	self test:
			[coll basicAt: index. coll basicAt: index. coll basicAt: index. coll basicAt: index.
			 coll basicAt: index. coll basicAt: index. coll basicAt: index. coll basicAt: index.
			 coll basicAt: index. coll basicAt: index. coll basicAt: index. coll basicAt: index.
			 coll basicAt: index. coll basicAt: index. coll basicAt: index. coll basicAt: index.
			 coll basicAt: index. coll basicAt: index. coll basicAt: index. coll basicAt: index. nil]
		labeled: 'send #basicAt: 20 times (to a set)' repeated: 1000

	"Benchmark new testBasicAt"!
testBasicAtPut
	| coll index element |
	coll _ Set new: 16.
	index _ 5.
	element _ 17.
	self test:
			[coll basicAt: index put: element. coll basicAt: index put: element.
			 coll basicAt: index put: element. coll basicAt: index put: element.
			 coll basicAt: index put: element. coll basicAt: index put: element.
			 coll basicAt: index put: element. coll basicAt: index put: element.
			 coll basicAt: index put: element. coll basicAt: index put: element.
			 coll basicAt: index put: element. coll basicAt: index put: element.
			 coll basicAt: index put: element. coll basicAt: index put: element.
			 coll basicAt: index put: element. coll basicAt: index put: element.
			 coll basicAt: index put: element. coll basicAt: index put: element.
			 coll basicAt: index put: element. coll basicAt: index put: element. nil]
		labeled: 'send #basicAtPut: 20 times (to a set)' repeated: 1000

	"Benchmark new testBasicAtPut"!
testBitBLT
	| bLTer |
	bLTer _ self sampleBitBLT.
	self test:
			[bLTer copyBits. bLTer copyBits.
			 bLTer copyBits. bLTer copyBits.
			 bLTer copyBits. bLTer copyBits.
			 bLTer copyBits. bLTer copyBits.
			 bLTer copyBits. bLTer copyBits. nil]
		labeled: 'call bitBLT 10 times' repeated: 10

	"Benchmark new testBitBLT"!
testFloatingPointAddition
	| a b |
	a _ 3.1.
	b _ 4.1.
	self test: [a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b.
			  a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b. nil]
		labeled: 'add 3.1 plus 4.1, 20 times' repeated: 100

	"Benchmark new testFloatingPointAddition"!
testPerform
	self test: [3 perform: #+ with: 4. 3 perform: #+ with: 4.
			  3 perform: #+ with: 4. 3 perform: #+ with: 4.
			  3 perform: #+ with: 4. 3 perform: #+ with: 4.
			  3 perform: #+ with: 4. 3 perform: #+ with: 4.
			  3 perform: #+ with: 4. 3 perform: #+ with: 4.
			  3 perform: #+ with: 4. 3 perform: #+ with: 4.
			  3 perform: #+ with: 4. 3 perform: #+ with: 4.
			  3 perform: #+ with: 4. 3 perform: #+ with: 4.
			  3 perform: #+ with: 4. 3 perform: #+ with: 4.
			  3 perform: #+ with: 4. 3 perform: #+ with: 4. nil]
		labeled: '3 perform: #+ with: 4, 20 times' repeated: 1000

	"Benchmark new testPerform"!
testStringReplace
	| source sink size |
	source _ self longishString copy.
	sink _ source copy.
	size _ sink size.
	self test:
			[sink replaceFrom: 1 to: size with: source startingAt: 1. nil]
		labeled: 'replace characters in a string' repeated: 100

	"Benchmark new testStringReplace"!
testTextScanning
	| clipRect para range scanner stops |
	clipRect _ Display boundingBox.
	para _ Paragraph withText: 'Hi there, folks' asText.
	range _ 1 to: para numberOfLines.
	scanner _ DisplayScanner new.
	scanner displayLines: range in: para clippedBy: clipRect.
	stops _ scanner instVarAt: 17.
	self test:
		[scanner destX: 0.
		 scanner
			scanCharactersFrom: 1
			to: 16
			in: 'Hi there, folks!!'
			rightX: 400
			stopConditions: stops
			displaying: true]
		labeled: 'scan characters (primitive text display)' repeated: 100

	"Benchmark new testTextScanning"!
"-----------------------------------"!
!Benchmark methodsFor: 'private'!
favoriteStringHolderView
	| aStringHolderView message |
	message _ self longishString.
	aStringHolderView _ StringHolderView container: (StringHolder new contents: message).
	aStringHolderView window: (0@0 extent: 300@200).
	aStringHolderView translateBy: 100@250.
	aStringHolderView display.
	^aStringHolderView!
longishString
	^ 'Now is the time for all good people to come to the aid of the cause of world peace.  It is just fine, even desirable, to love your country, if that means wanting it to play a beneficial role in the course of world events and be the best possible example of a good society.  But if it means wanting dominion over the rest of the world, it is not love but defensiveness or self-glorification, and will lead only to oblivion.'!
recur: exp
	"Invokes a recursion involving ((2 raisedTo: exp+1) - 1) activations and
	returns."

	exp = 0 ifTrue: [^self].
	self recur: exp - 1.
	^self recur: exp - 1!
sampleBitBLT
	^BitBlt
		destForm: Display
		sourceForm: nil
		halftoneForm: Form black
		combinationRule: Form reverse
		destOrigin: 0@0
		sourceOrigin: 0@0
		extent: 400@400
		clipRect: Display boundingBox!
stringForDisplay
	^'testTextDisplay
	| clipRect para range scanner |
	clipRect _ Display boundingBox.
	para _ Paragraph withText: self textForDisplay.
	range _ 1 to: para numberOfLines.
	scanner _ DisplayScanner new.
	self test: [scanner
				displayLines: range
				in: para
				clippedBy: clipRect]
		labeled: ''displaying text'' repeated: 10

	"Benchmark new testTextDisplay"'!
textForDisplay
	^self stringForDisplay asText!
"-----------------------------------"!
!Benchmark methodsFor: 'testing'!
test: aBlock labeled: label repeated: nTimes
	"This is the main message to a Benchmark. aBlock is repeated nTimes, and the
	results are reported."

	| time |
	time _ self time: aBlock repeated: nTimes.
	self
		report: label
		timedAt: time
		repeated: nTimes!
testList: selectorList
	"This message allows you to test a series of benchmarks and record all the results on
	a file or stream."

	fromList _ true.
	self setOutputParameters.
	selectorList do:
		[:selector | self perform: selector.
		 verboseTranscript ifTrue:
			[Transcript show: 'press any mouse button to continue'.
			 Sensor waitButton.
			 Transcript clear; refresh]].
	reporting ifTrue: [self closeOutput: reportStream].
	fromList _ false.

	"Benchmark new testList: #(testLoadInstVar testLoadLiteralIndirect testLoadLiteralNRef testLoadQuickConstant testLoadTempNRef)"!
testList: selectorList toFile: aFileStream
	"This message allows you to test a series of benchmarks and record all the results on
	a file or stream."

	fromList _ true.
	self fileOutputParameters: aFileStream.
	selectorList do:
		[:selector | self perform: selector.
		 verboseTranscript ifTrue:
			[Transcript show: 'press any mouse button to continue'.
			 Sensor waitButton.
			 Transcript clear; refresh]].
	reporting ifTrue: [self closeOutput: reportStream].
	fromList _ false.

	"Benchmark new testList: #(testLoadInstVar testLoadLiteralIndirect testLoadLiteralNRef testLoadQuickConstant testLoadTempNRef) toFile: (FileStream fileNamed: 'Smalltalk.timing')"!
time: aBlock repeated10K: tenKTimes
	| i emptyBlock emptyTime blockTime |
	tenKTimes > 10000 ifTrue: [^self error: 'one hundred million repetitions is my limit'].
	emptyBlock _ [].
	emptyTime _
			Time millisecondsToRun:
					[1 to: tenKTimes do:
						[:j |
						i _ 0.
						[(i _ i + 1) <= 10000]
							whileTrue: [emptyBlock value]]].
	blockTime _
			Time millisecondsToRun:
					[1 to: tenKTimes do:
						[:j |
						i _ 0.
						[(i _ i + 1) <= 10000]
							whileTrue: [aBlock value]]].
	^blockTime - emptyTime!
time: aBlock repeated: nTimes
	"Answer how many milliseconds it takes to repeat aBlock nTimes, corrected for the
	time to repeat an empty block."

	| i emptyBlock emptyTime blockTime iBox |
	nTimes > 10000 ifTrue: [^self time: aBlock repeated10K: nTimes // 10000].
	emptyBlock _ [].
	emptyTime _ Time millisecondsToRun:
							[i _ 0.
							 [(i _ i + 1) <= nTimes] whileTrue: [emptyBlock value]].
	blockTime _ Time millisecondsToRun:
							[i _ 0.
							 [(i _ i + 1) <= nTimes] whileTrue: [aBlock value]].
	^blockTime - emptyTime!
